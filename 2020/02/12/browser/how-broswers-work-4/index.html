<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>手把手教你实现一个浏览器引擎（四）Style - Jim Home</title><link rel="manifest" href="/blog/manifest.json"><meta name="application-name" content="leejimqiu"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="leejimqiu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="第四部分 Style欢迎回到关于构建你自己的玩具浏览器引擎的系列文章。如果你是刚开始收看文章，你可以从下面找到以前的文章：  第一部分：起步 第二部分：HTML 第三部分：CSS  本文将会介绍在CSS标准中所谓的 分配属性值(assigning vproperty values) 或者 样式模块(style module)。这个模块将拿DOM节点和CSS规则作为输入，将他们互相匹配，为所给的所有"><meta property="og:type" content="blog"><meta property="og:title" content="手把手教你实现一个浏览器引擎（四）Style"><meta property="og:url" content="https://leejim.github.io/blog/2020/02/12/browser/how-broswers-work-4/"><meta property="og:site_name" content="Jim Home"><meta property="og:description" content="第四部分 Style欢迎回到关于构建你自己的玩具浏览器引擎的系列文章。如果你是刚开始收看文章，你可以从下面找到以前的文章：  第一部分：起步 第二部分：HTML 第三部分：CSS  本文将会介绍在CSS标准中所谓的 分配属性值(assigning vproperty values) 或者 样式模块(style module)。这个模块将拿DOM节点和CSS规则作为输入，将他们互相匹配，为所给的所有"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/qpiaQcgGBL79wMzjlEyguV4WXTXbgtCwIOX8zNJ9KlOP8TScxxusxZbvAtic8qkmKC54PicgBRUe5iaRibIQIY764oQ/0?wx_fmt=jpeg"><meta property="article:published_time" content="2020-02-12T12:49:01.000Z"><meta property="article:modified_time" content="2023-08-04T13:18:20.480Z"><meta property="article:author" content="leejimqiu"><meta property="article:tag" content="leejimqiu,"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/qpiaQcgGBL79wMzjlEyguV4WXTXbgtCwIOX8zNJ9KlOP8TScxxusxZbvAtic8qkmKC54PicgBRUe5iaRibIQIY764oQ/0?wx_fmt=jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://leejim.github.io/blog/2020/02/12/browser/how-broswers-work-4/"},"headline":"手把手教你实现一个浏览器引擎（四）Style","image":[],"datePublished":"2020-02-12T12:49:01.000Z","dateModified":"2023-08-04T13:18:20.480Z","author":{"@type":"Person","name":"leejimqiu"},"publisher":{"@type":"Organization","name":"Jim Home","logo":{"@type":"ImageObject","url":"https://leejim.github.io/img/logo.svg"}},"description":"第四部分 Style欢迎回到关于构建你自己的玩具浏览器引擎的系列文章。如果你是刚开始收看文章，你可以从下面找到以前的文章：  第一部分：起步 第二部分：HTML 第三部分：CSS  本文将会介绍在CSS标准中所谓的 分配属性值(assigning vproperty values) 或者 样式模块(style module)。这个模块将拿DOM节点和CSS规则作为输入，将他们互相匹配，为所给的所有"}</script><link rel="canonical" href="https://leejim.github.io/blog/2020/02/12/browser/how-broswers-work-4/"><link rel="icon" href="/blog/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?6638f74329d0f52c5cdafdadb58010af";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog/"><img src="/blog/img/logo.svg" alt="Jim Home" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog/">Home</a><a class="navbar-item" href="/blog/archives">Archives</a><a class="navbar-item" href="/blog/categories">Categories</a><a class="navbar-item" href="/blog/tags">Tags</a><a class="navbar-item" href="/blog/projects">Projects</a><a class="navbar-item" href="/blog/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leejim"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-12T12:49:01.000Z" title="2/12/2020, 12:49:01 PM">2020-02-12</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">19 分钟读完 (大约2877个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">手把手教你实现一个浏览器引擎（四）Style</h1><div class="content"><h2 id="第四部分-Style"><a href="#第四部分-Style" class="headerlink" title="第四部分 Style"></a>第四部分 Style</h2><p>欢迎回到关于构建你自己的玩具浏览器引擎的系列文章。如果你是刚开始收看文章，你可以从下面找到以前的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00086eef5fcff8f5b3c97d08551413">第一部分：起步</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">第二部分：HTML</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/0004ae6f0b4c80883de95cfaa59413">第三部分：CSS</a></li>
</ul>
<p>本文将会介绍在CSS标准中所谓的 分配属性值(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html">assigning vproperty values</a>) 或者 样式模块(<a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/275ea716d50565b10ce91c0054fbf527281180bb/src/style.rs">style</a> module)。这个模块将拿DOM节点和CSS规则作为输入，将他们互相匹配，为所给的所有节点确定每个CSS属性的值。</p>
<p>这部分不会包含很多代码，因为我还没有实现相对复杂的部分。然而，我觉得剩下的仍然相当有趣，我还会解释如何实现一些缺失的部分。</p>
<h2 id="样式树-The-Style-Tree"><a href="#样式树-The-Style-Tree" class="headerlink" title="样式树 The Style Tree"></a>样式树 The Style Tree</h2><p>我将Robinson的样式模块的输出称为 **样式树(style tree)**， 在树里的每个节点都指向一个DOM节点，加上它的CSS属性值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map from CSS property names to values.</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PropertyMap</span></span> = HashMap&lt;<span class="built_in">String</span>, Value&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A node with associated style data.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StyledNode</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    node: &amp;<span class="symbol">&#x27;a</span> Node, <span class="comment">// pointer to a DOM node</span></span><br><span class="line">    specified_values: PropertyMap,</span><br><span class="line">    children: <span class="built_in">Vec</span>&lt;StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&#39;a</code>是什么意思呢？这是都是生命周期，是Rust保证指针是内存安全的且不需要进行垃圾收集的一部分。如果你不是使用Rust工作的话，你可以忽略他们。他们对代码的意义影响不是很大。</p>
</blockquote>
<p>其实，我们可以给<code>dom:Node</code>的结构增加字段，而不是创建一个新的树。但是我想抱着样式的代码和之前的“课程”相对独立。这也是给了我一个机会讲一下在大部分渲染引擎都会出现的 <strong>平行树(parallel trees)</strong> </p>
<p>浏览器引擎模块经常会将一个树当做输入，然后输出一个不同但是相关的树 。比如，Gecko的 <a target="_blank" rel="noopener" href="https://wiki.mozilla.org/Gecko:Key_Gecko_Structures_And_Invariants">布局代码(layout code)</a> 利用 <strong>DOM树</strong> 生成 **框架树(frame tree)**，然后将用于构建 **视图树(view tree)**。Blink 和 WebKit 将 DOM树 转换成 **渲染树(render tree)**。在这些引擎的后面阶段还会生成很多树，包括 <strong>层级树(layer tree)</strong> 和 **部件树(widget tree)**。</p>
<p>在完成其他几个阶段之后，我们的玩具浏览器引擎的流水线(pipeline)将会看起来像是这样：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/qpiaQcgGBL79wMzjlEyguV4WXTXbgtCwIOX8zNJ9KlOP8TScxxusxZbvAtic8qkmKC54PicgBRUe5iaRibIQIY764oQ/0?wx_fmt=jpeg"></p>
<p>在我的实现方式里，DOM树里的每个节点在样式树里都只有一个节点。但是在更复杂的流水线阶段，几个输入的节点可能会合并成一个输出节点。或者，一个输入节点可能会扩展为多个输出节点，或者被完全跳过。例如，样式树可能移除一个<code>display</code>属性设置成<code>none</code>的元素。（相反，我将在布局阶段移除这些，因为我的代码反而比较简单）</p>
<h2 id="匹配选择器-Selector-Matching"><a href="#匹配选择器-Selector-Matching" class="headerlink" title="匹配选择器 Selector Matching"></a>匹配选择器 Selector Matching</h2><p>构建 <strong>样式树(style tree)</strong> 的第一步就是匹配选择器。因为我的CSS解析器只支持简单选择器，因此这将是很简单。可以通过查看元素本身来判断简单选择器是否与元素匹配。匹配复合选择器则需要遍历整个DOM树来查看元素的 <strong>兄弟元素(siblings)<strong>，</strong>父元素(parents)</strong> 等等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matches</span></span>(elem: &amp;ElementData, selector: &amp;Selector) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> *selector &#123;</span><br><span class="line">        Simple(<span class="keyword">ref</span> simple_selector) =&gt; matches_simple_selector(elem, simple_selector)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了提供帮助，我们将给我们的 DOM元素类型 增加一些遍历的ID和class访问器。class属性可以包含多个用空格分隔的类名，最后将这些类名通过哈希表的形式返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> ElementData &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">id</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.attributes.get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">classes</span></span>(&amp;<span class="keyword">self</span>) -&gt; HashSet&lt;&amp;<span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.attributes.get(<span class="string">&quot;class&quot;</span>) &#123;</span><br><span class="line">            <span class="literal">Some</span>(classlist) =&gt; classlist.split(<span class="string">&#x27; &#x27;</span>).collect(),</span><br><span class="line">            <span class="literal">None</span> =&gt; HashSet::new()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要测试一个简单选择器是否匹配了元素，只需要查看每个选择器的 <strong>组件(component)</strong> ，如果一个元素没有一个匹配上的class，ID或者标签名就返回<code>false</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matches_simple_selector</span></span>(elem: &amp;ElementData, selector: &amp;SimpleSelector) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="comment">// Check type selector</span></span><br><span class="line">    <span class="keyword">if</span> selector.tag_name.iter().any(|name| elem.tag_name != *name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check ID selector</span></span><br><span class="line">    <span class="keyword">if</span> selector.id.iter().any(|id| elem.id() != <span class="literal">Some</span>(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check class selectors</span></span><br><span class="line">    <span class="keyword">let</span> elem_classes = elem.classes();</span><br><span class="line">    <span class="keyword">if</span> selector.class.iter().any(|class| !elem_classes.contains(&amp;**class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn&#x27;t find any non-matching selector components.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Rust笔记：这个函数使用<code>any</code>这个方法，如果迭代器包含一个可以通过提供的测试函数的元素则返回true。类似于 Python 或者 Haskell 里的 <code>any</code> 函数，JavaScript 里的 <code>some</code> 方法</p>
</blockquote>
<h2 id="构建样式树-Build-the-Style-Tree"><a href="#构建样式树-Build-the-Style-Tree" class="headerlink" title="构建样式树 Build the Style Tree"></a>构建样式树 Build the Style Tree</h2><p>接下来，我们需要遍历整个DOM树，对于树中的每个元素，我们将在样式表中搜索匹配的规则。</p>
<p>比较两个匹配相同元素的规则时，我们需要使用每个匹配项中 <strong>最高明确性(highest specificity)</strong> 的选择器。因为我们CSS解析器储存的选择器是按明确性从高往低排序的，所以我们可以在找到匹配的选择器后立即停止，然后返回其明确性以及规则的指针。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MatchedRule</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = (Specificity, &amp;<span class="symbol">&#x27;a</span> Rule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If `rule` matches `elem`, return a `MatchedRule`. Otherwise return `None`.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">match_rule</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(elem: &amp;ElementData, rule: &amp;<span class="symbol">&#x27;a</span> Rule) -&gt; <span class="built_in">Option</span>&lt;MatchedRule&lt;<span class="symbol">&#x27;a</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Find the first (highest-specificity) matching selector.</span></span><br><span class="line">    rule.selectors.iter()</span><br><span class="line">        .find(|selector| matches(elem, *selector))</span><br><span class="line">        .map(|selector| (selector.specificity(), rule))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了找到与某个元素匹配的所有规则，我们调用<code>filter_map</code>方法，它可以线性扫描整个样式表，检查每个规则并丢弃不匹配的规则。真正的浏览器引擎会通过基于标签名，ID，class等将规则存储在多个哈希表，从而实现快速匹配。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all CSS rules that match the given element.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matching_rules</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(elem: &amp;ElementData, stylesheet: &amp;<span class="symbol">&#x27;a</span> Stylesheet) -&gt; <span class="built_in">Vec</span>&lt;MatchedRule&lt;<span class="symbol">&#x27;a</span>&gt;&gt; &#123;</span><br><span class="line">    stylesheet.rules.iter().filter_map(|rule| match_rule(elem, rule)).collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦有了匹配的规则，我们就可以找到元素的 **指定值(specified value)**。将每个规则的属性值插入到<code>HashMap</code>。将规则按 <strong>明确性(specificity)</strong> 排序，这样较高明确性的规则会在较低的之后进行处理，可以在<code>HashMap</code>将它们的值覆盖。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply styles to a single element, returning the specified values.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">specified_values</span></span>(elem: &amp;ElementData, stylesheet: &amp;Stylesheet) -&gt; PropertyMap &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> values = HashMap::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rules = matching_rules(elem, stylesheet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go through the rules from lowest to highest specificity.</span></span><br><span class="line">    rules.sort_by(|&amp;(a, _), &amp;(b, _)| a.cmp(&amp;b));</span><br><span class="line">    <span class="keyword">for</span> (_, rule) <span class="keyword">in</span> rules &#123;</span><br><span class="line">        <span class="keyword">for</span> declaration <span class="keyword">in</span> &amp;rule.declarations &#123;</span><br><span class="line">            values.insert(declaration.name.clone(), declaration.value.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们拥有了遍历DOM树并构建样式树所需的一切。需要注意的是，选择器匹配仅适用于元素，因此文本节点的指定值只是一个空的<code>map</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply a stylesheet to an entire DOM tree, returning a StyledNode tree.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">style_tree</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(root: &amp;<span class="symbol">&#x27;a</span> Node, stylesheet: &amp;<span class="symbol">&#x27;a</span> Stylesheet) -&gt; StyledNode&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    StyledNode &#123;</span><br><span class="line">        node: root,</span><br><span class="line">        specified_values: <span class="keyword">match</span> root.node_type &#123;</span><br><span class="line">            Element(<span class="keyword">ref</span> elem) =&gt; specified_values(elem, stylesheet),</span><br><span class="line">            Text(_) =&gt; HashMap::new()</span><br><span class="line">        &#125;,</span><br><span class="line">        children: root.children.iter().map(|child| style_tree(child, stylesheet)).collect(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是Robinson关于构建样式树的所有代码。接下来，我将谈论一些明显的遗漏。</p>
<h2 id="层叠-Cascade"><a href="#层叠-Cascade" class="headerlink" title="层叠 Cascade"></a>层叠 Cascade</h2><p>由网页作者提供的样式表称为 **作者样式表(author stlye sheets)**，除此之外，浏览器还通过 <strong>用户代理样式表(user agent style sheets)</strong> 提供了<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/sample.html">默认样式</a>。还有它可以允许用户通过 <strong>用户样式表(user style sheets)</strong> 添加自定义样式（比如 Gecko 的 <a target="_blank" rel="noopener" href="http://www-archive.mozilla.org/unix/customizing.html#usercss">userContent.css</a>）。</p>
<p>层叠(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html#cascade">cascade</a>) 定义了这三个“数据源”哪个优先权更高。层叠有六个级别：每个数据源都有”普通(normal)“声明，加上每个数据源还有<code>!important</code>声明。</p>
<p>Robinson的样式代码没有实现层叠的功能。它仅读取一个样式表。缺少默认样式表意味着HTML元素不会有你预期的任何默认样式。例如：<code>&lt;head&gt;</code>元素的内容不会被隐藏，除非你明确在你的样式表中添加这个规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head &#123; <span class="attribute">display</span>: none &#125;</span><br></pre></td></tr></table></figure>

<p>实现层叠应该相当容易：只需跟踪每条规则的起源，并根据明确性排序，其中明确性要加入数据源和重要性这些权重。一个简化的两级层叠应该足以支持最常见的情况：普通用户代理样式 和 普通作者样式。</p>
<h2 id="计算值-Computed-Values"><a href="#计算值-Computed-Values" class="headerlink" title="计算值 Computed Values"></a>计算值 Computed Values</h2><p>除了上述提到的“指定值(sepecified values)”之外，CSS还定义了 <strong>初始值(initial values)<strong>，</strong>计算值(computed values)<strong>，</strong>使用值(used values)</strong> 和 **实际值(actual values)**。<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html#value-stages">CSS标准链接</a></p>
<p>初始值是层叠中没有指定的属性默认值。计算值则是基于指定值的，但可能会应用一些特定属性的规范化规则。</p>
<p>根据CSS规范的定义，正确实现这些属性需要为每个属性使用的单独的代码。这是现实浏览器引擎的必要工作，但希望在我的玩具项目中避免这些。在后面阶段，在缺少指定值的时候，使用这些值的代码会（通过某种方式）使用默认值来模拟初始值。</p>
<p>使用值 和 实际值则是在布局期间和布局之后计算的，我将在以后的文章中介绍。</p>
<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h2><p>如果文本节点不匹配任何选择器，那么它如何得到颜色和字体和其他样式呢？答案就是 <strong>继承</strong>(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html#inheritance">inheritance</a>)。</p>
<p>继承属性后，没有层叠值(cascaded value)的任何节点都将收到该属性的父元素的值。默认情况下，某些属性（如颜色）都是继承过来的；其他的属性只有在层叠值指定特殊值<code>inherit</code>时才会继承父元素。</p>
<p>我的代码没有支持继承。要实现这个，可以将父元素的样式数据传入<code>specified_values</code>函数，并使用硬编码的查找表来决定应继承哪些属性。</p>
<h2 id="样式属性-Style-Attributes"><a href="#样式属性-Style-Attributes" class="headerlink" title="样式属性 Style Attributes"></a>样式属性 Style Attributes</h2><p>任何HTML元素都可以包括一个<code>style</code>属性，其中包含一系列的CSS声明。它们没有选择器，因为这些声明自动应用到这个元素本身。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red; background: yellow;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  如果你想支持<code>style</code>属性，让<code>specified_values</code>函数检查属性即可。如果存在该属性，则将它从CSS解析器传入<code>parse_declarations</code>。由于这些属性比任何CSS选择器都更明确，因此在在 <strong>普通作者声明(normal author declarations)</strong> 之后应用这些 **结果声明(resulting declarations)**。</p>
<p>  原文链接：<a target="_blank" rel="noopener" href="https://limpet.net/mbrubeck/2014/08/23/toy-layout-engine-4-style.html">https://limpet.net/mbrubeck/2014/08/23/toy-layout-engine-4-style.html</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>手把手教你实现一个浏览器引擎（四）Style</p><p><a href="https://leejim.github.io/blog/2020/02/12/browser/how-broswers-work-4/">https://leejim.github.io/blog/2020/02/12/browser/how-broswers-work-4/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>leejimqiu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-02-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="africans.cn" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="//buymeacoffee.com/leejim" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/blog/2020/02/19/browser/how-broswers-work-5/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">手把手教你实现一个浏览器引擎（五）Boxes</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/blog/2020/02/10/browser/how-broswers-work-3/"><span class="level-item">手把手教你实现一个浏览器引擎（三）CSS</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://leejim.github.io/blog/2020/02/12/browser/how-broswers-work-4/';
            this.page.identifier = '2020/02/12/browser/how-broswers-work-4/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'leejim' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第四部分-Style"><span class="level-left"><span class="level-item">1</span><span class="level-item">第四部分 Style</span></span></a></li><li><a class="level is-mobile" href="#样式树-The-Style-Tree"><span class="level-left"><span class="level-item">2</span><span class="level-item">样式树 The Style Tree</span></span></a></li><li><a class="level is-mobile" href="#匹配选择器-Selector-Matching"><span class="level-left"><span class="level-item">3</span><span class="level-item">匹配选择器 Selector Matching</span></span></a></li><li><a class="level is-mobile" href="#构建样式树-Build-the-Style-Tree"><span class="level-left"><span class="level-item">4</span><span class="level-item">构建样式树 Build the Style Tree</span></span></a></li><li><a class="level is-mobile" href="#层叠-Cascade"><span class="level-left"><span class="level-item">5</span><span class="level-item">层叠 Cascade</span></span></a></li><li><a class="level is-mobile" href="#计算值-Computed-Values"><span class="level-left"><span class="level-item">6</span><span class="level-item">计算值 Computed Values</span></span></a></li><li><a class="level is-mobile" href="#继承-Inheritance"><span class="level-left"><span class="level-item">7</span><span class="level-item">继承 Inheritance</span></span></a></li><li><a class="level is-mobile" href="#样式属性-Style-Attributes"><span class="level-left"><span class="level-item">8</span><span class="level-item">样式属性 Style Attributes</span></span></a></li></ul></div></div><script src="/blog/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog/"><img src="/blog/img/logo.svg" alt="Jim Home" height="28"></a><p class="is-size-7"><span>&copy; 2023 leejimqiu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leejim"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="粤ICP备19015289号" href="https://beian.miit.gov.cn">粤ICP备19015289号</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/blog/js/column.js"></script><script src="/blog/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>