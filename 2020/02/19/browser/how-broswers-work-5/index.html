<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>手把手教你实现一个浏览器引擎（五）Boxes - Jim Home</title><link rel="manifest" href="/blog/manifest.json"><meta name="application-name" content="leejimqiu"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="leejimqiu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="第五部分：Boxes这是关于编写一个简单HTML渲染引擎系列文章的最后一篇（译者注：后续两篇是对这部分内容的补充）：  第一部分：起步 第二部分：HTML 第三部分：CSS 第四部分：Style  这篇文章将开始讨论 布局(layout) 模块，它将输入的样式树，转换成二维空间的一堆矩形。这是一个庞大的模块，因此我将它拆分成多篇文章。另外，我为后面部分内容写代码时，可能会改动这篇文章分享的一些代码"><meta property="og:type" content="blog"><meta property="og:title" content="手把手教你实现一个浏览器引擎（五）Boxes"><meta property="og:url" content="https://leejim.github.io/blog/2020/02/19/browser/how-broswers-work-5/"><meta property="og:site_name" content="Jim Home"><meta property="og:description" content="第五部分：Boxes这是关于编写一个简单HTML渲染引擎系列文章的最后一篇（译者注：后续两篇是对这部分内容的补充）：  第一部分：起步 第二部分：HTML 第三部分：CSS 第四部分：Style  这篇文章将开始讨论 布局(layout) 模块，它将输入的样式树，转换成二维空间的一堆矩形。这是一个庞大的模块，因此我将它拆分成多篇文章。另外，我为后面部分内容写代码时，可能会改动这篇文章分享的一些代码"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://leejim.github.io/blog/images/browsers/boxes-1.jpg"><meta property="og:image" content="https://leejim.github.io/blog/images/browsers/boxes-2.jpg"><meta property="og:image" content="https://leejim.github.io/blog/images/browsers/boxes-3.jpg"><meta property="og:image" content="https://leejim.github.io/blog/images/browsers/boxes-4.jpg"><meta property="article:published_time" content="2020-02-19T12:49:01.000Z"><meta property="article:modified_time" content="2023-08-04T13:15:23.437Z"><meta property="article:author" content="leejimqiu"><meta property="article:tag" content="leejimqiu,"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/blog/images/browsers/boxes-1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://leejim.github.io/blog/2020/02/19/browser/how-broswers-work-5/"},"headline":"手把手教你实现一个浏览器引擎（五）Boxes","image":["https://leejim.github.io/blog/images/browsers/boxes-1.jpg","https://leejim.github.io/blog/images/browsers/boxes-2.jpg","https://leejim.github.io/blog/images/browsers/boxes-3.jpg","https://leejim.github.io/blog/images/browsers/boxes-4.jpg"],"datePublished":"2020-02-19T12:49:01.000Z","dateModified":"2023-08-04T13:15:23.437Z","author":{"@type":"Person","name":"leejimqiu"},"publisher":{"@type":"Organization","name":"Jim Home","logo":{"@type":"ImageObject","url":"https://leejim.github.io/img/logo.svg"}},"description":"第五部分：Boxes这是关于编写一个简单HTML渲染引擎系列文章的最后一篇（译者注：后续两篇是对这部分内容的补充）：  第一部分：起步 第二部分：HTML 第三部分：CSS 第四部分：Style  这篇文章将开始讨论 布局(layout) 模块，它将输入的样式树，转换成二维空间的一堆矩形。这是一个庞大的模块，因此我将它拆分成多篇文章。另外，我为后面部分内容写代码时，可能会改动这篇文章分享的一些代码"}</script><link rel="canonical" href="https://leejim.github.io/blog/2020/02/19/browser/how-broswers-work-5/"><link rel="icon" href="/blog/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?6638f74329d0f52c5cdafdadb58010af";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog/"><img src="/blog/img/logo.svg" alt="Jim Home" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog/">Home</a><a class="navbar-item" href="/blog/archives">Archives</a><a class="navbar-item" href="/blog/categories">Categories</a><a class="navbar-item" href="/blog/tags">Tags</a><a class="navbar-item" href="/blog/projects">Projects</a><a class="navbar-item" href="/blog/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leejim"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-19T12:49:01.000Z" title="2/19/2020, 12:49:01 PM">2020-02-19</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:15:23.437Z" title="8/4/2023, 1:15:23 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">12 分钟读完 (大约1800个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">手把手教你实现一个浏览器引擎（五）Boxes</h1><div class="content"><h2 id="第五部分：Boxes"><a href="#第五部分：Boxes" class="headerlink" title="第五部分：Boxes"></a>第五部分：Boxes</h2><p>这是关于编写一个简单HTML渲染引擎系列文章的最后一篇（译者注：后续两篇是对这部分内容的补充）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00086eef5fcff8f5b3c97d08551413">第一部分：起步</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">第二部分：HTML</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/0004ae6f0b4c80883de95cfaa59413">第三部分：CSS</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000c0e53584310a068e9f0f7c5fc13">第四部分：Style</a></li>
</ul>
<p>这篇文章将开始讨论 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/master/src/layout.rs">布局(layout)</a> 模块，它将输入的样式树，转换成二维空间的一堆矩形。这是一个庞大的模块，因此我将它拆分成多篇文章。另外，我为后面部分内容写代码时，可能会改动这篇文章分享的一些代码。</p>
<p>布局模块的输入是来自 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000c0e53584310a068e9f0f7c5fc13">第四部分</a> 的样式树，输出的是其他的树——**布局树(layout tree)**。这让我们的迷你渲染流程向前迈进了一步：</p>
<p><img src="/blog/images/browsers/boxes-1.jpg"></p>
<p>我将从基础的HTML/CSS布局模型开始讲起。如果你曾经学过开发网页，则可能已经对这些比较熟悉——不过它可能和开发者的视角不太一样。</p>
<h2 id="盒模型-The-Box-Model"><a href="#盒模型-The-Box-Model" class="headerlink" title="盒模型 The Box Model"></a>盒模型 The Box Model</h2><p>布局与 <strong>盒子(boxes)</strong> 有关。盒子是网页的矩形部分。它有 **宽度(width)<strong>，</strong>高度(height)**，和在页面上的 **位置(position)**。这个矩形被称为 <strong>内容区域(content area)</strong> ，因为它是盒子内容绘制的位置。内容可能是文本，图片，视频或者其他盒子。</p>
<p>盒子可能也有 <strong>内边距(padding)<strong>，</strong>边框(borders)<strong>，</strong>外边距(margins)</strong> 围绕着它的内容区域。CSS规范有一张 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/box.html#box-dimensions">例图</a> 展示了所有这些层是如何组合在一起的。</p>
<p>Robinson使用以下的结构来存储盒子的内容区域和周围区域。</p>
<blockquote>
<p>Rust笔记：<code>f32</code>是32位浮点类型。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSS box model. All sizes are in px.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dimensions</span></span> &#123;</span><br><span class="line">    <span class="comment">// Position of the content area relative to the document origin:</span></span><br><span class="line">    content: Rect,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Surrounding edges:</span></span><br><span class="line">    padding: EdgeSizes,</span><br><span class="line">    border: EdgeSizes,</span><br><span class="line">    margin: EdgeSizes,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f32</span>,</span><br><span class="line">    y: <span class="built_in">f32</span>,</span><br><span class="line">    width: <span class="built_in">f32</span>,</span><br><span class="line">    height: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeSizes</span></span> &#123;</span><br><span class="line">    left: <span class="built_in">f32</span>,</span><br><span class="line">    right: <span class="built_in">f32</span>,</span><br><span class="line">    top: <span class="built_in">f32</span>,</span><br><span class="line">    bottom: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="块和内联布局-Block-and-Inline-Layout"><a href="#块和内联布局-Block-and-Inline-Layout" class="headerlink" title="块和内联布局 Block and Inline Layout"></a>块和内联布局 Block and Inline Layout</h2><p>CSS的<code>display</code>属性决定元素生成哪种类型的盒子。CSS定义了多种盒类型，各自有自己的布局规则。我只打算介绍其中两种：<strong>块(block)</strong> 和 **内联(inline)**。</p>
<p>我使用伪HTML来说明两者的差别：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c</span>&gt;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">d</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>块状盒子(Block boxes)</strong> 自上而下垂直地在他们的容器内排列。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c, d &#123; <span class="attribute">display</span>: block; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/browsers/boxes-2.jpg"></p>
<p><strong>内联盒子(inline boxes)</strong> 自左向右水平地在他们的容器里排列。如果他们触碰到容器的右边缘，将会环绕着容器，并继续在下面起新的一行排列。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c, d &#123; <span class="attribute">display</span>: inline; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/browsers/boxes-3.jpg"></p>
<p>每个盒子只能包含 **块级子元素(block children)**，或者 **内联子元素(inline children)**。当一个DOM元素包含了混合块级子元素和内联子元素时，布局引擎插入一个 <strong>匿名盒子(anonymous boxes)</strong> 去分隔两种类型。（这些盒子是“匿名的”，因为他们与DOM树种的节点没有关联）</p>
<p>在这个例子中，内联盒子 b 和 c 被一个匿名块状盒子围绕着，用粉色显示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>    &#123; <span class="attribute">display</span>: block; &#125;</span><br><span class="line"><span class="selector-tag">b</span>, c &#123; <span class="attribute">display</span>: inline; &#125;</span><br><span class="line">d    &#123; <span class="attribute">display</span>: block; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/browsers/boxes-4.jpg"></p>
<p>注意，默认情况下内容是纵向增长的。也就是说，添加子元素到容器内，通常使其变得更高，而不是更宽。换句话说，一块或者一行的宽度是依赖它们容器的宽度，而容器的高度则依赖子元素的高度。</p>
<p>如果你覆盖了例如<code>width</code>和<code>height</code>属性的默认值的话，情况将变得更加复杂。如果要支持垂直书写这样的特性的话，则情况会更加复杂。</p>
<h2 id="布局树-The-Layout-Tree"><a href="#布局树-The-Layout-Tree" class="headerlink" title="布局树 The Layout Tree"></a>布局树 The Layout Tree</h2><p>布局树是盒子的集合。盒子有尺寸，并且可能包含 **子盒子(child boxes)**。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutBox</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    dimensions: Dimensions,</span><br><span class="line">    box_type: BoxType&lt;<span class="symbol">&#x27;a</span>&gt;,</span><br><span class="line">    children: <span class="built_in">Vec</span>&lt;LayoutBox&lt;<span class="symbol">&#x27;a</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>盒子可以是一个块级节点，一个内联节点，或者是一个匿名块状盒子（如果我实现文本布局，这个将需要改变，因为换行会导致单个内联节点拆分为多个盒子。不过目前这样也是可以的）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BoxType</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    BlockNode(&amp;<span class="symbol">&#x27;a</span> StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    InlineNode(&amp;<span class="symbol">&#x27;a</span> StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    AnonymousBlock,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建布局树，我们需要查看每个DOM节点的<code>display</code>属性。为了获得节点的<code>display</code>的值，我在<code>style</code>模块添加了一些代码。如果没有指定的值，则返回默认值<code>inline</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">enum Display &#123;</span><br><span class="line">    Inline,</span><br><span class="line">    Block,</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl StyledNode &#123;</span><br><span class="line">    // Return the specified value of a property if it exists, otherwise `None`.</span><br><span class="line">    fn value(&amp;self, name: &amp;str) -&gt; Option&lt;Value&gt; &#123;</span><br><span class="line">        self.specified_values.get(name).map(|v| v.clone())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The value of the `display` property (defaults to inline).</span><br><span class="line">    fn display(&amp;self) -&gt; Display &#123;</span><br><span class="line">        match self.value(&quot;display&quot;) &#123;</span><br><span class="line">            Some(Keyword(s)) =&gt; match &amp;*s &#123;</span><br><span class="line">                &quot;block&quot; =&gt; Display::Block,</span><br><span class="line">                &quot;none&quot; =&gt; Display::None,</span><br><span class="line">                _ =&gt; Display::Inline</span><br><span class="line">            &#125;,</span><br><span class="line">            _ =&gt; Display::Inline</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以遍历样式树，为每个节点构建一个<code>LayoutBox</code>，然后为改节点的子级插入盒子。如果一个节点的<code>display</code>属性设置成<code>none</code>，那么它将不会被包含在布局树里。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build the tree of LayoutBoxes, but don&#x27;t perform any layout calculations yet.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_layout_tree</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(style_node: &amp;<span class="symbol">&#x27;a</span> StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;) -&gt; LayoutBox&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Create the root box.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> root = LayoutBox::new(<span class="keyword">match</span> style_node.display() &#123;</span><br><span class="line">        Block =&gt; BlockNode(style_node),</span><br><span class="line">        Inline =&gt; InlineNode(style_node),</span><br><span class="line">        DisplayNone =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Root node has display: none.&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the descendant boxes.</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> &amp;style_node.children &#123;</span><br><span class="line">        <span class="keyword">match</span> child.display() &#123;</span><br><span class="line">            Block =&gt; root.children.push(build_layout_tree(child)),</span><br><span class="line">            Inline =&gt; root.get_inline_container().children.push(build_layout_tree(child)),</span><br><span class="line">            DisplayNone =&gt; &#123;&#125; <span class="comment">// Skip nodes with `display: none;`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> LayoutBox &#123;</span><br><span class="line">    <span class="comment">// Constructor function</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(box_type: BoxType) -&gt; LayoutBox &#123;</span><br><span class="line">        LayoutBox &#123;</span><br><span class="line">            box_type: box_type,</span><br><span class="line">            dimensions: <span class="built_in">Default</span>::default(), <span class="comment">// initially set all fields to 0.0</span></span><br><span class="line">            children: <span class="built_in">Vec</span>::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个块级节点包含一个内联子级，创建一个匿名块级盒子去包含它。如果有多个内联子级在同一行，那么将他们都放在同一个匿名容器里。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Where a new inline child should go.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_inline_container</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> LayoutBox &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.box_type &#123;</span><br><span class="line">        InlineNode(_) | AnonymousBlock =&gt; <span class="keyword">self</span>,</span><br><span class="line">        BlockNode(_) =&gt; &#123;</span><br><span class="line">            <span class="comment">// If we&#x27;ve just generated an anonymous block box, keep using it.</span></span><br><span class="line">            <span class="comment">// Otherwise, create a new one.</span></span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.children.last() &#123;</span><br><span class="line">                <span class="literal">Some</span>(&amp;LayoutBox &#123; box_type: AnonymousBlock,..&#125;) =&gt; &#123;&#125;</span><br><span class="line">                _ =&gt; <span class="keyword">self</span>.children.push(LayoutBox::new(AnonymousBlock))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.children.last_mut().unwrap()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是从标准CSS <strong>盒子生成(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/visuren.html#box-gen">box generation</a>)</strong> 算法刻意通过多种方式简化后的版本。例如，这版本无法处理一个内联盒子包含块级子级的情况。还有，如果一个块级节点仅有一个内联子级，这会生成一个不必要的匿名盒子。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://limpet.net/mbrubeck/2014/09/08/toy-layout-engine-5-boxes.html">https://limpet.net/mbrubeck/2014/09/08/toy-layout-engine-5-boxes.html</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>手把手教你实现一个浏览器引擎（五）Boxes</p><p><a href="https://leejim.github.io/blog/2020/02/19/browser/how-broswers-work-5/">https://leejim.github.io/blog/2020/02/19/browser/how-broswers-work-5/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>leejimqiu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-02-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="africans.cn" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="//buymeacoffee.com/leejim" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/blog/2020/02/20/browser/how-broswers-work-6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">手把手教你实现一个浏览器引擎（六）Block Layout</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/blog/2020/02/12/browser/how-broswers-work-4/"><span class="level-item">手把手教你实现一个浏览器引擎（四）Style</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://leejim.github.io/blog/2020/02/19/browser/how-broswers-work-5/';
            this.page.identifier = '2020/02/19/browser/how-broswers-work-5/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'leejim' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#第五部分：Boxes"><span class="level-left"><span class="level-item">1</span><span class="level-item">第五部分：Boxes</span></span></a></li><li><a class="level is-mobile" href="#盒模型-The-Box-Model"><span class="level-left"><span class="level-item">2</span><span class="level-item">盒模型 The Box Model</span></span></a></li><li><a class="level is-mobile" href="#块和内联布局-Block-and-Inline-Layout"><span class="level-left"><span class="level-item">3</span><span class="level-item">块和内联布局 Block and Inline Layout</span></span></a></li><li><a class="level is-mobile" href="#布局树-The-Layout-Tree"><span class="level-left"><span class="level-item">4</span><span class="level-item">布局树 The Layout Tree</span></span></a></li></ul></div></div><script src="/blog/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog/"><img src="/blog/img/logo.svg" alt="Jim Home" height="28"></a><p class="is-size-7"><span>&copy; 2023 leejimqiu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leejim"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="粤ICP备19015289号" href="https://beian.miit.gov.cn">粤ICP备19015289号</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/blog/js/column.js"></script><script src="/blog/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>