{"pages":[{"title":"我的项目","text":"陆陆续续捣鼓了许多小工具，希望对大家有所帮助吧。 开源项目Jeep-UI 基于 Vue.js 2.x 框架的 UI 库，专注于快速生成 form 表单 因为ElementUI比较繁琐，而突发奇想做出来 smapp VSCode 插件，用于小程序开发，提供了一些自己想要的功能 wxml-minifier 微信小程序的 WXML 压缩工具。 小程序分享壁纸通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。 天气号初次尝试云开发，通过第三方API获取天气信息。 Web应用Web Hunter分享自己发现的有趣网站。 本来时拿来练手全栈开发的，后来通过博客系统改造而成，更简单便捷用于验证项目是否有价值。","link":"/blog/projects/index.html"},{"title":"","text":"LeeJimWeb 前端开发 / （正在努力增加斜杠称呼） 挺反感那些人叫“码农”的，但回过来一想。 其实连“码农”也不如，因为还没法达到 自给自足 的状态，只能称为“码工”，是一个工人。 未来希望可以成为 自给自足 的“码农”，不再打工。 之前总觉得需要独立开发一些 toC 的产品，但最近的思考是，其实 toT 也是一个不错的选择，成功的榜样比如 尤雨溪 或者 antfu 。—— leejim 2022.1","link":"/blog/about/index.html"}],"posts":[{"title":"多版本 Node.js","text":"最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。 然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。 于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。 所以我发现，拥有多版本的Node.js还是很有必要的。 开发环境linux / MacOs如果是在*nux的开发环境可以直接安装nvm即可 Windows需要安装nvm-window。github地址在此，下载地址在此 在此我着重说一下nvm-windows需要注意的地方： 安装nvm-windows之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用） 需要把NPM删掉(e.g. “C:\\Users\\AppData\\Roaming\\npm”) 对应每个Node.js版本的全局安装方法都用重新安装，比如： 1234567nvm use 4.0.0npm install -g grunt#切换版本nvm use 7.0.0npm install -g grunt","link":"/blog/2016/11/03/nvm-windows/"},{"title":"MongoDB 使用记录","text":"记录一下mongodb的使用记录，包含常用的启动、操作等命令。 初始化文件目录123456-data #数据+ log #日志 - mongod.log+ conf #配置文件 - mongod.confbin #二进制目录 启动的配置文件1234port = 12345 #启动端口dbpath = data #数据路径logpath = log/mongod.log #日志路径fork = true #表明启动的是后台进程 windows下无效 启动启动数据库1mongod -f conf/mongod.conf 连接数据库1mongo 127.0.0.1:12345/test 基本操作1234show dbs #显示所有数据库use company #使用company数据库 不存在则自动创建show collections #显示所有collectionshow tables #效果同上 CRUD插入数据123db.company_list.insert({name: 'one'}) # company_list为collection，不存在则自动创建，然后插入一个数据for(i=0;i&lt;10;i++) db.company_list.insert({name: i}) #使用js的语法插入10个数据 查找数据12345db.company_list.find() #显示该collection的所有数据db.company_list.find({name: 'one'}) #显示对应条件的数据db.company_list.find().skip(2).limit(3).sort({name: 1}) #跳过前2个数据，按name排序获取3个数据 数据更新1234567db.company_list.update({x:1}, {x:1000}) #第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即{x:1,y:1} =&gt; {x:1000}）db.company_list.update({x:1}, {$set: {x:1000}}) #只修改x字段db.company_list.update({x:99, {y:99}, true}) #修改一个不存在的数据则插入这个数据db.company_list.update({x:1}, {y:99}, false, true}) #批量修改多条数据 删除数据12db.company_list.remove({x:1}) #默认删除对应条件的所有数据dp.company_list.drop() #删除collection 索引相关12db.company_list.getIndexes() #列出所有索引db.company_list.ensureIndex({x:1}) #设置索引 索引的类型 _id索引 单键索引 多键索引 复合索引 过期索引 全文索引 地理位置索引 权限相关创建用户123456db.createUser({ user: &quot;&lt;name&gt;&quot;, pwd: &quot;&lt;cleartext password&gt;&quot;, customData: {&lt;any information}, roles: [{role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot;}]}) 用户类型： read readWrite dbAdmin dbOwner userAdmin","link":"/blog/2016/10/17/mongodb/"},{"title":"如果使用 Node.js 的 Buffers","text":"在纯 JavaScript 开发中，unicode 编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js 是服务器环境，必须要处理 TCP 流还有文件系统的读取和写入流，这就让 JavaScript 需要处理纯二进制数据了。 其实，要解决这个问题直接使用字符串也是可以的，这也是 Node.js 一开始的做法。然而，这样的做法有许多问题，也很慢。 所以，记住了，别使用二进制字符串(binary strings)，用 buffers 代替它！ 什么是Buffers？在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。 每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。 另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1) 在哪里可以看到buffers一般情况，buffer经常可以在读取二进制数据流的时候看到，比如fs.createReadStream 用法：创建buffer有许多方法可以生成新的buffers： 1var buffer = new Buffer(8); 这个buffer是未初始化的，且包含8个字节(bytes)。 1var buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]); 这个buffer用一个数组的内容来初始化。记住了，数组里的数字表示的是字节(bytes) 1var buffer = new Buffer(&quot;I'm a string!&quot;, &quot;utf-8&quot;) 通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码： “ascii”：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。 “ucs2”：一种双字节，小端存储的编码。可以编码一个unicode的子集。 “base64”：Base64字符串编码。 “binary”：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。 写入buffer创建一个buffer：1&gt; var buffer = new Buffer(16); 开始写入字符串： 12&gt; buffer.write(&quot;Hello&quot;, &quot;utf-8&quot;)5 buffer.write的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。 buffer.write返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要： 12&gt; buffer.write(&quot; world!&quot;, 5, &quot;utf-8&quot;)7 当buffer.write有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。 读取buffertoString：这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本： 12&gt; buffer.toString('utf-8')'Hello world!\\u0000�k\\t' 再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串： 12&gt; buffer.toString(&quot;utf-8&quot;, 0, 12)'Hello world!' 独立字节：你可以看到用类似数组的语法来设置独立位(individual bits) 12345678910&gt; buffer[12] = buffer[11];33&gt; buffer[13] = &quot;1&quot;.charCodeAt();49&gt; buffer[14] = buffer[13];49&gt; buffer[15] = 3333&gt; buffer.toString(&quot;utf-8&quot;)'Hello world!!11!' 在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。 更多有趣用法Buffer.isBuffer(object)这个方法是检测一个对象是否是buffer，类似于Array.isArray Buffer.byteLength(string, encoding)通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如： 12345&gt; var snowman = &quot;☃&quot;;&gt; snowman.length1&gt; Buffer.byteLength(snowman)3 这个unicode的雪人只有两个字符，却占了3个字节。 buffer.length这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如： 12345&gt; var buffer = new Buffer(16)&gt; buffer.write(snowman)3&gt; buffer.length16 在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。 buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)buffer.copy允许拷贝一个buffer的内容到另一个buffer。 第一个参数表示目标buffer，就是要写入内容的buffer。 另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子： 12345678&gt; var frosty = new Buffer(24)&gt; var snowman = new Buffer(&quot;☃&quot;, &quot;utf-8&quot;)&gt; frosty.write(&quot;Happy birthday! &quot;, &quot;utf-8&quot;)16&gt; snowman.copy(frosty, 16)3&gt; frosty.toString(&quot;utf-8&quot;, 0, 19)'Happy birthday! ☃' 在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。 其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。 buffer.slice(start, end=buffer.length)这个方法的API可以说和Array.prototype.slice是一样的。 不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例： 1234567&gt; var puddle = frosty.slice(16, 19)&gt; puddle.toString()'☃'&gt; puddle.write(&quot;___&quot;)3&gt; frosty.toString(&quot;utf-8&quot;, 0, 19)'Happy birthday! ___' 完。","link":"/blog/2017/10/06/how-to-use-buffers/"},{"title":"开始拥抱 Gulp","text":"前端工作流中常用的构建工具除了grunt，还有一个gulp(当然现在还有webpack)。gulp是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于nodejs流的构建工具，而且执行很快。 既然有了grunt，为啥还要来学习gulp呢？这是一个好问题，用过grunt的都知道，每次写Gruntfile.js的时候，都要先写一大片的配置文件，而gulp和grunt最大的差别在于，gulp是执行代码覆盖配置的。这样的好处在于，gulpfile.js很容易写，而且阅读起来清晰明了，并且容易维护。 gulp使用node.js的流(stream)，这让gulp构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看这篇文章（写得很好） gulp允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像grunt那样，为每一个grunt都写一些配置信息和输入输出路径。让我们看下使用grunt和gulp写的Sass编译： Grunt: 123456789101112131415161718192021222324sass: { dist: { options: { style: 'expanded' }, files: { 'dist/assets/css/main.css': 'src/styles/main.scss', } }},autoprefixer: { dist: { options: { browsers: [ 'last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4' ] }, src: 'dist/assets/css/main.css', dest: 'dist/assets/css/main.css' }},grunt.registerTask('styles', ['sass', 'autoprefixer']); Grunt需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到Sass插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给Autoprefixer输入，然后我们再将文件输出保存起来。 gulp: 12345gulp.task('sass', function() { return sass('src/styles/main.scss', { style: 'expanded' }) .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4')) .pipe(gulp.dest('dist/assets/css'))}); 使用gulp的时候，我们只需要输入一个文件，然后经过Sass插件修改，然后经过Autoprefixer插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。 安装Gulp在我们钻研配置任务信息之前，我们需要安装gulp： 1$ npm install gulp -g 以上命令会在全局环境上安装gulp，让我们可以使用gulp命令行。然后，我们需要在项目文件夹内安装本地的gulp，cd到你的项目路径，然后运行一下命令(执行命令前需确保项目下有package.json这个文件) 1$ npm install gulp --save-dev 以上命令会在项目内安装本地的gulp并保存到package.json里的devDependencies 安装gulp插件我们需要安装一些插件来完成以下的任务： 编译sass (gulp-ruby-sass) 自动添加厂商前缀 (gulp-autoprefixer) 压缩CSS (gulp-cssnano) js检测 (gulp-jshint) 合并文件 (gulp-concat) 压缩JS (gulp-uglify) 压缩图片 (gulp-imagemin) 动态加载 (gulp-livereload) 缓存图片然后只压缩改变后的图片 (gulp-cache) 提示信息 (gulp-notify) 清除文件 (del) 通过以下命令来安装这些插件： 1npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev 这将会安装全部需要的插件并将它们保存到package.json的devDependencies里面。你可以在这里找到gulp的全部插件。 加载插件之后，我们要创建一个文件夹gulpfile.js并加载这些插件： 12345678910111213var gulp = require('gulp'), sass = require('gulp-ruby-sass'), autoprefixer = require('gulp-autoprefixer'), cssnano = require('gulp-cssnano'), jshint = require('gulp-jshint'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), rename = require('gulp-rename'), concat = require('gulp-concat'), notify = require('gulp-notify'), cache = require('gulp-cache'), livereload = require('gulp-livereload'), del = require('del'); 这个时候，看起来是不是好像需要写的东西比grunt还多？其实，gulp插件和grunt插件有略微的不同——gulp插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，grunt的imagemin使用缓存来避免压缩已经压缩过的图片；而gulp则需要cache插件来协助完成这样的任务，当然cache插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？ 我们同样可以像grunt那样自动加载所有已安装的插件，不过为了这篇文章，我们就将坚持纯手工工艺！ 创建任务Compile Sass, Autoprefix and minify首先，我们先配置Sass编译，然后使用Autoprefixer添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给cssnao压缩成一个.min版本，最后再输出到另一个目的地，最后的最后调用notify提示我们任务完成了： 123456789gulp.task('styles', function() { return sass('src/styles/main.scss', { style: 'expanded' }) .pipe(autoprefixer('last 2 version')) .pipe(gulp.dest('dist/assets/css')) .pipe(rename({suffix: '.min'})) .pipe(cssnano()) .pipe(gulp.dest('dist/assets/css')) .pipe(notify({ message: 'Styles task complete' }));}); 继续往下讲之前，有一点东西需要解释一下： 1gulp.task('styles', function() {...}); 这里的gulp.taskAPI是用来创建任务的。我们在命令行工具中可以使用$ gulp styles运行上面的任务。 1return sass('src/styles/main.scss', { style: 'expanded' }) 这里是一个新的gulp-rubu-sassAPI，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用gulp.srcAPI来代替（在文章的下部分你将会看到）这同样可以使用glob pattern，比如：/**/*.scss来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.) 1.pipe(autoprefixer('last 2 version')) 我们通过.pipe()来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。 1.pipe(gulp.dest('dist/assets/css')); 这里的gulp.destAPI我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出expanded version(正常大小版本)，另一个输出minifed version(压缩版本) 我建议去看下gulp的API文档来更好地理解这些方法，它并不像听起来那么吓人！ JSHint, concat, and minify JavaScript希望你现在对如何创建一个gulp任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件： 1234567891011gulp.task('scripts', function() { return gulp.src('src/scripts/**/*.js') .pipe(jshint('.jshintrc')) .pipe(jshint.reporter('default')) .pipe(concat('main.js')) .pipe(gulp.dest('dist/assets/js')) .pipe(rename({suffix: '.min'})) .pipe(uglify()) .pipe(gulp.dest('dist/assets/js')) .pipe(notify({ message: 'Scripts task complete' }));}); 这里我们就是用gulp.srcAPI来指定我们的输入文件。有一件事情需要注意的是，我们需要为JSHint指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在JSHint官网找到更多的信息。 Compress Images接下来，我们设置图片压缩。 123456gulp.task('images', function() { return gulp.src('src/images/**/*') .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })) .pipe(gulp.dest('dist/assets/img')) .pipe(notify({ message: 'Images task complete' }));}); 这里我们将拿到一些图片，然后导到imagemin插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的gulp-cache插件。为了实现这个，我们需要改变这一行： 1.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })) 改成： 1.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true }))) 现在就只用新的图片和改变过的图片会被压缩了，nice吧？ Clean up!在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录： 123gulp.task('clean', function() { return del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img']);}); 这里我们不需要使用gulp的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.） The default task我们定义的default任务可以直接使用$ gulp运行，比如： 123gulp.task('default', ['clean'], function() { gulp.start('styles', 'scripts', 'images');}); 需要注意到的是，我们添加了一个数组到gulp.task上，在这里我们可以定义任务依赖。在这里例子里，clean任务将会在gulp.start之前先运行。gulp里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保clean任务完成之后才开始其他的任务。 注意： 建议是的不要在依赖任务中使用gulp.start，不过在这个脚本里为了确保clean完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option） watch监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用gulp.watchAPI来开始监听文件。 123456789101112gulp.task('watch', function() { // Watch .scss files gulp.watch('src/styles/**/*.scss', ['styles']); // Watch .js files gulp.watch('src/scripts/**/*.js', ['scripts']); // Watch image files gulp.watch('src/images/**/*', ['images']);}); 我们可以通过gulp.watchAPI来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行$ gulp watch，然后修改一下对应监听目录下的文件，就将会执行对应的任务。 LiveReloadgulp同样可以在文件修改的时候刷新页面，我们需要修改我们的watch任务来配置LiveReload服务： 123456789gulp.task('watch', function() { // Create LiveReload server livereload.listen(); // Watch any files in dist/, reload on change gulp.watch(['dist/**']).on('change', livereload.changed);}); 为了让实现这个梦想，你需要安装和启用LiveReload的浏览器插件。或者你也可以手动的添加这些东西 合并所有代码现在你拥有了一个完整的gulpfile了， 它来自于这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*! * gulp * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev */// Load pluginsvar gulp = require('gulp'), sass = require('gulp-ruby-sass'), autoprefixer = require('gulp-autoprefixer'), cssnano = require('gulp-cssnano'), jshint = require('gulp-jshint'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), rename = require('gulp-rename'), concat = require('gulp-concat'), notify = require('gulp-notify'), cache = require('gulp-cache'), livereload = require('gulp-livereload'), del = require('del');// Stylesgulp.task('styles', function() { return sass('src/styles/main.scss', { style: 'expanded' }) .pipe(autoprefixer('last 2 version')) .pipe(gulp.dest('dist/styles')) .pipe(rename({ suffix: '.min' })) .pipe(cssnano()) .pipe(gulp.dest('dist/styles')) .pipe(notify({ message: 'Styles task complete' }));});// Scriptsgulp.task('scripts', function() { return gulp.src('src/scripts/**/*.js') .pipe(jshint('.jshintrc')) .pipe(jshint.reporter('default')) .pipe(concat('main.js')) .pipe(gulp.dest('dist/scripts')) .pipe(rename({ suffix: '.min' })) .pipe(uglify()) .pipe(gulp.dest('dist/scripts')) .pipe(notify({ message: 'Scripts task complete' }));});// Imagesgulp.task('images', function() { return gulp.src('src/images/**/*') .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))) .pipe(gulp.dest('dist/images')) .pipe(notify({ message: 'Images task complete' }));});// Cleangulp.task('clean', function() { return del(['dist/styles', 'dist/scripts', 'dist/images']);});// Default taskgulp.task('default', ['clean'], function() { gulp.start('styles', 'scripts', 'images');});// Watchgulp.task('watch', function() { // Watch .scss files gulp.watch('src/styles/**/*.scss', ['styles']); // Watch .js files gulp.watch('src/scripts/**/*.js', ['scripts']); // Watch image files gulp.watch('src/images/**/*', ['images']); // Create LiveReload server livereload.listen(); // Watch any files in dist/, reload on change gulp.watch(['dist/**']).on('change', livereload.changed);}); 我也使用grunt写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。拿好了，不送了 本文翻译自：Getting started with gulp","link":"/blog/2016/09/23/getting-started-with-gulp/"},{"title":"从零开始，部署一个Web应用（三）Vue.js &amp; Redis","text":"这篇文章，就总结一些Vue.js和Redis遇到的问题。 Vue.js非index页面刷新报404由于采用了Vue-router前端路由。因此在非index页面刷新会出现404的问题。 原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。 以下是nginx的解决方案： 1234567891011server { listen 80; server_name favweb.cn; access_log off; root /home/vuejs/dist; location / { try_files $uri $uri/ /index.html; }} 页面统计问题由于Google Analytics的不可用，采用的是百度统计。 发现统计数据都是只有主页，因此又是因为SPA的问题。 解决方案是在前端路由切换的时候，手动调用PV追踪代码： 1_hmt.push(['_trackPageview', pageURL]); Vuejs的配置为： 123456789import Router from 'vue-router'const router = new Router(config)router.afterEach((to, from, next) =&gt; { try { window._hmt.push(['_trackPageview', to.path]) } catch (e) { }}) Redis安装：1234wget http://download.redis.io/releases/redis-4.0.2.tar.gztar xzf redis-4.0.2.tar.gzcd redis-4.0.2make 常用配置以MacOS的homebrew安装方式为例。其中redis.conf文件在/usr/local/etc/。 后台运行12345# 原来daemonize no# 改成daemonize yes 增加密码找到requirepass，去掉前面的注释符号#，后面改成自己的密码 12345#原来#requirepass yourPassword#改成requirepass yourPassword 远程访问找到bind，将127.0.0.1改成0.0.0.0即可。 因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。 因此要开启这个之前，一定要先设置好密码。","link":"/blog/2017/10/27/about-deploly-favweb-3/"},{"title":"从零开始，部署一个Web应用（二）MongoDB &amp; nginx","text":"这篇文章，就总结一些部署MongoDB和nginx遇到的问题。 MongoDB安装的是社区版本(MongoDB Community Edition)。 安装先创建Mongodb在yum的配置文件： 123456[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc 可动态改变版本号 然后使用yum安装： 1sudo yum install -y mongodb-org 安全相关如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。 在MongoDB中，常用的是增加用户访问限制。 高级管理员第一步，是先创建一个高级管理员。这个高级管理员可管理其他用户： 12345678&gt; use admin&gt; db.createUser( { user: &quot;myUserAdmin&quot;, pwd: &quot;abc123&quot;, roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ] }) 注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。 可以这样以该角色进入MongoDB的命令行： 1mongo --port 27017 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot; 增加其他用户MongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入test数据库： 1use test 然后创建角色时，设置账户，密码以及对应的数据库权限，比如： 12345678db.createUser( { user: &quot;testAdmin&quot;, pwd: &quot;abc123&quot;, roles: [ { role: &quot;readWrite&quot;, db: &quot;test&quot; }, { role: &quot;read&quot;, db: &quot;reporting&quot; } ] }) nginx安装nginx之前，需要先将nginx的依赖安装完： gcc 安装：yum install gcc-c++ PCRE pcre-devel 安装：yum install -y pcre pcre-devel zlib 安装: yum install -y zlib zlib-devel OpenSSL 安装: yum install -y openssl openssl-devel 安装123456789101112131415161718# 下载Nginxwget -c https://nginx.org/download/nginx-1.10.1.tar.gz# 解压：tar -zxvf nginx-1.10.1.tar.gz# 进入nginx解压目录cd nginx-1.10.1 # 配置：./configure# 编译安装:makemake install# 查找安装路径：whereis nginx 环境变量因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用nginx命令。 设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下： 1cp /usr/local/nginx/sbin/nginx /usr/local/bin 假设上面的whereis nginx返回的是/usr/local/nginx 开启SSL模块切换到安装的源码包，我是安装在/usr/local/src/nginx-1.11.3。 修改配置： 1./configure --prefix=/usr/local/nginx --with-http_ssl_modul 执行make之后，切记不要执行make install，否则就覆盖安装了。 先备份已安装好的nginx: 1cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak 然后关闭已启动的nginx： 123# 查看进程号ps -ef|grep nginxkill -QUIT [进程号] 将刚刚编译好的nginx覆盖掉原有的nginx: 1cp ./objs/nginx /usr/local/nginx/sbin/ 启动nginx，仍可以通过命令查看是否已经加入成功 1/usr/local/nginx/sbin/nginx -V","link":"/blog/2017/10/21/about-deploly-favweb-2/"},{"title":"从零开始，部署一个Web应用（一）","text":"起始篇，先介绍一个整个系列文章涉及到的开发环境，技术栈。 环境开发环境： 设备：MacBook Pro 2015环境：Node.js v8.9.3 + WebPack v3.0IDE：Sublime Text + Visual Studio Code 生产环境： 设备：腾讯云CVM(香港)系统：CentOS 7.2 64位 技术盏前端采用了Vue.js + Vue-router + Element-UI 采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。 而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。 后端采用 Node.js + Think.js 因为个人技术盏限制，故采用比较擅长的Node.js。 采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。 数据库采用MongoDB + Redis MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。 Redis是用来保存Session，邀请码等数据。 服务器部署：Nginx + Node.js反向代理 利用Nginx来实现负载均衡 代码管理：Coding 由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。","link":"/blog/2017/10/14/about-deploly-favweb-1/"},{"title":"理解underscore.js系列——③基础函数","text":"从_.each函数入手，理解underscore.js的基础函数，_.each的调用盏可以参考如下思维导图： underscore.js的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，_.each也不例外。因此先来介绍内置的cb函数还有optimizeCb函数 cbcb顾名思义，就是回调函数(CallBack的简称)的意思。 12345678910// An internal function to generate callbacks that can be applied to each// element in a collection, returning the desired result — either `identity`,// an arbitrary callback, a property matcher, or a property accessor.var cb = function(value, context, argCount) { if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 1 if (value == null) return _.identity; // 2 if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 3 if (_.isObject(value) &amp;&amp; !_.isArray(value)) return _.matcher(value); // 4 return _.property(value);}; 对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的_.iteratee 如果没有传入value，就使用_.identity = function(value) { return value; } 如果传入了function，则使用optimizeCb格式化一下 如果传入了object，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致 否则就将传入的值当成一个属性，返回一个匹配该属性的函数 optimizeCb格式化传入的回调函数，以统一迭代函数，方便后续使用 123456789101112131415161718192021222324// Internal function that returns an efficient (for current engines) version// of the passed-in callback, to be repeatedly applied in other Underscore// functions.var optimizeCb = function(func, context, argCount) { // 如果没有执行上下文，就直接返回该函数 if (context === void 0) return func; switch (argCount) { case 1: return function(value) { return func.call(context, value); }; // The 2-parameter case has been omitted only because no current consumers // made use of it. case null: case 3: return function(value, index, collection) { return func.call(context, value, index, collection); }; case 4: return function(accumulator, value, index, collection) { return func.call(context, accumulator, value, index, collection); }; } return function() { return func.apply(context, arguments); };}; collectNonEnumProps在IE9以下版本，会有一个bug：如果重写了原不可枚举的属性，使用for...in是不会返回的。 相关信息可参考：W3Help SJ5003 1234567891011121314151617181920212223242526// Keys in IE &lt; 9 that won't be iterated by `for key in ...` and thus missed.var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];var collectNonEnumProps = function(obj, keys) { var nonEnumIdx = nonEnumerableProps.length; // 获取对象的构造函数，以获取对象的原型 var constructor = obj.constructor; var proto = _.isFunction(constructor) &amp;&amp; constructor.prototype || ObjProto; // Constructor is a special case. // 将构造函数属性放入keys var prop = 'constructor'; if (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop); while (nonEnumIdx--) { prop = nonEnumerableProps[nonEnumIdx]; // 如果obj有这个属性 // obj[prop] !== proto[prop] 说明重写了该属性 // keys不包含该属性 if (prop in obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) { keys.push(prop); } }}; 这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章待续 restArgsrest是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：function(value, ...rest) 1234567891011121314151617181920212223242526272829// Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)// This accumulates the arguments passed into an array, after a given index.var restArgs = function(func, startIndex) { // func.length可获取函数定义的参数个数 // eg: function (a, b) {} =&gt; 2 startIndex = startIndex == null ? func.length - 1 : +startIndex; return function() { var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0; // 将定义的最后一个参数和超过定义的参数都放进rest数组 for (; index &lt; length; index++) { rest[index] = arguments[index + startIndex]; } // 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。 switch (startIndex) { case 0: return func.call(this, rest); case 1: return func.call(this, arguments[0], rest); case 2: return func.call(this, arguments[0], arguments[1], rest); } // 将超出的部分(指rest)放在args数组的最后一位 var args = Array(startIndex + 1); for (index = 0; index &lt; startIndex; index++) { args[index] = arguments[index]; } args[startIndex] = rest; return func.apply(this, args); };}; 这里涉及到两个知识点： function.length指的是函数定义的参数个数 function.call和function.apply的区别：call需逐个传入参数，而apply则将参数放进一个数组传入","link":"/blog/2017/09/18/underscore/underscore-base-function/"},{"title":"理解underscore.js系列——①分析外包装","text":"前言其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。 另外提醒，此文对应的underscore.js版本是v1.8.3 正文下面将以源码+解析的形式，叙述我对underscore.js的理解，能力有限，如有错误请指正。 立即执行函数源码的最外面是一个立即执行函数(IIFE)： 123(function() { // ...其他内容}()); 之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。 全局变量以前刚接触前端开发的时候，不懂Node.js，认为全局变量就是window，因此看到下面的代码会很困惑： 1234567// Establish the root object, `window` (`self`) in the browser, `global`// on the server, or `this` in some virtual machines. We use `self`// instead of `window` for `WebWorker` support.var root = typeof self == 'object' &amp;&amp; self.self === self &amp;&amp; self || typeof global == 'object' &amp;&amp; global.global === global &amp;&amp; global || this || {}; 这是一个很geek的做法，运用了逻辑运算中的短路运算，在||操作的时候，如果前面为true的话，就不会计算后面的了。 印象当中，以前的js库都是用window的，现在改用self，是因为要兼容webWorker的缘故。因此（如注释所言） 在浏览器或者webWorker的话，root = self 在服务器环境的话，root = global 在其他的虚拟机的话，则指向this即root = this 其他环境就设置为空对象{} 变量冲突我们假设一个情况，如果_这个变量被别人使用了。如果我们直接给_赋值，不就丢失了前面的对于_的定义。 因此undersocre.js就先保存起来了： 1var previousUnderscore = root._; 这样的话，就不会丢失了前面对_的定义，如果要使用的话，就可以使用underscore.js提供的noConflict方法： 1234_.noConflict = function() { root._ = previousUnderscore; return this;}; 缓存引用这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规： 123456789101112131415// Save bytes in the minified (but not gzipped) version: var ArrayProto = Array.prototype, ObjProto = Object.prototype; var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null; // Create quick reference variables for speed access to core prototypes. var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use // are declared here. var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create; 实现继承众所周知的是，js是使用原型链来实现继承的。 其实这个实现方法就是ES5的Object.create的Polyfill，这么做是为了向后兼容： 1234567891011var Ctor = function(){};// An internal function for creating a new object that inherits from another.var baseCreate = function(prototype) { if (!_.isObject(prototype)) return {}; if (nativeCreate) return nativeCreate(prototype); Ctor.prototype = prototype; var result = new Ctor; Ctor.prototype = null; // 恢复CTor的原型，以备后续使用 return result;}; 初始化123456// Create a safe reference to the Underscore object for use below. var _ = function(obj) { if (obj instanceof _) return obj; if (!(this instanceof _)) return new _(obj); this._wrapped = obj; }; 一开始我对这个部分有些困惑的，因为我简单地认为_就应该是一个空对象{}。 其实，underscore.js是支持面向对象的方式使用的，也就是把_当作一个构造函数。即new _(obj)这样的用法。 但是由于js没用真正的构造函数，因此还可以这样使用：_(obj)。为了避免这种情况，因此有了第二行代码：if (!(this instanceof _)) return new _(obj);。因为直接调用函数的话，this是指向全局的。 兼容Node.js环境12345678910111213// Export the Underscore object for **Node.js**, with// backwards-compatibility for their old module API. If we're in// the browser, add `_` as a global object.// (`nodeType` is checked to ensure that `module`// and `exports` are not HTML elements.)if (typeof exports != 'undefined' &amp;&amp; !exports.nodeType) { if (typeof module != 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) { exports = module.exports = _; } exports._ = _;} else { root._ = _;} 由于Node.js的存在，因此在Node.js环境就将_赋值给exports 另外如注释所说，之所以要检测nodeType，是为了确保exports和module不是HTML元素 结尾这篇文章就是我阅读udersocre.js的第一篇源码分析文章，也是这个系列的第一篇。 写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。","link":"/blog/2017/09/04/underscore/underscore-wrapper/"},{"title":"理解underscore.js系列——④精选函数","text":"这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过underscore的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。 _.sample随意取出数组中的N个元素。 按我的思路，就是使用_.random得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。 underscore则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。 123456789101112131415161718192021// Sample **n** random values from a collection using the modern version of the// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).// If **n** is not specified, returns a single random element.// The internal `guard` argument allows it to work with `map`._.sample = function(obj, n, guard) { if (n == null || guard) { if (!isArrayLike(obj)) obj = _.values(obj); return obj[_.random(obj.length - 1)]; } var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj); var length = getLength(sample); n = Math.max(Math.min(n, length), 0); var last = length - 1; for (var index = 0; index &lt; n; index++) { var rand = _.random(index, last); var temp = sample[index]; sample[index] = sample[rand]; sample[rand] = temp; } return sample.slice(0, n);}; _.throttle节流函数，频繁触发的函数可用throttle来实现一段时间(周期取决于wait)内只执行一次。 常见的场景是：页面滚动时scroll、页面大小改变时resize 可以看到，这个throttle函数是比较健壮的。 有leading、trailing可选，意思为开始和结束这个临界点是否触发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Returns a function, that, when invoked, will only be triggered at most once// during a given window of time. Normally, the throttled function will run// as much as it can, without ever going more than once per `wait` duration;// but if you'd like to disable the execution on the leading edge, pass// `{leading: false}`. To disable execution on the trailing edge, ditto._.throttle = function(func, wait, options) { var timeout, context, args, result; var previous = 0; if (!options) options = {}; var later = function() { previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; var throttled = function() { var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout &amp;&amp; options.trailing !== false) { timeout = setTimeout(later, remaining); } return result; }; throttled.cancel = function() { clearTimeout(timeout); previous = 0; timeout = context = args = null; }; return throttled;}; 实现options.leading（即开始时是否执行）相关： 设置var previous = 0; 默认不设置options.leading即默认开始时执行，故此时if (!previous &amp;&amp; options.leading === false) previous = now;不会执行。 此时，previous = 0。因此，remaining = wait - (now - previous);肯定小于0，故开始时必会执行。 实现options.trailing（即最后是否执行一次）相关： 考虑一个情况，只触发一次时，那么最终要在wait时间之后是否执行呢？ 此时underscore就是使用一个定时器来实现。 _.debounce防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于wait)才执行一次。 常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。 1234567891011121314151617181920212223242526272829303132// Returns a function, that, as long as it continues to be invoked, will not// be triggered. The function will be called after it stops being called for// N milliseconds. If `immediate` is passed, trigger the function on the// leading edge, instead of the trailing._.debounce = function(func, wait, immediate) { var timeout, result; var later = function(context, args) { timeout = null; if (args) result = func.apply(context, args); }; var debounced = restArgs(function(args) { if (timeout) clearTimeout(timeout); if (immediate) { var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); } else { timeout = _.delay(later, wait, this, args); } return result; }); debounced.cancel = function() { clearTimeout(timeout); timeout = null; }; return debounced;}; 可以看到，该版本的debounce函数增加了immediate选项：就是刚开始的时候执行一次，n秒之后再执行一次。 在看underscore官网上，介绍说这个在防止意外的双击submit按钮时很有用。 这我有一点困惑，那不就提交了两次表单吗？ 后来我发现，later函数里，执行func有一个前置条件:if (args)，而在immediate = true的情况下，later是这么调用的：setTimeout(later, wait)，这时没有传入任何参数，故args = undefind即func不会执行。 因此，immediate = true时，就只提交了一次表单，没任何问题。 _.compose组成函数，类似jQuery的链式调用：将前一个函数的执行结果传入后一个函数。 123456789101112// Returns a function that is the composition of a list of functions, each// consuming the return value of the function that follows._.compose = function() { var args = arguments; var start = args.length - 1; return function() { var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; };}; 这里我觉得var i = start似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。 _.after执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。 12345678// Returns a function that will only be executed on and after the Nth call. _.after = function(times, func) { return function() { if (--times &lt; 1) { return func.apply(this, arguments); } }; }; 在javaScript开发中，经常遇到异步调用的问题。 拿开发小程序为例，上传图片的功能官方只提供单张上传API，当我们要批量上次的时候，执行循环调用单张上传API。此时要全部上传完执行回调就可以使用这个方法了。 现在想想，我之前的做法是setTimeout(uploadSuccess, 100)，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。","link":"/blog/2017/09/23/underscore/underscore-featured-function/"},{"title":"理解underscore.js系列——②杂项","text":"这一篇文章，就写一些零散的（我所理解的）知识点，感觉underscore.js许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。 typeof在underscore.js里，typeof后面都是跟着==而不是我们常用的=== 看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的： typeof typeof x，不管x是什么都是返回string的话，那么==就已经足够，并且与===相比还节省了一个字节。 void 0与undefined首先，void在C里是和常见的，但在js里就很少看到了。void在js里是一个操作符，它的作用在MDN里是这样描述的： The void operator evaluates the given expression and then returns undefined. 简而言之，void后面无论跟着什么表达式，都返回undefined。那使用void 0就是因为这样比较简洁。即 1void 0 === undefined 那么，为什么不直接用undefined而多此一举呢。 那是因为 undefined有可能被重写(undefined不是保留字) 123456789// 在IE8及以下var undefined = 10console.log(undefined) // 10// 主流浏览器function() { var undefined = 10 console.log(undefined) // 10} void 0的长度为6个字符，而undefined则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。 在iOS某版本下，void 0的速度比undefind快（这个是网上看到的，未验证） val == null在underscore.js里，经常会看到val == null这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。 在开发时，我要判断一个变量是否有传入，是这么做的： 123if (typeof val === 'undefined') { // others} 这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢： 12345function someTest(val, otherVal) { }someTest(null, 1) 此时就要传入null了，而此时很容易补丁式将上面的判断改成如下： 123if (typeof val === 'undefined' || val === null) { // others} 其实，此时完全可以用：val == null代替（此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句）。 其中涉及的==（半等）知识，可以参考Standard ECMA-262","link":"/blog/2017/09/11/underscore/underscore-mix/"},{"title":"如何将小程序的 API Promise 化","text":"前言众所周知，前端一大坑就是回调函数。 相信很多人是从async/await的温柔乡，掉到小程序重新写回调的大坑里的。 由于开发者工具新增了 增强编译 从而原生支持了async\\await，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 异步调用 方式改成 Promise的方式 即可。 分析与实践大致上可以有两种思路，第一种就是，逐个函数封装： 12345678910let promisify = func =&gt; args =&gt; new Promise((resolve, reject) =&gt; { func(Object.assign(args, { success: resolve, fail: reject, }))})let _login = promisify(wx.login) // 将wx.login转成Promise形式的方法_login().then(res =&gt; console.log) 这种方式比较麻烦，每次调用都需要手动转换。 劫持WX第二种就类似Page封装那样，劫持wx对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的： 同步方法是以Sync结尾的 通过typeof判断是否为函数 123456789101112// promisify.jslet originalWX = wxlet props = Object.keys(wx)for (let name of props) { let fn = wx[name] if (typeof fn === 'function' &amp;&amp; !name.endsWith('Sync')) { wx[name] = promisify(fn) }} 尝试封装之后，发现报错了。因为wx.drawCanvas只有getter没有setter，无法给它赋值。相当于这个方法是readonly。 既然存在没有setter的方法，那么我看有多少方法是有setter的： 1234Object.keys(wx).filter(name =&gt; { let descriptor = Object.getOwnPropertyDescriptor(wx, name) return typeof descriptor.set === 'function'}) 结果是[]，相当于无法改变wx对象的每个属性值。 复制模式虽然wx的属性都是readonly，不能劫持wx，但我发现wx是writable的。 那么可以采用复制模式，将它的所有异步方法拷贝一份并promisify之后赋值到新对象，最后再将整个对象赋值给wx即可： 1234567891011121314let props = Object.keys(wx)let jwx = {}for (let name of props) { let fn = wx[name] if (typeof fn === 'function' &amp;&amp; !name.endsWith('Sync')) { jwx[name] = promisify(fn) } else { jwx[name] = fn }}wx = jwx 这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了promisify。 代理模式熟悉ES新特性的读者应该知道Proxy。 它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上Proxy之后，对这个属性的任何行为都可以被代理。 那么我们就可以给wx挂上代理： 1234567891011121314let originalWX = wxwx = new Proxy({}, { get(target, name) { if (name in originalWX ) { let fn = originalWX[name] let isSyncFunc = name.endsWith('Sync') // 同步函数 let isNotFunc = typeof fn !== 'function' // 非函数 if (isSyncFunc || isNotFunc) return fn return promisify(fn) } }}); 代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。 在实践中，我发现并不是所有同步方法都是以Sync结尾的。比如：wx.getMenuButtonBoundingClientRect。 因此打算手动维护一个同步方法列表，将这项方法过滤掉： 123let syncFuncList = ['getMenuButtonBoundingClientRect']// name为函数名let isSync = name.endsWith('Sync') || syncFuncList.includes(name) 优化考虑到要兼容已上线的小程序，若匆忙替换wx，必会导致全局报错，因此可以如下处理： 当用户调用API时，如果传入了success、fail、complete等回调方法的话，则仍继续使用回调的方式继续执行。那么promisify可以如下优化： 12345678910111213141516171819202122let originalWX = wxlet hasCallback = obj =&gt; { let cbs = ['success', 'fail', 'complete'] return Object.keys(obj).some(k =&gt; cbs.includes(k))}wx = new Proxy({}, { get(target, name) { if (name in originalWX ) { let fn = originalWX[name] let isSyncFunc = name.endsWith('Sync') // 同步函数 let isNotFunc = typeof fn !== 'function' // 非函数 if (isSyncFunc || isNotFunc) return fn return (obj) =&gt; { if (!obj) return fn() if (hasCallback(obj)) return fn(obj) return promisify(fn)(obj) } } }}); 由于本文的前提是开启 增强编译，而该模式下也新增支持Array.prototype.includes，因此可以放心使用该ES7的新特性。 后续由于发现了微信官方也提供了一个 API Promise化 的工具类库，因此增加了本章节。 通过阅读源代码，发现官方的工具类库提供两个方法：promisify 和 promisifyAll 其中promisify与前文的同名方法是几乎一致的。而promisifyAll则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似： 1234567import { promisifyAll } from 'miniprogram-api-promise';let jwx = {}promisifyAll(wx, jwx)wx = jwx 另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。 相当于我的做法是黑名单机制，而官方采用了白名单机制。 最后再提醒下，开发者工具记得打开 增强编译","link":"/blog/2020/03/31/miniprogram/api-promisify/"},{"title":"小程序中实现自定义导航栏","text":"小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。 自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域 作用最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。 其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。 需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过wx.getMenuButtonBoundingClientRect获取胶囊按钮的布局位置信息。 布局信息由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。 如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过wx.getSystemInfo获取系统信息，其中的statusBarHeight即是状态栏的高度。 另外前文也提到了，胶囊按钮的信息可以通过wx.getMenuButtonBoundingClientRect获取。胶囊按钮与状态栏的距离可以这样计算： 1234let mb = wx.getMenuButtonBoundingClientRect();let sh = wx.getSystemInfoSync().statusBarHeight // 为getSystemInfo的同步版本let distance = mb.top - sh 基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的distance是一致的。所以，导航栏的高度是： 1let nh = mb.height + distance * 2 // navigatorHeight 总计一下，导航栏的布局信息如下： 12345678let navigator = { top: sh bottom: mb.bottom + distance left: 0, right: 0, height: mb.height + distance * 2 width: wx.getSystemInfoSync().screenWidth} 兼容问题前文提到页面设置导航栏是要求客户端7.0.0以上； 另外计算 状态栏高度(statusBarHeight) 需要基础库版本1.9.0以上； 计算胶囊按钮的布局信息wx.getMenuButtonBoundingClientRect则要求基础库2.1.0； 由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为2.4.3 因此，只要判断当前用户的客户端是否为7.0.0或以上即可。 注意事项由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意position: fixed的元素，此时应该将top对应的数值加上statusBarHeight和navigator.height，才能渲染正确。","link":"/blog/2020/05/05/miniprogram/custom-navigator/"},{"title":"小程序中实现自定义标签栏","text":"前言由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。 因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比： 分析原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。 从 小程序的官网文档 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下： 123&quot;tabbar&quot;: { &quot;custom&quot;: true} 设置了custom之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。 而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了） 实践按照官网文档的描述，在根目录上创建组件的文件夹，命名custom-tab-bar，里面的文件和正常的组件保持一致。 此时就可以将组件的样式和逻辑稍作调整： 当进入首页时，背景色改成透明 进入其他页面，背景色改回白色 这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的WXML里显式引用。 选中态由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？ 根据官网的描述，即是提供了接口getTabBar，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢） 需要在tabbar包含的每个页面的onShow里这样设置： 1234567Page({ onShow() { if (typeof this.getTabBar === 'function') { this.getTabBar().setData({ selected: 0 }) // 0代表第一个 } }}) 此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router 兼容性为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉custom:true才会恢复渲染tabbar。 所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。 如果你知道有什么兼容办法，欢迎和我联系。","link":"/blog/2020/03/28/miniprogram/custom-tabbar/"},{"title":"浅谈小程序的框架设计","text":"前言其实说是框架设计，有点“夸大其词”。 实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。 封装Page对小程序的Page进行封装，是一个框架的基础，也是解决许多通用问题的利刃。 如每个页面都需要设置分享onShareAppMessage，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装Page。 一种方案是，通过Page来定义一个新的Page，如：JPage，然后每个页面不再使用Page注册页面，而是使用JPage。 还有一种更好的方案，也是我所采取的方案：劫持Page。以至于不用改变每个页面的注册方式： 123456789101112131415// app.jslet realPage = PagePage = function Page(obj) { let defaultPageConfig = { onShareAppMessage() { return { title: '这里有很多有趣的壁纸', path: `/pages/index/index`, imageUrl: 'http://resoure.africans.cn/1.jpg', } } } return realPage({ ...defaultPageConfig, ...obj })} 这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子： 如果使用过 云开发 的读者，应该知道 获取集合 的步骤是这样的： 12let db = wx.cloud.database()let table = db.collection('wallpapers') 可以将这个 获取集合 的方法抽象成这样: 1234let getTable = (tableName) =&gt; { let db = wx.cloud.database() return db.collection(tableName)} 将这个方法放在defaultPageConfig里，以后每个页面都可以这样获取集合： 1this.getTable('wallpapers') 环境每个小程序都有三种版本：开发版、体验版、正式版。 往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？ 微信官网提供了 wx.getAccountInfoSync，为了避免在Page对象里冗余太多信息，因此env添加至App： 123456App({ env: (function() { let { miniProgram } = wx.getAccountInfoSync() return miniProgram.envVersion }())}) 需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案 后续可以这样使用： 12let app = getApp()console.log(app.env) // develop 设备信息由于每个用户进入小程序之后，设备信息不可能发生变更。 但在每个Page都封装这个信息会有点冗余，因此可以放进App里： 12345678App({ getSystemInfo() { let info = wx.getSystemInfoSync() this.getSystemInfo = () =&gt; info return info }}) 采用了缓存的机制，第一次调用时，调用getSystemInfoSync获取，第二次就直接返回缓存的设备信息了","link":"/blog/2020/03/27/miniprogram/frame-design/"},{"title":"小程序如何管理全局变量","text":"前言 在浏览器的环境下有一个全局变量：window。若定义变量时，遗漏了var，此时声明的变量就变成了全局变量，自动挂载到window下，可当做window的属性来访问，也可以直接访问。 小程序的底层也是通过Web实现的，因此同样存在window对象，但是微信团队做了些处理： 微信团队将window设置成了writable:false，且值也为undefined。 即我们无法像在web那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的wx、global。 问题虽然window是只读的，但是global是可写的: 因此常见的做法，就是将需要全局访问的变量都保存到global下，间接声明了全局变量。 全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。 另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。 同理，setStorage也存在同样的问题。 思考简单地将这些变量改成readonly肯定是不可取的，这影响了日常的开发。 在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案： 命名空间 模块化 其中 模块化 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。 因此 命名空间 是可以深入探索的思路。 实践命名空间命名空间是一种常用的代码组织形式。 大致做法是，先通过命名分配空间，再使用空间。 我的习惯是，用业务或者功能来命名空间 12345678910global.localStorage = { doSet() {}, doGet() {}, doClear() {}}global.util = { format() {}, valide() {}} 命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。 SymbolSymbol是ES2015中新增的基本数据类型。这个类型有个特别之处，每个Symbol()返回的值都是独一无二的，举个例子： 1Symbol('foo') === Symbol('foo') // false 因此通过Symbol的方式，可以完美避免变量被覆盖： 1234567// car.jslet car = Symbol()global[car] = {}// health.jslet health = Symbol()global[health] = {} 由于每个Symbol返回的值是唯一的，因此这个Symbol可以单独保存，以便各个文件引用。 由于 Symbol 属于新特性，因此需要关注下兼容性 管理声明通过Symbol的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。 我想到的办法就是给 global 增加个代理，对 global 的任何操作，都先经过代理检测，这样就有了强力的保障。 因此，可以使用新特性：Proxy 来监听 global 的变更，举例说明： 123456789101112global = new Proxy(global, { set(obj, prop, val) { if (prop in obj) { throw new TypeError(`${prop}: 该属性已定义！`) } // 可以做其他策略 // 或者上报数据，让你知道有哪些人偷偷定义了全局对象 obj[prop] = val return true },}) 由于 Proxy 属于新特性，因此需要关注下兼容性 总结使用 Proxy 之后，能对 global 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。","link":"/blog/2020/04/06/miniprogram/global-data-manage/"},{"title":"关于订阅消息的思考","text":"前言小程序的早期定位是“即用即走”或者说是“用完即走”。但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。让用户回流的关键手段就是 订阅消息，通过点击订阅消息，可直接回到小程序。 背景早期小程序提供的是 模板消息，用户每次点击或者完成支付，都会生成一个formId或者paypay_id，开发者可以通过这个formId给用户发送一次模板消息。 因此，开发者的常规做法：尽可能地在每个按钮上都封装form，用以收集formId；收集的formId并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些formId发送模板消息。 这样会存在几个问题： 用户会被莫名的骚扰（因为formId有7天的有效期） 用户收到的模板消息是无预期的（因为formId可以发任意的模板消息） 开发者在每个页面每个可点击区域都封装了form，导致代码混乱 为了解决以上问题，小程序团队就采用了 订阅消息 来替换 模板消息。 小程序模板消息接口于2020年1月10日下线 订阅消息的优势订阅消息 与 模板消息 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如： 另外，对订阅消息的发送时限不做限制，即可以在任意时间给用户发送一条模板消息，而不像以前的formId有7天的有效期。 从开发者的角度看：订阅消息是使用接口调用(wx.requestSubscribeMessage)，不再是以前那样，一定要用Button。对于代码维护和开发效率来说，都是利好的。 从代码维护上讲，开发者不用再层层嵌套form了，简化了许多代码；另外，以前模板消息是通过Button封装的，拜托了这层束缚之后，就不用再重置Button的样式了，对于开发效率也是有一定的帮助。 模板消息12345&lt;form bindsubmit=&quot;addFormId&quot; report-submit&gt; &lt;button class=&quot;invite-btn&quot; form-type=&quot;submit&quot;&gt; 邀请好友 &lt;/button&gt;&lt;/form&gt; 1234567Page({ data: {}, addFormId(e) { let { formId } = e.detail; // save formId }}) 订阅消息1&lt;view class=&quot;invite-btn&quot; bindtap=&quot;handleInvite&quot;&gt;邀请好友&lt;/view&gt; 1234567Page({ handleInvite() { wx.requestSubscribeMessage({ tmplIds: [''] // 订阅的模板ID }) }}) 但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。 订阅消息的类型以往的模板消息，每次发送消息需要消耗一个formId，而formId有7天的有效期，因此小程序无法召回7天以前的活跃用户。 而订阅消息则提供了两种类型： 一次性订阅 长期订阅 其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。 不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。 开发的差异小程序端以往的模板消息方式，需要前端将每次收集到的formId，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。 另外每次发起消息订阅，都会有弹窗出现： 用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。 若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息： 其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。 如果用户关闭接收所有订阅消息，那么调用wx.requestSubscribeMessage时，会触发fail，并返回如下信息： 12345{ errCode: 20004, errMsg: 'The main switch is switched off', // 用户关闭了主开关，无法进行订阅} 总结订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往formId的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。 因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。","link":"/blog/2020/05/15/miniprogram/think-about-subscribe/"},{"title":"关于小程序组件透传函数的实践","text":"开发小程序组件库 TDesign 有感 微信小程序，从基础库 2.0.9 开始，自定义组件的 type: Object 属性（properties）支持函数类型的值了，但仍不支持函数类型的属性，即： 1234567891011121314151617// dialog.jsComponent({ properties: { confirmBtn: { type: Object, // ok }, cancelBtn: { type: Function // wrong } }, observer: { confirmBtn(obj) { console.log(obj.bindgetuserinfo) // function } }}) 这种能力，在实现 Dialog 组件的时候，非常有用。这样在 Dialog 组件的 cancel 和 confirm 按钮可以方便地支持 Button 的各种开放能力。 于是，就会想当然地这样实现： 1234567891011121314151617181920212223242526&lt;view class=&quot;t-dialog&quot;&gt; &lt;!-- ... --&gt; &lt;button class=&quot;cancel-btn&quot; size=&quot;{{cancelBtn.size}}&quot; type=&quot;{{cancelBtn.type}}&quot; plain=&quot;{{cancelBtn.plain}}&quot; disabled=&quot;{{cancelBtn.disabled}}&quot; open-type=&quot;{{cancelBtn.openType}}&quot; bindgetuserinfo=&quot;{{cancelBtn.bindgetuserinfo}}&quot; &gt; 取消 &lt;/button&gt; &lt;button class=&quot;confirm-btn&quot; size=&quot;{{confirmBtn.size}}&quot; type=&quot;{{confirmBtn.type}}&quot; plain=&quot;{{confirmBtn.plain}}&quot; disabled=&quot;{{confirmBtn.disabled}}&quot; open-type=&quot;{{confirmBtn.openType}}&quot; bindgetuserinfo=&quot;{{confirmBtn.bindgetuserinfo}}&quot; &gt; 确认 &lt;/button&gt;&lt;/view&gt; 这样就会出现几个问题： 属性透传写法太冗余 事件不会触发 按钮内容没法传入 属性透传Dialog 组件存在两个按钮，所以两个按钮都需要透传 button 属性，直观的想法就是采用 template 来处理: 1234567891011121314&lt;!-- button.wxml --&gt;&lt;template name=&quot;button&quot;&gt; &lt;button class=&quot;{{class}}&quot; size=&quot;{{size}}&quot; type=&quot;{{type}}&quot; plain=&quot;{{plain}}&quot; disabled=&quot;{{disabled}}&quot; open-type=&quot;{{openType}}&quot; bindgetuserinfo=&quot;{{bindgetuserinfo}}&quot; &gt; 确认 &lt;/button&gt;&lt;/template&gt; 于是 Dialog 的代码就可以省略成这样： 1234567&lt;import src=&quot;./button.wxml&quot; /&gt; &lt;view class=&quot;t-dialog&quot;&gt; &lt;!-- ... --&gt; &lt;template is=&quot;button&quot; data={{...cancelBtn, class: 'cancel-btn'}}&gt; &lt;template is=&quot;button&quot; data={{...confirmBtn, class: 'confirm-btn'}}&gt;&lt;/view&gt; 这里确实挺奇怪的，可以直接传入了一个解构后的值。 这里可以直接合并对象 事件不会触发一开始以为是 template 的值传递过程，不支持 function 类型的值，因此丢失了。 比如在 template 里面使用 wxs 打印类型，居然是空的。 后来经过各种测试，最后在官网文档找到答案：小程序框架/事件系统 在小程序的事件绑定，只需要传入的是字符串: 1&lt;view bindtap=&quot;handletap&quot;&gt;Tap me!&lt;/view&gt; 也可以是一个数据绑定: 1&lt;view bindtap=&quot;{{ handlerName }}&quot;&gt;Tap me!&lt;/view&gt; 但，这个数据的返回值类型应该是 string 而不是 function。 通过这点，恍然大悟，想起了小程序的双线程模型： 为了减轻线程之间的传输负担，是不需要将 function 传到渲染层的，只需要给一个函数名，然后在逻辑层执行对应的函数即可。 因此没有办法在 wxml 里面执行对象属性的函数，需要找一个代理函数（Proxy function）处理。 为了区分对应的按钮，因此 template 做了小改动，增加了一个 data-token 的属性： 123&lt;template name=&quot;button&quot;&gt; &lt;button data-token=&quot;{{token}}&quot; bindtap=&quot;onTplButtonTap&quot;&gt;&lt;/template&gt; 对应的 Dialog 的 wxml 的改动是这样的： 1234567&lt;import src=&quot;button.wxml&quot; /&gt; &lt;view class=&quot;t-dialog&quot;&gt; &lt;!-- ... --&gt; &lt;template is=&quot;button&quot; data={{...cancelBtn, token: 'cancel', class: 'cancel-btn'}}&gt; &lt;template is=&quot;button&quot; data={{...confirmBtn, token: 'confirm', class: 'confirm-btn'}}&gt;&lt;/view&gt; 对应的 JS 是这样的： 1234567891011121314Component({ methods: { onTplButtonTap(e) { const { token } = e.target.dataset // cancel or confirm const evtType = e.type // 对应的事件名，如 getuserinfo/getphonenumber 等 const evtName = `bind${evtType}` const targetBtn = this.data[`${type}Btn`] if (typeof targetBtn[evtName] == 'function') { targetBtn[evtName](e.detail) } } }}) 这样就能完美透传并触发各种 button 事件了。 按钮内容传入其事这个倒是个小问题，因为 TDesign 组件在规划的时候，就已经充分地考虑了多框架之间的差异。为了弥补框架之间的差异，都可以通过 content 的属性来传入插槽的内容，起初我还不理解，直到遇到了这个问题。 以前总觉得，可以通过 slot 的方式传入，又支持一个 content 有点多此一举。直到我遇到了需要透传 button 属性的 dialog 组件。 总结小程序的黑盒子运行时，在遇到问题的时候真的很容易陷入盲调的困境，此时应该去看看官方文档的资料，或者网上搜一下是否其他人也遇到类似的问题，这样才可能破局。 毕竟只有他们才知道代码是怎么跑的。","link":"/blog/2022/01/06/miniprogram/miniprogram-function-property/"},{"title":"小程序的自动更新机制","text":"前言小程序的更新机制与它的运行机制有关。 为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。 运行机制首先，先看下小程序的运行机制： 与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。 更新机制小程序的更新机制分为： 未启动时更新 启动时更新 未启动时更新：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。 启动时更新：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API： 1234567891011121314151617181920212223const updateManager = wx.getUpdateManager()updateManager.onCheckForUpdate(function (res) { // 请求完新版本信息的回调 console.log(res.hasUpdate)})updateManager.onUpdateReady(function () { wx.showModal({ title: '更新提示', content: '新版本已经准备好，是否重启应用？', success(res) { if (res.confirm) { // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() } } })})updateManager.onUpdateFailed(function () { // 新版本下载失败}) 如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。 根据微信提供的能力，小程序的更新流程大致如下： 由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。 下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。 由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。 测试更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。 笔者尝试在体验版上做测试：先打开v0.0.1版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是v0.0.2，根本没有还原小程序的更新机制。 因此可以得出结论：体验版无法测试更新机制。 模拟更新另外，开发者工具的编译模式提供模拟更新： 兼容处理由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。 最简单的方式：每次升级接口时，均采用新接口。","link":"/blog/2020/04/26/miniprogram/update/"},{"title":"小程序的组件封装思考","text":"前言在小程序开发的早期，是没有 自定义组件(component) ，仅有 自定义模板(template) 的。最早接触到组件开发还是在使用 React、Vue 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多 为什么要有组件？对于这个问题，很多人的第一反应也许是：代码复用 的确，代码复用是组件的核心职责，但它还有更大的使命：性能 因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果 生命周期在 Vue 中，每个页面是一个 Vue 实例，而组件又是可复用的 Vue 实例，因此可以理解成，页面和组件是相同的生命周期 而小程序就将页面和组件拆分成两个类：Page 和 Component，因此接收的生命周期函数也是不一样的。比如，Page 接收的是：onLoad、onShow、onReady等函数，而 Component 则接收 created、attached、ready 等函数 命名风格都不一致，真是让人头大 数据传递VueVue 的组件间数据传递的机制是这样的：父组件通过property传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件 在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境 为了解决这个问题，Vue 推出了 Vuex 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念： 小程序小程序同样有类似的机制，property和事件。此外还提供了获取 子组件实例 的方法：selectComponent() 和 定义组件间关系的字段 relations 其中常用的就是获取子组件实例，比如: 123&lt;parent-component&gt; &lt;child-component id=&quot;child&quot;&gt;&lt;/child-component&gt;&lt;/parent-component&gt; 此时，在parent-component组件中可以直接获取child-component的实例： 1234567Component({ attached() { let $child = this.selectComponent('#child') // $child.doSomeThing() }}) 实战背景 制作一个 对话框(modal) 组件 也许有的读者会感到困惑，官方不是有提供 wx.showModal 可以直接用吗，为什么要重复造轮子 其实，当你的产品想要结合 Modal 和 Button 的 open-type 能力时，你就会明白重复造轮子的必要性以及wx.showModal的局限性 属性定义对话框的常见属性可以参考wx.showModal 除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：visible 此时，有两种选择，第一种是将这个变量存在页面上，通过property传递给Modal组件；另外一种，就是作为Modal组件data中的一员 property传递通过property传递的话，就相当于将 Modal 的控制权交到对应的页面，举例： 123&lt;!-- home.wxml --&gt;&lt;modal visible=&quot;{{visible}}&quot; /&gt; 12345678910// home.jsPage({ data: { visible: false }, toggleModal() { this.setData({ visible: !this.data.visible }) }}) 此时对应的 Modal： 12345678910111213// modal.jsComponent({ properties: { visible: { type: Boolean, value: false, observer(newVal, oldVal) { this.setData({ visible: newVal }) } } }}) 这里和Vue框架有个差异，Vue对于传进来的property会自动赋值，而小程序则需要自己手动赋值 问题与办法当 visible 这个变量被 Modal 和 Page 同时使用时，会出现不显示的问题。 为了便于描述，我通过描述真实场景来讲解： 当页面需要显示对话框时，Page 传递 visible=true 给 Modal 经过一段时间之后，用户关闭了对话框，此时 Modal 将自身的 visible 设置为 false 当页面需要再次出现对话框时，Page 继续传递visible=true 给 Modal，此时发现对话框不会显示 通过分析可以发现，由于 Page 两次传递相同的 visible=true 给 Modal ，因此第二次传递的时候，被 Modal 直接忽略掉了。 这个问题也很好解决，大致思路就是保证每次传递的值不同即可： 传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便） 利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如{ visible: true } !== { visible: true }) 组件自身属性这种是我推荐的方案。将 visible 属性交由组件 Modal 自行管理： 123456789101112// modal.jsComponent({ data: { visible: false }, methods: { show() { this.setData({ visible: true }) } }}) 由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的setData，如： 123let $modal = this.selectComponent('#modal')$modal.setData({ visible: true }) 但是不建议这样使用，而是组件暴露方法让外部调用： 123let $modal = this.selectComponent('#modal')$modal.show() 组件的事件通常，对话框都会有按钮，一个或两个。 因此 Modal 需要与父组件通过 事件(event) 的方式传递信息：当前点击了取消还是确定按钮： 123&lt;!-- home.wxml --&gt;&lt;modal id=&quot;modal&quot; bind:btntap=&quot;handleModalTap&quot; /&gt; 1234567891011121314151617// home.jsPage({ showModal() { let $modal = this.selectComponent('#modal') $modal.show() }, // 其他方法 handleModalTap(e) { let { type } = e.detail // type = cancel or confirm }}) 在 Modal 的构造函数则是这样的： 1234567891011121314// modal.jsComponent({ data: { visible: false } methods: { handleBtnTap(e) { let { type } = e.target.dataset this.triggerEvent('btntap', { type }) } }}) 123456789&lt;!-- modal.wxml --&gt;&lt;view class=&quot;wrapper&quot;&gt; &lt;!-- 省略其他结构 --&gt; &lt;view class=&quot;foot&quot; bindtap=&quot;handleBtnTap&quot;&gt; &lt;button data-type=&quot;cancel&quot;&gt;取消&lt;/button&gt; &lt;button data-type=&quot;confirm&quot;&gt;确定&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; 这样设计 Modal 组件，的确可以满足使用，但是不够好用 因为展示对话框时使用的是 showModal 而用户操作之后又是通过另外一个方法 handleModalTap 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护 所以，我建议结合 Promise 来封装 Modal 省略事件由于展示对话框之后，用户必然要操作，因此可以在 showModal 的时候，通过 Promise 返回对应的操作信息即可 另外，需要引入发布订阅机制（以下使用 Node.js 的 Events 举例）： 1234567891011121314151617181920212223242526272829303132// modal.jsconst EventEmitter = require('events');const ee = new EventEmitter();Component({ data: { visible: false }, methods: { show() { this.setData({ visible: true }) return new Promise((resolve, reject) =&gt; { ee.on('cancel', () =&gt; { reject() }) ee.on('confirm', () =&gt; { resolve() }) }) }, handleBtnTap(e) { let { type } = e.target.dataset ee.emit(type) this.triggerEvent('btntap', { type }) } }}) 此时，在 Page 即可这样展示对话框： 12345678910111213// home.jsPage({ onLoad() { let $modal = this.selectComponent('#modal') $moda.show().then(() =&gt; { // 当点击确认时 }).catch(() =&gt; { // 当点击取消时 }) }}) 总结组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！","link":"/blog/2020/04/07/miniprogram/thinking-about-components/"},{"title":"小程序实战汇总一","text":"随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。 那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。 授权处理在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。 因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。 解决方案在基础库1.2版本，新增了wx.getSetting接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。 具体实现可参考一下代码： 1234567891011121314151617181920212223242526272829wx.getUserInfo({ success: function (res) { // 成功获取用户信息，继续操作 }, fail: (res) =&gt; { wx.showModal({ title: '用户未授权', content: '如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？', success: (action) =&gt; { if (action.confirm) { } } }) }})// 检查状态wx.openSetting({ success: (res) =&gt; { // 二次授权成功 if (res.authSetting[&quot;scope.userInfo&quot;]) { // 成功获取用户信息 } }, fail: function () { fail() }}) 页面数据传递页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？ URL传递类似Web的链接跳转，使用类似query串的形式。 1wx.navigateTo('../user/user?name=leejim') 在目的页的onload函数，可以这么获取： 123onLoad(options) { console.log(options.name) // leejim} 使用客户端缓存小程序提供了本地存储的方式：wx.setStorage和wx.getStorage。 可以在页面跳转前，先用wx.setStorage缓存数据，然后在目的页使用wx.getStorage获取数据。 使用全局变量在小程序里，有一个全局函数getApp用来获取全局变量app。 比如这样： 12var app = getApp()app.index = 1 // 设置变量 往栈内的页面传递数据使用全局函数getCurrentPages函数可以获取栈内的所有页面。 然后就可以直接设置那个页面的数据： 1234var pages = getCurrentPages()pages[pages.length -1].setData({ // 往前一个页面设置数据 data: 123}) 修改Input组件的值因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。 但是我们能通过data绑定的方式来实现： 1&lt;input value='{{inputValue}}' /&gt; js部分： 123this.setData({ inputValue: ''})","link":"/blog/2018/01/07/miniprogram/practice-of-wxapp-1/"},{"title":"我所理解的BFC","text":"BFC (Block Formatting Context) 块级格式化上下文，在W3C上是这么定义的： Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).For information about page breaks in paged media, please consult the section on allowed page breaks. BFC效果先来说说BFC有什么效果，从效果看本质。 逐个翻译W3c的定义如下： boxes按顺序，从上到下，垂直排列 boxes are laid out one after the other, vertically, beginning at the top of a containing block 相邻boxes的垂直距离由margin决定，但是在同一个BFC容器的话，margin会合并 The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. 每个boxes的左边会和BFC容器的左边重叠，float元素也是如此 each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), 可以解决因float元素导致的高度收缩问题（也就是常说的消除浮动） This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 如何触发BFC float元素和 absolutely元素 (例如position: absolute||fixed) display等于inline-blocks, table-cells, and table-captions的块级容器元素 overflow不等于visible的元素 BFC作用 相邻margin合并的问题 消除浮动 参考 CSS之BFC详解 W3C block-formatting","link":"/blog/2017/11/11/css/what-is-bfc/"},{"title":"探索CSS盒模型","text":"从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。 现在开发基本遇到的基本样式(CSS)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。 块级元素毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图： 水平格式化水平方向的大小也是有些复杂，主要一个原因是width影响的是内容(content)区域的宽度，而不是整个可见的元素框。 大多数开发者以为，widht指的就是可见元素框的宽度，其实不是这样的(不过CSS3的box-sizing可以修改盒模型，这里暂不讨论)。 可见元素框的宽 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。 以上7个属性中，只有margin-left、margin-right和width这三个属性可以设置为auto，其他必须设置特定的值或0 使用auto首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的width。 设置一个auto假定父元素width: 400px 12345p { magrin-left: auto; /* 等于200px */ margin-right: 100px; width: 100px;} 此时margin-left就是弥补剩余的宽度即400-100-100=200 不设置auto如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的width: 12345p { magrin-left: 100px; margin-right: 100px; /* 等于200px */ width: 100px; } 其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(overconstrained)，因此此时的margin-right会被强制设置成auto，即margin-right=200px而不是我们想当然的那样等于100px。 (ps:在英语这种从左向右读的语言是强制设置marin-right，而在从右向左的语言则是强制设置margin-left为auto了) 设置两个auto首先先考虑常用的，设置两个margin为auto，此时就可以实现水平居中的效果。 如果设置其中一个margin和width为auto的话，margin的值则会减为0，而widht会水平延伸直至充满父元素。 设置三个auto即margin-left、margin-right和widht都为auto。此时和上面那个例子比较类似，就是margin都减为0，width则填满父元素。 负的margin值前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子： 12345678910.parent { widht: 400px; border: 2px solid black;}.child { margin-left: 10px; width: auto; margin-right: -50px;} 这个时候child这个子元素的widht是多少呢？ 根据前面提到的算法可以得到：10px + 0 + 0 + width + -50px = 400px，此时可以得到width=440px 另外需要注意的是：padding、border和width都不能设置为负值。 垂直格式化垂直方向和水平的大部分都比较类似，比如： 可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom 如果此时子元素的height大于父元素的height时，具体效果就要取决于overflow属性的值了，这里暂不讨论。 有一点不一样的是：margin-top和margin-bottom设置为auto的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。 设置margin-top、margin-bottom经常会有这么一个情况：子元素设置了margin-top或者margin-bottom，但是父元素不会撑开这部分的margin高度，这部分出现在父元素以外: 123&lt;div class=&quot;parent&quot; style=&quot;background-color: silver&quot;&gt; &lt;p class=&quot;child&quot; style=&quot;margin-top: 100px; margin-bottom: 100px&quot;&gt;test&lt;/p&gt;&lt;/div&gt; 此时效果是这样的： 因为块级元素只有块级子元素的话，其高度是子元素的border-top + padding-top + height + padding-bottom + border-bottom的总和。 但是如果该块级元素有padding或者border的话，则其高度等于子元素的margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom总和。比如： 123&lt;div class=&quot;parent&quot; style=&quot;background-color: silver; border: 1px solid black&quot;&gt; &lt;p class=&quot;child&quot; style=&quot;margin-top: 100px; margin-bottom: 100px&quot;&gt;test&lt;/p&gt;&lt;/div&gt; 合并margin-top和margin-bottom众所周知的是，如果有上下两个元素，上元素的margin-bottom和下元素的margin-top是会合并的，大小等于这两个的最大值。 这时又有一个例外，就是如果元素含有padding或者border的话，则不会合并。","link":"/blog/2017/08/15/css/css-box-model/"},{"title":"小程序 Session","text":"最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。 登录态维护每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。 无cookie首先，第一个需要踩的坑就是无cookie的登录态要如何维护。 微信官方提供了一个流程图，我们可以先看看： 简而言之： 在小程序上通过wx.login()获取code 将code传到自己的服务器，然后将小程序的secret和appid与微信服务器交换openid和session_key 将session_key加上随机数生成sessionId，然后openid和session_key存在session里 小程序将sessionId存起来，每次访问都带上这个sessionId 小程序获取code在小程序的app.js文件里，onLaunch函数调用我们写好的login函数： 123456789101112131415wx.login({ success: function (loginResult) { wx.getUserInfo({ withCredentials: true, success: function (userResult) { // doLogin 就是将这些数据发送到服务器 doLogin(null, { code: loginResult.code, encryptedData: userResult.encryptedData, iv: userResult.iv }) } }) }}) 服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是openid和session_key。 解密用户信息通过小程序传过来的和encryptedData和iv，然后还有刚才获取的session_key，我们就能解密用户的信息，通过对比解密出来的openid和微信交换来的openid对比，即可知道用户信息的正确性。 sessionId生成：123function generateSessionId() { return crypto.randomBytes(32).toString('hex')} 按理说，我们生成了sessionId，然后将对应的用户信息存在session里就大功告成了。 但是这样的话，很容易被伪造的暴力的伪造sessionId攻击。因此，需要再进一步，生成另外一个校验数据称为sessionkey简称sKey，这时就使用到刚获取到的session_key： 1234567function generateSkey(sessionKey) { const sha1 = (message) =&gt; { return crypto.createHash('sha1').update(message, 'utf8').digest('hex') } return sha1(appid + secret + sessionKey)} 此时我们的session的key就是一个前面随机生成的sessionId。value则为： 12345{ userinfo, session_key, sKey} 然后每次sessionId传递过来的时候，我们获取对应的session_key，然后调用generateSkey生成sKey，然后和session里面的sKey对比即可。 此时，session的生成大功告成了！ 两个登录态的问题首先，调用微信生成的code的login()函数是有时效的，大概5分钟。 我们生成的session也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。 小程序登录态官方提供了wx.checkSession()方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的login函数 session失效这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现session失效了。 因此我们可以在app.js的onShow()里发送请求到服务器测试session是否过期。过期的话就重新调用login函数。","link":"/blog/2017/07/18/miniprogram/wechat-miniapp-session/"},{"title":"HTTP 常用安全头","text":"Security - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容web安全，不能更生动形象。最近项目涉及到一些web安全的东西，就来总结一下相关的HTTP安全头部。 Content-Security-Policy作用：防止的内容注入（减缓了XSS攻击，恶意iframe注入） 不足：目前只支持现代浏览器，对浏览器有要求，要求如下： header Chrome FireFox Safari Internet Explorer Content-Security-Policy CSP Level 2 40+ Full January 2015 31+ PartialJuly 2014 - - Content-Security-Policy CSP 1.0 25+ 23+ 7+ Edge 12 build 10240+ 分析： 由于HTML的img、script、css是可以跨域的，这就导致了XSS缺陷。CSP可以设置default-src、script-src、img-src等等来限制HTML资源的加载 script-src可以设置两个特殊的值（unsafe-inline、unsafe-eval）。unsafe-inline代表不能执行内script，这就对XSS增添了一次防御，不过这样对开发人员有一定的规范。unsafe-eval则是代表不能执行eval方法(这是一个比较BUG级的函数，它会把传入的参数全部当做JS代码解释并且执行) sandbox沙盒则适用于同源策略的webapp，可以限制新标签页面打开等等。 report-uri这个属性可以设置一个URL，然后会把CSP的失败信息POST到这个URL。我们则可以记录这个有用的信息用来安全性分析。 Strict Transport Security1Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload] 作用：告诉浏览器接下来的一定时间内（自己设置）只能用HTTPS访问。这个只会让用HTTPS访问的用户继续使用HTTPS。而HTTP访问的则无效。 分析：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入HTTPS。所以第一次访问的时候，都是以HTTP访问，这时负载服务器就应该返回一个301跳转给客户端，让客户端跳转到HTTPS的服务下。由于有了HSTS的头部，下次用户再次以HTTP访问的时候，浏览器会自己做307跳转到HTTPS请求。 实际开发遇到的问题： 由于公司使用阿里云的SLB负载均衡，无法实现301跳转，于是使用了node再开启一个服务，用于接受来自SLB80端口的请求，然后返回一个301状态码并在Location头部加上HTTPS的地址。真正的node服务只接受SLB443接口的请求。 X-Content-Type-Options1X-Content-Type-Options: nosniff 作用：互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：text/html代表html文档，image/png是PNG图片，text/css是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。 例如，我们即使给一个html文档指定Content-Type为text/plain，在IE8中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。 实际开发遇到的问题： 在IE下图片验证码不能显示。分析后得出，是因为图片验证码返回的时候没有返回content-type这个文件类型的头部。所以IE不能识别文件类型。解决办法是修改图片验证码插件在返回图片是增加头部content-type：image/jpg 参考： Node.js Security Checklist Express.js官方的安全性最佳实践指导 xss攻击入门","link":"/blog/2016/05/09/http/web-safe-http-header/"},{"title":"CSS Background 基础知识","text":"WEB开发常用到background但是没有去深究，仔细看了之后，发现background里面的知识点还是挺多不懂的。 background-size设置背景图大小[初始值auto auto-非继承-适用所有元素] 1backgrount-size: (&lt;length&gt; | &lt;percentage&gt; | auto){1,2} | contain | cover length：直接指定背景图大小 percentage：指定背景图片相对背景区的百分比 auto：以背景图片的比例缩放背景图片 contain：缩放背景图片以完全装入背景区，可能背景区部分空白。 cover：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。 补充： &lt;length&gt;/&lt;percentage&gt;/auto 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成auto 逗号分隔的多个值：设置多重背景 contain/cover 会保留图片的原来比例 background-origin规定了指定背景图片background-image属性的原点位置的背景相对区域[初始值padding-box-非继承-适用所有元素] 1backgrount-origin: border-box | padding-box | content-box border-box: 背景图将显示在border上，设置border-style:dashed即可以看到效果 padding-box: 背景图将显示到padding上。 content-box: 背景图只显示在内容区域 如果还不明白，可以看这个例子 补充： 当使用 background-attachment 为fixed时，该属性将被忽略不起作用。 background-clip效果同上面的background-origin，差别在于指定的是背景色不是图片 例子才此，可以和上面对比一下 background-attachment如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的[初始值scroll-非继承-适用所有元素] 1background-attachment: scroll | fixed | local scroll： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。 fixed：表示背景相对于视口固定 local：表示背景相对于元素的内容固定。 解释： fixed和其他两个的差别在于：fixed是相对于视窗（可以理解成屏幕）固定的。 scroll和local的差别在于：scroll在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而local则是跟着滚动的。可以看下根据MDN改编的例子 background-position指定背景图片的初始位置[初始值0% 0%-非继承-适用所有元素] 12background-position: (top, bottom, left, right){1,2} | &lt;percentage&gt; | &lt;length&gt; top: 等于垂直方向的0% bottom：等于垂直方向的100% left：等于水平方向的0% right：等于水平方向的100%","link":"/blog/2015/10/17/css/css-background/"},{"title":"CSS 空格和换行","text":"在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。 break-all指定怎么在单词内断行。[初始值normal-继承属性-适用全部元素] 1work-break: normal | break-all | keep-all; normal: 使用默认的换行 break-all: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。 keep-all: CJK文本不断行，non-CJK文本的行为则和normal保持一致。 具体效果可以看这个参考例子 overflow-wrap(别名：word-wrap)指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[初始值normal-继承属性-适用全部元素] 1overflow-wrap: normal | break-word; normal: 表示在正常的单词结束处换行。 break-word: 如果一行内无法容下某个单词的话，那就断开这个单词。 补充： 如果不明白break-all和overflow-wrap的差别的话，查看这个例子就可以明白了。 white-space用来描述要如何处理元素内的空格。[初始值normal-继承属性-适用全部元素] 1white-space: normal | pre | nowrap | pre-wrap | pre-line; normal: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。 nowrap: 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre: 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素时才会换行。 pre-wrap: 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时才会换行。 pre-line: 连续的空白符会被合并。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时会换行。 各种white-space的值对应的行为如下： 换行符 空白符和制表符 文字换行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 效果请看这个MDN的例子","link":"/blog/2015/10/14/css/white-space-and-wrap/"},{"title":"小程序按钮组件的亿点细节","text":"前言TDesign 的 button 是之前的同事开发的，我接手过来只是做了样式的调整，因此对组件的实现没有很清楚。最近有用户反馈传了 disabled 之后仍然会触发 tap 事件。我的第一反应以为是个小问题，就是漏掉了透传 disabled 而已，但我发现问题没这么简单，于是便有了这篇小文章。 透传 disabled 属性将 disabled 透传至 button 之后，就发现 user agent 的样式权重很高： 这其实是小程序的坑。按理说 user agent stylesheet 的优先级肯定比 user stylesheet 低才合理的: 这明显是不讲武德了，但问题还是要解决。为了样式的正确还原，有两个解决方案： 增加封装样式的特异性（specity） 不透传disabled 第一种方案，就是为了弥补小程序埋的坑而因此更多的问题，比如用户如果想要自定义主题的话，要想覆盖 TDesign 的样式就需要将 specity 提得更高，因此否定了这个方案。 第二种方案，就是不将 disabled 属性透传到原生 Button，手动实现 disabled 的效果。 重新实现 disabled这种方案很直观，就是监听 tap 事件，然后在 disabled 的时候不触发 tap 事件即可： 1&lt;button class=&quot;t-button&quot; bind:tap=&quot;handleTap&quot;&gt; 1234567// t-buttonComponent({ handleTap() { if (this.data.disabled) return this.triggerEvent('tap') }} 但此时需要考虑一种情况，就是有 open-type 的时候，会没法阻止。 此时直观的想法是在每个开发能力对应的事件里，对 disabled 做特殊处理，但其实也是不合理的。因为这样没法阻止 open-type 的事件发生，用户仍然会看到对应的授权弹窗。 另外一种方案，反而会合理许多，但也 hack 许多。就是在 disabled 的时候，不透传 open-type： 1&lt;button open-type=&quot;{{ disabled ? '' : openType }}&quot; /&gt; 事件问题在使用 t-button 组件的时候，就发现问题了，tap 事件触发了两次： 1&lt;t-button bind:tap=&quot;handler&quot;&gt; 12345Page({ handler() { console.log(1) // 触发两次 }}) 这个问题也是比较典型的事件模型问题： 因此，需要通过 catch 事件来捕获 tap 事件，避免冒泡： 1&lt;button class=&quot;t-button&quot; capture-catch:tap=&quot;handleTap&quot;&gt; 这样解决了上面的问题，但此时会导致 open-type 的事件不会触发。因此不能使用 capture-catch 而是使用 catch： 1&lt;button class=&quot;t-button&quot; catch:tap=&quot;handleTap&quot;&gt; 总结最后 button 的组件完成了，我就好奇业界其他组件库是如何实现的。 于是我去看了下 vant 和 lin-ui，这两个算是微信小程序组件库的两个明星仓库。 结果发现，这两个库都选择了不透传 disabled，自行实现disabled。但在事件问题上，三个组件库走在了不同的路上： vant 的 tap 事件是不受 disabled 影响的，新增了一个 disabled 时不触发的 click 事件。 lin-ui 则是会在有 open-type 的时候，disabled 失效。 TDesign 的 tap 的事件保持了和原生一致。","link":"/blog/2022/01/25/miniprogram/component-button/"},{"title":"关于组件库的代码复用","text":"TDesign 组件库覆盖的范围很广，包括移动端、PC端、小程序端；也覆盖了主流的前端框架，如 Vue、React、Angular 等。因此，开发组件库时，代码的维护及复用是我们最头疼的问题，这就引发了我的思考，也就诞生了这篇文章。 终端的差异其实这里讲的差异主要是 web 端和小程序端。本质上，他们不是在一个水平上的产物，小程序属于更高级的框架，提供了新的语法之外，还提供了许多二次封装的组件。 除了组件这方面的差异，还体现在语法支持上的差异。比如说，小程序的组件属性，不支持 Date 类型，这类的问题还属于是开发中才会发现的“陷阱”。 CSS 的复用Web 的组件，本质上是 HTML + CSS + JS 的组合。不管框架如何变化，本质上只会影响 HTML + JS 的写法，并不会对 CSS 有太多影响。反而是终端的变化对 CSS 的影响更大一些。很多时候，我们只会考虑在逻辑做分层处理，反而忽略了 CSS 的分层，其实对 CSS 分层的意义在组件库开发中，尤为重要。其中 CSS 规则大致可以分成以下几类： 颜色/文本 尺寸/位置 布局 动画 在不同终端，颜色/文本 和 动画 不会有太大差异，因此可以做到复用。但尺寸/位置 和 布局 则会因为终端的变化而变化。因此 CSS 的分层是这样的： 通过这样的分层，就可以最大化复用 CSS ，只需要各自实现一下 Mobile 和 Desktop 的尺寸/位置 和 布局样式即可。对于小程序的处理，则需要对 CSS unit 做个转换即可。不至于导致每个终端都需要重新写一份 CSS。降低代码的重复率，也就降低代码的维护成本，尽可能延续组件库的生命。 逻辑复用业界比较热门的组件库，如 Ant Design 和 Element UI 都是专注于一个框架来开发的。因此他们并不会遇到多框架逻辑复用的问题。 跨框架级复用但最近发布的 Semi Design 则和 TDesign 一样，同步开发了 Vue 和 React 组件库，采用的逻辑复用方案被他们称之为 F/A 方案。其中 F 是 Foundation 的简称，代表与框架无关的逻辑；而 A 则是 Adapter 的简称，代表每个框架的适配器，与框架强相关。 其实思路还是比较直观的，将逻辑拆分成工具函数，封装成一个工具类作为 Foundation，然后在用户操作或者组件生命周期中调用 Foundation 对应的函数。 本质上就是提前规划好组件的函数拆分，做到函数级别上的复用。 目前来说，如果不使用 DSL 或者二次编译的方式，确实没办法做到更多的复用。但如果采用 DSL 的话，极大可能会陷入编译器的深渊之中。 组件级复用当我们使用一个组件，UI 又没法满足要求时，我们往往会选择重新造一个轮子。 但其实，如果此时组件的 UI 无法满足，但逻辑是符合的，是不是可以做到只复用逻辑，然后只需要重写 UI 即可。 比如，以我实际开发时遇到的 Select 举例，TDesign 的 Select 是长这样的： 但用户反馈说，他们的视觉是这样的： 功能可以说是一致的，差别仅仅是 用于筛选的 input 的位置。 对于常规的组件来说，组件的每个节点是固定的，可以扩展的位置（插槽 Slot）也是固定的。像这样要大范围调整内部节点的场景，是无法满足的。 为了满足这样的诉求，我的实现思路是这样的：将组件的实现拆分成两层：rawComponent 和 realComponent RawComponent 将每个模块输出，拆分成更小粒度的组件，用户可以自定义组合，也可以通过渲染函数或者 Scoped Slot 来实现不一样的 UI。 在 React 中使用 Render Props 自定义渲染 1234567891011121314151617181920212223242526// rawclass RawComponent extends React.Component { constructor(props) { super(props) } render() { return this.props.render({ // ... some props }) }}class RealComponent extends React.Component { constructor(props) { super(props) } render() { return ( &lt;RawComponent render={() =&gt; (&lt;div&gt;&lt;/div&gt;)} /&gt; ) }} 在 Vue 中使用 Scoped Slot 自定义渲染 12345678910// raw.vueVue.extend({ data() { return {} }, render() { return this.$scopedSlots.default({ result: []}) }}) 12345678910111213141516// real.vue&lt;template&gt; &lt;RawComponent&gt; &lt;div scope-slot=&quot;{ result }&quot;&gt; &lt;span&gt;{{result}}&lt;/span&gt; &lt;/div&gt; &lt;/RawComponent&gt;&lt;/template&gt;&lt;script&gt;import RawComponent from './raw.vue';Vue.extend({ components: { RawComponent }})&lt;/script&gt; 思考作为组件库的开发者，也是使用者。我选用组件库时，对组件库的期望是这样的： 组件数量齐全且特性完善 代码质量高（可维护性高，可阅读性高，可扩展性高） 可复用性高 组件的特性完善需要通过不断的用户反馈然后进行迭代才能达到的。而代码的质量，和可复用性高则是我们从一开始就能考虑并尽可能实现的。 如果说，要如何在相对成熟的组件库市场上有所与众不同，或者说能让用户选用我们的话，那可复用性可能是其中之一。 参考资料 Semi Design - UI组件库如何分层设计，使其具备适配多种mvvm框架能力 Component Reusability in React &amp; Vue","link":"/blog/2021/12/01/about-code-reuse-for-uilib/"},{"title":"小程序复用函数的五种方式","text":"开发过小程序的朋友们应该都遇到这样的情况，可能很多个页面有相同的函数，例如onShareAppMessage，有什么最佳实践吗，应该如何处理呢？ 本次开发技巧，我从以下几种解决办法剖析： 将它复制粘贴到每个地方（最烂的做法） 抽象成一个公共函数，每个Page都手动引用 提取一个behavior，每个页面手动注入 通过Page封装一个新的newPage，以后每个页面都通过newPage注册 劫持Page函数，注入预设方法，页面仍可使用Page注册 复制粘贴大法这是最直观，也是初学者最常用到的办法。也是作为工程师最不应该采取的办法。这有一个致命的问题，如果某一天，需要改动这个函数，岂不是要将所有的地方都翻出来改，所以这个办法直接否决。 抽象公共函数这种方式，解决了复制粘贴大法的致命问题，不需要改动很多地方，只需要改动这个抽象出来的函数即可。但是其实，这个方式不便捷，每次新增页面都需要手动引入这个函数。 以下都通过onShareAppMessage方法举例。 假设在app.js通过global注册了onShareAppMessage方法： 12345678// app.jsglobal.onShareAppMessage = function() { return { title: '我在这里发现了很多好看的壁纸', path: 'pages/index/index', imageUrl: '' }} 那么此时每次新增的Page都需要这样引入： 123456// page.jsPage({ ...global.onShareAppMessage, data: {}}) 这样的缺点也是非常明显的： 创建新页面时，容易遗忘 如果多个相同的函数，则需要每个独立引入，不方便 提取Behavior将多个函数集成到一个对象中，每个页面只需要引入这个对象即可注入多个相同的函数。这种方式可以解决 抽象公共函数 提到的 缺点2。 大致的实现方式如下： 同样在app.js通过global注册一个behavior对象： 12345678910111213// app.jsglobal.commonPage = { onShareAppMessage: function() { return { title: '我在这里发现了很多好看的壁纸', path: 'pages/index/index', imageUrl: '' } }, onHide: function() { // do something }} 在新增的页面注入： 123456// page.jsPage({ data: {}, ...global.commonPage,}}) 缺点仍然是，新增页面时容易遗忘 封装新Page封装新的Page，然后每个页面都通过这个新的Page注册，而不是采用原有的Page。 同理，在app.js先封装一个新的Page到全局变量global： 12345678910111213141516// app.jsglobal.newPage = function(obj) { let defaultSet = { onShareAppMessage: function() { return { title: '我在这里发现了很多好看的壁纸', path: 'pages/index/index', imageUrl: '' } }, onShow() { // do something } } return Page({...defaultSet, ...obj})} 往后在每个页面都使用新的newPage注册： 1234// page.jsglobal.newPage({ data: {}}) 好处即是全新封装了Page，后续只需关注是否使用了新的Page即可；此外大家也很清晰知道这个是采用了新的封装，避免了覆盖原有的Page方法。 我倒是觉得没什么明显缺点，要是非要鸡蛋里挑骨头的话，就是要显式调用新的函数注册页面。 劫持Page劫持函数其实是挺危险的做法，因为开发人员可能会在定位问题时，忽略了这个被劫持的地方。 劫持Page的做法，简单的说就是，覆盖Page这个函数，重新实现Page，但这个新的Page内部仍会调用原有的Page。说起来可能有点拗口，通过代码看就一目了然： 1234567891011121314151617// app.jslet originalPage = PagePage = function(obj) { let defaultSet = { onShareAppMessage: function() { return { title: '我在这里发现了很多好看的壁纸', path: 'pages/index/index', imageUrl: '' } }, onShow() { // do something } } return originalPage({ ...defaultSet, ...obj})} 通过这种方式，不改变页面的注册方式，但可能会让不了解底层封装的开发者感到困惑：明明没注册的方法，怎么就自动注入了呢？ 这种方式的缺点已经说了，优点也很明显，不改变任何原有的页面注册方式。 其实这个是一个挺好的思路，在一些特定的场景下，会有事半功倍的效果。","link":"/blog/2020/03/14/miniprogram/how-to-resue-method/"},{"title":"浅谈小程序的错误处理","text":"其实，错误（异常）处理在任何编程语言里，都是不可避免的。正确处理异常，是一个程序/应用保持健壮的关键。 现实从小程序的 API 文档可以看出，每个异步方法都支持传入一个 fail 方法，用于异常处理，例如： 12345678wx.login({ success (res) { console.log(res) }, fail(err) { // handle error }}) 会存在这样一种情况：开发人员会因为惰性直接忽略这个参数；而测试人员由于无法 mock 这些错误情况，导致测试用例没有覆盖，最终可能会因此流失用户。 还有一种情况，当这些 API 调用是在非关键流程上。若调用成功，则继续执行；若调用失败，直接忽略也不会影响。 对于第一种情况，除了在 fail 里做异常处理以外，别无他法。 本文将进一步讨论第二种情况。 分析官方提供的 API，在发生异常时，均会通过回调函数 fail 回传错误信息。如果我们能采集这些数据，进行统计分析能有这些作用： 为后续技术优化提供指导方向 了解用户设备的兼容性，预防踩重复的坑 由于官方提供的 API，所有的异步方法都需要手动传入 fail，因此手动给每个方法传入 fail 可能是不可行的。 另外，小程序的更新频率很高，每隔一段时间就会出现许多新的API。 因此，最佳的实践即是封装全局对象 wx 实践封装 wx 的方案有很多，这里就列出两种比较常规的方案： 较安全的方案：在全局变量 global 上新增方法（如：global.wx） 较激进的方案：劫持 wx，直接在 wx 上动刀 两种方案可有利弊，要看如何权衡。以下我将以第二种方案举例： 1234567891011121314151617181920212223242526272829// global.jslet originalWX = wx;wx = new Proxy({}, { // [0] get(target, name) { if (name in originalWX ) { let isSyncFunction = name.endsWith('Sync'); // 同步函数 [1] let isNotFunction = typeof originalWX[name] !== 'function'; // 非函数 [2] if (isSyncFunction || isNotFunction) return originalWX[name]; return function(obj) { if (typeof obj === 'object') { // [3] let originalFail = function() {}; if ('fail' in obj) { originalFail = obj.fail; } obj.fail = function() { // todo 上报数据到后端 [4] console.log('hijack success'); originalFail(); }; } return originalWX[name](obj); }; } }}); 代码注释： [0]： 这里使用的是ES6提供的Proxy代理对象；会有一定的兼容性，如果需要兼容更低版本的机型，可采用其他方案（感兴趣的人多的话，后续补上） [1]：前文也提到，只有异步方法才会有回调，因此同步方法直接返回原wx的方法 [2]：非函数；wx对象里有非函数的值，如 wx.env [3]：wx对象里的函数，可能传入非对象参数。如：wx.canIUse [4]：请看下一章节 进阶其实上述的代码，还不是最终版本。因为数据上报部分，还依赖后端提供接口。 按理说，日志系统也算是通用的服务。我很早前就在思考，为什么微信官方不提供呢？细心的读者可能会反驳说，微信有提供类似的功能：wx.reportMonitor（业务数据监控上报接口）。 其实，用过的读者应该了解，这个接口是非实时的，不能算是日志服务。 如果你有不定时翻看微信小程序开发文档的习惯的话，你总会有这样的感觉：时不时就新增了一个特性，塞在了一个不容易发现的角落。接下来要讲的新特性，就是官方提供的 实时日志： 123var log = wx.getRealtimeLogManager ? wx.getRealtimeLogManager() : nulllog &amp;&amp; log.info.apply(log, arguments) 所有的日志，都可以通过 小程序管理后台 查看。 访问路径：[ 开发-&gt;运维中心-&gt;实时日志 ]","link":"/blog/2020/03/23/miniprogram/handle-error/"},{"title":"小程序加载性能优化实践","text":"前言对于互联网产品来说，第一印象就是应用的启动速度。虽然启动足够快时用户不会有很大的感知，但是如果慢就会被发现就会被挑战，总结来说，快就是应该的。 而应用的启动速度优化，又可以分成首次启动速度优化和二次启动速度优化。对于不同的类型，对应的优化方案也是截然不同的。要如何确定优化方向以及优先级呢，这就要从具体的业务场景出发。 业务场景但凡不谈业务场景就直接谈优化都是不够专业的。 本次优化实践主要是依托在微保的车险业务。 众所周知，车险一般都是一年期的保险。因此车险用户的访问频次非常低，一年一次。其次，因监管要求，用户在投保车险之前，必须要先完成实名认证；认证通过之后才能添加要投保的车辆。因此一个用户要想完成投保，一定要经过实名认证、添加车辆、报价、支付、完成投保等步骤。 另外，为了优化用户访问频次低的问题，平台通常会提供一些车主必备服务。以提升用户活跃度。 由此可见，微保车险的业务矩阵大致如下： 相较于车主服务，主流程的性能显得更为重要，毕竟涉及到成交的流程才是关键。因此，本次总结也是在 主流程 上优化实践得出的。 优化方向绝大多数车主用户只拥有一辆汽车。因此一年之中就只有一次购买车险的机会。对于如此低频的产品，每次用户过来，都是全新的UI，全新的代码。相当于每次过来都是首次启动，此时 首次启动速度 就显得极为重要。这也是本次优化的主要方向。 我们参考Google提出的RAIL性能模型目标。 以用户为中心；最终目标不是让您的网站在任何特定设备上都能运行很快，而是使大部分用户满意。 立即响应用户；在 100 毫秒以内确认用户输入。 设置动画或滚动时，在 10 毫秒以内生成帧。 最大程度增加主线程的空闲时间。 持续吸引用户；在 1000 毫秒以内呈现交互内容。 总结起来，我们的第一优化原则就是，保证绝大多数的用户能够较快地访问我们的应用。 准备工作展开性能优化工作之前，还有一个重要的准备工作。即要预先采集基准数据。有了基准数据，才能很好地衡量自己的优化效果。 微信公众平台虽有提供小程序启动耗时、下载耗时的图表，但由于不能提供原始数据，不利于细化分析，因此本次性能优化采用的是自建日志上报系统提供的数据。 确定好性能指标，获取到相关数据，这还不够。 由于现实网络环境非常复杂，收集的原始数据是非常粗犷的，相同的代码，相同的配置，在不同的网络环境和手机上，加载时间会千差万别。因此对于收集到各种极端数据，必须要做一定的加工处理，才能变成可分析的数据： 常见的加工处理（指标计算口径）主要如下几种： 平均数： 最直接的想法，计算所有数据的平均值。但是平均数会因为部分极端值导致偏大，会观察到数据的波动较大，因此平均数不适合作为参考指标。 95分位数： 将所有数据从小到大排列，取第 95%位置的数值，将这个值作为我们的性能指标。 截尾平均数： 同样将所有数据顺序排列，将尾部的部分数据移除，然后取平均值。这个值会相对平稳，比较适合作为参考指标。 结合前面提到的第一优化原则，明显 截尾平均数 这种指标计算口径是最佳选择。 比如假设我们承诺保证90%的用户在1000ms内完成小程序的加载，那么我们就只要关注前90%的用户的加载耗时是否在1000ms内即可。 通过截尾获得耗时较少的前50%、80%、90%用户的平均加载耗时数据（后续横向分析这三类用户的加载耗时的优化效果） 处理好数据之后，进行性能分析的时，可以如下进行分类分析： 按手机系统（Android、iOS）分类 按网络环境（WIFI和4G）分类 以下是采集的 4G网络下，不区分手机系统 的车险分包的加载耗时（作为优化前的基线数据）： 实践由于小程序有提供许多基础API、UI库，而这部分代码是每个小程序的依赖。因此初始化代码的时候，这个是最先初始化的，渲染流程大致如下： 相对于传统web，我们能在很多环节上做优化。比如资源加载顺序（图片懒加载、CSS前置加载，JS后置加载等），使用构建工具实现按需加载等。但小程序的底层逻辑比较封闭，我们无法深入参与，因此要优化小程序的加载性能，能做且最行之有效的方案就是优化小程序代码包的大小。 优化代码包大小的方案主要有以下几种： 移除未使用的代码 实现代码按需加载（在小程序里，即是采用分包加载方案） 移除小程序包里的图片资源（因为小程序包下载时，默认使用了gzip压缩，而非文本的压缩效率较低） 简化JavaScript，尽量避免在前端进行复杂的计算（将JS逻辑尽量迁移至后端或者采用Nodejs中台来完成这部分计算工作，这样也利于后续扩展到多平台） 移除未使用的代码由于车险是微保最先推出的产品，经历了无数多个迭代，不可避免会出现已下线的业务或功能。这部分代码一般都是以页面为单位，因此可以结合PV数据来找到这部分代码。 提到PV数据，顺带提一下如何自建日志上报系统。由于小程序的每个页面都有完整的生命周期，因此进入一个新页面时，都会触发Page的onLoad方法，此时通过向后台服务上报进入页面的信息，即可完成页面PV数据统计。 对于如何实现错误路径的重定向处理，提供两个思路： 小程序提供的路由能力（如wx.navigateTo），当传入的url不存在时，会触发 fail 方法，此时在 fail 处理下即可。 使用 wx.onPageNotFound 方法处理，不过有一定的兼容性问题。 移除未使用的代码之后，车险分包由 1100+KB 降到 900+KB （减小18%） 代码按需加载理想情况下，访问用户应该只下载有访问到的资源，其他资源一概等到需要的时候才下载。这种按需加载的方案，小程序是采用代码分包的方式处理。但由于分包与分包之间无法相互引用资源，无法复用代码，因此拆分分包必然导致开发的效率下降。因此拆分分包时，要把握好性能与效率的平衡。 由此，我们提出了 基于UV及访问路径的分包拆分原则 。 结合日志系统，我们发现车险的实名认证页是UV大户，而实名认证的逻辑和添加车辆、编辑车辆的逻辑比较类似，均包含了车辆管理逻辑和组件。因此这部分页面的代码相似度较高，比较适合拆成一个分包，最终将实名认证、车辆管理等页面拆分到：新用户分包A。 其次，通过观察页面漏斗数据发现，大部分的用户只访问了主流程上的页面：车险首页、报价页、支付页、保单详情页。至于调整方案页、车辆列表页等分支流程，只有少部分用户会访问到的。因此将主流程的页面拆分成主分包B，而其他所有分支流程的页面则拆分成另外一个分包：其他分包C。 最后将车险的分包拆分成如下： 包含实名认证、车辆管理流程的新用户分包A（200+KB） 包含主流程的主分包B（400+KB） 包含分支流程的其他分包C（100+KB） 对于新用户（未完成实名认证），通过预检测实名情况，分发不同路径，从而实现新用户仅先加载新用户分包A，与此同时预加载主分包B。因此对于新用户来说，首次加载的是200+KB的新用户分包A，相对于优化前加载的900+KB完整分包，加载的小程序分包大小减少了78%。 对于旧用户（已完成实名认证），不再加载新用户分包A，与此同时预加载了其他分包C，因此加载的小程序分包大小减少了56%。 简化JavaScript这部分优化与传统web开发的优化原理类似。 代码包下载完成之后，就要完成业务代码注入。这时，JS引擎就要解析/编译JavaScript，这也是JS引擎最耗时的操作，从Chrome开发者工具可以看到，其中黄色部分就是解析/编译耗时的部分： 因历史遗留问题，导致一些复杂的数据需要前端拼凑计算处理（如可续保车辆的计算等）。将这部分逻辑迁移至后端后，JavaScript的代码得到了进一步简化，只对最终数据做基本展示变换。 由于本次实践没有深入这方面的优化，故不详细叙述这块优化的效果，后续有机会另外开篇文章详细讲。 遇到的问题在本次优化实践的过程中，遇到了许多问题，和大家分享一下我们的处理办法。 第一个遇到的问题，就是组件的引用。 因为小程序的限制，组件不能跨分包互相引用，要想跨分包复用，就要将组件放在小程序主包，而主包的代码是跨业务共有的，不能随意添加。因此在拆分分包的时候，需考虑到这个问题。 其次，是JS公共库的引用问题。 原本在同一个分包时，通过相对路径引入即可。但拆分成多个分包之后，JS就无法直接引用了。此时需要变换思路，如：将JS公共库挂载到全局变量global上；或者将代码copy一份到其他分包上（当然不是直接copy，是通过gulp或者webpack打包）；又或者将公共库放在主包上。 还有更让人头疼的是，目录变更导致的路由跳转问题。 由于小程序分包机制要求每个分包都在一个目录里。因此拆分分包就不可避免地要对文件进行迁移，而小程序的跳转又和文件目录强耦合，文件路径变更导致跳转路径变化。因此涉及到的页面的跳转路径均要改变。 此时，还要考虑向前兼容，比如已推送的模板通知。因此路由跳转的封装就显得极为必要。 效果经历以上的抽茧剥丝，终于等到了上线时间，可以到看，优化的效果非常明显： 横向对比不同分类的用户，可以更清晰看到各类用户的提升情况： 对于较快的前50%用户，也提升了接近50%的访问速度。 此次优化，保证了90%的用户可以在2000ms内完成小程序的加载。 后续优化对于接下来的优化工作，我们仍有几个计划： 充分利用小程序提供的预下载分包功能。若没有设置预下载，用户在跳转其他分包页面时，就要等待分包的下载。对于比较急躁的用户，会以为卡机了，最终导致用户跳出。（小程序预下载的唯一限制就是，当前分包和预下载的分包大小之和不能超出2M，如果超出，可以考虑再次拆分分包） 简化WXML的class。类选择器是最常见的样式选择器，当页面变得庞大时，class的长度往往会越来越长。然而在不支持DOM操作的小程序里，class的主要作用主要是样式注入。因此可以通过脚本将WXML和WXSS相同的class统一精简成短小的命名。 采用Node.js中台转移部分计算。将JavaScript的代码进一步简化，这样有利于对小程序的加载性能进一步优化。其次，这样也有利用扩展到其他平台，比如H5等。 总结尽管看似微信小程序的开发、发布方式和传统web有很大的差异。但是底层的运行还是类似的，因此可以从传统的web优化实践中找到优化的思路。 其中本文提到的一些优化实践是非常定制化的，是根据特殊的业务场景采取的特殊方式处理。毫无疑问，业务在发展，代码也会随着发生变动，这就需要不断的优化，才让用户的体验愈来愈好。 感谢大家阅读，如有错误，欢迎指正，感谢。","link":"/blog/2020/05/27/miniprogram/performance-optimization/"},{"title":"浅谈小程序路由的封装设计","text":"微信官方提供了基础的路由能力，在日常的开发中虽已够用，但随着开发的深入，会遇到许多值得思考提炼的问题。本文将探讨作者在微信小程序（以下简称小程序）开发当中遇到的问题，以及解决方案设计。 参考“WHY-HOW-WHAT”黄金圈思维法则，首先讲述为什么小程序的路由需要封装设计，也就是存在哪些问题，需要封装处理？ 存在的问题路由跳转的路径与文件路径耦合小程序的路由跳转使用的是真实文件路径，因此若文件的结构发生变化，必会影响到所有的页面的跳转路径。 笔者在实际开发中就遇到这个问题，以小程序分包举例。 小程序的分包是以文件夹为单位的。如果要将一系列的页面拆分成分包，则需要将这些文件移至同个目录之下，因此必然导致路由的跳转路径发生变更。如果此时路由跳转均是直接通过文件路径跳转的话，则需要全局改动，导致的工作量不少。 另外，当开发团队比较庞大时，不同的业务之间总会存在互相跳转的情况。当其中一个页面地址发生变更时，其他业务跳转到该页面的路径都需要手动变更。若此时通知不及时，或者遗漏了一些地方，导致跳转失败，终会酿成大错。 路由传参目前小程序支持的传参方式，即通过跳转路径上的 query 查询参数。 通过 query 传参的问题，与在 Web 上 URL 传参是一致的，比如： query 的参数长度有限 query 只能传递可序列化的数据 导航前需手动序列化，到达目标页面后需反序列化 条件导航在日常业务中，会存在一些页面需要一定条件才允许进入的。 举个例子，会员服务是一种很常见的能力，而会员中心的进入条件是： 该用户已经完成登录 该用户是本产品的会员 一般情况下，这有特定准入资格的页面的导航逻辑是这样的： 这种方式简单明了，但存在一个问题：需要每次跳转前主动判断，逻辑冗余以外，还可能被遗漏。 思路由于小程序本身已提供了基础的路由导航能力，不像 react、vue 那样需要从底层进行封装，从而提供路由能力。但是，本质上小程序可以理解成类 vue 这样的框架，因此可以从 vue 的路由库 vue-router 上找到灵感，从而解决以上问题。 命名路由使用 命名路由 的方式可以解决前文提及的跳转路径和文件真实路径耦合问题。 通过 Map 来映射 页面ID 和 页面地址，路由跳转时，仅能使用 页面ID 进行路由跳转。 下面以导航至首页举例： 12345// beforewx.switchTab('pages/home/index')// afterrouter.go('home') 由于小程序有 tab 页面和普通页面之分，因此导航至 tab 页时需使用 switchTab 细心的读者可能会发现上文使用了 go 方法，而不是 switchTab。其实，具体哪些页面属于 tab 页面，在 app.json 已经明确配置。对于使用者来说，不需要关心跳转的页面是属于哪种类型，这些细节都应该统一在底层封装好。下面罗列 Router 与官方 API 的对应关系： Router API的设计原则是保持简单，以及尽量保持与web规范一致 参数传递微信官方提供的 query 方式传参，若参数是普通数据类型（如Number、String）时可以直接使用；但若是涉及到复杂数据类型（如Array、Object）时，需要先做序列化处理，当数据较为庞大时，性能的损耗还是比较明显的。 因此，在内存上传递参数是比较便利且容易想到的办法。 利用数据字典，将 页面ID 作为 key、传递的参数作为 value，写入 Router 的 state： 1234router.go = function(pageID, params) { // do something... router.state[pageID] = params} 在目标页面上，可以通过 router.getParams() 方法，获取传递的参数。 由于采用了命名路由的方式，可以使用 页面ID 作为 key，避免了使用跳转路径做 key 时，涉及到的绝对与相对路径问题。 条件导航条件导航可以使用类似 vue-router 的导航守卫来解决问题。 由于路由的能力是微信官方提供的，因此无法像 vue-router 那样提供多类型的导航守卫，但仅有全局导航守卫也足够使用。 以下仍以“会员中心”的进入逻辑举例，并简要介绍实现思路： 其中，to和from目前是pageID，其实可以封装更多信息，以保证导航守卫可以尽可能拥有更多的信息。因此to可以理解成是即将进入的页面路由对象，而from则是当前正要离开的路由对象。 路由对象可以包含以下信息： pageID：页面 ID path：页面 ID 对应的 path params：传递的参数 query: URL的查询参数 配置信息由前文提到的 命名路由 做法需要一个配置文件来关联 页面ID 与 页面路径 的关系。 页面的配置信息，则是使用 router.config.js 设置，然后通过构建工具编译转成 app.json。 以下是 route.config.js： 其中，跳转首页则是 router.go('home')；而跳转分包 health 的首页则是使用 router.go('health.home') 通过以上的配置文件，使用构建工具转换成微信官方可识别的 app.json 配置： 辅助函数在日常开发当中，经常会用到一些和路由相关的通用辅助函数，如获取当前页面，获取上个页面等。这些辅助函数都应该统一抽象封装，避免代码冗余。 1234567891011121314router.utils = { getCurPage() { // 获取当前页面信息 let pages = getCurrentPages() let len = pages.length return pages[len - 1] }, getPrePage() {}, // 获取上个页面信息 getParams() {}, // 获取传递的参数 getPageID(path) {} // 通过path找到pageID} navigator 组件微信官方除了提供 API 用于导航以外，还提供了 navigator 组件。 另外还有 functional-page-navigator 是用于插件当中，不能在小程序包使用，因此本文暂且将其忽略。 由于 navigator 的跳转参数仍是使用 path，因此笔者将其进行二次封装，改造成可以通过 pageID 跳转： 总结由于小程序相对比较封闭，因此在路由上能做的东西比较有限。 但路由又与许多概念有千丝万缕的关系。比如路由与文件结构关联，而文件结构又影响到分包的设计，环环相扣，影响到的地方则会越来越多。 因此，能提前看到本文提到的可能出现的问题，也许对后续的小程序开发有一定的参考意义。 另外，前文提到的很多问题，在早期开发，或者没有深入开发之前，都不会遇到。但是当你开始经历前文提到的那些问题时，往往此时的改造成本已经很大了。因此希望本文能给你带了一些启发，在早期规避这些问题，那本文的使命就达到了。","link":"/blog/2020/06/02/miniprogram/router-design/"},{"title":"移动端适配的四种方案","text":"viewport 的作用viewport 翻译成中文是“视窗”的意思，也就是字面上的意思，页面展示的窗口。知道这个 viewport 有哪些作用呢？我举例一下： 计算百分比值当我们设置一个块级元素的宽度为百分比的时候，在HTML的规则中，最终的大小取决于它的父元素。如果元素嵌套情况如下： 1html &gt; body &gt; div 最终要计算出 div 的实际大小，就要知道 body 的大小，而 body 的大小又依赖于 html。所以最终的问题是，如何计算 html 的大小。而这个 html 是根元素，没有父元素。此时就是 viewport 登场了。由它来约束 html 的大小。 用户缩放当用户进行缩放时，对于我们的页面是如何变化的，或者用户当前是否存在缩放状态，这些都是通过 viewport 来获取的。 用户进行缩放时，页面的 CSS 像素是不发生变化的（如果有变化，必然触发重新渲染），变化的是视窗的大小。当用户放大页面是，视窗应该是变小，但物理像素是不会变化的，因此相同的 CSS 像素占用更多的设备像素，因此此时 dpr 会变大。 dpr(device pixel ratio) 设备像素比 = 物理像素 / 设备独立像素 在 JavaScript 里，我们可以通过 screen.width 获取物理像素的宽度，通过 window.innerWidth 获取当前页面的独立设备像素，因此可以这样计算设备像素比：screen.width / window.innerWidth。 当然，也可以直接获得设备像素比：window.devicePixelRatio 在桌面端，设备像素比(dpr) 通常情况下都是等于 1，当不等于 1 的时候，通常是用户进行缩放了。 移动端适配在移动端，会有许多各种尺寸的屏幕。如何在不同的屏幕呈现相同的效果，这就是移动端适配的工作，要想弄清楚如何兼容，就要先理解 viewport 的概念。 基础概念屏幕尺寸可通过 screen.width/height 获得。一般是通过 设备像素(device pixel) 来计算。 窗口尺寸可通过 window.innerWidth/innerHeight 获得。一般是通过 CSS 像素来计算。窗口是浏览器的窗口，包含了滚动条的尺寸，不包含顶部菜单： 视窗尺寸可通过 document.documentElement.clientWidth/clientHeight 获得。一般是通过 CSS 像素来计算。视窗与窗口差别在于不包含滚动条的尺寸： 移动端适配REM 方案视觉稿 750px，设置根元素即（html）的大小为 75px，所有元素均这样计算，以 230px 举例: 1width: 350px / 75px = 5rem 此时页面上的所有元素均以根元素的 font-size 计算，因此要做到动态支持不同尺寸的手机，只需要动态修改根元素的 font-size 即可。由于我们是以 750px 的十分之一为基准的，所以只需将当前 视觉窗口(visual viewport) 同样除以 10 即可： 1234let docEl = document.documentElementlet rem = docEl.clientWidth / 10docEl.style.fontSize = rem + 'px' 另外，由于 font-size 是继承性属性，上述代码将 &lt;html&gt; 的 font-size 修改了，为了不影响到默认的字体大小，可以在 &lt;body&gt; 上重置 font-size: 123body { font-size: inital;} VW 方案VW 方案是和 REM 方案的原理是一致的：以当前宽度按比例动态调整。 VW 方案的优势是 不需要动态调整基数。vw 单元原生支持与当前视觉窗口按比例动态变化。缺点是会有一定的兼容性，可以看下 vw 的兼容情况： 具体实现方案与 REM 类似，以视觉稿的宽度（一般为 750px）为基准，将 px 单位转换成 vw 单位，以 75px 举例：(基于 vw 的定义，全宽等于 100vw)： 123.banner { width: calc(75 / 750 * 100) vw} transfrom 方案该方案不需要转换单位，正常以 px 为单位。只需要以屏幕宽度与视觉稿的宽度的比作为基数，在根节点上进行缩变即可： 1234let docEl = document.documentElementlet ratio = 750 / docEl.clientWidthdocument.body.style.transform = `scale(${ratio})` 目前发现此方案存在兼容性问题，在 iOS 上，fixed 定位的元素会失去固定的效果，会随着滚动改变位置。另外在某些 Android 上，fixed 的元素会滑动之后消失。因此，不建议使用此方案 viewport meta 方案此方案与 transform 方案类似，通过缩变，以将页面宽度适应屏幕宽度。 不同的地方在于，需要移除现有的 viewport meta，在 head 增加一个脚本实时生成 viewport meta： 1234567&lt;script&gt; let meta = document.createElement('meta') meta.setAttribute('name', 'viewport') meta.setAttribute('content', `width=750, initial-scale=${screen.width/750}, user-scalable=no`) document.documentElement.firstElementChild.appendChild(meta)&lt;/script&gt;&lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; --&gt; 参考资料 移动端viewport标签背后的三层含义 使用Flexible实现手淘H5页面的终端适配 MDN meta Configuring the Viewport A tale of two viewports — part two 掘金 H5移动多终端适配全解 - 从原理到方案","link":"/blog/2020/08/11/responsive-web/"},{"title":"Vue 技术细节 - data","text":"Vue.js 是前端热门的UI框架。目前国内的前端团队一般都是 Vue.js、React 二选一。 理解 Vue.js 的技术细节，既有助于日常工作开发，也是一个很好的敲门砖。 背景我在社区里搜索过 Vue.js 相关的文章，发现不少高赞的文章都是水文，或者是年久失修的老文。 如果读者不明所以，直接照本宣科，面试的结果必然是凉凉。因此，我还是建议读者们自行阅读源码，或者看一些源码解析的文章（这里我推荐一下黄老师的源码解析），不会一知半解，被水文坑害。本文也是笔者自己的 Vue.js 相关的底层原理的认知总结，如有纰漏，或者错误，烦请指正。 常见问题Vue.js 里 data 为什么必须是函数？因为最近几年微信小程序也挺火，因此这个问题可以联想到 微信小程序的 data 怎么是对象而不是函数呢？ vue 的官方也有提到，在同时渲染多个相同组件时，为了避免组件之间的数据互相影响，因此需要使用函数返回的对象来隔离。 其实，从上面官网的解释很容易理解。对象是引用类型，被多个组件使用，必然会互相影响。所以不要被官网初始化 Vue 实例的例子误导： 123456var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }}) 因为这个 Vue 实例是唯一的，所以不存在互相影响的问题。 所以可以得出结论1：data 使用函数是避免多个组件实例之间互相影响 使用组件有两种方式： 全局注册；使用 Vue.component() 局部注册；在组件对象里使用 components 属性 下面以局部注册举例。 渲染页面时，Vue.js 会解析 HTML 的tag，如果此时发现不是原生 tag，就会从 components 属性里获取对应的组件声明，如果找到，则使用 createComponent 函数创建组件，将组件声明通过 Vue.extend（源码位置：src/core/global-api/extend.js）来初始化构造函数 Ctor，这个 Ctor 将会被复用。 由此可见，我们的组件声明并不是直接用来当构造函数的，而是构造函数的入参。因此使用 data 函数可以避免数据的混淆，也避免了 Vue.js 需要对 data 进行深复制的繁琐操作，提升了执行速度。 参考资料 Vue.js技术揭秘","link":"/blog/2020/07/22/vue/why-data-must-function/"},{"title":"JavaScript 数据类型详解","text":"前言JavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。 但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。 社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。但为了解决问题而引入新的语法糖，只会是增加复杂度，将问题转移罢了。 因此对待问题的最好解决办法是正视它，剖析其背后原理。 本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。 数据类型 基础数据类型：undefined、null、Boolean、String、Number、Symbol 引用数据类型：Object 任何没有赋值的变量都有这个值：undefined 类型转换显示类型转换（explicit conversion）常用的数据类型有这三种：Boolean、Number、String，可以看下显示转换： undefined null Boolean Number String Symbol Object toBoolean false false / false: -0、+0、NaNtrue：其他 false: ‘’true：其他 true true toNumber NaN 0 1：true0：false / （下章详解） 抛出异常TypeError 调用valueOf() toString ‘undefined’ ‘null’ ‘true’：true‘false’：false （下章详解） / 抛出异常TypeError 调用toString() 隐式类型转换（implicitly conversion）大致有以下场景会出现隐式类型转换： 条件语句（if、else、） 循环语句（for、while） 逻辑运算符：!、&amp;&amp;、||、?:三元运算符 算术运算符：+ 比较运算符：==、&lt;、&gt; 其中，条件语句和循环语句都是将类型转换成 Boolean，因此可以参考上表。其他的类型，会有特殊的类型转换规则： Number String Boolean Object undefined null Symbol Number === String string.toNumber() === Boolean boolean.toNumber() boolean.toNumber() === Object Object.toPrimitive() Object.toPrimitive() false === undefined false false false false true null false false false false true true Symbol false false false Object.toPrimitive() false false === 字符串转数字具体转换算法有些复杂，以下拿具体的方式举例。 JavaScript 提供了好几种方式： parseInt() parseFloat() Number() Math.ceil() Math.floor() 运算符：+或* 以下举例对比之前的差别，如整数字符串(int string)： 123456789let intStr = '1'parseInt(intStr) // 1parseFloat(intStr) // 1Number(intStr) // 1Math.ceil(intStr) // 1Math.floor(intStr) // 1+ intStr // 1intStr * 1 // 1 浮点型数字字符串(float string)： 123456789let fltStr = '1.23'parseInt(fltStr) // 1parseFloat(fltStr) // 1.23Number(fltStr) // 1.23Math.ceil(fltStr) // 2Math.floor(fltStr) // 1+ fltStr // 1.23fltStr * 1 // 1.23 非数字字符串(NaN string) 123456789let str = 'abcdefg'parseInt(str) // NaNparseFloat(str) // NaNNumber(str) // NaNMath.ceil(str) // NaNMath.floor(str) // NaN+ str // NaNstr * 1 // NaN 数字+字母 字符串(number and alpha string): 123456789let str = '1.23abcdefg'parseInt(str) // 1parseFloat(str) // 1.23Number(str) // NaNMath.ceil(str) // NaNMath.floor(str) // NaN+ str // NaNstr * 1 // NaN 字母+数字 字符串(alpha and number string) 123456789let str = 'abcd1.23'parseInt(str) // NaNparseFloat(str) // NaNNumber(str) // NaNMath.ceil(str) // NaNMath.floor(str) // NaN+ str // NaNstr * 1 // NaN 除了结果直接的差异之外，性能也有些差异，在《how-to-convert-string-to-number-javascript》文章有相关的性能对比，有兴趣的可以看一下。这里我直接贴个结果图： 数字转字符串相对比较复杂，可以参考 ecma262 的文档 。。。持续更新 参考 深入理解JS的类型、值、类型转换 JavaScript Convert String to Number Converting strings to numbers with vanilla JavaScript How to convert a string to a number in JavaScript","link":"/blog/2020/07/27/fe-base/js-data-type/"},{"title":"JavaScript 的数据类型转换","text":"前言JavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。 但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。 社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。从团队的收益出发，增加这些是一个好的选择，但是也增加了许多学习成本。思考本质的话，这其实是为了解决问题而引入新的语法糖，增加了项目的复杂度，将问题转移罢了。 因此对于个人成长而言，对待问题的最好解决办法是正视它，剖析其背后原理。 本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。 原始数据类型：boolean、number、bigint、string、undefined、null、symbol（ES2016新增） 复合数据类型：Object 相等算法截止 ES2015，存在 4 种数值相等算法： Abstract Equality Comparison(==)：也称半等 Strict Equality Comparison(===)：也成全等；使用相同算法的还有 Array.prototype.indexOf、Array.prototype.lastIndexOf、case 语法 Same-Value-Zero：Set、Map、还有 Array.prototype.includes 和 String.prototype.includes Same-Value：除了以上都是该算法；常见：Object.is 半等和全等比较常见，唯一差别就是是否进行类型转换（当类型相同时，两个算法是相等的） 半等和全等为了满足 IEEE 754 标准，做了特殊处理：NaN ! = NaN 和 -0 == +0 半等 Abstract Equality Comparison半等（==）的逻辑大致可以这么理解： 类型是否相等？同类型则使用全等比较，类型不同则往下 两个数分别是 undefined、null？是则返回 true，否则往下 类型是 boolean 或 string？通过转换成 number 再比较 使用Number()转换而不是parseInt，可以看下面代码： 12'123abc' == 123 // falseparseInt('123abc') == 123 // true 类型是 object？通过 转换成原始数据类型(toPrimitive) 再比较 转换原始数据类型优先使用 valueOf() 而不是 toString() ，但如果未定义 valueOf() 则会使用 toSting() 12345678910111213var obj = { valueOf: () =&gt; 1, toString: () =&gt; 2}obj == 1 // trueobj == 2 // falsevar obj2 = { toString: () =&gt; 2}obj == 2 // true 都不是则返回 false 总的原则是：尽可能都转换成Number容易比较 全等 Strict Equality Comparison全等（===）的逻辑比较符合预期： 类型不一致，直接返回 false 如果是 undefined 或 null，则返回 true 如果是 Number 的话，做了特殊处理： NaN != NaN -0 == +0 如果是对象，查看是否是同个引用，是则返回 true，否则返回 false 剩下的逻辑都是判断两值是否相等 Same-Value 算法之所以会提供这个算法，是因为半等和全等存在两个问题： 无法正确判断NaN，因为 NaN != NaN 无法区分 +0 和 -0 而支持该算法的函数有 Object.is() ： 1234567Object.is(-0, +0) // false-0 == +0 // true-0 === +0 // trueObject.is(NaN, NaN) // trueNaN == NaN // falseNaN === NaN // false 此处 NaN 的判断又可以延伸一下，ES2015 提供了 Number.isNaN 方法 此时，你会很奇怪，之前不是有个全局方法 isNaN 了吗？是的，这个方法也是很诡异的。 因为 isNaN 会对传入的参数做类型转换，如果能转换成 Number 类型，则返回 true，否则返回 false 而 Number.isNaN 修正了这个逻辑，只做纯粹的判断，避免了歧义： 123456789101112var numberStr = '123'isNaN(numberStr) // falseNumber.isNaN(numberStr) // falsevar str = 'abc'isNaN(str) // true **歧义点**Number.isNaN(str) // falseisNaN(NaN) // trueNumber.isNaN(NaN) // true 因此，Number.isNaN 的 pollfill 可以这样实现： 123Number.isNaN = function(value) { return typeof value == 'number' &amp;&amp; isNaN(value);} Same-Value-Zero 算法很多时候，可能并不想区别开 +0 与 -0，但还需要知道是不是 NaN，因此推出了这个算法。 这个算法和 Same-Value 算法很类似，以为差别是目前这个算法 +0 等于 -0 。 内置该算法的函数前面有提到，下面以 Set 举例： 1234567891011let set = new Set()set.add(NaN)set.add(0 / 0) // 0 / 0 = NaN 因此不会添加console.log(set.size) // 1set.add(+0)set.add(-0) // -0 == +0 因此不会添加console.log(set.size) // 2 参考资料： Primitive | MDN Standard ECMA-262 5.1 Edition Equality comparisons and sameness | MDN","link":"/blog/2021/02/03/fe-base/js-data-type-transform/"},{"title":"手把手教你实现一个浏览器引擎（一）Start","text":"第一部分：起步我正在打造一个玩具HTML渲染引擎，与此同时，我觉得你也应该尝试一下。这是这个系列文章的第一篇： 第一部分：起步 第二部分：HTML 第三部分：CSS 第四部分：Style 第五部分：Boxes 第六部分：Block layout 第七部分：Painting 101 完整的系列文章将会通过描述我编写的代码，让大家学会如何制作自己的专属浏览器引擎。但是首先，让我解释一些东西。 我们准备做的是一个什么东西？首先，我们先谈谈一些术语(terminology)。 浏览器引擎(browser engine) 是网络浏览器(web browser)的一部分，作用是“在幕后”从互联网上获取网页，并将其内容转换为你可以阅读，观看的形式。 Blink，Gecko，WebKit 和 Trident 都是浏览器引擎。 相反，浏览器自己的用户界面（UI），如：标签（tabs）、工具栏（toolbar），菜单（menu）等等，我们称之为 chrome。 Firefox 和 SeaMonkey 是两个采用不同chrome，相同Gecko 引擎的浏览器。 一个浏览器还有其他很多子组件（sub-components）：一个HTTP 客户端，一个HTML解析器（parser），一个CSS解析器（parser），一个JavaScript引擎（包含解析器parsers、解释器interpreters、编译器compilers）等等。这些组件涉及到HTML，CSS等网络格式的解析，并转换成我们在浏览器看到的内容。有时，也将它们称之为布局引擎（layout engine）或者渲染引擎（rendering engine）。 为什么是一个玩具引擎？一个完整的浏览器引擎是相当的复杂的。 Blink，Gecko，WebKit这些引擎每个都是需要通过数百万行代码实现的。甚至一些如 Servo 和 WeasyPrint 这样比较新，比较简单的渲染引擎都是数万行代码的级别。对于新人来说，不是一个简单能完成的事。 说到巨型复杂软件：如果你上过编译器或操作系统的课，你可能做过或者修改过一个“玩具型”编译器或者内核。这是一个为学习而设计的简单模型；这可能是除了作者以外没人会运行的代码。不过制作一个“玩具型”的系统是一个很有用的学习方式，有助于我们的真正的编程工作。如果你从未做过真正的编译器或者内核，理解它们的工作机制也能在我们写代码的时候帮助我们更好地使用它们。 在家里尝试 try this at home我希望我已经说服你去做个尝试。如果你已有一定的编程经验，且懂得一些HTML和CSS的高阶概念的话，这个系列的内容就不会难倒你。 然而，如果你刚开始编程的话，或者有些地方不懂，可以自由提问，我尝试讲得更通俗易懂些。 在开始之前，先谈一下，你可以有哪些选择： 编程语言你可以使用任何语言来编写渲染引擎，真的，你可以使用你熟悉或者喜欢的任何语言。或者如果听起来很有趣，也可以以此为借口来学习一种新语言。 如果你想开始对一些主流的浏览器引擎如：Gecko 或 WebKit做贡献的话，你可能要使用C++，因为它是这些引擎的主要语言，并且使用它可以使将代码与其代码进行比较变得更加容易。 我的玩具项目：robinson 是使用 Rust 编写的。我是 Moziila 的 Servo team 成员，因此我非常喜欢使用Rust编程。另外，我在该项目中的目标之一，是了解Servo的更多实现。Ronbison偶尔也会用到Servo简化版的数据结构和代码。 关于库与捷径 On Libraries and Shortcuts在像这样的学习练习中，你需要决定到底是 直接使用他人的代码还是自己重写实现一遍。我的建议是，如果你想真正得理解的话，你应该自己重新实现一遍，不过千万不要愧于使用第三方库或者参考别人的代码。学习如何使用特定的库本身可能是一个有价值的练习。 我编写的Robinson，不仅要为了自己，而且还要作为这些文章和练习的示例代码。为了这样和那样的理由，我希望它尽可能的小且独立。目前为止，我没使用任何第三方代码除了 Rust 的标准库（这也避免了在语言仍处于开发阶段时使用相同版本的Rust来构建多个依赖项的麻烦。）当然，这些规则也不是一成不变的。举例来说，我可能决定之后使用第三方图形库而不是自己手写低级的绘制代码。 还有一种避免写代码的捷径就是，让这些功能都不要了吧。比如 robinson 是没有任何联网的代码，它仅仅可以读取本地文件。在一个玩具项目里，你可以随心所欲地跳过任何东西。因此，读这个系列文章，你可以随时跳过你不感兴趣的部分，直接阅读你觉得有趣的部分。在你回心转意时，再去补回前面的跳过的内容。 第一步：The DOM你准备好写一些代码了吗？我们从一些小方面开始着手：DOM的数据结构。我们一起来看看 robinson 的 DOM Module DOM是由许多的节点（nodes）组成的树（tree），一个节点（node）有零个或者多个子节点（Child）。（另外，它还有许多其他属性或者方法，不过我们可以暂时忽略这部分） 1234567struct Node { // data common to all nodes: children: Vec&lt;Node&gt;, // data specific to each node type: node_type: NodeType,} 其实节点是有许多的节点类型（node types），不过目前我们将忽略其中的大多数，并当做只有两种类型的节点：元素（Element）或者文本节点（Text node）。在具有继承性的语言中，这些将是Node的子类型。在Rust里，他们可以是枚举（enum ）类型： 1234enum NodeType { Text(String), Element(ElementData),} 一个元素包含：一个标签名（tag name）、任意个属性（attributes），可以将属性其存储为从名称到值的映射。Robinson不支持任何命名空间，因此只是将标签名（tag name）和属性名（attribute name）存成简单的字符串类型。 123456struct ElementData { tag_name: String, attributes: AttrMap,}type AttrMap = HashMap&lt;String, String&gt;; 最后是一些便于创建新节点的构造方法： 12345678910111213fn text(data: String) -&gt; Node { Node { children: Vec::new(), node_type: NodeType::Text(data) }}fn elem(name: String, attrs: AttrMap, children: Vec&lt;Node&gt;) -&gt; Node { Node { children: children, node_type: NodeType::Element(ElementData { tag_name: name, attributes: attrs, }) }} 就是这样！全面的DOM实现将包含更多数据和数十种方法，但这就是我们开始所需要的 练习以下是一些建议的练习方法。你可以做一些感兴趣的练习，然后跳过所有您不感兴趣的练习。 开始一个新项目，自由选择一种语言，编写代码实现包含text nodes 和 elements的DOM tree 安装最新版本的Rust，然后下载和构建 Robinson，打开 dom.rs 然后继承 NodeType 追加实现其他类型，如comment nodes 编写代码输出一个漂亮的树形DOM nodes 在下篇文章里，我们将会添加一个解析器（parser），把HTML源代码（source code）转换成包含DOM nodes的树 参考有关浏览器引擎内部的更多详细信息，请参阅 Tali Garsiel 精彩的 How Browsers Work 及其指向更多资源的链接。 有关参考代码，以下是“小型”开源渲染引擎的清单。其中大部分都比 robinson 大好几倍，但仍远远小于 Gecko 和 WebKit。 其中 WebWHirr 只有2000行代码，这是唯一一个我会称之为玩具的一个引擎。 CSSBox (Java) Cocktail (Haxe) gngr (Java) litehtml (C++) LURE (Lua) NetSurf （C） Servo (Rust) Simple San Simon (Haskell) WeasyPrint (Python) WebWhirr (C++) 你可能会发现这些项目可以给你很多灵感或者参考。如果你知道其他类似的项目或者如果你开始自己的项目，请让我知道！","link":"/blog/2020/01/22/browser/how-broswers-work-1/"},{"title":"手把手教你实现一个浏览器引擎（二）HTML","text":"这是关于构建一个玩具浏览器引擎这个系列文章的第二篇。 本文主要阐述如何将HTML源代码转化成Node节点树。解析（Parsing）是一个吸引人的主题，但是我没有足够的时间或专业知识来详细介绍它。你可以通过任何关于编译器（compilers）的好课程或书中获得有关解析（parsing）的详细介绍。或者选择你自己的编程语言，通过分析程序生成器(parser generator)的文档着手开始做项目也可以。 HTML拥有自己独特(unique)的解析算法。不像其他大部分编程语言和文件格式，HTML解析算法不拒绝非法输入。相反，它包含特定的错误处理操作指南，因此网络浏览器可以一致地显示每个网页，甚至是不符合语法规则的网页。网络浏览器不得不使这些不符合语法规则的页面正常显示：由于自web早期以来，就一直支持这些不符合要求的HTML，因此现在已有大量现有的页面正在使用这些不符合语法规则的HTML。 一个简单的HTML例子我不打算尝试去实现标准的HTML解析算法。相反我写了一个基础的解析器，支持HTML语法的子集。我的解析器可以处理这样简单的页面： 12345678&lt;html&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;div id=&quot;main&quot; class=&quot;test&quot;&gt; &lt;p&gt;Hello &lt;em&gt;world&lt;/em&gt;!&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以下语法是允许的： 平衡的标签(Balanced tags)：&lt;p&gt;...&lt;/p&gt; 带上引号的属性值：id=&quot;main&quot; 文本节点：&lt;em&gt;world&lt;/em&gt; 所有其他都是不支持的，包括以下： 注释（Comments） Doctype申明 转义字符（比如 $amp;) 和 CDATA sections 自闭合标签: 或者 没有闭合的标签 错误处理（如 标签不平衡 或者 不合理的嵌套标签） 命名空间（Namespaces） 和 其他 XHTML语法：html:body 字符编码检测 在该项目的每个阶段，我都会或多或少地编写支持后续阶段所需的最少的代码。不过如果你想学习更多有关解析理论和工具的信息，你可以尽可能地完善你自己的项目。 样例代码接下来，让我们来看一下我的玩具HTML解析器。切记这只是其中一种实现方式（可能不是最好的方式）。它的结构大致基于Servo的 cssparser 库的 tokenizer 模块。它没有真正的错误处理，在大部分的情况，只会在遇到不预期的语法时才会中断。代码是基于 Rust，但我希望对使用外观看似相似的语言如Java，C++或者C#的人来说，是可以理解的。可以看到，这使用了该系列文章第一部分的DOM数据结构。 解析器保存其输入的字符串（input）和该字符串当前的位置（pos）。这个位置是下一个我们还为处理的字符的索引（index） 1234struct Parser { pos: usize, // &quot;usize&quot; is an unsigned integer, similar to &quot;size_t&quot; in C input: String,} 我们可以使用它来实现一些简单的方法来寻找输入中的下一个字符： 123456789101112131415161718impl Parser { // Read the current character without consuming it. fn next_char(&amp;self) -&gt; char { self.input[self.pos..].chars().next().unwrap() } // Do the next characters start with the given string? fn starts_with(&amp;self, s: &amp;str) -&gt; bool { self.input[self.pos ..].starts_with(s) } // Return true if all input is consumed. fn eof(&amp;self) -&gt; bool { self.pos &gt;= self.input.len() } // ...} Rust 的字符串是以 UTF-8 字节数组 的形式存储的。要跳转到到下一个字符，我们不能简单地前进一个字节。相反，我们使用 char_indices 来正确处理多字节字符（如果我们使用等宽字符的字符串，那我们可以仅给 pos 加一即可） 12345678// Return the current character, and advance self.pos to the next character.fn consume_char(&amp;mut self) -&gt; char { let mut iter = self.input[self.pos..].char_indices(); let (_, cur_char) = iter.next().unwrap(); let (next_pos, _) = iter.next().unwrap_or((1, ' ')); self.pos += next_pos; return cur_char;} 通常，我们会想要消耗一串连续的字符。consume_while 方法会一直收集字符，直到满足给定的条件，最终将他们以字符串的形式返回。这个方法的参数是一个接收字符返回布尔值的函数。 123456789// Consume characters until `test` returns false.fn consume_while(&amp;mut self, test: F) -&gt; String where F: Fn(char) -&gt; bool { let mut result = String::new(); while !self.eof() &amp;&amp; test(self.next_char()) { result.push(self.consume_char()); } return result;} 我们可以使用这个来忽略一连串的空格字符。或者是消耗字母数字组成的字符串： 123456789101112// Consume and discard zero or more whitespace characters.fn consume_whitespace(&amp;mut self) { self.consume_while(CharExt::is_whitespace);}// Parse a tag or attribute name.fn parse_tag_name(&amp;mut self) -&gt; String { self.consume_while(|c| match c { 'a'...'z' | 'A'...'Z' | '0'...'9' =&gt; true, _ =&gt; false })} 现在我们已做好准备开始解析HTML。解析一个独立的节点，我们先看它的第一个字符，可以区分这是一个元素（element）还是文本节点（text node）。在我们HTML的简化版本，一个文本节点可以包含非 &lt; 的任何字符。 123456789101112// Parse a single node.fn parse_node(&amp;mut self) -&gt; dom::Node { match self.next_char() { '&lt;' =&gt; self.parse_element(), _ =&gt; self.parse_text() }}// Parse a text node.fn parse_text(&amp;mut self) -&gt; dom::Node { dom::text(self.consume_while(|c| c != '&lt;'))} 元素（element）则会更复杂一些。它包含开始和结束标签，以及标签之间的若干个子节点： 12345678910111213141516171819// Parse a single element, including its open tag, contents, and closing tag.fn parse_element(&amp;mut self) -&gt; dom::Node { // Opening tag. assert!(self.consume_char() == '&lt;'); let tag_name = self.parse_tag_name(); let attrs = self.parse_attributes(); assert!(self.consume_char() == '&gt;'); // Contents. let children = self.parse_nodes(); // Closing tag. assert!(self.consume_char() == '&lt;'); assert!(self.consume_char() == '/'); assert!(self.parse_tag_name() == tag_name); assert!(self.consume_char() == '&gt;'); return dom::elem(tag_name, attrs, children);} 在我们的简化语法，解析属性则是相对的简单。直到我们到达开始标签（&gt;）的末尾，我们反复查找名称，后跟=，然后是用引号引起来的字符串。 123456789101112131415161718192021222324252627282930// Parse a single name=&quot;value&quot; pair.fn parse_attr(&amp;mut self) -&gt; (String, String) { let name = self.parse_tag_name(); assert!(self.consume_char() == '='); let value = self.parse_attr_value(); return (name, value);}// Parse a quoted value.fn parse_attr_value(&amp;mut self) -&gt; String { let open_quote = self.consume_char(); assert!(open_quote == '&quot;' || open_quote == '\\''); let value = self.consume_while(|c| c != open_quote); assert!(self.consume_char() == open_quote); return value;}// Parse a list of name=&quot;value&quot; pairs, separated by whitespace.fn parse_attributes(&amp;mut self) -&gt; dom::AttrMap { let mut attributes = HashMap::new(); loop { self.consume_whitespace(); if self.next_char() == '&gt;' { break; } let (name, value) = self.parse_attr(); attributes.insert(name, value); } return attributes;} 解析子节点，我们可以递归地调用 parse_node 在循环里，直到我们遇到结束标签。这个方法返回一个 Vec，是 Rust 的自增长数组。 123456789101112// Parse a sequence of sibling nodes.fn parse_nodes(&amp;mut self) -&gt; Vec&lt;dom::Node&gt; { let mut nodes = Vec::new(); loop { self.consume_whitespace(); if self.eof() || self.starts_with(&quot;&lt;/&quot;) { break; } nodes.push(self.parse_node()); } return nodes;} 最好，我们将以上的所有代码整合一起，就可以将完整的HTML文档解析成DOM树了。这个函数将会未包含根节点的文档创建根节点。这类似于真正的HTML解析器所做的。 1234567891011// Parse an HTML document and return the root element.pub fn parse(source: String) -&gt; dom::Node { let mut nodes = Parser { pos: 0, input: source }.parse_nodes(); // If the document contains a root element, just return it. Otherwise, create one. if nodes.len() == 1 { nodes.swap_remove(0) } else { dom::elem(&quot;html&quot;.to_string(), HashMap::new(), nodes) }} 以上是 robinson HTML parser 的完整代码！整个过程仅包含100多行代码（不包含空行和注释）。如果你使用好的库 或 解析器生成器，你可以使用更少的空间实现类似的玩具解析器。","link":"/blog/2020/01/23/browser/how-broswers-work-2/"},{"title":"手把手教你实现一个浏览器引擎（三）CSS","text":"第三部分：CSS这是关于构建玩具浏览器渲染引擎的系列文章中的第三篇。想要构建你自己的吗？从开始的文章了解更多吧： 第一部分：起步 第二部分：HTML 本文介绍如何关于如何读取并解析 层叠样式表（Cascading Style Sheets，缩写为 CSS）的代码。和往常一样，我不会尝试去涵盖规范中的所有内容。取而代之的是，我会尝试实现这样一个渲染引擎：足以说明一些概念，并为渲染流程的后续阶段提供输入。 解剖样式这是CSS源代码的示例： 123h1, h2, h3 { margin: auto; color: #cc0000; }div.note { margin-bottom: 20px; padding: 10px; }#answer { display: none; } 接下来，我将通过我的玩具渲染引擎 Robinson 来详细介绍 css module。代码是由 Rust 编写的，尽管这些概念可以轻松地转换成其他编程语言。先阅读前面的文章会帮助你更好理解下面的代码。 CSS样式表是一系列的规则（上面的示例，每一行包含一条规则） 123struct Stylesheet { rules: Vec&lt;Rule&gt;,} 一个规则包含一个或多个选择器（由逗号隔开）。后跟着一系列由大括号括起来的声明（declaration） 1234struct Rule { selectors: Vec&lt;Selector&gt;, declarations: Vec&lt;Declaration&gt;,} 选择器可以是简单选择器，也可以是通过组合器连接的选择器链。Robinson 目前只支持简单选择器。 令人困惑的是，在较新的 Selectors Level3 标准中，使用了相同的术语表示稍有不同的东西。本文将主要参考 CSS2.1。尽管内容有些过时，但这是一个有用的起点，因为这更小且更独立（与CSS3相比，CSS3分为无数的规范，这些规范和CSS2.1各自相互依赖） 在 Robinson，一个简单选择器可以包括一个标签名，一个带有 # 前缀的ID，任何以 . 为前缀的类名，或者以上的一些组合。如果标签名为空或者是 *，这是一个“通用选择器”，意味着将匹配所有标签。 还有很多其他类型的选择器（特别是CSS3），不过现在这就可以了。 123456789enum Selector { Simple(SimpleSelector),}struct SimpleSelector { tag_name: Option&lt;String&gt;, id: Option&lt;String&gt;, class: Vec&lt;String&gt;,} 声明（declaration）是一个键值对，由冒号隔开，以分号结尾。举个例子：margin: auto;就是一个声明。 1234struct Declaration { name: String, value: Value,} 我的玩具引擎只支持CSS众多的值类型（value types）的少数。 123456789101112131415161718enum Value { Keyword(String), Length(f32, Unit), ColorValue(Color), // insert more values here}enum Unit { Px, // insert more units here}struct Color { r: u8, g: u8, b: u8, a: u8,} Rust提示：u8是一个8位的无符号整型，而 f32 则是 32位浮点型。 其他的所有语法都不支持。包括 @规则，注释，其他上面没提到的选择器，值，单位。 解析CSS具有常规的语法，相比起怪异的HTML更易于正确解析。一个符合标准的CSS解析器，遇到解析错误时，会丢弃样式表中不可识别的部分，然后继续处理剩余的部分。这很有用，因为它允许样式表包含新的语法，但仍在较旧的浏览器中产生定义良好的输出。 Robinson 使用了一个简化的（完全不符合标准的）解析器，和第二部分的HTML解析器构建方式相同。我将不再粘贴所有内容，而只是粘贴一些代码片段。例如，下面是解析单个选择器的代码： 12345678910111213141516171819202122232425// Parse one simple selector, e.g.: `type#id.class1.class2.class3`fn parse_simple_selector(&amp;mut self) -&gt; SimpleSelector { let mut selector = SimpleSelector { tag_name: None, id: None, class: Vec::new() }; while !self.eof() { match self.next_char() { '#' =&gt; { self.consume_char(); selector.id = Some(self.parse_identifier()); } '.' =&gt; { self.consume_char(); selector.class.push(self.parse_identifier()); } '*' =&gt; { // universal selector self.consume_char(); } c if valid_identifier_char(c) =&gt; { selector.tag_name = Some(self.parse_identifier()); } _ =&gt; break } } return selector;} 需要注意的时，这缺少了错误检查。一些类似 ### 或者 *foo* 的错误输入都会被成功解析，然后输出奇怪的结果。一个真正的CSS解析器将会忽略这些无效的选择器。 明确性 Specificity明确性是渲染引擎在样式冲突时，决定哪个覆盖哪个的一种方式。 如果一个样式表中两个规则匹配同一个元素，那么具有较高明确性（high specificity)的匹配选择器的规则可以覆盖具有较低明确性的规则的值。 选择器的明确性取决于其组成部分。ID选择器比class选择器更明确，而class选择器比tag选择器更明确。重点是，选择器越多越明确。 123456789101112pub type Specificity = (usize, usize, usize);impl Selector { pub fn specificity(&amp;self) -&gt; Specificity { // http://www.w3.org/TR/selectors/#specificity let Selector::Simple(ref simple) = *self; let a = simple.id.iter().count(); let b = simple.class.len(); let c = simple.tag_name.iter().count(); (a, b, c) }} （如果我们支持链式选择器，我们可以通过将各个部分的明确性相加来计算一条链式选择器的明确性） 每个规则的选择器都存储在有序的数组（译者注：原文为vector，vector在rust表示自增长的数组）中，最具体的放前面。这对于匹配非常重要，我将在下一篇文章介绍。 123456789101112131415161718192021222324// Parse a rule set: `&lt;selectors&gt; { &lt;declarations&gt; }`.fn parse_rule(&amp;mut self) -&gt; Rule { Rule { selectors: self.parse_selectors(), declarations: self.parse_declarations() }}// Parse a comma-separated list of selectors.fn parse_selectors(&amp;mut self) -&gt; Vec&lt;Selector&gt; { let mut selectors = Vec::new(); loop { selectors.push(Selector::Simple(self.parse_simple_selector())); self.consume_whitespace(); match self.next_char() { ',' =&gt; { self.consume_char(); self.consume_whitespace(); } '{' =&gt; break, // start of declarations c =&gt; panic!(&quot;Unexpected character {} in selector list&quot;, c) } } // Return selectors with highest specificity first, for use in matching. selectors.sort_by(|a,b| b.specificity().cmp(&amp;a.specificity())); return selectors;} CSS解析器的剩余部分是相当的直截了当的了。你可以在 GitHub 上看到完整的代码。如果你还没有阅读 系列文章第二部分，这是一个很好的机会去尝试做一个分析程序生成器（parser generator）。我的手动（译者注：原文为hand-rolled，想表达的意思是作者的解析器是不完善的，只能手动读取文件）解析器可以完成简单文件的解析工作，但是如果你违反了其中的假设，那么将会有很多棘手的地方，且会运行失败。总有一天，我可能会用内置在 rust-peg的东西 或者 类似的东西替换它。 原文链接：https://limpet.net/mbrubeck/2014/08/13/toy-layout-engine-3-css.html","link":"/blog/2020/02/10/browser/how-broswers-work-3/"},{"title":"手把手教你实现一个浏览器引擎（四）Style","text":"第四部分 Style欢迎回到关于构建你自己的玩具浏览器引擎的系列文章。如果你是刚开始收看文章，你可以从下面找到以前的文章： 第一部分：起步 第二部分：HTML 第三部分：CSS 本文将会介绍在CSS标准中所谓的 分配属性值(assigning vproperty values) 或者 样式模块(style module)。这个模块将拿DOM节点和CSS规则作为输入，将他们互相匹配，为所给的所有节点确定每个CSS属性的值。 这部分不会包含很多代码，因为我还没有实现相对复杂的部分。然而，我觉得剩下的仍然相当有趣，我还会解释如何实现一些缺失的部分。 样式树 The Style Tree我将Robinson的样式模块的输出称为 **样式树(style tree)**， 在树里的每个节点都指向一个DOM节点，加上它的CSS属性值： 123456789// Map from CSS property names to values.type PropertyMap = HashMap&lt;String, Value&gt;;// A node with associated style data.struct StyledNode&lt;'a&gt; { node: &amp;'a Node, // pointer to a DOM node specified_values: PropertyMap, children: Vec&lt;StyledNode&lt;'a&gt;&gt;,} 'a是什么意思呢？这是都是生命周期，是Rust保证指针是内存安全的且不需要进行垃圾收集的一部分。如果你不是使用Rust工作的话，你可以忽略他们。他们对代码的意义影响不是很大。 其实，我们可以给dom:Node的结构增加字段，而不是创建一个新的树。但是我想抱着样式的代码和之前的“课程”相对独立。这也是给了我一个机会讲一下在大部分渲染引擎都会出现的 平行树(parallel trees) 浏览器引擎模块经常会将一个树当做输入，然后输出一个不同但是相关的树 。比如，Gecko的 布局代码(layout code) 利用 DOM树 生成 **框架树(frame tree)**，然后将用于构建 **视图树(view tree)**。Blink 和 WebKit 将 DOM树 转换成 **渲染树(render tree)**。在这些引擎的后面阶段还会生成很多树，包括 层级树(layer tree) 和 **部件树(widget tree)**。 在完成其他几个阶段之后，我们的玩具浏览器引擎的流水线(pipeline)将会看起来像是这样： 在我的实现方式里，DOM树里的每个节点在样式树里都只有一个节点。但是在更复杂的流水线阶段，几个输入的节点可能会合并成一个输出节点。或者，一个输入节点可能会扩展为多个输出节点，或者被完全跳过。例如，样式树可能移除一个display属性设置成none的元素。（相反，我将在布局阶段移除这些，因为我的代码反而比较简单） 匹配选择器 Selector Matching构建 样式树(style tree) 的第一步就是匹配选择器。因为我的CSS解析器只支持简单选择器，因此这将是很简单。可以通过查看元素本身来判断简单选择器是否与元素匹配。匹配复合选择器则需要遍历整个DOM树来查看元素的 兄弟元素(siblings)，父元素(parents) 等等。 12345fn matches(elem: &amp;ElementData, selector: &amp;Selector) -&gt; bool { match *selector { Simple(ref simple_selector) =&gt; matches_simple_selector(elem, simple_selector) }} 为了提供帮助，我们将给我们的 DOM元素类型 增加一些遍历的ID和class访问器。class属性可以包含多个用空格分隔的类名，最后将这些类名通过哈希表的形式返回。 123456789101112impl ElementData { pub fn id(&amp;self) -&gt; Option&lt;&amp;String&gt; { self.attributes.get(&quot;id&quot;) } pub fn classes(&amp;self) -&gt; HashSet&lt;&amp;str&gt; { match self.attributes.get(&quot;class&quot;) { Some(classlist) =&gt; classlist.split(' ').collect(), None =&gt; HashSet::new() } }} 要测试一个简单选择器是否匹配了元素，只需要查看每个选择器的 组件(component) ，如果一个元素没有一个匹配上的class，ID或者标签名就返回false 1234567891011121314151617181920fn matches_simple_selector(elem: &amp;ElementData, selector: &amp;SimpleSelector) -&gt; bool { // Check type selector if selector.tag_name.iter().any(|name| elem.tag_name != *name) { return false; } // Check ID selector if selector.id.iter().any(|id| elem.id() != Some(id)) { return false; } // Check class selectors let elem_classes = elem.classes(); if selector.class.iter().any(|class| !elem_classes.contains(&amp;**class)) { return false; } // We didn't find any non-matching selector components. return true;} Rust笔记：这个函数使用any这个方法，如果迭代器包含一个可以通过提供的测试函数的元素则返回true。类似于 Python 或者 Haskell 里的 any 函数，JavaScript 里的 some 方法 构建样式树 Build the Style Tree接下来，我们需要遍历整个DOM树，对于树中的每个元素，我们将在样式表中搜索匹配的规则。 比较两个匹配相同元素的规则时，我们需要使用每个匹配项中 最高明确性(highest specificity) 的选择器。因为我们CSS解析器储存的选择器是按明确性从高往低排序的，所以我们可以在找到匹配的选择器后立即停止，然后返回其明确性以及规则的指针。 123456789type MatchedRule&lt;'a&gt; = (Specificity, &amp;'a Rule);// If `rule` matches `elem`, return a `MatchedRule`. Otherwise return `None`.fn match_rule&lt;'a&gt;(elem: &amp;ElementData, rule: &amp;'a Rule) -&gt; Option&lt;MatchedRule&lt;'a&gt;&gt; { // Find the first (highest-specificity) matching selector. rule.selectors.iter() .find(|selector| matches(elem, *selector)) .map(|selector| (selector.specificity(), rule))} 为了找到与某个元素匹配的所有规则，我们调用filter_map方法，它可以线性扫描整个样式表，检查每个规则并丢弃不匹配的规则。真正的浏览器引擎会通过基于标签名，ID，class等将规则存储在多个哈希表，从而实现快速匹配。 1234// Find all CSS rules that match the given element.fn matching_rules&lt;'a&gt;(elem: &amp;ElementData, stylesheet: &amp;'a Stylesheet) -&gt; Vec&lt;MatchedRule&lt;'a&gt;&gt; { stylesheet.rules.iter().filter_map(|rule| match_rule(elem, rule)).collect()} 一旦有了匹配的规则，我们就可以找到元素的 **指定值(specified value)**。将每个规则的属性值插入到HashMap。将规则按 明确性(specificity) 排序，这样较高明确性的规则会在较低的之后进行处理，可以在HashMap将它们的值覆盖。 1234567891011121314// Apply styles to a single element, returning the specified values.fn specified_values(elem: &amp;ElementData, stylesheet: &amp;Stylesheet) -&gt; PropertyMap { let mut values = HashMap::new(); let mut rules = matching_rules(elem, stylesheet); // Go through the rules from lowest to highest specificity. rules.sort_by(|&amp;(a, _), &amp;(b, _)| a.cmp(&amp;b)); for (_, rule) in rules { for declaration in &amp;rule.declarations { values.insert(declaration.name.clone(), declaration.value.clone()); } } return values;} 现在我们拥有了遍历DOM树并构建样式树所需的一切。需要注意的是，选择器匹配仅适用于元素，因此文本节点的指定值只是一个空的map 1234567891011// Apply a stylesheet to an entire DOM tree, returning a StyledNode tree.pub fn style_tree&lt;'a&gt;(root: &amp;'a Node, stylesheet: &amp;'a Stylesheet) -&gt; StyledNode&lt;'a&gt; { StyledNode { node: root, specified_values: match root.node_type { Element(ref elem) =&gt; specified_values(elem, stylesheet), Text(_) =&gt; HashMap::new() }, children: root.children.iter().map(|child| style_tree(child, stylesheet)).collect(), }} 以上是Robinson关于构建样式树的所有代码。接下来，我将谈论一些明显的遗漏。 层叠 Cascade由网页作者提供的样式表称为 **作者样式表(author stlye sheets)**，除此之外，浏览器还通过 用户代理样式表(user agent style sheets) 提供了默认样式。还有它可以允许用户通过 用户样式表(user style sheets) 添加自定义样式（比如 Gecko 的 userContent.css）。 层叠(cascade) 定义了这三个“数据源”哪个优先权更高。层叠有六个级别：每个数据源都有”普通(normal)“声明，加上每个数据源还有!important声明。 Robinson的样式代码没有实现层叠的功能。它仅读取一个样式表。缺少默认样式表意味着HTML元素不会有你预期的任何默认样式。例如：&lt;head&gt;元素的内容不会被隐藏，除非你明确在你的样式表中添加这个规则： 1head { display: none } 实现层叠应该相当容易：只需跟踪每条规则的起源，并根据明确性排序，其中明确性要加入数据源和重要性这些权重。一个简化的两级层叠应该足以支持最常见的情况：普通用户代理样式 和 普通作者样式。 计算值 Computed Values除了上述提到的“指定值(sepecified values)”之外，CSS还定义了 初始值(initial values)，计算值(computed values)，使用值(used values) 和 **实际值(actual values)**。CSS标准链接 初始值是层叠中没有指定的属性默认值。计算值则是基于指定值的，但可能会应用一些特定属性的规范化规则。 根据CSS规范的定义，正确实现这些属性需要为每个属性使用的单独的代码。这是现实浏览器引擎的必要工作，但希望在我的玩具项目中避免这些。在后面阶段，在缺少指定值的时候，使用这些值的代码会（通过某种方式）使用默认值来模拟初始值。 使用值 和 实际值则是在布局期间和布局之后计算的，我将在以后的文章中介绍。 继承 Inheritance如果文本节点不匹配任何选择器，那么它如何得到颜色和字体和其他样式呢？答案就是 继承(inheritance)。 继承属性后，没有层叠值(cascaded value)的任何节点都将收到该属性的父元素的值。默认情况下，某些属性（如颜色）都是继承过来的；其他的属性只有在层叠值指定特殊值inherit时才会继承父元素。 我的代码没有支持继承。要实现这个，可以将父元素的样式数据传入specified_values函数，并使用硬编码的查找表来决定应继承哪些属性。 样式属性 Style Attributes任何HTML元素都可以包括一个style属性，其中包含一系列的CSS声明。它们没有选择器，因为这些声明自动应用到这个元素本身。 1&lt;span style=&quot;color: red; background: yellow;&quot;&gt; 如果你想支持style属性，让specified_values函数检查属性即可。如果存在该属性，则将它从CSS解析器传入parse_declarations。由于这些属性比任何CSS选择器都更明确，因此在在 普通作者声明(normal author declarations) 之后应用这些 **结果声明(resulting declarations)**。 原文链接：https://limpet.net/mbrubeck/2014/08/23/toy-layout-engine-4-style.html","link":"/blog/2020/02/12/browser/how-broswers-work-4/"},{"title":"手把手教你实现一个浏览器引擎（五）Boxes","text":"第五部分：Boxes这是关于编写一个简单HTML渲染引擎系列文章的最后一篇（译者注：后续两篇是对这部分内容的补充）： 第一部分：起步 第二部分：HTML 第三部分：CSS 第四部分：Style 这篇文章将开始讨论 布局(layout) 模块，它将输入的样式树，转换成二维空间的一堆矩形。这是一个庞大的模块，因此我将它拆分成多篇文章。另外，我为后面部分内容写代码时，可能会改动这篇文章分享的一些代码。 布局模块的输入是来自 第四部分 的样式树，输出的是其他的树——**布局树(layout tree)**。这让我们的迷你渲染流程向前迈进了一步： 我将从基础的HTML/CSS布局模型开始讲起。如果你曾经学过开发网页，则可能已经对这些比较熟悉——不过它可能和开发者的视角不太一样。 盒模型 The Box Model布局与 盒子(boxes) 有关。盒子是网页的矩形部分。它有 **宽度(width)，高度(height)**，和在页面上的 **位置(position)**。这个矩形被称为 内容区域(content area) ，因为它是盒子内容绘制的位置。内容可能是文本，图片，视频或者其他盒子。 盒子可能也有 内边距(padding)，边框(borders)，外边距(margins) 围绕着它的内容区域。CSS规范有一张 例图 展示了所有这些层是如何组合在一起的。 Robinson使用以下的结构来存储盒子的内容区域和周围区域。 Rust笔记：f32是32位浮点类型。 12345678910111213141516171819202122232425// CSS box model. All sizes are in px.struct Dimensions { // Position of the content area relative to the document origin: content: Rect, // Surrounding edges: padding: EdgeSizes, border: EdgeSizes, margin: EdgeSizes,}struct Rect { x: f32, y: f32, width: f32, height: f32,}struct EdgeSizes { left: f32, right: f32, top: f32, bottom: f32,} 块和内联布局 Block and Inline LayoutCSS的display属性决定元素生成哪种类型的盒子。CSS定义了多种盒类型，各自有自己的布局规则。我只打算介绍其中两种：块(block) 和 **内联(inline)**。 我使用伪HTML来说明两者的差别： 123456&lt;container&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;c&gt;&lt;/c&gt; &lt;d&gt;&lt;/d&gt;&lt;/container&gt; 块状盒子(Block boxes) 自上而下垂直地在他们的容器内排列。 1a, b, c, d { display: block; } 内联盒子(inline boxes) 自左向右水平地在他们的容器里排列。如果他们触碰到容器的右边缘，将会环绕着容器，并继续在下面起新的一行排列。 1a, b, c, d { display: inline; } 每个盒子只能包含 **块级子元素(block children)**，或者 **内联子元素(inline children)**。当一个DOM元素包含了混合块级子元素和内联子元素时，布局引擎插入一个 匿名盒子(anonymous boxes) 去分隔两种类型。（这些盒子是“匿名的”，因为他们与DOM树种的节点没有关联） 在这个例子中，内联盒子 b 和 c 被一个匿名块状盒子围绕着，用粉色显示： 123a { display: block; }b, c { display: inline; }d { display: block; } 注意，默认情况下内容是纵向增长的。也就是说，添加子元素到容器内，通常使其变得更高，而不是更宽。换句话说，一块或者一行的宽度是依赖它们容器的宽度，而容器的高度则依赖子元素的高度。 如果你覆盖了例如width和height属性的默认值的话，情况将变得更加复杂。如果要支持垂直书写这样的特性的话，则情况会更加复杂。 布局树 The Layout Tree布局树是盒子的集合。盒子有尺寸，并且可能包含 **子盒子(child boxes)**。 12345struct LayoutBox&lt;'a&gt; { dimensions: Dimensions, box_type: BoxType&lt;'a&gt;, children: Vec&lt;LayoutBox&lt;'a&gt;&gt;,} 盒子可以是一个块级节点，一个内联节点，或者是一个匿名块状盒子（如果我实现文本布局，这个将需要改变，因为换行会导致单个内联节点拆分为多个盒子。不过目前这样也是可以的） 12345enum BoxType&lt;'a&gt; { BlockNode(&amp;'a StyledNode&lt;'a&gt;), InlineNode(&amp;'a StyledNode&lt;'a&gt;), AnonymousBlock,} 构建布局树，我们需要查看每个DOM节点的display属性。为了获得节点的display的值，我在style模块添加了一些代码。如果没有指定的值，则返回默认值inline。 123456789101112131415161718192021222324enum Display { Inline, Block, None,}impl StyledNode { // Return the specified value of a property if it exists, otherwise `None`. fn value(&amp;self, name: &amp;str) -&gt; Option&lt;Value&gt; { self.specified_values.get(name).map(|v| v.clone()) } // The value of the `display` property (defaults to inline). fn display(&amp;self) -&gt; Display { match self.value(&quot;display&quot;) { Some(Keyword(s)) =&gt; match &amp;*s { &quot;block&quot; =&gt; Display::Block, &quot;none&quot; =&gt; Display::None, _ =&gt; Display::Inline }, _ =&gt; Display::Inline } }} 现在我们可以遍历样式树，为每个节点构建一个LayoutBox，然后为改节点的子级插入盒子。如果一个节点的display属性设置成none，那么它将不会被包含在布局树里。 12345678910111213141516171819202122232425262728293031// Build the tree of LayoutBoxes, but don't perform any layout calculations yet.fn build_layout_tree&lt;'a&gt;(style_node: &amp;'a StyledNode&lt;'a&gt;) -&gt; LayoutBox&lt;'a&gt; { // Create the root box. let mut root = LayoutBox::new(match style_node.display() { Block =&gt; BlockNode(style_node), Inline =&gt; InlineNode(style_node), DisplayNone =&gt; panic!(&quot;Root node has display: none.&quot;) }); // Create the descendant boxes. for child in &amp;style_node.children { match child.display() { Block =&gt; root.children.push(build_layout_tree(child)), Inline =&gt; root.get_inline_container().children.push(build_layout_tree(child)), DisplayNone =&gt; {} // Skip nodes with `display: none;` } } return root;}impl LayoutBox { // Constructor function fn new(box_type: BoxType) -&gt; LayoutBox { LayoutBox { box_type: box_type, dimensions: Default::default(), // initially set all fields to 0.0 children: Vec::new(), } } // ...} 如果一个块级节点包含一个内联子级，创建一个匿名块级盒子去包含它。如果有多个内联子级在同一行，那么将他们都放在同一个匿名容器里。 123456789101112131415// Where a new inline child should go.fn get_inline_container(&amp;mut self) -&gt; &amp;mut LayoutBox { match self.box_type { InlineNode(_) | AnonymousBlock =&gt; self, BlockNode(_) =&gt; { // If we've just generated an anonymous block box, keep using it. // Otherwise, create a new one. match self.children.last() { Some(&amp;LayoutBox { box_type: AnonymousBlock,..}) =&gt; {} _ =&gt; self.children.push(LayoutBox::new(AnonymousBlock)) } self.children.last_mut().unwrap() } }} 以上是从标准CSS 盒子生成(box generation) 算法刻意通过多种方式简化后的版本。例如，这版本无法处理一个内联盒子包含块级子级的情况。还有，如果一个块级节点仅有一个内联子级，这会生成一个不必要的匿名盒子。 原文链接：https://limpet.net/mbrubeck/2014/09/08/toy-layout-engine-5-boxes.html","link":"/blog/2020/02/19/browser/how-broswers-work-5/"},{"title":"手把手教你实现一个浏览器引擎（六）Block Layout","text":"第六部分：Block layout欢迎回到我的关于构建玩具HTML渲染引擎的系列文章： 第一部分：起步 第二部分：HTML 第三部分：CSS 第四部分：Style 第五部分：Boxes 本文将继续讨论我们在第五部分开始讨论的布局模块。此时，我们将增添布局块状盒子的能力。例如标题和段落这些都是垂直堆叠的盒子。 为简单起见，此代码仅实现正常流(normal flow)：没有浮动(floats)，没有绝对定位(absolute positioning)，也没有固定定位(fixed positioning)。 遍历布局树 Traversing the Layout Tree代码的入口是layout函数，它利用LayoutBox来计算它的尺寸。我将这个函数拆分三种情况，然后目前只实现其中的一种： 123456789101112impl LayoutBox { // Lay out a box and its descendants. fn layout(&amp;mut self, containing_block: Dimensions) { match self.box_type { BlockNode(_) =&gt; self.layout_block(containing_block), InlineNode(_) =&gt; {} // TODO AnonymousBlock =&gt; {} // TODO } } // ...} 块(block) 的布局取决于其 包含块(containing block) 的尺寸。对于正常流的块级盒子，这就是盒子的父级。对于根元素来说，就是浏览器窗口（或者视图）的大小了。 你应该记得上篇文章说过，块(block) 的宽度取决于它的父级，而它的高度则取决于子级。这意味着我们的代码需要自上而下地遍历树来计算宽度，这样才可以在知道父级的宽度之后布局子级。接着要自下而上遍历树来计算高度，这样计算完子级的高度就自然可以得到父级的高度。 123456789101112131415fn layout_block(&amp;mut self, containing_block: Dimensions) { // Child width can depend on parent width, so we need to calculate // this box's width before laying out its children. self.calculate_block_width(containing_block); // Determine where the box is located within its container. self.calculate_block_position(containing_block); // Recursively lay out the children of this box. self.layout_block_children(); // Parent height can depend on child height, so `calculate_height` // must be called *after* the children are laid out. self.calculate_block_height();} 这个函数执行了布局树的单个遍历，通过向下的路径计算宽度，向上的路径来计算高度。一个真正的布局引擎可能会执行多次树的遍历，有时自上而下，有时自下向上。 计算宽度 Calculating the width块的布局函数的第一步就是计算宽度，也是最复杂的步骤。我将逐步介绍。首先，我们需要CSS的width属性的值和所有左右边缘的大小： 123456789101112131415161718192021fn calculate_block_width(&amp;mut self, containing_block: Dimensions) { let style = self.get_style_node(); // `width` has initial value `auto`. let auto = Keyword(&quot;auto&quot;.to_string()); let mut width = style.value(&quot;width&quot;).unwrap_or(auto.clone()); // margin, border, and padding have initial value 0. let zero = Length(0.0, Px); let mut margin_left = style.lookup(&quot;margin-left&quot;, &quot;margin&quot;, &amp;zero); let mut margin_right = style.lookup(&quot;margin-right&quot;, &quot;margin&quot;, &amp;zero); let border_left = style.lookup(&quot;border-left-width&quot;, &quot;border-width&quot;, &amp;zero); let border_right = style.lookup(&quot;border-right-width&quot;, &quot;border-width&quot;, &amp;zero); let padding_left = style.lookup(&quot;padding-left&quot;, &quot;padding&quot;, &amp;zero); let padding_right = style.lookup(&quot;padding-right&quot;, &quot;padding&quot;, &amp;zero); // ...} 这使用了一个名为lookup的辅助函数，该函数仅按顺序尝试一系列的值。如果第一个属性没设置，它会尝试第二个属性。如果都没有设置，它会返回所设置的默认值。这里提供了一个不完善（但是简单）的 快捷属性(shorthand properties) 和 初始值(initial values) 的实现版本。 Rust笔记：下面的代码和JavaScript或者Ruby类似 1margin_left = style[&quot;margin-left&quot;] || style[&quot;margin&quot;] || zero; 由于子级无法改变父级的宽度，因此需要确保自己的宽度适合父级的宽度。CSS规范将其表示为一组约束和求解约束的算法。以下代码实现了该算法。 首先我们将margin，padding，border和内容宽度加在一起。to_px辅助函数将长度转换成他们的数值。如果属性设置为auto，则返回0，因此它无法影响总数。 12let total = [&amp;margin_left, &amp;margin_right, &amp;border_left, &amp;border_right, &amp;padding_left, &amp;padding_right, &amp;width].iter().map(|v| v.to_px()).sum(); 这就是盒子需要的最小水平空间。如果他和容器的宽度不相等，那我们需要做些调整使其相等。 如果width或者margins设置成auto，他们可以扩展或者收缩以适应可用的空间。根据规范，我们首先要检查盒子是否太大。如果太大，我们将所有可扩展的margins设置为0。 123456789// If width is not auto and the total is wider than the container, treat auto margins as 0.if width != auto &amp;&amp; total &gt; containing_block.content.width { if margin_left == auto { margin_left = Length(0.0, Px); } if margin_right == auto { margin_right = Length(0.0, Px); }} 如果盒子比容器还大。它就 溢出(overflow) 了容器。如果他太小，他将 **下溢(underflow)**，留下额外的空间。我们将计算下溢量——容器中剩余的额外空间量。（如果数字为负数，实际上是一个溢出） 1let underflow = containing_block.content.width - total; 现在我们依照规范的算法，通过调整可扩展的尺寸来消除任何溢出或下溢。如果没有auto的尺寸，我们就调整右边的margin（是的，这意味着溢出时margin可能为负值） 12345678910111213141516171819202122232425262728293031match (width == auto, margin_left == auto, margin_right == auto) { // If the values are overconstrained, calculate margin_right. (false, false, false) =&gt; { margin_right = Length(margin_right.to_px() + underflow, Px); } // If exactly one size is auto, its used value follows from the equality. (false, false, true) =&gt; { margin_right = Length(underflow, Px); } (false, true, false) =&gt; { margin_left = Length(underflow, Px); } // If width is set to auto, any other auto values become 0. (true, _, _) =&gt; { if margin_left == auto { margin_left = Length(0.0, Px); } if margin_right == auto { margin_right = Length(0.0, Px); } if underflow &gt;= 0.0 { // Expand width to fill the underflow. width = Length(underflow, Px); } else { // Width can't be negative. Adjust the right margin instead. width = Length(0.0, Px); margin_right = Length(margin_right.to_px() + underflow, Px); } } // If margin-left and margin-right are both auto, their used values are equal. (false, true, true) =&gt; { margin_left = Length(underflow / 2.0, Px); margin_right = Length(underflow / 2.0, Px); }} 至此，约束已得到解决，并且所有auto的值都被转换成长度。结果就是盒子水平尺寸的 **使用值(used values)**，我们将它存储在 **布局树(layout tree)**。你可以在 layout.rs 看到最终的代码。 定位 Positioning下个步骤相对比较简单。这个函数查找剩余的margin/padding/border样式，然后使用它们和 包含块(containing block) 的尺寸决定这个块在页面的位置。 123456789101112131415161718192021222324fn calculate_block_position(&amp;mut self, containing_block: Dimensions) { let style = self.get_style_node(); let d = &amp;mut self.dimensions; // margin, border, and padding have initial value 0. let zero = Length(0.0, Px); // If margin-top or margin-bottom is `auto`, the used value is zero. d.margin.top = style.lookup(&quot;margin-top&quot;, &quot;margin&quot;, &amp;zero).to_px(); d.margin.bottom = style.lookup(&quot;margin-bottom&quot;, &quot;margin&quot;, &amp;zero).to_px(); d.border.top = style.lookup(&quot;border-top-width&quot;, &quot;border-width&quot;, &amp;zero).to_px(); d.border.bottom = style.lookup(&quot;border-bottom-width&quot;, &quot;border-width&quot;, &amp;zero).to_px(); d.padding.top = style.lookup(&quot;padding-top&quot;, &quot;padding&quot;, &amp;zero).to_px(); d.padding.bottom = style.lookup(&quot;padding-bottom&quot;, &quot;padding&quot;, &amp;zero).to_px(); d.content.x = containing_block.content.x + d.margin.left + d.border.left + d.padding.left; // Position the box below all the previous boxes in the container. d.content.y = containing_block.content.height + containing_block.content.y + d.margin.top + d.border.top + d.padding.top;} 仔细看最后的一条设置y位置的语句。这就是使 块布局(block layout) 具有独特的 垂直堆叠(vertical stacking) 行为的原因。为此，我们需要确保在对每个子级布局之后，更新父级的content.height。 子级 Child这是递归排列盒子内容的代码。当遍历子级盒子时，它会跟踪总内容的高度。这被计算定位（上述）的代码用来查找下个子级的 垂直位置(vertical position) 12345678fn layout_block_children(&amp;mut self) { let d = &amp;mut self.dimensions; for child in &amp;mut self.children { child.layout(*d); // Track the height so each child is laid out below the previous content. d.content.height = d.content.height + child.dimensions.margin_box().height; }} 每个子级占用的垂直空间总和就是它的margin box的高度。我们这样计算： 12345678910111213141516171819202122232425impl Dimensions { // The area covered by the content area plus its padding. fn padding_box(self) -&gt; Rect { self.content.expanded_by(self.padding) } // The area covered by the content area plus padding and borders. fn border_box(self) -&gt; Rect { self.padding_box().expanded_by(self.border) } // The area covered by the content area plus padding, borders, and margin. fn margin_box(self) -&gt; Rect { self.border_box().expanded_by(self.margin) }}impl Rect { fn expanded_by(self, edge: EdgeSizes) -&gt; Rect { Rect { x: self.x - edge.left, y: self.y - edge.top, width: self.width + edge.left + edge.right, height: self.height + edge.top + edge.bottom, } }} 为了简单起见，不实现 **外边距折叠(margin collapsing)**。一个真正的布局引擎会允许一个盒子的bottom margin和下个盒子的top magin重叠，而不是将每个margin box完全放在前一个的下方。 高度属性 The ‘height’ Property默认情况下，盒子的高度和它的内容高度相等。不过如果height属性设置了一个指定的长度，我们将改用它： 1234567fn calculate_block_height(&amp;mut self) { // If the height is set to an explicit length, use that exact length. // Otherwise, just keep the value set by `layout_block_children`. if let Some(Length(h, Px)) = self.get_style_node().value(&quot;height&quot;) { self.dimensions.content.height = h; }} 到此结束了块的布局算法。现在你可以在一个有样式的HTML文档上调用layout()，它将吐出一群具有宽度，高度，边距等等的矩形。这很酷，对吧？","link":"/blog/2020/02/20/browser/how-broswers-work-6/"},{"title":"手把手教你实现一个浏览器引擎（七）Paint","text":"第七部分：Painting 101欢迎回到我的关于构建玩具HTML渲染引擎的系列文章的最后一篇： 第一部分：起步 第二部分：HTML 第三部分：CSS 第四部分：Style 第五部分：Boxes 第六部分：Block layout 本文我将添加非常基础的绘制代码。此代码将布局模块生成的由盒子组成的树转换成一个像素数组。这个过程也被称为”栅格化“。 浏览器通常借助图形API和一些例如 Skia，Cairo，Direct2D 等等的库来实现栅格化。这些APIs提供函数来绘制多边形，线条，曲线，渐变色和文本。目前为止，我打算写我自己的栅格化工具，它只能绘制一种图形：矩形。 最终我想实现文本渲染。到那时，我可能会丢弃这个玩具绘制代码，并切换到一个”真正“的2D图形库。不过目前为止，矩形是足以将我的块布局算法的输出转换成图片。 追赶 Catching Up从上篇文章开始，我对以前的文章中的代码做了一些小的改变。其中包含一些小的重构，和一些更新，以保持代码和最新的Rust每晚构建版本兼容。这些改变对理解代码都不重要，不过如果你觉得困惑，可以查看下 提交历史 构建显示列表 Building the Display List开始绘制之前，我们要遍历布局树构建一个显示列表。这是一个例如”画一个圆圈“或”画一个文本字符串“的图形操作列表。或者在我们这个例子，就是”画一个矩形“。 为什么将这些命令放在一个显示列表而不是直接执行他们呢？显示列表之所以有用，有几个原因。你可以在其中搜索到被后续操作完全覆盖的项目，然后将他们移除来消除冗余的绘制。当你知道只有一个确定的项目被修改时，可以修改和重复使用这个显示列表。你可以使用相同的列表来生成不同类型的输出：例如，屏幕的显示，或者以矢量图的形式发送到打印机。 Robinson的显示列表是一个DisplayCommands的向量。目前只有一个类型的DisplayCommands，一个纯色的矩形。 123456type DisplayList = Vec&lt;DisplayCommand&gt;;enum DisplayCommand { SolidColor(Color, Rect), // insert more commands here} 为了构建显示列表，我们需要遍历布局树和为每个盒子生成一系列的命令。首先我们绘制盒子的背景，然后位置它的边框和背景上的内容。 123456789101112131415fn build_display_list(layout_root: &amp;LayoutBox) -&gt; DisplayList { let mut list = Vec::new(); render_layout_box(&amp;mut list, layout_root); return list;}fn render_layout_box(list: &amp;mut DisplayList, layout_box: &amp;LayoutBox) { render_background(list, layout_box); render_borders(list, layout_box); // TODO: render text for child in &amp;layout_box.children { render_layout_box(list, child); }} 默认情况下，HTML元素依照出现它们出现顺序来叠放的：如果两个元素重叠，后面的那个将绘制在前面那个上方。这反映到我们的显示列表中，该列表将按照于它们在DOM树种出现的顺序相同的顺序绘制元素。如果这代码支持 z-index 属性，则单个元素能够覆盖此堆叠顺序，并且我们需要相应地对显示列表进行排序。 背景比较简单。这仅仅是实心的矩形。如果没指定背景的颜色，那么背景是透明的，然后我们也就不需要生成一个显示命令了。 123456789101112131415fn render_background(list: &amp;mut DisplayList, layout_box: &amp;LayoutBox) { get_color(layout_box, &quot;background&quot;).map(|color| list.push(DisplayCommand::SolidColor(color, layout_box.dimensions.border_box())));}// Return the specified color for CSS property `name`, or None if no color was specified.fn get_color(layout_box: &amp;LayoutBox, name: &amp;str) -&gt; Option&lt;Color&gt; { match layout_box.box_type { BlockNode(style) | InlineNode(style) =&gt; match style.value(name) { Some(Value::ColorValue(color)) =&gt; Some(color), _ =&gt; None }, AnonymousBlock =&gt; None }} 边框也是类似的。不过我们绘制的不是一个矩形，而是四个——对应盒子的各个边缘。 1234567891011121314151617181920212223242526272829303132333435363738394041fn render_borders(list: &amp;mut DisplayList, layout_box: &amp;LayoutBox) { let color = match get_color(layout_box, &quot;border-color&quot;) { Some(color) =&gt; color, _ =&gt; return // bail out if no border-color is specified }; let d = &amp;layout_box.dimensions; let border_box = d.border_box(); // Left border list.push(DisplayCommand::SolidColor(color, Rect { x: border_box.x, y: border_box.y, width: d.border.left, height: border_box.height, })); // Right border list.push(DisplayCommand::SolidColor(color, Rect { x: border_box.x + border_box.width - d.border.right, y: border_box.y, width: d.border.right, height: border_box.height, })); // Top border list.push(DisplayCommand::SolidColor(color, Rect { x: border_box.x, y: border_box.y, width: border_box.width, height: d.border.top, })); // Bottom border list.push(DisplayCommand::SolidColor(color, Rect { x: border_box.x, y: border_box.y + border_box.height - d.border.bottom, width: border_box.width, height: d.border.bottom, }));} 接下来的渲染函数将绘制每个盒子的子级，直到整个布局树都被翻译成 **显示命令(display commands)**。 栅格化 Rasterization现在我们完成了显示列表的构建，我们需要执行每个DisplayCommand并将它转换成像素。我们将像素存储到 **画布(Canvas)**。 123456789101112131415161718struct Canvas { pixels: Vec&lt;Color&gt;, width: usize, height: usize,}impl Canvas { // Create a blank canvas fn new(width: usize, height: usize) -&gt; Canvas { let white = Color { r: 255, g: 255, b: 255, a: 255 }; return Canvas { pixels: repeat(white).take(width * height).collect(), width: width, height: height, } } // ...} 在画布上绘制矩形，我们只需要借助辅助函数来遍历其行和列，以确保我们不会超出画布边界。 123456789101112131415161718fn paint_item(&amp;mut self, item: &amp;DisplayCommand) { match item { &amp;DisplayCommand::SolidColor(color, rect) =&gt; { // Clip the rectangle to the canvas boundaries. let x0 = rect.x.clamp(0.0, self.width as f32) as usize; let y0 = rect.y.clamp(0.0, self.height as f32) as usize; let x1 = (rect.x + rect.width).clamp(0.0, self.width as f32) as usize; let y1 = (rect.y + rect.height).clamp(0.0, self.height as f32) as usize; for y in (y0 .. y1) { for x in (x0 .. x1) { // TODO: alpha compositing with existing pixel self.pixels[x + y * self.width] = color; } } } }} 现在这些代码能只绘制不透明的颜色。如果我们添加透明度（通过读取opacity属性，或者在CSS解析器增加支持rgba()值），然后它需要将每个新像素与它所绘制的内容混合。 现在我们可以将所有内容组合到paint函数中，来构建显示列表，然后将其格栅化成画布： 123456789// Paint a tree of LayoutBoxes to an array of pixels.fn paint(layout_root: &amp;LayoutBox, bounds: Rect) -&gt; Canvas { let display_list = build_display_list(layout_root); let mut canvas = Canvas::new(bounds.width as usize, bounds.height as usize); for item in display_list { canvas.paint_item(&amp;item); } return canvas;} 最后，我们可以写 几行代码，使用 Rust Image 库将像素数组另存为PNG文件。 漂亮的图片 Pretty Pictures最后，我们抵达了我们的渲染流程的尾部。在不到1000行代码里，Robinson现在可以解析这个HTML文件： 1234567891011121314&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt; &lt;div class=&quot;c&quot;&gt; &lt;div class=&quot;d&quot;&gt; &lt;div class=&quot;e&quot;&gt; &lt;div class=&quot;f&quot;&gt; &lt;div class=&quot;g&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 和这个CSS文件： 12345678* { display: block; padding: 12px; }.a { background: #ff0000; }.b { background: #ffa500; }.c { background: #ffff00; }.d { background: #008000; }.e { background: #0000ff; }.f { background: #4b0082; }.g { background: #800080; } 和生成这个：","link":"/blog/2020/02/21/browser/how-broswers-work-7/"},{"title":"iOS 软键盘弹出","text":"移动WEB开发经常要遇到控制软键盘：弹出键盘和收起键盘。 12345 // 弹出键盘 input.focus();// 收起键盘 input.blur(); 在Android上，弹出和收起都比较正常，在任何时候调用都行。在iOS则不一样，一定要有在用户有实际交互时马上(right now)调用focus或者blur才行。比如： 123btn.addEventListener('click', function(){ input.focus(); //弹出键盘}, false); 如果此时使用了setTimeout： 12345btn.addEventListener('click', function(){ setTimeout(function(){ input.focus(); //键盘是不会弹出的 }, 50);}, false); 或者此时我调用ajax请求再focus也是不会弹出来的 123456$.ajax({ //...}).then(function(){ input.focus(); //键盘是不会弹出的})","link":"/blog/2016/07/22/browser/mobile-web-soft-keyboard/"},{"title":"使用 Web Storage API","text":"其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。 说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。 MDN要探究Web API，首先就想到MDN。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！ 中英文版本的差异中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。 比如： 我们可以像访问对象一样来访问Storage 123localStorage.colorSetting = '#a4509b';localStorage['colorSetting'] = '#a4509b';localStorage.setItem('colorSetting', '#a4509b'); 但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下《The pitfalls of using objects as maps in JavaScript》。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。 可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法： 12345678910function storageAvailable() { try { const mod = '__storage__test__' localStorage.setItem(mod, mod); localStorage.removeItem(mod); return true; } catch(e) { return false; }} 附上一个Storage可用性检测函数的简要历史 基本概念Web Storage提供了两种机制让我们实现离线存储： localStorage sessionStorage 其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。 另外需要注意的是，两种机制都是在每个独立域名下分开独立存储数据的。也就是浏览器的同源策略(相同协议；相同域名；相同端口) 意思就是，在a.com下无法访问到b.com的storage数据，当然这是基于安全性的考虑。 跨域跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用Access-Control-Allow-origin解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。 由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的postMessage方法： 首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考annn.me的流程图如下： github上已有一个比较完备的类库可以参考：cross-storage","link":"/blog/2017/08/07/browser/using-web-storage-api/"},{"title":"什么是 cookie","text":"起源，因为HTTP的无状态，无法知道两个请求是来自同个人。 由NetScape工程师Lou Montulli与1994发表。正式确定于RFC2109，最终演变成RFC2965 Cookie为何物？简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。 创建服务器通过Set-Cookie的HTTP头来设置： 1Set-Cookie: &lt;em&gt;value&lt;/em&gt;[; expires=&lt;em&gt;date&lt;/em&gt;][; domain=&lt;em&gt;domain&lt;/em&gt;][; path=&lt;em&gt;path&lt;/em&gt;][; secure] 客户端将多个cookie通过Cookie的HTTP头来返回服务器： 1Cookie: value1; value2; name1=value1 多个value直接由一个分号和一个空格分隔开 value编码在普遍持有的观念中，value一定要是URL-endcoed编码的。 其实这是个谬论，在文档中，明确指出只有分号、逗号、空格才需要编码。 expires设置过期时间。需要使用GMT格式的时间。 1Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT 若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除 校验的时间是以客户端的时间为准 domain指定什么域名请求时需要发送该cookie。 采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送) path指定域名下的对应路径的请求才发送cookie。 secure有这个标志，cookie只会在HTTPS协议的请求发送该cookie。 维护Cookie和周期修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。 自动删除以下三个原因导致cookie被浏览器自动删除： 会话结束自动删除 expires到期自动删除 超过上线自动删除相对较旧的cookie 其他限制 HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。 参考： HTTP cookies explained Cookies and security Simple cookie framework","link":"/blog/2017/11/05/browser/what-is-cookie/"},{"title":"编码规范的一些思考","text":"引言古人常说，无规矩不成方圆。在编程的世界里也同样如此。 从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。 然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。 现实在笔者呆过的团队，似乎都在重蹈覆辙： 一开始不重视文档、规范，快速启动，敏捷开发 等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码 由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码 如此往复，无形中浪费了许多因修复历史代码而产生的工作量。 笔者认为，有可能是以下几种原因导致这种现象： 团队早期人员少，项目急，人力不足 前端开发仍不够成熟，没可落地的完整方案 经验不足，无法意识到规范的重要性 范围我们常说的代码规范属于编码规范的子集。 笔者理解的编码规范包括一下几种： 代码规范 文件规范 项目结构规范 其中，代码规范 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。 代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。 文件规范 则包含：文件的命名规范，以及文件的类型规范（如图片）。 项目结构规范 是规范化项目的结构，有利于项目的可读性。 由于篇幅有限，文本将主要阐述 代码规范 的制定与落地实施。 前端的特殊性若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。 但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多： 编程语言：JavaScript、CSS、HTML 框架：Vue、React、Angular runtime：Node.js、小程序、浏览器 语法糖：CoffeeScript、TypeScript 其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。 上述的runtime和语法糖都是针对于JavaScript而言，因此确定JavsScript的代码规范是首要任务。 最好的结果就是每个人写得代码都是一样的。 快速开始导致团队的代码规范难以指定的一个很大原因就是无法快速开始。 因此笔者提供一种思路：工具驱动规范(Tool Drive Specification) 通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。 对于JavaScript来说，最强力的代码分析检测工具非ESLint莫属，其涵盖了代码质量和编码风格的检测。 ESLint ESLint官方有提供一个推荐方案，通过配置文件.eslintrc： 123{ &quot;extends&quot;: &quot;eslint:recommended&quot;} 或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。 使用ESlint --init即可开启交互式初始化ESLint配置。 对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架Vue举例说明： Vue官方提供了ESLint的插件：eslint-plugin-vue 通过此插件，可以利用ESLint检测.vue文件的&lt;template&gt;和&lt;script&gt;模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置： 123456{ &quot;extends&quot;: &quot;plugin:vue/vue3-recommended&quot;, &quot;rules&quot;: { }} 另外，可以在rules里覆盖推荐的规范 执行检测： 1npx eslint **/*.{js,vue} HTMLHint 因为HTML不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：HTMLHint Rules 通过配置文件.htmlhintrc配置，默认配置如下： 123456789101112{ &quot;tagname-lowercase&quot;: true, &quot;attr-lowercase&quot;: true, &quot;attr-value-double-quotes&quot;: true, &quot;doctype-first&quot;: true, &quot;tag-pair&quot;: true, &quot;spec-char-escape&quot;: true, &quot;id-unique&quot;: true, &quot;src-not-empty&quot;: true, &quot;attr-no-duplication&quot;: true, &quot;title-require&quot;: true} 执行检测： 1npx htmlhint **/*.html stylelint stylelint是CSS的代码分析工具，类似于ESLint，stylelint也提供了 **标准配置(standard configuration)**，安装方式： 1npm install --save-dev stylelint stylelint-config-standard 在项目根目录创建配置文件.stylelintrc.json： 123{ &quot;extends&quot;: &quot;stylelint-config-standard&quot;} 执行检测： 1npx stylelint &quot;**/*.css&quot; 实施方案如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以GitLab举例： 每个仓库均可设置多个分支，在GitLab上对关键分支（比如master）的权限做严格把控，比如： 不允许任何人直接push到关键分支（Allowed to push: No one) 仅允许通过pipeline的 合并请求(merge requests) 进行合并 最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。 总结编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。 另外，需要切记的是，规范文档的落地不一定需要正式的word格式，markdown、html乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。","link":"/blog/2020/04/11/fe-base/code-style-guide/"},{"title":"ES6 Promise","text":"由于js的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。ES6(也叫ES2015)为了解决这个问题提出了Promse对象。 出现Promise的原因当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。 123456789101112$.ajax({ //...}).then(function (data) { // 要在第一个请求成功后才可以执行下一步 $.ajax({ //... }) .then(function (data) { // ... });}); 缺点： 回调地狱，多个操作的时候就要无限嵌套回调函数了 如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了 什么是Promise？一个Promise对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了Promise对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。 resolve和reject1234567891011121314function helloWorld (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(&quot;Hello World!&quot;); } else { reject(&quot;Good bye!&quot;); } });}helloWorld(true).then(function (message) { alert(message);}, function (error) { alert(error);}); resolve 方法可以使Promise对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。reject 方法则是将Promise对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。 promise三种状态上面提到了 resolve 和 reject 可以改变Promise对象的状态，那么它究竟有哪些状态呢？Promise对象有三种对象1 Fulfilled 可以理解为成功的状态2 Rejected 可以理解为失败的状态3 Pending 可以理解为Promise对象实例创建时候的初始状态 then和catchhelloWorld 的例子当中利用了 then(onFulfilld, onRejected) 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。 123456789101112131415161718192021function printHello (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(&quot;Hello&quot;); } else { reject(&quot;Good bye!&quot;); } });}function printWorld () { alert(&quot;World&quot;);}function printExclamation () { alert(&quot;!&quot;);}printHello(true) .then(function(message){ alert(message); }) .then(printWorld) .then(printExclamation); catch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected 函数的一个简单的写法，也就是说可以写成then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch 的写法比一般的写法更加清晰明确。 Promise.all 和 Promise.racePromise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。 12345678910111213var p1 = new Promise(function (resolve) { setTimeout(function () { resolve(&quot;Hello&quot;); }, 3000);});var p2 = new Promise(function (resolve) { setTimeout(function () { resolve(&quot;World&quot;); }, 1000);});Promise.all([p1, p2]).then(function (result) { console.log(result); // [&quot;Hello&quot;, &quot;World&quot;]}); Promise.race 在promise数组中任何一个promise对象变成resolve或者reject，马上执行函数 123456789101112131415161718// `delay`毫秒后执行resolvefunction timerPromisefy(delay) { return new Promise(function (resolve) { setTimeout(function () { resolve(delay); }, delay); });}// 任何一个promise变为resolve或reject 的话程序就停止运行Promise.race([ timerPromisefy(1), timerPromisefy(32), timerPromisefy(64), timerPromisefy(128)]).then(function (value) { console.log(value); // =&gt; 1}); 特殊地方： 12345678var promise = new Promise(function (resolve){ console.log(&quot;inner promise&quot;); // 1 resolve(42);});promise.then(function(value){ console.log(value); // 3});console.log(&quot;outer promise&quot;); // 2 输出结果是：inner promise -&gt; outer promise -&gt; 42","link":"/blog/2016/08/05/fe-base/es6-promise/"},{"title":"简单实现前端路由","text":"路由一直都是后端控制的，然而，其实我们前端也可以使用hash实现我们前端自己的路由。下面的代码就是参考他人代码实现的： 12345678910111213141516171819202122232425262728var router = { routes: {}, currentUrl: '', lastPanel: ''};router.init = function(){ window.addEventListener('load', this.update.bind(this), false); window.addEventListener('hashchange', this.update.bind(this), false);};router.add = function(path, callback){ this.routes[path] = callback;};router.update = function(){ this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl]();}if(this === window &amp;&amp; typeof window.document !== 'undefined') { window.router = router;}else if(typeof define === 'function') { define('router', [], function(){ return router; })}","link":"/blog/2015/09/21/fe-base/front-end-router/"},{"title":"HTML5 History API","text":"在DOM中，window对象中有一个history的对象可以用来访问浏览器的历史记录，在HTML5中，更可以通过它来操作历史记录 以前的API历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮） 12history.forward(); //前进history.back(); //后退 移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页） 12history.go(-1) //相当于history.back();history.go(1) //相当于history.forward(); 其中，history有一个length的属性，就是历史记录的长度 1var historyLength = history.length; 更强大的HTML5 Histroy API history.pushState() history.replaceState()两个方法配合window.onpopstate事件使用更佳。 其中，pushState()方法接受三个参数 状态对象（state obejct）即一个可序列化的javascript对象，与新历史记录相关联。可以使用history.state读取当前历史记录相关的数据对象。 标题（title）目前暂时会忽略这个参数，以后可能会用上。 地址（URL）新的历史记录的地址。 举个例子，假设我们现在打开的是index.html 1234var stateObj = { country: 'China' };setTimeout(function(){ history.pushState(stateObj, 'china', 'china.html');}, 1000); 页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的history.state就是stateObj的拷贝，此时我们就可以利用这个数据来进行相关的操作了。如果此时我们点击后退，则URL变成index.html，此时history.state=null 说到这里，你应该会有点困惑，好像这个API并没什么卵用，直接用hash配合window.onhashchange就可以做到啦，类似如下 1location.href = 'www.someURL.com#/china.html?country=china'; 上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应伪URL的相关的数据。 不过对比而言，pushState也有它的优势： 使用hash的方式时，如果当前hash的值不变（即url=’www.someURL.com#foo'时，设置location.href = ‘www.someURL.com#foo'），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同 url 时则会创建新的历史记录。 绑定相关数据时，history.state可以说是可以绑定任意数据，而基于hash的方式则要把所有数据转换成相关的字符串 replaceState()使用方法和pushState()基本一致。不同的是，replaceState()方法会修改当前历史记录而不是创建新的历史记录 相关DEMO，敬请期待。。。","link":"/blog/2016/07/05/fe-base/h5-history-api/"},{"title":"使用 HTML 发送邮件","text":"最近项目上的需求是在HTML上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。 使用方法 直接用a标签，然后href属性设置协议为mailto即可。然后后面可以跟一些参数 1&lt;a href=&quot;mailto:xxx@qq.com?subject=这是标题&amp;cc=这是抄送&amp;body=这是正文内容&quot;&gt;发送邮件&lt;/a&gt; 其实和上面的方法差不多，不过是换了提交的方式，就是使用form表单，然后在form的action属性设置协议mailto即可。 123456&lt;form action=&quot;mailto:xxx@qq.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;cc&quot; value=&quot;这是抄送&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;subject&quot; value=&quot;这是标题&quot;&gt; &lt;textarea name=&quot;body&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;这是内容&lt;/textarea&gt; &lt;button type=&quot;submit&quot;&gt;发送邮件&lt;/button&gt;&lt;/form&gt; 如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如： 1&lt;a href=&quot;mailto:xxx@qq.com,yyy@qq.com&quot;&gt;发送邮件&lt;/a&gt; 存在的问题很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。 由于需求的问题，需要自由输入邮件的内容，所有就没使用a标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题： 在textarea的内容格式提交到邮件系统就乱了（换行什么的丢失了） 在ios上出现的问题：点击发送的时候，safari浏览器提示“这是一张不安全的表单”。 分析： 出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用encodeURIComponent编码一下textarea的内容即可。 出现问题2：则是因为在生产上，我们是使用https协议的，如果表单提交到mailto这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉form表单的提交，自己使用location.href跳转（与此同时编码一下textarea的内容，则完美解决以上两个问题），这时就类似a标签的方式了。（其实这个时候倒不如使用a标签提交） 无法解决的问题 在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起） 参考 HTML的电子邮件链接标签mailto用法详解","link":"/blog/2016/09/12/fe-base/html-send-email/"},{"title":"Web 与原生应用的常见通信方式","text":"在移动web开发过程中，一定会遇到web端与APP端交互的情况。下面就来分析下，web端到底是如何与APP端实现交互的。 在APP端，iOS和Andriod的实现方式各不一样。 大家都知道，我们的javascript大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的javascript提供了window,navigator等宿主对象。 Andriod在Android上，实现的方式就和上面这种方式类似，就是在webview上注册一个全局变量，然后我们再js直接调用即可。下面即表示在全局环境下定义了一个对象androidEnv : 1webview.addJavascriptInterface(object, &quot;androidEnv&quot;); web调用AndriodAndriod在webview这个类里面定义的方法，我们在js都可以直接调用，这样就实现了web到Andriod的单向交互了，例如： 1AndriodEnv.sayHi(); //注意：sayHi是Andriod定义的方法 Andriod调用web然后，如果我们要实现Andriod到web的单向交互呢，道理也一样。即是js定义一个全局的函数，然后Andriod就可以直接调用了： 123function globalFunc(){ return 'hello Andriod';} iOS相反在iOS上，则没这么方便了，需要用到一个叫WebViewJavascriptBridge的桥接中间件。 在js上我们需要判断这个bridge是否已经注册，如果有就直接拿来使用；否则就监听一下brideg的变化，然后再使用。因此我们先封装好一个方法： 12345678910function connectWebViewJavascriptBridge(callback) { if (window.WebViewJavascriptBridge) { callback(WebViewJavascriptBridge); } else { document.addEventListener('WebViewJavascriptBridgeReady', function() { callback(WebViewJavascriptBridge); }, false); }; } 之后我们用一个callback来处理这个bridge： 12345connectWebViewJavascriptBridge(function(bridge) { bridge.init(function(data, responseCallback) {}); }); 到这个时候，基础工作就做完了，接下来就是web与iOS之间的交互了。 web调用iOS123bridge.callHandler('ObjC Echo', {'key':'value'}, function responseCallback(responseData) { console.log(&quot;JS received response:&quot;, responseData)}) 其中，ObjC Echo是iOS上的对应方法（其实并不是函数，只是一个token），{'key':'value'}则是web传到iOS的参数，responseData则是iOS回传的数据。 这里还有另外一种方法，就是我们可以直接利用bridge的send方法，直接将所有东西都send过去给iOS即可，例如： 12345678910111213var param = { &quot;functionName&quot; : &quot;share&quot;, &quot;params&quot;:{ &quot;title&quot; : opt.title, &quot;desc&quot; : opt.desc }};connectWebViewJavascriptBridge(function(bridge) { bridge.send(param);}); send可以接受两个参数，第二个参数就是回调函数了： 12345678connectWebViewJavascriptBridge(function(bridge) { bridge.send(param, function(data){ callback(data); });}); iOS调用web1234bridge.registerHandler('JS Echo', function(data, responseCallback) { console.log(&quot;JS Echo called with:&quot;, data) responseCallback(data)}) 这里的JS Echo则是JS上注册的一个方法名，当iOS执行玩这个方法，我们就可以马上监听到并接受到一些数据data，之后我们还可以执行responseCallback回调iOS告诉它我们的处理情况。 说说js代码知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。 12345678910111213141516171819202122232425262728293031jAPP = { getUserName: function(){ if(inAPP) { if(iOS){ //... } if(Andriod){ //... } } else { //... console.log('请在APP内打开') } }, getUserId: function(){ if(inAPP) { if(iOS){ //... } if(Andriod){ //... } } else { //... console.log('请在APP内打开') } }} 我认为的缺点： 重复判断设备信息，因为设备信息可以理解成常量，一经获取就不会更改，所以我们可以用初始化分支来优化。 重复判断是否在APP内。同样可以采用初始化分支来优化，也就是说不在APP内的话，调用的方法都不需要初始化了。 console.log没有意义，只有在测试环境下能有，上生产应该去除。 优化12345678910111213141516171819202122232425262728var ua = navigator.userAgent().toLowerCase();var inIOS = !!( ua.indexOf('iphone') &gt; -1 || ua.indexOf('ipad') &gt; -1 );var inAndriod = !!( ua.indexOf('andriod') &gt; -1 );var inAPP = !!( ua.indexOf('your APP token') &gt; -1 );var jAPP = {};if(inAPP) { if(inIOS) { jAPP.getUserId = function(){ //.. }; jAPP.getUserName = function(){ //.. }; } else if(inAndriod) { jAPP.getUserId = function(){ //.. }; jAPP.getUserName = function(){ //.. }; }} 初始化分支的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。好处在于不用重复判断分支。 如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。 参考 JS与WebView交互存在的一些问题 WebViewJavascriptBridge","link":"/blog/2016/09/26/fe-base/interact-with-app/"},{"title":"我所理解的 JavaScript 闭包","text":"闭包是JavaScript的一种特性，而不是函数。 闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。 使用场景定义私有变量的时候12345678910function Application() { var password = '123456'; this.getPassword = function(){ return password; }}var app = new Application();app.getPassword(); password此时就是个私有变量，只能通过getPassword获取。 变量作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局和局部（函数）。 Javascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子： 1234567891011121314151617181920var color = 'blue';function changeColor(){ var anotherColor = 'red'; function swapColors() { var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可访问color，anotherColor和tempColor } // 这里可访问color，anotherColor，但不能访问tempColor swapColors();}// 这里只能访问colorchangeColor(); 本文主要参考： Private Members in JavaScript 学习Javascript闭包（Closure）","link":"/blog/2017/03/05/fe-base/javascript-closure/"},{"title":"总结 JavaScript 的检测方式","text":"在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。 我们都知道，JavaScript是有5种原始类型的： number string boolean undefined null 检测原始类型检测原始类型的最佳选择是使用typeof 1234typeof 'abc' // stringtypeof 123 // numbertypeof true // booleantypeof undefined // undefined typeof有一个好处就是：未声明的变量也不会报错 1typeof someVariable //此时someVariable是未定义，返回undefined 检测复合类型复合类型内置有（不只以下几种，只是举例说明）： Object Array Date Error 当我们使用typeof检测的时候，就会看到都是返回object 1234typeof {} //objecttypeof [] //objecttypeof new Date() //objecttypeof new Error() //object 此时的最佳选择是使用instanceof 123var today = new Date()today instanceof Date // true 到这里好像全部的检测类型都搞定了。 但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。 检测函数当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题： 12345678// 在frame A定义的函数testfunction test(){}// 在frame B检测test instanceof Function //false// 而使用typeof则可以正确返回typeof test // function 故检测函数的时候，最佳选择是使用typeof 检测数组数组的问题和函数是一样的，因为不同的构造函数。而此时typeof也不灵了，因为只返回object。 Douglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式： 123function isArray(value){ return typeof value.sort === 'function';} 其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。 最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法： 123function isArray(value){ return Object.prototype.toString.call(value) === '[object Array]' ;} 这个方法能完美地辨别是否为数组。 在ECMAScript 5则可以使用Array的内置方法： 1Array.isArray([]) // true 检测属性我发现，在检测一个对象的属性是否存在的时候，常常是这样的： 123if(object.someProps){ //一些逻辑} 或者是这样的： 123if(object.someProps != null){ //一些逻辑} 或者是这样的： 123if(object.someProps != undefined){ //一些逻辑} 其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用in运算符： 123if(someProps in object){ //一些逻辑} 以上检测数据类型的所有方式。 参考：《Maintainable JavaScript》","link":"/blog/2016/11/15/fe-base/javascript-detect/"},{"title":"JavaScript 模块的差异","text":"以下 ES5 方式代表的是 Node.js 采用的 CMD，ES6 方式代表的是 ES6 提供的模块化定义 ES5方式输出模块 ES5方式输出模块，ES5方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}module.exports = {a, add} //ES5输出 12345var out = require('./out.js'); //ES5输入console.log('before:', out.a); // before:1out.add();console.log('after:', out.a); // after:1 ES5方式输出模块，ES6方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}module.exports = {a, add} //ES5输出 12345import {a, add} from './out.js'; //ES6输入console.log('before:', a); // before:1add();console.log('after:', a); // after:1 ES6方式输出模块 ES6方式输出模块，ES5方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}export {a, add} // ES6输出 12345var out = require('./out.js'); //ES5输入console.log('before:', out.a); // before:1out.add();console.log('after:', out.a); // after:2 ES6方式输出模块，ES6方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}export {a, add} // ES6输出 12345import {a, add} from './out.js'; //ES6输入console.log('before:', a); // before:1add();console.log('after:', a); // after:2 总结上面的例子可以看出： ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1 ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2 因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用","link":"/blog/2016/11/04/fe-base/javascript-modules/"},{"title":"正确使用 JavaScript 数组","text":"首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。 “…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”－Luis Atencio 循环我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。 在JavaScript上至少有四五种循环的方式，其中最基础的就是while循环了。讲例子前，先设定一个函数和数组： 1234567891011// oodlify :: String -&gt; Stringfunction oodlify(s) { return s.replace(/[aeiou]/g, 'oodle');}const input = [ 'John', 'Paul', 'George', 'Ringo',]; 那么，如果我们现在要使用oodlify函数操作一下数组里每个元素的话，如果我们使用while循环的话，是这样子的： 123456789101112let i = 0;const len = input.length;let output = [];while (i &lt; len) { let item = input[i]; let newItem = oodlify(item); output.push(newItem); i = i + 1;} 这里就有许多无谓的，但是又不得不做的工作。比如用i这个计数器来记住当前循环的位置，而且需要把i初始化成0，每次循环还要加一；比如要拿i和数组的长度len对比，这样才知道循环到什么时候停止。 这时为了让清晰一点，我们可以使用JavaScript为我们提供的for循环： 12345678910const len = input.length;let output = [];for (let i = 0; i &lt; len; i = i + 1) { let item = input[i]; let newItem = oodlify(item); output.push(newItem);} for循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。 对比起while循环虽有一定改进，但是也会发生类似忘记给计数器i加一而导致死循环的情况。 现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下oodlify函数而已。其实我们真的不想关什么计数器。 因此，ES2015就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ for...of循环 ： 12345let output = [];for (let item of input) { let newItem = oodlify(item); output.push(newItem);} 这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。 如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。 但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。 Mappingfor...of循环的确比for循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如output数组，以及把每个操作过后的值push进去。 其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先： 如果我们有两个数组需要使用oodlify函数操作的话呢？ 12345678910111213141516const fellowship = [ 'frodo', 'sam', 'gandalf', 'aragorn', 'boromir', 'legolas', 'gimli',];const band = [ 'John', 'Paul', 'George', 'Ringo',]; 很明显，我们就要这样循环两个数组： 12345678910111213let bandoodle = [];for (let item of band) { let newItem = oodlify(item); bandoodle.push(newItem);}let floodleship = [];for (let item of fellowship) { let newItem = oodlify(item); floodleship.push(newItem);} 这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数： 12345678910111213function oodlifyArray(input) { let output = []; for (let item of input) { let newItem = oodlify(item); output.push(newItem); } return output;}let bandoodle = oodlifyArray(band);let floodleship = oodlifyArray(fellowship); 这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？ 123function izzlify(s) { return s.replace(/[aeiou]+/g, 'izzle');} 这时，我们前面创建的oodlifyArray函数帮不了我们了。不过如果我们这时创建izzlifyArray函数的话，代码不就又有许多重复的部分了吗？ 123456789101112131415161718192021function oodlifyArray(input) { let output = []; for (let item of input) { let newItem = oodlify(item); output.push(newItem); } return output;}function izzlifyArray(input) { let output = []; for (let item of input) { let newItem = izzlify(item); output.push(newItem); } return output;} 这两个函数是不是及其相似呢。 如果此时我们将其抽象成一个模式的话呢：我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组。这个模式就称为mapping： 1234567function map(f, a) { let output = []; for (let item of a) { output.push(f(item)); } return output;} 其实我们并不需要自己手动写mapping函数，因为JavaScript提供了内置的map函数给我们使用，此时我们的代码是这样的： 1234let bandoodle = band.map(oodlify);let floodleship = fellowship.map(oodlify);let bandizzle = band.map(izzlify);let fellowshizzle = fellowship.map(izzlify); Reducing此时map是很方便了，但是并不能覆盖我们所有的循环需要。 如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组： 1234567891011const heroes = [ {name: 'Hulk', strength: 90000}, {name: 'Spider-Man', strength: 25000}, {name: 'Hawk Eye', strength: 136}, {name: 'Thor', strength: 100000}, {name: 'Black Widow', strength: 136}, {name: 'Vision', strength: 5000}, {name: 'Scarlet Witch', strength: 60}, {name: 'Mystique', strength: 120}, {name: 'Namora', strength: 75000},]; 如果我们要找到strength最大的那个的元素的话，使用for...of循环是这样的： 123456let strongest = {strength: 0};for (hero of heroes) { if (hero.strength &gt; strongest.strength) { strongest = hero; }} 如果此时我们想累计一下所有的strength的话，循环里面就是这样的了： 1234let combinedStrength = 0;for (hero of heroes) { combinedStrength += hero.strength;} 这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的： 123456789101112131415161718192021222324function greaterStrength(champion, contender) { return (contender.strength &gt; champion.strength) ? contender : champion;}function addStrength(tally, hero) { return tally + hero.strength;}// 例子 1const initialStrongest = {strength: 0};let working = initialStrongest;for (hero of heroes) { working = greaterStrength(working, hero);}const strongest = working;// 例子 2const initialCombinedStrength = 0;working = initialCombinedStrength;for (hero of heroes) { working = addStrength(working, hero);}const combinedStrength = working; 此时我们可以抽象成这样一个函数： 1234567function reduce(f, initialVal, a) { let working = initialVal; for (item of a) { working = f(working, item); } return working;} 其实这个方法JavaScript也提供了内置函数，就是reduce函数。这时代码是这样的： 12const strongestHero = heroes.reduce(greaterStrength, {strength: 0});const combinedStrength = heroes.reduce(addStrength, 0); Filtering前面的map函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组； reduce则是将数组的全部值执行操作之后，最终输出一个值。 如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子： 1234567891011const heroes = [ {name: 'Hulk', strength: 90000, sex: 'm'}, {name: 'Spider-Man', strength: 25000, sex: 'm'}, {name: 'Hawk Eye', strength: 136, sex: 'm'}, {name: 'Thor', strength: 100000, sex: 'm'}, {name: 'Black Widow', strength: 136, sex: 'f'}, {name: 'Vision', strength: 5000, sex: 'm'}, {name: 'Scarlet Witch', strength: 60, sex: 'f'}, {name: 'Mystique', strength: 120, sex: 'f'}, {name: 'Namora', strength: 75000, sex: 'f'},]; 现在假设我们要做的两件事： 找到sex = f的元素 找到strength &gt; 500的元素 如果使用for...of循环的话，是这样的： 123456789101112131415let femaleHeroes = [];for (let hero of heroes) { if (hero.sex === 'f') { femaleHeroes.push(hero); }}let superhumans = [];for (let hero of heroes) { if (hero.strength &gt;= 500) { superhumans.push(hero); }} 由于有重复的地方，那么我们就把不同的地方抽取出来： 123456789101112131415161718192021222324function isFemaleHero(hero) { return (hero.sex === 'f');}function isSuperhuman(hero) { return (hero.strength &gt;= 500);}let femaleHeroes = [];for (let hero of heroes) { if (isFemaleHero(hero)) { femaleHeroes.push(hero); }}let superhumans = [];for (let hero of heroes) { if (isSuperhuman(hero)) { superhumans.push(hero); }} 此时就可以抽象成JavaScript内置的filter函数： 12345678910111213141516function filter(predicate, arr) { let working = []; for (let item of arr) { if (predicate(item)) { working = working.concat(item); } }}const femaleHeroes = filter(isFemaleHero, heroes);const superhumans = filter(isSuperhuman, heroes); Findingfilter搞定了，那么如果我们只要找到一个元素呢。 的确，我们同样可以使用filter函数完成这个目标，比如： 12345function isBlackWidow(hero) { return (hero.name === 'Black Widow');}const blackWidow = heroes.filter(isBlackWidow)[0]; 当然我们也同样会发现，这样的效率并不高。因为filter函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数： 123456789function find(predicate, arr) { for (let item of arr) { if (predicate(item)) { return item; } }}const blackWidow = find(isBlackWidow, heroes); 正如大家所预期那样，JavaScript也同样提供了内置方法find给我们，因此我们最终的代码是这样的： 1const blackWidow = heroes.find(isBlackWidow); 总结这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。 现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点： 摒弃了循环的控制结构，使代码更容易阅读。 通过使用适当的方法名称描述我们正在使用的方法。 减少了处理整个数组的问题，只需要关注我们的业务代码。 在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。 本文翻译自：JavaScript Without Loops","link":"/blog/2017/02/20/fe-base/javascript-without-loops/"},{"title":"JavaScript 内存管理","text":"JavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。 内存生命周期不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读／写） 不需要时将其回收 其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。 垃圾回收JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。 我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种： － Reference-counting（引用计数）－ Mark-and-sweep（标记清除） 引用一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。 引用计数其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决循环引用的问题： 123456var div;window.onload = function(){ div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);}; 这时DOM 元素myDivElement就永远不会被回收了。 标记清除这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象window。 然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。 这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。 这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。 本文主要内容参考：Memory Management","link":"/blog/2017/03/05/fe-base/memory-management/"},{"title":"Promise 原理 &amp; 宏微任务","text":"读完这篇文章，你的收获有： Promise简史 Promise的关键概念 可以手写符合标准的Promise 可以解答任意宏任务/微任务的题目 前言为什么写这篇文章？ JavaScript是异步语言，因此Promise的重要性不言而喻。 而我看了一些文章，觉得质量参差不齐。 于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。 由于能力有限，文中可能存在错误，望广大网友指正。 Promise 简史Promise 并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。 这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：Promise/A+。 在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。 Promise 的关键概念 “The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference Promise的基础认知，推荐看阮一峰的《ES6 入门教程》。 本文的重点是讲解一些手写Promise需要关注的关键概念。 Promise 有三个状态： pending resolved rejected 只能从pending到resolved或rejected，之后状态就凝固了。 当状态流转成resolved时，需要选择一个值作为当前Promise的value： new Promise时，则是通过resolve(val) promise.then时，则是通过return（需要注意的是，没有显式return时是默认return undefined） 这个值可以是任意的合法JavaScript值（包括undefined、thenable对象或者promise） thenable对象是一个定义了then方法的对象或者函数 状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。 Promise.prototype.then1promise.then(onFulfilled, onRejected) Promise/A+ 是Promise的标准规范，其中指出Promise实例只需要实现then一个方法 then接收两个参数，而两个参数都是可选的，意味着可以什么都不传 then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的 每次调用then均返回一个全新的Promise实例，这样就可以链式调用 then会在当前宏任务下形成一个微任务（具体介绍看下面） Promise 的状态then其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。 它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定： 123new Promise((resolve, reject) =&gt; { resolve(1) // 将当前的状态流转成resolved}) 而then返回的promise的状态判断需要分两步走： then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态 若满足条件1，则看当前回调函数能否正常处理 说得有点绕口，看下面的实例代码即可理解： 理解条件1： 12345let p1 = new Promise((resolve, reject) =&gt; { // Promise {&lt;rejected&gt;: &quot;error1&quot;} reject('error1')})let p2 = p1.then(console.log) // Promise {&lt;rejected&gt;: &quot;error1&quot;} 由于p1的状态是Rejected的，而p2没有传入onRejected的回调函数，因此p2的状态完全复用p1的状态。 理解条件2： 12345678910let p1 = new Promise((resolve, reject) =&gt; { // Promise {&lt;fulfilled&gt;: 1} resolve(1)})let p2 = p1.then(val =&gt; { // Promise {&lt;rejected&gt;: ReferenceError: x is not defined} console.log('p1 was resolved:', val) return x; // Uncaught referenceError})let p3 = p2.then(undefined, reason =&gt; 1) // Promise {&lt;fulfilled&gt;: 1} p1的状态是fulfilled的，而p2有onFulfilled的回调函数，但是没有正确处理，抛异常了。因此p2的状态变成了rejected，其中的reason为则报错的原因。 而此时p3刚好有onRejected的函数，也能正确处理，最后的返回值则是自己的value，因此p3的状态是fulfilled的。 Promise 的返回值前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了promise，这里重点讲下。 由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。 同样看看例子： 12345let p1 = new Promise(resolve =&gt; { setTimeout(resolve, 1000, 1)}) let p2 = new Promise(() =&gt; p1) p1是一个简单的定时器promise，在1000ms之后，状态会变成&lt;fulfilled: 1&gt;。 而p2的返回值是p1，因此p2在1000ms之内也是&lt;pending&gt;，同样会在1000ms之后，变成&lt;fulfilled: 1&gt; Promise.prototype.catch虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。 其实，catch可以理解成then的一种封装： 1promise.catch(function onRejected() {}) == promise.then(undefined, function onRejected() {}) 微任务 microtask当前promise的状态变更之后，不是立即执行then方法的。此时引入了 微任务(microtask) 的概念。 与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。 也可以通过其他的方式生成宏任务：setTimeout、setInterval；而微任务则可以通过promise.then、Object.observe(已废弃)、MutationObserver生成。 宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）： 即一个宏任务下，是可以有多个微任务的。 由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。 解析任务分析代码的时候，可以这样分几步走： 理想情况下，如果没有任何setTimeout和promise.then的话，则全部在一个宏任务里执行 若出现promise.then，则在当前宏任务生成一个微任务，用于执行promise.then 若出现了setTimeout，则添加一个宏任务，重复条件1 分析几个例子考验一下： 例子1： 12345678setTimeout(console.log, 0, 0)new Promise((resolve) =&gt; { console.log(1) resolve(2)}).then(console.log)console.log(3) 正确的输出顺序： 1、3、2、0 例子2： 123456789101112131415console.log(8)setTimeout(function() { console.log(0) Promise.resolve(4).then(console.log)}) // 省略参数，delay默认为0new Promise((resolve) =&gt; { console.log(1) resolve(2)}).then(console.log)console.log(3)setTimeout(console.log, 0, 5) 正确的输出顺序： 8、1、3、2、0、4、5 其实，还有async/await相关的题目，如果阅读足够多的话，我再完善吧。 手写 Promise其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。 我在github写了一份，代码逻辑都算挺清晰的，大家可以去看看。 我建议大家在写之前，再仔细看一下Promise/A+的标准规范，可以结合我的代码一起看。 清晰理解细节之后，再动手写一遍。 如果觉得不错的话，记得给我点赞 + star。 撒花，感谢阅读！","link":"/blog/2021/01/17/fe-base/promise/"},{"title":"关于事件绑定的一些知识","text":"前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题： 现在有一段HTML 12345&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt; 点击li的时候alert弹出li里面的文本内容，离开ul时alert提醒。 注意，需要考虑性能和兼容性问题。 分析点击事件首先，大家都知道的是，在IE下绑定事件是使用attachEvent的，而不是addEventListener，因此可以封装一个方法来绑定事件： 12345678910111213141516/** * @param {DOM} target 表示事件绑定的元素 * @param {String} method 表示绑定的事件 * @param {Function} handler 表示绑定的事件处理函数 */function addEvent(target, method, handler) { if (target.addEventListener) { target.addEventListener(method, handler, false); } else if(target.attachEvent) { target.attachEvent('on' + method, handler) } else { target['on'+method] = handler }} 需要注意的是，使用attachEvent时，事件类型都是需要加个on前缀的。还有就是因为attachEvent是将事件绑定在冒泡阶段的，为了保持一致，所以使用addEventListener时，需指定第三个参数为false，否则就添加到事件捕获阶段了。 其次，不能给每个li绑定事件，可以利用事件的冒泡机制，故需把事件绑定到ul上而不是li上。 此时要拿到真正的li就要读取事件(event)的真实对象(target)了，这也是一个考察点： 在IE上，事件(event)要需要通过window.event获取的。 在IE上，事件对象(event target)的值是event.srcElement而不是event.target 因此绑定点击事件的完整代码是这样的： 12345678var list = document.getElementById('list')addEvent(list, 'click', function(event){ event = event || window.event; var target = event.target || event.srcElement; alert(target.innerHTML)}) 分析鼠标移开事件其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用mouseout事件就完了。然而这里隐藏了一个问题：就是当鼠标移入ul的子元素li时，也会触发mouseout事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。 然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。 在现代浏览器(chrome，firefox，safari等等)上，我们直接用event.relatedTarget就可以直接获取；而在IE上则比较繁琐，mouseout事件有一个叫toElement的元素（顾名思义就是鼠标移到了哪个元素），mouseover事件则有一个叫fromElement元素。 因此，我们可以这么做： 1234567 addEvent(list, 'mouseout', function(event){ event = event || window.event; var t = event.relatedTarget || event.toElement; if(!list.contains(t)) { alert('!') }}) 取消冒泡其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。 因为我们没有处理list.contains(t)的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点： － IE取消冒泡的方法是event.cancelBubble = true 在符合w3c标准的浏览器上，则是使用event.stopPropagation() 最终的代码是这样的： 1234567891011121314151617181920212223242526272829303132/** * @param {DOM} target 表示事件绑定的元素 * @param {String} method 表示绑定的事件 * @param {Function} handler 表示绑定的事件处理函数 */function addEvent(target, method, handler) { if (target.addEventListener) { target.addEventListener(method, handler, false); } else if(target.attachEvent) { target.attachEvent('on' + method, handler) } else { target['on'+method] = handler }}var list = document.getElementById('list');addEvent(list, 'mouseout', function(event){ event = event || window.event; var t = event.relatedTarget || event.toElement; if(list.contains(t)) { event.cancelBubble = true; event.stopPropagation(); } else { alert('你正在离开list!') }})","link":"/blog/2016/11/24/fe-base/some-summarize-about-event/"},{"title":"当 TDesign 小程序遇上 GitHub Actions","text":"在微信小程序刚发布那会，要想做自动化，都必须有 hack 开发者工具的能力才能做到，而且在 Linux 系统没有开发者工具，需要使用 windows 或 macOS。好在微信也明白开发者的痛点，在小程序发布了 3 年之后的 2020 年提供了 CI 的能力。 在 TDesign 正式开源的前半年，我们投入在自动化这些基础实施的人力比较多，可以分享的内容也挺多，这里主要分享小程序相关的自动化，并且是在 GitHub Actions 上的实现。 自动上传体验版在 TDesign 小程序组件库的开发中，比较早期做的CI 能力是自动上传体验版，我也封装了一个 GitHub Actions 可以直接使用：LeeJim/setup-miniprogram。 我们的发布流程是这样的： 其中生成 CHANGELOG 也是发布的痛点，这个能力主要是 @lucaszzhou 实现的，后面他可能会分享了相关实现，我再补充下链接。大家可以期待一下。 可以看到，整个发布流程，我只需要修改 package.json 的版本号，后面的流程几乎都是自动操作的。 上传密钥其中，上传小程序 这块，需要有上传密钥，具体路径：微信公众平台 - 开发管理 - 开发设置 - 小程序代码上传密钥。 由于密钥是敏感的信息，不能放在代码里明文展示，因此需要使用到 GitHub 的 secret。具体路径：Settings - Secrets - Actions - Repository secrets 将在微信公众平台下载下来的密钥保存到这里，然后起一个对应的 secret name 即可。使用的时候，在 GitHub Actions 的 yml 文件里可以这样使用，以下以 tdesign-miniprogram 举例： 小程序版本关系小程序的有 3 种版本：开发版、体验版、正式版。体验版和正式版都只有一个，开发版可以有多个，对应的关系是这样的： 这里需要特别提醒的一点是，开发版是可以覆盖的，体验版的关系也会继承。这里如何决定哪个版本覆盖哪个版本，取决于上传时的 CI 机器人编号，而开发者工具无法选择，因此开发者工具上传的开发版会一直覆盖。 所以这个流水线的体验版可以自动覆盖，不需要手动选择，也是基于这个原理。 自动预览由于 TDesign 小程序组件库的开发环境依赖许多编译工具，因此在验收开发者提交的 PR 时需要 执行构建 - 打开开发者工具 - 点击预览 一系列操作，才能开始扫码体验，较为繁琐。 如果是设计师验收的话，还需要搭开发环境，非常不合理。 另外更麻烦是，小程序的开发版二维码有时效限制（开发者工具显示时效 25 min）。因此没有办法像常规 Web 开发那样，在 PR 的各种检测相关流水通过之后构建出一个产物，后续随时可以验收。 Web 预览方案作为对比，可以先看一下 TDesign Web Vue 的 PR 流程： 可以看到每当 PR 创建或者同步时，都会触发构建官网，这样每次都能预览该 PR 最新的代码，用以验收。对应的预览评论如下： 小程序预览方案因为二维码的时效限制，所以小程序的预览不能直接借鉴 Web 的方式，只能在需要验收的时候再构建，这就需要一个触发构建的开关。 我把这个开关定义成：在 PR 上评论 “预览” 二字 。 以下是触发的过程： 因为构建需要一定的时间，因此先通过 Comment 告知构建已在进行。等构建成功之后，就会用二维码将这个 Comment 替换掉。 以上就是小程序预览方案的大体过程。 不过在实现这个方案的时候也遇到了不少坑，这里也顺便分享一下。 GitHub Actions 避坑获取 PR 对应的代码因为这个功能使用的是 issue_comment: created 这个触发事件。因此需要判断这个 comment 是属于 PR ，并需要获取 Comment 对应的 PR 信息。 判断 Comment 是否属于 PR 比较容易，判断这个环境变量是否存在即可：${{ github.event.pull_request }}。 获取 PR 信息但是，可能是因为触发事件的缘故，没法直接通过 ${{ github.event.pull_request.head.sha }} 获取这个 PR 对应的 Commit SHA。 通过搜索，发现了一个 Action 可以通过 GitHub 的 graphQL 获取对应 PR 的信息：xt0rted/pull-request-comment-branch 但是，这个 Action 又忽略了另外一个重要的问题：PR 的 base branch 可能是 fork 的仓库，它没有返回对应的仓库信息。因此我又基于这个 Action 封装了新的 Action：LeeJim/pull-request-comment-branch 至此，基于 actions/checkout 和 LeeJim/pull-request-comment-branch 才完成了指定评论对应的 PR 对应的代码克隆工作： 1234567- uses: LeeJim/pull-request-comment-branch@main id: comment-branch- uses: actions/checkout@v3 if: success() with: ref: ${{ steps.comment-branch.outputs.head_ref }} repository: ${{ steps.comment-branch.outputs.head_repo_name_with_owner }} 小程序预览之前实现小程序发布的时候，因为各种问题也自己实现了一个 Action：LeeJim/setup-miniprogram。 因此本次就在这个 Action 的基础上，支持了预览的功能，返回了对应的预览二维码。 给评论加图片因为小程序上传之后，可以选择返回 base64 或 jpg 格式的图片，为了避免图床的问题，因此我就想当然地选择 base64。后来才发现 GitHub 的 MarkDown 因为安全限制的问题，不支持 base64 的图片。因此我需要使用另外的图床。 腾讯云 COS此时，我的想法也很简单，直接使用腾讯云 COS 发布的 Action 上传就完事。结果在 GitHub 上找到的 Action 都是上传完不返回地址的。于是，我又需要创建一个新的 Action：LeeJim/tencent-cos-action，将上传的地址返回。 评论替换给指定 PR 添加 Comment 使用的 Action：thollander/actions-comment-pull-request。 该 Action 提供了 Comment 的功能，但我遇到的坑是文档和版本不一致。所以此刻就觉得 GitHub Actions 设计的巧妙且简单，当遇到问题的时候，可以直接去看对应的代码实现。 替换的功能是通过 comment_tag 的参数来实现。原理也很简单，就是如果有传 comment_tag 的话，就会查找这个 PR 对应的所有 Comment 是否存在这个 tag，有的话就直接替换，没有就创建一个新的 Comment。 这里有一个技巧就是：将这个 tag 通过 &lt;!-- ${{tag}} --&gt; 包装了，因此在 Comment 也看不到这个 tag。 以下是 TDesign Miniprogram 自动预览功能的完整实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859name: PREVIEWon: issue_comment: types: [created]jobs: request-preview: runs-on: ubuntu-latest if: github.event_name == 'issue_comment' &amp;amp;&amp;amp; github.event.issue.pull_request &amp;amp;&amp;amp; github.event.comment.body == '预览' steps: - run: | timestamp=$(date +%s) echo &quot;timestamp=${timestamp}&quot; &gt;&gt; $GITHUB_OUTPUT id: time - name: Comment PR uses: thollander/actions-comment-pull-request@v2 with: message: | 正在构建预览的二维码，请稍等... comment_tag: ${{steps.time.outputs.timestamp}} - uses: LeeJim/pull-request-comment-branch@main id: comment-branch - uses: actions/checkout@v3 if: success() with: ref: ${{ steps.comment-branch.outputs.head_ref }} repository: ${{ steps.comment-branch.outputs.head_repo_name_with_owner }} - uses: ./.github/actions/install-dep - run: npm run build shell: bash - name: get preview qrcode id: preview uses: LeeJim/setup-miniprogram@main with: project_type: miniProgram action_type: preview project_path: ./_example es6: true es7: true minify: true env: MINI_APP_ID: ${{ secrets.TDESIGN_APP_ID }} MINI_APP_PRIVATE_KEY: ${{ secrets.TDESIGN_MINI_KEY }} - name: Upload qrcode to Tencent COS uses: LeeJim/tencent-cos-action@main id: cos with: secretId: ${{ secrets.TENCENT_COS_SECRET_ID }} secretKey: ${{ secrets.TENCENT_COS_SECRET_KEY }} bucket: mp-qrcode-1255404841 region: ap-guangzhou content: ${{ steps.preview.outputs.preview-qrcode }} - name: Comment PR uses: thollander/actions-comment-pull-request@v2 with: message: | &lt;img alt=&quot;qrcode&quot; src=&quot;${{ steps.cos.outputs.url }}&quot; width=&quot;256&quot; /&gt; comment_tag: ${{steps.time.outputs.timestamp}} 最后提醒一下，GitHub Actions 对 Public 的仓库是没有 CI 运行累计时长的限制，而 Private 的仓库只能几千分钟的 CI 累计时长，这个需要注意。","link":"/blog/2022/12/10/miniprogram/with-github-action/"},{"title":"一个小小的优化，能让你的小程序瘦身10%","text":"我司一直专注于微信小程序（以下简称小程序）开发，可以说是重仓押注在小程序上。但由于小程序的大小有严格的限制(单个分包/主包大小不能超过 2M )。而我们的业务又相对比较复杂，因此常常会突破小程序的大小限制。因此，我们就不得不思考 如何优化小程序的大小。 暴力方式要优化小程序的大小，最好（最暴力）的方式就是删页面。 这样来，即高效执行起来也简单：统计下所有页面的 PV、UV，将一些不活跃的页面移除就完事了。 但是，本文并不是要讲如何移除页面，因为这没什么好讲的。 分析讲本文的优化方式之前，先分析一下小程序一般都由哪些文件组成的。 一般都是由以下几种文件组成： .js 逻辑文件 .wxml 页面结构文件 .wxss 样式文件 .json 配置文件 也许你会将一些 image 放在小程序里，一般建议放较小且少量的 image，其他都使用网络图片 其中，由于 JavaScript 有一定的兼容问题需要处理，因此在打包和上传小程序时，开发者工具会对 JavaScript 进行 babel 编译处理，故这块可优化的空间比较有限。 而 JSON 的大小都比较小，且格式较为固定，也没什么可优化的地方。 接下来就是本文要重点说到的 WXML 了，一般 WXSS 都是和 WXML 配套使用的。这两者占小程序的大小比例也比较高，可优化空间非常大，可优化的思路也非常多。本文先讲一下 WXML 的一个优化技巧。 试验其实，小程序最终的执行都是以WEB的形式完成的。因此 WXML 可以理解成类似于 VUE 的语法糖，最终都是要编译成 HTML 的。 所以，想要压缩 WXML 代码，就可以参考 HTML 的压缩方式。比如移除多余的空格。 我立马做了个试验，将 WXML 中的部分的空格移除之后，再使用开发者工具上传，发现小程序的大小真的发生了变化，变得更小了。因此可以得出结论，移除 WXML 中的空格是可行的压缩思路。 自动化既然移除空格是可以减小小程序代码体积的，那么如何实现自动化移除的。 首先我想到的是，利用巨人的肩膀：htmlparser2。通过语法分析器，识别 WXML 的空格，并一举歼灭。 绝大多数情况下，这个做法是可行的。但是有一种情况，会导致parser识别出错：WXML 中出现 {{ }}，且使用了 &lt;。 因此需要特制一个识别 WXML 语法的 parser。 由于这样的 parser 比较简单，因此我就自己上手写了一个：wxml-parser 实践通过上述我写的 parser，写了一个简单的 minifier：wxml-minifier 安装1npm i -D wxml-minifier 使用123456let minifier = require('wxml-minifier')let fs = require('fs')let resource = fs.readSync('./app.wxml') // 假设输入为：&lt;view class=&quot;home&quot; &gt;&lt;/view&gt; &lt;!-- test --&gt;let result = minifier(resource)console.log(result) // &lt;view class=&quot;home&quot;&gt;&lt;/view&gt; 总结通过将 WXML 中多余的空格移除，可以将小程序的代码减小大概10%。 其实，从这个角度可以发现，开发者工具在上传 WXML 时，是没有做任何处理的。因此对于 HTML 的任何压缩方式都可以在 WXML 上使用。当然这也是后续我的 wxml-parser 持续更新迭代的方向。 不知道为什么微信官方在开发者工具上传代码时，不进行简单的简化处理。如果你有答案的话，欢迎在评论中给我回复！ 如果觉得对你有用，希望给我一个 star，感谢！","link":"/blog/2020/01/21/miniprogram/wxml-minifier/"},{"title":"初用 Vue.js 的一些心得","text":"其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。 期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。 inputtype类型的选择 初始版本123456789&lt;template v-if=&quot;type === 'number'&quot;&gt; &lt;input type=&quot;number&quot; /&gt;&lt;/template&gt;&lt;template v-else-if=&quot;type === 'tel'&quot;&gt; &lt;input type=&quot;tel&quot; /&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;input type=&quot;text&quot; /&gt;&lt;/template&gt; 原因：避免使用非法类型 最终版本123456789101112131415&lt;input :type=&quot;type&quot;/&gt;&lt;script type=&quot;es6&quot;&gt;export default { props: { type: { type: 'string', default: 'text', validator(type){ return ['password', 'tel', 'number'].indexOf(type) &gt; -1 } } }}&lt;/script&gt; 同步校验与异步校验同步校验input事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。 异步校验因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default { props: { verify: { // 验证规则 {rule: '规则', errMsg: '错误信息提示'} type: Object, 'validator'(value) { return value.rule &amp;&amp; (value.rule instanceof RegExp || typeof value.rule === 'string') } }, asyncVerify: String, // 异步验证规则（URL地址） }, methods: { async validate() { const {verify, inValue, asyncVerify} = this let isValid // 存在验证规则 if (verify) { const {rule, errMsg} = verify // 正则的验证规则 if (rule instanceof RegExp) { isValid = rule.test(inValue) } // 字符串型内置类型验证 else if (typeof rule === 'string') { switch (rule) { case 'tel': isValid = /^1[34578]\\d{9}$/.test(inValue) break case 'password': isValid = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]{6,12}$/.test(inValue) break case 'telCaptcha': isValid = /^\\d{6}$/.test(inValue) break case 'imgCaptcha': isValid = /^\\S{4}$/.test(inValue) break default: // no default } } if (!isValid) { this.$emit('show-error', errMsg || '格式错误') return } } // 存在异步校验 if (asyncVerify) { } } }} 数据流动问题情况一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError 问题父元素传递’first error’，子元素自产生’second error’，此时父再传’first error’，子元素就会忽略，因为父元素传递的数据还没改变还是’first error’。 解决A方法：子元素不自己产生childError，统一$emit发送给父元素，然后才传递给子元素 B方法：父元素传递的数据，前缀加计数器以区别每次传递的数据 错误信息往上传递123456789101112131415// bd-inputthis.$emit('show-error', '出错了!')// 父组件// 用户名&lt;bd-input @show-error=&quot;showError&quot; type=&quot;text&quot; /&gt;// 密码&lt;bd-input @show-error=&quot;showError&quot; type=&quot;password&quot; /&gt;showError(error) { // error = 谁的错误信息? 用户名 or 密码} A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可 B方法：使用curry化函数 A方法1234567891011121314151617// bd-inputthis.$emit('show-error', JSON.stringify([token, '出错了!']) )// 父组件// 用户名&lt;bd-input @show-error=&quot;showError&quot; type=&quot;text&quot; token=&quot;username&quot;/&gt;// 密码&lt;bd-input @show-error=&quot;showError&quot; type=&quot;password&quot; token=&quot;password&quot;/&gt;showError(errObj) { parsedErrObj = JSON.parse(errObj) token = parsedErrObj[0] // 错误信息的宿主 error = parsedErrObj[1]} B方法12345678910111213141516// bd-inputthis.$emit('show-error', '出错了!')// 父组件// 用户名&lt;bd-input @show-error=&quot;curryShowError('username')&quot; type=&quot;text&quot; /&gt;// 密码&lt;bd-input @show-error=&quot;curryShowError('password')&quot; type=&quot;password&quot; /&gt;curryShowError(token) { return function(error){ }}","link":"/blog/2017/05/19/vue/summary-of-vuejs/"},{"title":"关于 Vue3 的 Proxy 引起的问题","text":"Vue3 是 Vuejs 新出的 3.0 版本，性能以及代码可维护性都提升了许多，也解决了许多 Vue2 中使用不便的地方。此外，由于使用了 Proxy 来实现 Reactivity，所以对客户端的要求也就更高了，但总的来说，Vue3 的普及是势不可挡的。 TDesign 是汇集了公司多个 Oteam 的结晶，包括了多种框架多种终端的组件。 其中，Tree 可以说是组件库里最复杂的组件了，可以说是没有之一。 这次分享的内容是在我将 Tree 由 Vue2 迁移至 Vue3 过程中遇到的问题、分析过程以及最终的解决方案。 迁移策略从 Vue2 升级至 Vue3，可以从官方的 《Migration Guide》可以看到了解到底有哪些 breaking changes。 升级的最小成本就是将 breaking changes 修复即可。 至于其他更好用的特性（如 Composition API、Fragments 等），属于非必需特性，可以放在后置再进行优化。其中的缘由是因为 Vue2 也在高速运转中，仍处于不稳定的状态，不对代码进行较大改动是为了之后可以方便地同步 Vue2 最新的代码。 Vue3Vue 的核心模块有三个：Reactivity Module、Compiler Module、Renderer Module。 其中，Compiler Module 是将 template 转换成 render function，日常开发不会遇到问题。 而 Reactivity Module 则从 Object.defineProperty 升级成 Proxy 的形式实现，会存在原理上的不同，导致代码的实现思路也会受影响。在较复杂逻辑中比较容易出现问题。 Renderer Module 则是核心的渲染逻辑。问题常出现在 Patch 阶段，需要了解其中的 diff 算法。 代码结构在开始迁移之前，先了解了一下 Tree 的代码结构： 1234567- common - tree-store.ts - tree-node.ts- src - tree - td-tree.tsx - tree-item.tsx common里面的代码是tree的公共逻辑，会在多个框架多个终端之间共享。 数据的流动： 状况百出渲染死循环通过断点发现，在不断地渲染 td-tree，其中就卡在 patchChildren 的逻辑：vue-next/packages/runder-core/src/renderer.ts:1771，下面是我摘选的部分代码： 1234567while (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[i] const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) //...} 这是一个简单的数组赋值，为什么在 Vue2 正常运行，而在 Vue3 则发生了死循环呢？ 是因为我们 td-tree 的渲染函数是这样的： 1234567export default defineComponent({ //... render() { const { TreeNodes } = this; return (&lt;transition-group&gt;{TreeNodes}&lt;/transition-group&gt;); } }) 而 TreeNodes 则是 TreeItem 实例的集合： 1234567this.treeNodes.push(&lt;TreeItem key={node.value} node={node} treeScope={treeScope} onClick={this.handleClick} onChange={this.handleChange}/&gt;)) 所以，在 patch 的时候，对当前 VNode Child 进行了替换。 由于Vue3使用了 Proxy 而不再是Vue2的 Object.defineProperty，因此通过数组的下标进行赋值也会被监听到，自然就又重新进入了渲染流程，最终导致了渲染死循环。 解决办法：避免使用 VNode 数组。 在当前的组件里，就是将 treeNodes 的元素改成 node，而不是 tree-item 的 VNode。 最终 td-tree 的渲染函数是这样的： 123456789export default defineComponent({ //... render() { const { TreeNodes } = this; return (&lt;transition-group&gt; {TreeNodes.map(node =&gt; this.renderItem(node))} &lt;/transition-group&gt;); } }) 数据变更不渲染为了实现多框架之间可以实现逻辑复用，所以 tree 的很多复杂逻辑计算都被封装在一个公共模块里。 而其中 tree-item 的很多逻辑存在于 common/tree-node.ts 里面。 按理说，Vue2 运行正常的情况下，我只需要改动 Vue3 的 breaking changes 的地方，其他逻辑我是不需要改动的。而且由于公共模块的部分是多框架复用的，所以我是不应该改动这部分的，除非 Vue2 同样存在问题。 诡异的情况发生了，在测试 异步加载节点 的 case 的时候，发现 loading 的 icon 一直不会消失。 于是我开始梳理各种 tree 的渲染逻辑，最后通过数据的追踪，发现其实当前的 node 的 loading 值已经变成了 false，只是tree-item的 render 没有被触发而已。 表面的原因发现了，但深层的原因是为什么呢？ 其实，这又是 Vue3 和 Vue2 的响应式实现的差异引起的问题。 在 Vue2 中，每个被当作 property 传到组件的值，会通过 Object.defineProperty 来对每个 key 设置 getter 和 setter。 以当前的组件举例： 1&lt;tree-item :node=&quot;node&quot; /&gt; 我们将 node 当作 property 传给 tree-item 的时候，Vue 就将 node 的每个 key 设置了 getter 和 setter，其中关键的是 setter，如果改变了node 的任意属性值，就会触发了 setter 与此同时就会对当前这个 tree-item 进行渲染。 而在 Vue3 中，由于Object.definedProperty 的各种局限，所以采用了更先进的 Proxy 来实现响应式。 这也就带了问题。Proxy 的机制要求我们访问 代理对象 而不是源对象，但由于 tree 的封装设计，只会在源对象上进行属性值变更，也就不会触发tree-item的渲染了。 找到了核心问题，解决思路有很多种： 让公共部分的逻辑在 代理对象 上进行，而不是源对象（不能因为版本的差异去影响公共逻辑，所以这个方案 pass） tree-item 不再使用 tree-store 返回的 node，而是新的 Object。在 tree-store 触发 update 时，再将 node 的每个 key 值进行比较，逐个update，同时也就可以触发渲染了。 总结上面遇到的两个问题都是由 Vue3 的 Reactivity 机制变更导致的，均不是 Migration Guide 里有提到的 breaking changes，都属于 Vue3 的核心实现机制的改变。 因此，要想顺利完成 Vue2 到 Vue3 的升级，最好是能理解核心思想的改变，以及能熟悉框架的源码。","link":"/blog/2021/05/28/vue/vue3-on-tdesign/"}],"tags":[{"name":"小程序","slug":"小程序","link":"/blog/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"cookie","slug":"cookie","link":"/blog/tags/cookie/"},{"name":"CSS","slug":"CSS","link":"/blog/tags/CSS/"},{"name":"BFC","slug":"BFC","link":"/blog/tags/BFC/"},{"name":"网络安全","slug":"网络安全","link":"/blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"HTTP","slug":"HTTP","link":"/blog/tags/HTTP/"},{"name":"Session","slug":"Session","link":"/blog/tags/Session/"},{"name":"JavaScript","slug":"JavaScript","link":"/blog/tags/JavaScript/"},{"name":"Storage","slug":"Storage","link":"/blog/tags/Storage/"},{"name":"underscore.js","slug":"underscore-js","link":"/blog/tags/underscore-js/"},{"name":"vue.js","slug":"vue-js","link":"/blog/tags/vue-js/"},{"name":"事件","slug":"事件","link":"/blog/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"Node.js","slug":"Node-js","link":"/blog/tags/Node-js/"},{"name":"MongoDB","slug":"MongoDB","link":"/blog/tags/MongoDB/"},{"name":"ES6","slug":"ES6","link":"/blog/tags/ES6/"},{"name":"模块化","slug":"模块化","link":"/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"Array","slug":"Array","link":"/blog/tags/Array/"},{"name":"闭包","slug":"闭包","link":"/blog/tags/%E9%97%AD%E5%8C%85/"},{"name":"HTML","slug":"HTML","link":"/blog/tags/HTML/"},{"name":"Buffers","slug":"Buffers","link":"/blog/tags/Buffers/"},{"name":"History API","slug":"History-API","link":"/blog/tags/History-API/"},{"name":"gulp","slug":"gulp","link":"/blog/tags/gulp/"},{"name":"路由","slug":"路由","link":"/blog/tags/%E8%B7%AF%E7%94%B1/"},{"name":"盒模型","slug":"盒模型","link":"/blog/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"name":"内存管理","slug":"内存管理","link":"/blog/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"垃圾回收","slug":"垃圾回收","link":"/blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"编码规范","slug":"编码规范","link":"/blog/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"自定义组件","slug":"自定义组件","link":"/blog/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"},{"name":"promise","slug":"promise","link":"/blog/tags/promise/"},{"name":"vue","slug":"vue","link":"/blog/tags/vue/"}],"categories":[{"name":"小程序","slug":"小程序","link":"/blog/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"源码解析","slug":"源码解析","link":"/blog/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"underscore","slug":"源码解析/underscore","link":"/blog/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/underscore/"},{"name":"CSS","slug":"CSS","link":"/blog/categories/CSS/"},{"name":"计算机网络","slug":"计算机网络","link":"/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"工程实践","slug":"工程实践","link":"/blog/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"},{"name":"Node.js","slug":"Node-js","link":"/blog/categories/Node-js/"},{"name":"前端基础","slug":"前端基础","link":"/blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"浏览器","slug":"浏览器","link":"/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"数据库","slug":"数据库","link":"/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端工程化","slug":"前端工程化","link":"/blog/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"组件库","slug":"组件库","link":"/blog/categories/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"vue","slug":"vue","link":"/blog/categories/vue/"},{"name":"译文","slug":"译文","link":"/blog/categories/%E8%AF%91%E6%96%87/"}]}