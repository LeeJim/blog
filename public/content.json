{"pages":[{"title":"我的项目","text":"开源项目Jeep-UI基于Vue.js框架的UI库，专注于快速生成form表单（因为ElementUI比较繁琐，而突发奇想做出来） smappVSCode插件，用于小程序开发，提供了一些自己想要的功能 小程序分享壁纸通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。 天气号初次尝试云开发，通过第三方API获取天气信息。 Web应用分享网站 #Link做为一个Web前端工程师，我希望挖掘许多有趣的网站分享给大家。 另外也是拿来练手，尝试全栈开发，全流程独立完成。","link":"/projects/index.html"}],"posts":[{"title":"自动更新机制","text":"前言小程序的更新机制与它的运行机制有关。 为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。 运行机制首先，先看下小程序的运行机制： 与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。 更新机制小程序的更新机制分为： 未启动时更新 启动时更新 未启动时更新：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。 启动时更新：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API： 1234567891011121314151617181920212223const updateManager = wx.getUpdateManager()updateManager.onCheckForUpdate(function (res) { // 请求完新版本信息的回调 console.log(res.hasUpdate)})updateManager.onUpdateReady(function () { wx.showModal({ title: '更新提示', content: '新版本已经准备好，是否重启应用？', success(res) { if (res.confirm) { // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() } } })})updateManager.onUpdateFailed(function () { // 新版本下载失败}) 如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。 根据微信提供的能力，小程序的更新流程大致如下： 由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。 下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。 由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。 测试更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。 笔者尝试在体验版上做测试：先打开v0.0.1版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是v0.0.2，根本没有还原小程序的更新机制。 因此可以得出结论：体验版无法测试更新机制。 模拟更新另外，开发者工具的编译模式提供模拟更新： 兼容处理由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。 最简单的方式：每次升级接口时，均采用新接口。","link":"/2020/05/23/mini-program/update/"},{"title":"什么是cookie","text":"起源，因为HTTP的无状态，无法知道两个请求是来自同个人。 由NetScape工程师Lou Montulli与1994发表。正式确定于RFC2109，最终演变成RFC2965 Cookie为何物？简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。 创建服务器通过Set-Cookie的HTTP头来设置： 1Set-Cookie: &lt;em&gt;value&lt;/em&gt;[; expires=&lt;em&gt;date&lt;/em&gt;][; domain=&lt;em&gt;domain&lt;/em&gt;][; path=&lt;em&gt;path&lt;/em&gt;][; secure] 客户端将多个cookie通过Cookie的HTTP头来返回服务器： 1Cookie: value1; value2; name1=value1 多个value直接由一个分号和一个空格分隔开 value编码在普遍持有的观念中，value一定要是URL-endcoed编码的。 其实这是个谬论，在文档中，明确指出只有分号、逗号、空格才需要编码。 expires设置过期时间。需要使用GMT格式的时间。 1Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT 若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除 校验的时间是以客户端的时间为准 domain指定什么域名请求时需要发送该cookie。 采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送) path指定域名下的对应路径的请求才发送cookie。 secure有这个标志，cookie只会在HTTPS协议的请求发送该cookie。 维护Cookie和周期修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。 自动删除以下三个原因导致cookie被浏览器自动删除： 会话结束自动删除 expires到期自动删除 超过上线自动删除相对较旧的cookie 其他限制 HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。 参考： HTTP cookies explained Cookies and security Simple cookie framework","link":"/2017/11/05/what-is-cookie/"},{"title":"我所理解的BFC","text":"BFCBFC (Block Formatting Context) 块级格式化上下文，在W3C上是这么定义的： Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).For information about page breaks in paged media, please consult the section on allowed page breaks. BFC效果先来说说BFC有什么效果，从效果看本质。 逐个翻译W3c的定义如下： boxes按顺序，从上到下，垂直排列 boxes are laid out one after the other, vertically, beginning at the top of a containing block 相邻boxes的垂直距离由margin决定，但是在同一个BFC容器的话，margin会合并 The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse. 每个boxes的左边会和BFC容器的左边重叠，float元素也是如此 each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), 可以解决因float元素导致的高度收缩问题（也就是常说的消除浮动） This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 如何触发BFC float元素和 absolutely元素 (例如position: absolute||fixed) display等于inline-blocks, table-cells, and table-captions的块级容器元素 overflow不等于visible的元素 BFC作用 相邻margin合并的问题 消除浮动 参考： CSS之BFC详解 W3C block-formatting","link":"/2017/11/11/what-is-bfc/"},{"title":"CSS空格和换行","text":"在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。 break-all指定怎么在单词内断行。[初始值normal-继承属性-适用全部元素] 1work-break: normal | break-all | keep-all; normal: 使用默认的换行 break-all: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。 keep-all: CJK文本不断行，non-CJK文本的行为则和normal保持一致。 具体效果可以看这个参考例子 overflow-wrap(别名：word-wrap)指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[初始值normal-继承属性-适用全部元素] 1overflow-wrap: normal | break-word; normal: 表示在正常的单词结束处换行。 break-word: 如果一行内无法容下某个单词的话，那就断开这个单词。 补充： 如果不明白break-all和overflow-wrap的差别的话，查看这个例子就可以明白了。 white-space用来描述要如何处理元素内的空格。[初始值normal-继承属性-适用全部元素] 1white-space: normal | pre | nowrap | pre-wrap | pre-line; normal: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。 nowrap: 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre: 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素时才会换行。 pre-wrap: 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时才会换行。 pre-line: 连续的空白符会被合并。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时会换行。 各种white-space的值对应的行为如下： 换行符 空白符和制表符 文字换行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 效果请看这个MDN的例子","link":"/2015/10/14/white-space-and-wrap/"},{"title":"web安全相关-HTTP头部","text":"Security - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容web安全，不能更生动形象。最近项目涉及到一些web安全的东西，就来总结一下相关的HTTP安全头部。 Content-Security-Policy作用：防止的内容注入（减缓了XSS攻击，恶意iframe注入） 不足：目前只支持现代浏览器，对浏览器有要求，要求如下： header Chrome FireFox Safari Internet Explorer Content-Security-Policy CSP Level 2 40+ Full January 2015 31+ PartialJuly 2014 - - Content-Security-Policy CSP 1.0 25+ 23+ 7+ Edge 12 build 10240+ 分析： 由于HTML的img、script、css是可以跨域的，这就导致了XSS缺陷。CSP可以设置default-src、script-src、img-src等等来限制HTML资源的加载 script-src可以设置两个特殊的值（unsafe-inline、unsafe-eval）。unsafe-inline代表不能执行内script，这就对XSS增添了一次防御，不过这样对开发人员有一定的规范。unsafe-eval则是代表不能执行eval方法(这是一个比较BUG级的函数，它会把传入的参数全部当做JS代码解释并且执行) sandbox沙盒则适用于同源策略的webapp，可以限制新标签页面打开等等。 report-uri这个属性可以设置一个URL，然后会把CSP的失败信息POST到这个URL。我们则可以记录这个有用的信息用来安全性分析。 Strict Transport Security1Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload] 作用：告诉浏览器接下来的一定时间内（自己设置）只能用HTTPS访问。这个只会让用HTTPS访问的用户继续使用HTTPS。而HTTP访问的则无效。 分析：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入HTTPS。所以第一次访问的时候，都是以HTTP访问，这时负载服务器就应该返回一个301跳转给客户端，让客户端跳转到HTTPS的服务下。由于有了HSTS的头部，下次用户再次以HTTP访问的时候，浏览器会自己做307跳转到HTTPS请求。 实际开发遇到的问题： 由于公司使用阿里云的SLB负载均衡，无法实现301跳转，于是使用了node再开启一个服务，用于接受来自SLB80端口的请求，然后返回一个301状态码并在Location头部加上HTTPS的地址。真正的node服务只接受SLB443接口的请求。 X-Content-Type-Options1X-Content-Type-Options: nosniff 作用：互联网上的资源有各种类型，通常浏览器会根据响应头的Content-Type字段来分辨它们的类型。例如：text/html代表html文档，image/png是PNG图片，text/css是CSS样式文档。然而，有些资源的Content-Type是错的或者未定义。这时，某些浏览器会启用MIME-sniffing来猜测该资源的类型，解析内容并执行。 例如，我们即使给一个html文档指定Content-Type为text/plain，在IE8中这个文档依然会被当做html来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为JavaScript。 实际开发遇到的问题： 在IE下图片验证码不能显示。分析后得出，是因为图片验证码返回的时候没有返回content-type这个文件类型的头部。所以IE不能识别文件类型。解决办法是修改图片验证码插件在返回图片是增加头部content-type：image/jpg 参考： Node.js Security Checklist Express.js官方的安全性最佳实践指导 xss攻击入门","link":"/2016/05/09/web-safe-http-header/"},{"title":"小程序开发总结（session部分）","text":"最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。 登录态维护每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。 无cookie首先，第一个需要踩的坑就是无cookie的登录态要如何维护。 微信官方提供了一个流程图，我们可以先看看： 简而言之： 在小程序上通过wx.login()获取code 将code传到自己的服务器，然后将小程序的secret和appid与微信服务器交换openid和session_key 将session_key加上随机数生成sessionId，然后openid和session_key存在session里 小程序将sessionId存起来，每次访问都带上这个sessionId 小程序获取code在小程序的app.js文件里，onLaunch函数调用我们写好的login函数： 123456789101112131415wx.login({ success: function (loginResult) { wx.getUserInfo({ withCredentials: true, success: function (userResult) { // doLogin 就是将这些数据发送到服务器 doLogin(null, { code: loginResult.code, encryptedData: userResult.encryptedData, iv: userResult.iv }) } }) }}) 服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是openid和session_key。 解密用户信息通过小程序传过来的和encryptedData和iv，然后还有刚才获取的session_key，我们就能解密用户的信息，通过对比解密出来的openid和微信交换来的openid对比，即可知道用户信息的正确性。 sessionId生成：123function generateSessionId() { return crypto.randomBytes(32).toString('hex')} 按理说，我们生成了sessionId，然后将对应的用户信息存在session里就大功告成了。 但是这样的话，很容易被伪造的暴力的伪造sessionId攻击。因此，需要再进一步，生成另外一个校验数据称为sessionkey简称sKey，这时就使用到刚获取到的session_key： 1234567function generateSkey(sessionKey) { const sha1 = (message) =&gt; { return crypto.createHash('sha1').update(message, 'utf8').digest('hex') } return sha1(appid + secret + sessionKey)} 此时我们的session的key就是一个前面随机生成的sessionId。value则为： 12345{ userinfo, session_key, sKey} 然后每次sessionId传递过来的时候，我们获取对应的session_key，然后调用generateSkey生成sKey，然后和session里面的sKey对比即可。 此时，session的生成大功告成了！ 两个登录态的问题首先，调用微信生成的code的login()函数是有时效的，大概5分钟。 我们生成的session也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。 小程序登录态官方提供了wx.checkSession()方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的login函数 session失效这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现session失效了。 因此我们可以在app.js的onShow()里发送请求到服务器测试session是否过期。过期的话就重新调用login函数。","link":"/2017/07/18/wechat-miniapp-session/"},{"title":"使用Web Storage API","text":"其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。 说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。 MDN要探究Web API，首先就想到MDN。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！ 中英文版本的差异中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。 比如： 我们可以像访问对象一样来访问Storage 123localStorage.colorSetting = '#a4509b';localStorage['colorSetting'] = '#a4509b';localStorage.setItem('colorSetting', '#a4509b'); 但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下《The pitfalls of using objects as maps in JavaScript》。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。 可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法： 12345678910function storageAvailable() { try { const mod = '__storage__test__' localStorage.setItem(mod, mod); localStorage.removeItem(mod); return true; } catch(e) { return false; }} 附上一个Storage可用性检测函数的简要历史 基本概念Web Storage提供了两种机制让我们实现离线存储： localStorage sessionStorage 其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。 另外需要注意的是，两种机制都是在每个独立域名下分开独立存储数据的。也就是浏览器的同源策略(相同协议；相同域名；相同端口) 意思就是，在a.com下无法访问到b.com的storage数据，当然这是基于安全性的考虑。 跨域跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用Access-Control-Allow-origin解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。 由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的postMessage方法： 首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考annn.me的流程图如下： github上已有一个比较完备的类库可以参考：cross-storage","link":"/2017/08/07/using-web-storage-api/"},{"title":"理解underscore.js系列——①分析外包装","text":"前言其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。 另外提醒，此文对应的underscore.js版本是v1.8.3 正文下面将以源码+解析的形式，叙述我对underscore.js的理解，能力有限，如有错误请指正。 立即执行函数源码的最外面是一个立即执行函数(IIFE)： 123(function() { // ...其他内容}()); 之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。 全局变量以前刚接触前端开发的时候，不懂Node.js，认为全局变量就是window，因此看到下面的代码会很困惑： 1234567// Establish the root object, `window` (`self`) in the browser, `global`// on the server, or `this` in some virtual machines. We use `self`// instead of `window` for `WebWorker` support.var root = typeof self == 'object' &amp;&amp; self.self === self &amp;&amp; self || typeof global == 'object' &amp;&amp; global.global === global &amp;&amp; global || this || {}; 这是一个很geek的做法，运用了逻辑运算中的短路运算，在||操作的时候，如果前面为true的话，就不会计算后面的了。 印象当中，以前的js库都是用window的，现在改用self，是因为要兼容webWorker的缘故。因此（如注释所言） 在浏览器或者webWorker的话，root = self 在服务器环境的话，root = global 在其他的虚拟机的话，则指向this即root = this 其他环境就设置为空对象{} 变量冲突我们假设一个情况，如果_这个变量被别人使用了。如果我们直接给_赋值，不就丢失了前面的对于_的定义。 因此undersocre.js就先保存起来了： 1var previousUnderscore = root._; 这样的话，就不会丢失了前面对_的定义，如果要使用的话，就可以使用underscore.js提供的noConflict方法： 1234_.noConflict = function() { root._ = previousUnderscore; return this;}; 缓存引用这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规： 123456789101112131415// Save bytes in the minified (but not gzipped) version: var ArrayProto = Array.prototype, ObjProto = Object.prototype; var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null; // Create quick reference variables for speed access to core prototypes. var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use // are declared here. var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create; 实现继承众所周知的是，js是使用原型链来实现继承的。 其实这个实现方法就是ES5的Object.create的Polyfill，这么做是为了向后兼容： 1234567891011var Ctor = function(){};// An internal function for creating a new object that inherits from another.var baseCreate = function(prototype) { if (!_.isObject(prototype)) return {}; if (nativeCreate) return nativeCreate(prototype); Ctor.prototype = prototype; var result = new Ctor; Ctor.prototype = null; // 恢复CTor的原型，以备后续使用 return result;}; 初始化123456// Create a safe reference to the Underscore object for use below. var _ = function(obj) { if (obj instanceof _) return obj; if (!(this instanceof _)) return new _(obj); this._wrapped = obj; }; 一开始我对这个部分有些困惑的，因为我简单地认为_就应该是一个空对象{}。 其实，underscore.js是支持面向对象的方式使用的，也就是把_当作一个构造函数。即new _(obj)这样的用法。 但是由于js没用真正的构造函数，因此还可以这样使用：_(obj)。为了避免这种情况，因此有了第二行代码：if (!(this instanceof _)) return new _(obj);。因为直接调用函数的话，this是指向全局的。 兼容Node.js环境12345678910111213// Export the Underscore object for **Node.js**, with// backwards-compatibility for their old module API. If we're in// the browser, add `_` as a global object.// (`nodeType` is checked to ensure that `module`// and `exports` are not HTML elements.)if (typeof exports != 'undefined' &amp;&amp; !exports.nodeType) { if (typeof module != 'undefined' &amp;&amp; !module.nodeType &amp;&amp; module.exports) { exports = module.exports = _; } exports._ = _;} else { root._ = _;} 由于Node.js的存在，因此在Node.js环境就将_赋值给exports 另外如注释所说，之所以要检测nodeType，是为了确保exports和module不是HTML元素 结尾这篇文章就是我阅读udersocre.js的第一篇源码分析文章，也是这个系列的第一篇。 写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。","link":"/2017/09/04/underscore-wrapper/"},{"title":"理解underscore.js系列——②杂项","text":"这一篇文章，就写一些零散的（我所理解的）知识点，感觉underscore.js许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。 typeof在underscore.js里，typeof后面都是跟着==而不是我们常用的=== 看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的： typeof typeof x，不管x是什么都是返回string的话，那么==就已经足够，并且与===相比还节省了一个字节。 void 0与undefined首先，void在C里是和常见的，但在js里就很少看到了。void在js里是一个操作符，它的作用在MDN里是这样描述的： The void operator evaluates the given expression and then returns undefined. 简而言之，void后面无论跟着什么表达式，都返回undefined。那使用void 0就是因为这样比较简洁。即 1void 0 === undefined 那么，为什么不直接用undefined而多此一举呢。 那是因为 undefined有可能被重写(undefined不是保留字) 123456789// 在IE8及以下var undefined = 10console.log(undefined) // 10// 主流浏览器function() { var undefined = 10 console.log(undefined) // 10} void 0的长度为6个字符，而undefined则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。 在iOS某版本下，void 0的速度比undefind快（这个是网上看到的，未验证） val == null在underscore.js里，经常会看到val == null这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。 在开发时，我要判断一个变量是否有传入，是这么做的： 123if (typeof val === 'undefined') { // others} 这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢： 12345function someTest(val, otherVal) { }someTest(null, 1) 此时就要传入null了，而此时很容易补丁式将上面的判断改成如下： 123if (typeof val === 'undefined' || val === null) { // others} 其实，此时完全可以用：val == null代替（此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句）。 其中涉及的==（半等）知识，可以参考Standard ECMA-262","link":"/2017/09/11/underscore-mix/"},{"title":"理解underscore.js系列——④精选函数","text":"这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过underscore的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。 _.sample随意取出数组中的N个元素。 按我的思路，就是使用_.random得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。 underscore则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。 123456789101112131415161718192021// Sample **n** random values from a collection using the modern version of the// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).// If **n** is not specified, returns a single random element.// The internal `guard` argument allows it to work with `map`._.sample = function(obj, n, guard) { if (n == null || guard) { if (!isArrayLike(obj)) obj = _.values(obj); return obj[_.random(obj.length - 1)]; } var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj); var length = getLength(sample); n = Math.max(Math.min(n, length), 0); var last = length - 1; for (var index = 0; index &lt; n; index++) { var rand = _.random(index, last); var temp = sample[index]; sample[index] = sample[rand]; sample[rand] = temp; } return sample.slice(0, n);}; _.throttle节流函数，频繁触发的函数可用throttle来实现一段时间(周期取决于wait)内只执行一次。 常见的场景是：页面滚动时scroll、页面大小改变时resize 可以看到，这个throttle函数是比较健壮的。 有leading、trailing可选，意思为开始和结束这个临界点是否触发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Returns a function, that, when invoked, will only be triggered at most once// during a given window of time. Normally, the throttled function will run// as much as it can, without ever going more than once per `wait` duration;// but if you'd like to disable the execution on the leading edge, pass// `{leading: false}`. To disable execution on the trailing edge, ditto._.throttle = function(func, wait, options) { var timeout, context, args, result; var previous = 0; if (!options) options = {}; var later = function() { previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; var throttled = function() { var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout &amp;&amp; options.trailing !== false) { timeout = setTimeout(later, remaining); } return result; }; throttled.cancel = function() { clearTimeout(timeout); previous = 0; timeout = context = args = null; }; return throttled;}; 实现options.leading（即开始时是否执行）相关： 设置var previous = 0; 默认不设置options.leading即默认开始时执行，故此时if (!previous &amp;&amp; options.leading === false) previous = now;不会执行。 此时，previous = 0。因此，remaining = wait - (now - previous);肯定小于0，故开始时必会执行。 实现options.trailing（即最后是否执行一次）相关： 考虑一个情况，只触发一次时，那么最终要在wait时间之后是否执行呢？ 此时underscore就是使用一个定时器来实现。 _.debounce防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于wait)才执行一次。 常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。 1234567891011121314151617181920212223242526272829303132// Returns a function, that, as long as it continues to be invoked, will not// be triggered. The function will be called after it stops being called for// N milliseconds. If `immediate` is passed, trigger the function on the// leading edge, instead of the trailing._.debounce = function(func, wait, immediate) { var timeout, result; var later = function(context, args) { timeout = null; if (args) result = func.apply(context, args); }; var debounced = restArgs(function(args) { if (timeout) clearTimeout(timeout); if (immediate) { var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); } else { timeout = _.delay(later, wait, this, args); } return result; }); debounced.cancel = function() { clearTimeout(timeout); timeout = null; }; return debounced;}; 可以看到，该版本的debounce函数增加了immediate选项：就是刚开始的时候执行一次，n秒之后再执行一次。 在看underscore官网上，介绍说这个在防止意外的双击submit按钮时很有用。 这我有一点困惑，那不就提交了两次表单吗？ 后来我发现，later函数里，执行func有一个前置条件:if (args)，而在immediate = true的情况下，later是这么调用的：setTimeout(later, wait)，这时没有传入任何参数，故args = undefind即func不会执行。 因此，immediate = true时，就只提交了一次表单，没任何问题。 _.compose组成函数，类似jQuery的链式调用：将前一个函数的执行结果传入后一个函数。 123456789101112// Returns a function that is the composition of a list of functions, each// consuming the return value of the function that follows._.compose = function() { var args = arguments; var start = args.length - 1; return function() { var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; };}; 这里我觉得var i = start似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。 _.after执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。 12345678// Returns a function that will only be executed on and after the Nth call. _.after = function(times, func) { return function() { if (--times &lt; 1) { return func.apply(this, arguments); } }; }; 在javaScript开发中，经常遇到异步调用的问题。 拿开发小程序为例，上传图片的功能官方只提供单张上传API，当我们要批量上次的时候，执行循环调用单张上传API。此时要全部上传完执行回调就可以使用这个方法了。 现在想想，我之前的做法是setTimeout(uploadSuccess, 100)，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。","link":"/2017/09/23/underscore-featured-function/"},{"title":"理解underscore.js系列——③基础函数","text":"从_.each函数入手，理解underscore.js的基础函数，_.each的调用盏可以参考如下思维导图： underscore.js的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，_.each也不例外。因此先来介绍内置的cb函数还有optimizeCb函数 cbcb顾名思义，就是回调函数(CallBack的简称)的意思。 12345678910// An internal function to generate callbacks that can be applied to each// element in a collection, returning the desired result — either `identity`,// an arbitrary callback, a property matcher, or a property accessor.var cb = function(value, context, argCount) { if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 1 if (value == null) return _.identity; // 2 if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 3 if (_.isObject(value) &amp;&amp; !_.isArray(value)) return _.matcher(value); // 4 return _.property(value);}; 对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的_.iteratee 如果没有传入value，就使用_.identity = function(value) { return value; } 如果传入了function，则使用optimizeCb格式化一下 如果传入了object，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致 否则就将传入的值当成一个属性，返回一个匹配该属性的函数 optimizeCb格式化传入的回调函数，以统一迭代函数，方便后续使用 123456789101112131415161718192021222324// Internal function that returns an efficient (for current engines) version// of the passed-in callback, to be repeatedly applied in other Underscore// functions.var optimizeCb = function(func, context, argCount) { // 如果没有执行上下文，就直接返回该函数 if (context === void 0) return func; switch (argCount) { case 1: return function(value) { return func.call(context, value); }; // The 2-parameter case has been omitted only because no current consumers // made use of it. case null: case 3: return function(value, index, collection) { return func.call(context, value, index, collection); }; case 4: return function(accumulator, value, index, collection) { return func.call(context, accumulator, value, index, collection); }; } return function() { return func.apply(context, arguments); };}; collectNonEnumProps在IE9以下版本，会有一个bug：如果重写了原不可枚举的属性，使用for...in是不会返回的。 相关信息可参考：W3Help SJ5003 1234567891011121314151617181920212223242526// Keys in IE &lt; 9 that won't be iterated by `for key in ...` and thus missed.var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];var collectNonEnumProps = function(obj, keys) { var nonEnumIdx = nonEnumerableProps.length; // 获取对象的构造函数，以获取对象的原型 var constructor = obj.constructor; var proto = _.isFunction(constructor) &amp;&amp; constructor.prototype || ObjProto; // Constructor is a special case. // 将构造函数属性放入keys var prop = 'constructor'; if (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop); while (nonEnumIdx--) { prop = nonEnumerableProps[nonEnumIdx]; // 如果obj有这个属性 // obj[prop] !== proto[prop] 说明重写了该属性 // keys不包含该属性 if (prop in obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) { keys.push(prop); } }}; 这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章待续 restArgsrest是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：function(value, ...rest) 1234567891011121314151617181920212223242526272829// Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)// This accumulates the arguments passed into an array, after a given index.var restArgs = function(func, startIndex) { // func.length可获取函数定义的参数个数 // eg: function (a, b) {} =&gt; 2 startIndex = startIndex == null ? func.length - 1 : +startIndex; return function() { var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0; // 将定义的最后一个参数和超过定义的参数都放进rest数组 for (; index &lt; length; index++) { rest[index] = arguments[index + startIndex]; } // 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。 switch (startIndex) { case 0: return func.call(this, rest); case 1: return func.call(this, arguments[0], rest); case 2: return func.call(this, arguments[0], arguments[1], rest); } // 将超出的部分(指rest)放在args数组的最后一位 var args = Array(startIndex + 1); for (index = 0; index &lt; startIndex; index++) { args[index] = arguments[index]; } args[startIndex] = rest; return func.apply(this, args); };}; 这里涉及到两个知识点： function.length指的是函数定义的参数个数 function.call和function.apply的区别：call需逐个传入参数，而apply则将参数放进一个数组传入","link":"/2017/09/18/underscore-base-function/"},{"title":"初用Vue.js的一些心得","text":"其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。 期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。 inputtype类型的选择 初始版本：123456789&lt;template v-if=&quot;type === 'number'&quot;&gt; &lt;input type=&quot;number&quot; /&gt;&lt;/template&gt;&lt;template v-else-if=&quot;type === 'tel'&quot;&gt; &lt;input type=&quot;tel&quot; /&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;input type=&quot;text&quot; /&gt;&lt;/template&gt; 原因：避免使用非法类型 最终版本：123456789101112131415&lt;input :type=&quot;type&quot;/&gt;&lt;script type=&quot;es6&quot;&gt;export default { props: { type: { type: 'string', default: 'text', validator(type){ return ['password', 'tel', 'number'].indexOf(type) &gt; -1 } } }}&lt;/script&gt; 同步校验与异步校验同步校验：input事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。 异步校验：因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default { props: { verify: { // 验证规则 {rule: '规则', errMsg: '错误信息提示'} type: Object, 'validator'(value) { return value.rule &amp;&amp; (value.rule instanceof RegExp || typeof value.rule === 'string') } }, asyncVerify: String, // 异步验证规则（URL地址） }, methods: { async validate() { const {verify, inValue, asyncVerify} = this let isValid // 存在验证规则 if (verify) { const {rule, errMsg} = verify // 正则的验证规则 if (rule instanceof RegExp) { isValid = rule.test(inValue) } // 字符串型内置类型验证 else if (typeof rule === 'string') { switch (rule) { case 'tel': isValid = /^1[34578]\\d{9}$/.test(inValue) break case 'password': isValid = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]{6,12}$/.test(inValue) break case 'telCaptcha': isValid = /^\\d{6}$/.test(inValue) break case 'imgCaptcha': isValid = /^\\S{4}$/.test(inValue) break default: // no default } } if (!isValid) { this.$emit('show-error', errMsg || '格式错误') return } } // 存在异步校验 if (asyncVerify) { } } }} 数据流动问题情况：一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError 问题：父元素传递’first error’，子元素自产生’second error’，此时父再传’first error’，子元素就会忽略，因为父元素传递的数据还没改变还是’first error’。 解决：A方法：子元素不自己产生childError，统一$emit发送给父元素，然后才传递给子元素 B方法：父元素传递的数据，前缀加计数器以区别每次传递的数据 错误信息往上传递123456789101112131415// bd-inputthis.$emit('show-error', '出错了!')// 父组件// 用户名&lt;bd-input @show-error=&quot;showError&quot; type=&quot;text&quot; /&gt;// 密码&lt;bd-input @show-error=&quot;showError&quot; type=&quot;password&quot; /&gt;showError(error) { // error = 谁的错误信息? 用户名 or 密码} A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可 B方法：使用curry化函数 A方法1234567891011121314151617// bd-inputthis.$emit('show-error', JSON.stringify([token, '出错了!']) )// 父组件// 用户名&lt;bd-input @show-error=&quot;showError&quot; type=&quot;text&quot; token=&quot;username&quot;/&gt;// 密码&lt;bd-input @show-error=&quot;showError&quot; type=&quot;password&quot; token=&quot;password&quot;/&gt;showError(errObj) { parsedErrObj = JSON.parse(errObj) token = parsedErrObj[0] // 错误信息的宿主 error = parsedErrObj[1]} B方法12345678910111213141516// bd-inputthis.$emit('show-error', '出错了!')// 父组件// 用户名&lt;bd-input @show-error=&quot;curryShowError('username')&quot; type=&quot;text&quot; /&gt;// 密码&lt;bd-input @show-error=&quot;curryShowError('password')&quot; type=&quot;password&quot; /&gt;curryShowError(token) { return function(error){ }}","link":"/2017/05/19/summary-of-vuejs/"},{"title":"前端进阶 - Promise原理&amp;宏微任务","text":"读完这篇文章，你的收获有： Promise简史 Promise的关键概念 可以手写符合标准的Promise 可以解答任意宏任务/微任务的题目 0. 前言为什么写这篇文章？ JavaScript是异步语言，因此Promise的重要性不言而喻。 而我看了一些文章，觉得质量参差不齐。 于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。 由于能力有限，文中可能存在错误，望广大网友指正。 1. Promise简史Promise并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。 这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：Promise/A+。 在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。 2. Promise的关键概念 “The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference Promise的基础认知，推荐看阮一峰的《ES6 入门教程》。 本文的重点是讲解一些手写Promise需要关注的关键概念。 2.1 Promise有三个状态： pending resolved rejected 只能从pending到resolved或rejected，之后状态就凝固了。 当状态流转成resolved时，需要选择一个值作为当前Promise的value： new Promise时，则是通过resolve(val) promise.then时，则是通过return（需要注意的是，没有显式return时是默认return undefined） 这个值可以是任意的合法JavaScript值（包括undefined、thenable对象或者promise） thenable对象是一个定义了then方法的对象或者函数 状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。 2.2 Promise.prototype.then1promise.then(onFulfilled, onRejected) Promise/A+ 是Promise的标准规范，其中指出Promise实例只需要实现then一个方法 then接收两个参数，而两个参数都是可选的，意味着可以什么都不传 then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的 每次调用then均返回一个全新的Promise实例，这样就可以链式调用 then会在当前宏任务下形成一个微任务（具体介绍看下面） 2.2.1 promise的状态then其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。 它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定： 123new Promise((resolve, reject) =&gt; { resolve(1) // 将当前的状态流转成resolved}) 而then返回的promise的状态判断需要分两步走： then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态 若满足条件1，则看当前回调函数能否正常处理 说得有点绕口，看下面的实例代码即可理解： 理解条件1： 12345let p1 = new Promise((resolve, reject) =&gt; { // Promise {&lt;rejected&gt;: &quot;error1&quot;} reject('error1')})let p2 = p1.then(console.log) // Promise {&lt;rejected&gt;: &quot;error1&quot;} 由于p1的状态是Rejected的，而p2没有传入onRejected的回调函数，因此p2的状态完全复用p1的状态。 理解条件2： 12345678910let p1 = new Promise((resolve, reject) =&gt; { // Promise {&lt;fulfilled&gt;: 1} resolve(1)})let p2 = p1.then(val =&gt; { // Promise {&lt;rejected&gt;: ReferenceError: x is not defined} console.log('p1 was resolved:', val) return x; // Uncaught referenceError})let p3 = p2.then(undefined, reason =&gt; 1) // Promise {&lt;fulfilled&gt;: 1} p1的状态是fulfilled的，而p2有onFulfilled的回调函数，但是没有正确处理，抛异常了。因此p2的状态变成了rejected，其中的reason为则报错的原因。 而此时p3刚好有onRejected的函数，也能正确处理，最后的返回值则是自己的value，因此p3的状态是fulfilled的。 2.2.2 promise的返回值前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了promise，这里重点讲下。 由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。 同样看看例子： 12345let p1 = new Promise(resolve =&gt; { setTimeout(resolve, 1000, 1)}) let p2 = new Promise(() =&gt; p1) p1是一个简单的定时器promise，在1000ms之后，状态会变成&lt;fulfilled: 1&gt;。 而p2的返回值是p1，因此p2在1000ms之内也是&lt;pending&gt;，同样会在1000ms之后，变成&lt;fulfilled: 1&gt; 2.3 Promise.prototype.catch虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。 其实，catch可以理解成then的一种封装： 1promise.catch(function onRejected() {}) == promise.then(undefined, function onRejected() {}) 2.4 微任务 microtask当前promise的状态变更之后，不是立即执行then方法的。此时引入了 微任务(microtask) 的概念。 与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。 也可以通过其他的方式生成宏任务：setTimeout、setInterval；而微任务则可以通过promise.then、Object.observe(已废弃)、MutationObserver生成。 宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）： 即一个宏任务下，是可以有多个微任务的。 由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。 2.4.1 解析任务分析代码的时候，可以这样分几步走： 理想情况下，如果没有任何setTimeout和promise.then的话，则全部在一个宏任务里执行 若出现promise.then，则在当前宏任务生成一个微任务，用于执行promise.then 若出现了setTimeout，则添加一个宏任务，重复条件1 分析几个例子考验一下： 例子1： 12345678setTimeout(console.log, 0, 0)new Promise((resolve) =&gt; { console.log(1) resolve(2)}).then(console.log)console.log(3) 正确的输出顺序： 1、3、2、0 例子2： 123456789101112131415console.log(8)setTimeout(function() { console.log(0) Promise.resolve(4).then(console.log)}) // 省略参数，delay默认为0new Promise((resolve) =&gt; { console.log(1) resolve(2)}).then(console.log)console.log(3)setTimeout(console.log, 0, 5) 正确的输出顺序： 8、1、3、2、0、4、5 其实，还有async/await相关的题目，如果阅读足够多的话，我再完善吧。 3. 手写Promise其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。 我在github写了一份，代码逻辑都算挺清晰的，大家可以去看看。 我建议大家在写之前，再仔细看一下Promise/A+的标准规范，可以结合我的代码一起看。 清晰理解细节之后，再动手写一遍。 如果觉得不错的话，记得给我点赞 + star。 撒花，感谢阅读！","link":"/2021/01/17/promise/"},{"title":"小程序实战汇总一","text":"随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。 那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。 授权处理在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。 因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。 解决方案在基础库1.2版本，新增了wx.getSetting接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。 具体实现可参考一下代码： 1234567891011121314151617181920212223242526272829wx.getUserInfo({ success: function (res) { // 成功获取用户信息，继续操作 }, fail: (res) =&gt; { wx.showModal({ title: '用户未授权', content: '如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？', success: (action) =&gt; { if (action.confirm) { } } }) }})// 检查状态wx.openSetting({ success: (res) =&gt; { // 二次授权成功 if (res.authSetting[&quot;scope.userInfo&quot;]) { // 成功获取用户信息 } }, fail: function () { fail() }}) 页面数据传递页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？ URL传递类似Web的链接跳转，使用类似query串的形式。 1wx.navigateTo('../user/user?name=leejim') 在目的页的onload函数，可以这么获取： 123onLoad(options) { console.log(options.name) // leejim} 使用客户端缓存小程序提供了本地存储的方式：wx.setStorage和wx.getStorage。 可以在页面跳转前，先用wx.setStorage缓存数据，然后在目的页使用wx.getStorage获取数据。 使用全局变量在小程序里，有一个全局函数getApp用来获取全局变量app。 比如这样： 12var app = getApp()app.index = 1 // 设置变量 往栈内的页面传递数据使用全局函数getCurrentPages函数可以获取栈内的所有页面。 然后就可以直接设置那个页面的数据： 1234var pages = getCurrentPages()pages[pages.length -1].setData({ // 往前一个页面设置数据 data: 123}) 修改Input组件的值因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。 但是我们能通过data绑定的方式来实现： 1&lt;input value='{{inputValue}}' /&gt; js部分： 123this.setData({ inputValue: ''})","link":"/2018/01/07/practice-of-wxapp-1/"},{"title":"关于事件绑定的一些知识","text":"前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题： 现在有一段HTML 12345&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt; 点击li的时候alert弹出li里面的文本内容，离开ul时alert提醒。 注意，需要考虑性能和兼容性问题。 分析点击事件首先，大家都知道的是，在IE下绑定事件是使用attachEvent的，而不是addEventListener，因此可以封装一个方法来绑定事件： 12345678910111213141516/** * @param {DOM} target 表示事件绑定的元素 * @param {String} method 表示绑定的事件 * @param {Function} handler 表示绑定的事件处理函数 */function addEvent(target, method, handler) { if (target.addEventListener) { target.addEventListener(method, handler, false); } else if(target.attachEvent) { target.attachEvent('on' + method, handler) } else { target['on'+method] = handler }} 需要注意的是，使用attachEvent时，事件类型都是需要加个on前缀的。还有就是因为attachEvent是将事件绑定在冒泡阶段的，为了保持一致，所以使用addEventListener时，需指定第三个参数为false，否则就添加到事件捕获阶段了。 其次，不能给每个li绑定事件，可以利用事件的冒泡机制，故需把事件绑定到ul上而不是li上。 此时要拿到真正的li就要读取事件(event)的真实对象(target)了，这也是一个考察点： 在IE上，事件(event)要需要通过window.event获取的。 在IE上，事件对象(event target)的值是event.srcElement而不是event.target 因此绑定点击事件的完整代码是这样的： 12345678var list = document.getElementById('list')addEvent(list, 'click', function(event){ event = event || window.event; var target = event.target || event.srcElement; alert(target.innerHTML)}) 分析鼠标移开事件其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用mouseout事件就完了。然而这里隐藏了一个问题：就是当鼠标移入ul的子元素li时，也会触发mouseout事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。 然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。 在现代浏览器(chrome，firefox，safari等等)上，我们直接用event.relatedTarget就可以直接获取；而在IE上则比较繁琐，mouseout事件有一个叫toElement的元素（顾名思义就是鼠标移到了哪个元素），mouseover事件则有一个叫fromElement元素。 因此，我们可以这么做： 1234567 addEvent(list, 'mouseout', function(event){ event = event || window.event; var t = event.relatedTarget || event.toElement; if(!list.contains(t)) { alert('!') }}) 取消冒泡其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。 因为我们没有处理list.contains(t)的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点： － IE取消冒泡的方法是event.cancelBubble = true 在符合w3c标准的浏览器上，则是使用event.stopPropagation() 最终的代码是这样的： 1234567891011121314151617181920212223242526272829303132/** * @param {DOM} target 表示事件绑定的元素 * @param {String} method 表示绑定的事件 * @param {Function} handler 表示绑定的事件处理函数 */function addEvent(target, method, handler) { if (target.addEventListener) { target.addEventListener(method, handler, false); } else if(target.attachEvent) { target.attachEvent('on' + method, handler) } else { target['on'+method] = handler }}var list = document.getElementById('list');addEvent(list, 'mouseout', function(event){ event = event || window.event; var t = event.relatedTarget || event.toElement; if(list.contains(t)) { event.cancelBubble = true; event.stopPropagation(); } else { alert('你正在离开list!') }})","link":"/2016/11/24/some-summarize-about-event/"},{"title":"多版本Node.js","text":"最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。 然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。 于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。 所以我发现，拥有多版本的Node.js还是很有必要的。 开发环境linux / MacOs如果是在*nux的开发环境可以直接安装nvm即可 Windows需要安装nvm-window。github地址在此，下载地址在此 在此我着重说一下nvm-windows需要注意的地方： 安装nvm-windows之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用） 需要把NPM删掉(e.g. “C:\\Users\\AppData\\Roaming\\npm”) 对应每个Node.js版本的全局安装方法都用重新安装，比如： 1234567nvm use 4.0.0npm install -g grunt#切换版本nvm use 7.0.0npm install -g grunt","link":"/2016/11/03/nvm-windows/"},{"title":"mongodb使用记录","text":"记录一下mongodb的使用记录，包含常用的启动、操作等命令。 初始化文件目录123456-data #数据+ log #日志 - mongod.log+ conf #配置文件 - mongod.confbin #二进制目录 启动的配置文件1234port = 12345 #启动端口dbpath = data #数据路径logpath = log/mongod.log #日志路径fork = true #表明启动的是后台进程 windows下无效 启动启动数据库1mongod -f conf/mongod.conf 连接数据库1mongo 127.0.0.1:12345/test 基本操作1234show dbs #显示所有数据库use company #使用company数据库 不存在则自动创建show collections #显示所有collectionshow tables #效果同上 CRUD插入数据123db.company_list.insert({name: 'one'}) # company_list为collection，不存在则自动创建，然后插入一个数据for(i=0;i&lt;10;i++) db.company_list.insert({name: i}) #使用js的语法插入10个数据 查找数据12345db.company_list.find() #显示该collection的所有数据db.company_list.find({name: 'one'}) #显示对应条件的数据db.company_list.find().skip(2).limit(3).sort({name: 1}) #跳过前2个数据，按name排序获取3个数据 数据更新1234567db.company_list.update({x:1}, {x:1000}) #第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即{x:1,y:1} =&gt; {x:1000}）db.company_list.update({x:1}, {$set: {x:1000}}) #只修改x字段db.company_list.update({x:99, {y:99}, true}) #修改一个不存在的数据则插入这个数据db.company_list.update({x:1}, {y:99}, false, true}) #批量修改多条数据 删除数据12db.company_list.remove({x:1}) #默认删除对应条件的所有数据dp.company_list.drop() #删除collection 索引相关12db.company_list.getIndexes() #列出所有索引db.company_list.ensureIndex({x:1}) #设置索引 索引的类型 _id索引 单键索引 多键索引 复合索引 过期索引 全文索引 地理位置索引 权限相关创建用户123456db.createUser({ user: &quot;&lt;name&gt;&quot;, pwd: &quot;&lt;cleartext password&gt;&quot;, customData: {&lt;any information}, roles: [{role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot;}]}) 用户类型： read readWrite dbAdmin dbOwner userAdmin","link":"/2016/10/17/mongodb/"},{"title":"模块化 CommonJS VS ES6 Module","text":"以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义 ES5方式输出模块 ES5方式输出模块，ES5方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}module.exports = {a, add} //ES5输出 12345var out = require('./out.js'); //ES5输入console.log('before:', out.a); // before:1out.add();console.log('after:', out.a); // after:1 ES5方式输出模块，ES6方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}module.exports = {a, add} //ES5输出 12345import {a, add} from './out.js'; //ES6输入console.log('before:', a); // before:1add();console.log('after:', a); // after:1 ES6方式输出模块 ES6方式输出模块，ES5方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}export {a, add} // ES6输出 12345var out = require('./out.js'); //ES5输入console.log('before:', out.a); // before:1out.add();console.log('after:', out.a); // after:2 ES6方式输出模块，ES6方式输入 12345678// 输出out.jsvar a = 1;function add(){ a++;}export {a, add} // ES6输出 12345import {a, add} from './out.js'; //ES6输入console.log('before:', a); // before:1add();console.log('after:', a); // after:2 总结上面的例子可以看出： ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1 ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2 因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用","link":"/2016/11/04/module-es6-vs-amd/"},{"title":"iOS 软键盘弹出","text":"移动WEB开发经常要遇到控制软键盘：弹出键盘和收起键盘。 12345 // 弹出键盘 input.focus();// 收起键盘 input.blur(); 在Android上，弹出和收起都比较正常，在任何时候调用都行。在iOS则不一样，一定要有在用户有实际交互时马上(right now)调用focus或者blur才行。比如： 123btn.addEventListener('click', function(){ input.focus(); //弹出键盘}, false); 如果此时使用了setTimeout： 12345btn.addEventListener('click', function(){ setTimeout(function(){ input.focus(); //键盘是不会弹出的 }, 50);}, false); 或者此时我调用ajax请求再focus也是不会弹出来的 123456$.ajax({ //...}).then(function(){ input.focus(); //键盘是不会弹出的})","link":"/2016/07/22/mobile-web-soft-keyboard/"},{"title":"正确使用JavaScript数组","text":"首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。 “…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”－Luis Atencio 循环我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。 在JavaScript上至少有四五种循环的方式，其中最基础的就是while循环了。讲例子前，先设定一个函数和数组： 1234567891011// oodlify :: String -&gt; Stringfunction oodlify(s) { return s.replace(/[aeiou]/g, 'oodle');}const input = [ 'John', 'Paul', 'George', 'Ringo',]; 那么，如果我们现在要使用oodlify函数操作一下数组里每个元素的话，如果我们使用while循环的话，是这样子的： 123456789101112let i = 0;const len = input.length;let output = [];while (i &lt; len) { let item = input[i]; let newItem = oodlify(item); output.push(newItem); i = i + 1;} 这里就有许多无谓的，但是又不得不做的工作。比如用i这个计数器来记住当前循环的位置，而且需要把i初始化成0，每次循环还要加一；比如要拿i和数组的长度len对比，这样才知道循环到什么时候停止。 这时为了让清晰一点，我们可以使用JavaScript为我们提供的for循环： 12345678910const len = input.length;let output = [];for (let i = 0; i &lt; len; i = i + 1) { let item = input[i]; let newItem = oodlify(item); output.push(newItem);} for循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。 对比起while循环虽有一定改进，但是也会发生类似忘记给计数器i加一而导致死循环的情况。 现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下oodlify函数而已。其实我们真的不想关什么计数器。 因此，ES2015就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ for...of循环 ： 12345let output = [];for (let item of input) { let newItem = oodlify(item); output.push(newItem);} 这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。 如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。 但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。 Mappingfor...of循环的确比for循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如output数组，以及把每个操作过后的值push进去。 其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先： 如果我们有两个数组需要使用oodlify函数操作的话呢？ 12345678910111213141516const fellowship = [ 'frodo', 'sam', 'gandalf', 'aragorn', 'boromir', 'legolas', 'gimli',];const band = [ 'John', 'Paul', 'George', 'Ringo',]; 很明显，我们就要这样循环两个数组： 12345678910111213let bandoodle = [];for (let item of band) { let newItem = oodlify(item); bandoodle.push(newItem);}let floodleship = [];for (let item of fellowship) { let newItem = oodlify(item); floodleship.push(newItem);} 这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数： 12345678910111213function oodlifyArray(input) { let output = []; for (let item of input) { let newItem = oodlify(item); output.push(newItem); } return output;}let bandoodle = oodlifyArray(band);let floodleship = oodlifyArray(fellowship); 这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？ 123function izzlify(s) { return s.replace(/[aeiou]+/g, 'izzle');} 这时，我们前面创建的oodlifyArray函数帮不了我们了。不过如果我们这时创建izzlifyArray函数的话，代码不就又有许多重复的部分了吗？ 123456789101112131415161718192021function oodlifyArray(input) { let output = []; for (let item of input) { let newItem = oodlify(item); output.push(newItem); } return output;}function izzlifyArray(input) { let output = []; for (let item of input) { let newItem = izzlify(item); output.push(newItem); } return output;} 这两个函数是不是及其相似呢。 如果此时我们将其抽象成一个模式的话呢：我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组。这个模式就称为mapping： 1234567function map(f, a) { let output = []; for (let item of a) { output.push(f(item)); } return output;} 其实我们并不需要自己手动写mapping函数，因为JavaScript提供了内置的map函数给我们使用，此时我们的代码是这样的： 1234let bandoodle = band.map(oodlify);let floodleship = fellowship.map(oodlify);let bandizzle = band.map(izzlify);let fellowshizzle = fellowship.map(izzlify); Reducing此时map是很方便了，但是并不能覆盖我们所有的循环需要。 如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组： 1234567891011const heroes = [ {name: 'Hulk', strength: 90000}, {name: 'Spider-Man', strength: 25000}, {name: 'Hawk Eye', strength: 136}, {name: 'Thor', strength: 100000}, {name: 'Black Widow', strength: 136}, {name: 'Vision', strength: 5000}, {name: 'Scarlet Witch', strength: 60}, {name: 'Mystique', strength: 120}, {name: 'Namora', strength: 75000},]; 如果我们要找到strength最大的那个的元素的话，使用for...of循环是这样的： 123456let strongest = {strength: 0};for (hero of heroes) { if (hero.strength &gt; strongest.strength) { strongest = hero; }} 如果此时我们想累计一下所有的strength的话，循环里面就是这样的了： 1234let combinedStrength = 0;for (hero of heroes) { combinedStrength += hero.strength;} 这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的： 123456789101112131415161718192021222324function greaterStrength(champion, contender) { return (contender.strength &gt; champion.strength) ? contender : champion;}function addStrength(tally, hero) { return tally + hero.strength;}// 例子 1const initialStrongest = {strength: 0};let working = initialStrongest;for (hero of heroes) { working = greaterStrength(working, hero);}const strongest = working;// 例子 2const initialCombinedStrength = 0;working = initialCombinedStrength;for (hero of heroes) { working = addStrength(working, hero);}const combinedStrength = working; 此时我们可以抽象成这样一个函数： 1234567function reduce(f, initialVal, a) { let working = initialVal; for (item of a) { working = f(working, item); } return working;} 其实这个方法JavaScript也提供了内置函数，就是reduce函数。这时代码是这样的： 12const strongestHero = heroes.reduce(greaterStrength, {strength: 0});const combinedStrength = heroes.reduce(addStrength, 0); Filtering前面的map函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组； reduce则是将数组的全部值执行操作之后，最终输出一个值。 如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子： 1234567891011const heroes = [ {name: 'Hulk', strength: 90000, sex: 'm'}, {name: 'Spider-Man', strength: 25000, sex: 'm'}, {name: 'Hawk Eye', strength: 136, sex: 'm'}, {name: 'Thor', strength: 100000, sex: 'm'}, {name: 'Black Widow', strength: 136, sex: 'f'}, {name: 'Vision', strength: 5000, sex: 'm'}, {name: 'Scarlet Witch', strength: 60, sex: 'f'}, {name: 'Mystique', strength: 120, sex: 'f'}, {name: 'Namora', strength: 75000, sex: 'f'},]; 现在假设我们要做的两件事： 找到sex = f的元素 找到strength &gt; 500的元素 如果使用for...of循环的话，是这样的： 123456789101112131415let femaleHeroes = [];for (let hero of heroes) { if (hero.sex === 'f') { femaleHeroes.push(hero); }}let superhumans = [];for (let hero of heroes) { if (hero.strength &gt;= 500) { superhumans.push(hero); }} 由于有重复的地方，那么我们就把不同的地方抽取出来： 123456789101112131415161718192021222324function isFemaleHero(hero) { return (hero.sex === 'f');}function isSuperhuman(hero) { return (hero.strength &gt;= 500);}let femaleHeroes = [];for (let hero of heroes) { if (isFemaleHero(hero)) { femaleHeroes.push(hero); }}let superhumans = [];for (let hero of heroes) { if (isSuperhuman(hero)) { superhumans.push(hero); }} 此时就可以抽象成JavaScript内置的filter函数： 12345678910111213141516function filter(predicate, arr) { let working = []; for (let item of arr) { if (predicate(item)) { working = working.concat(item); } }}const femaleHeroes = filter(isFemaleHero, heroes);const superhumans = filter(isSuperhuman, heroes); Findingfilter搞定了，那么如果我们只要找到一个元素呢。 的确，我们同样可以使用filter函数完成这个目标，比如： 12345function isBlackWidow(hero) { return (hero.name === 'Black Widow');}const blackWidow = heroes.filter(isBlackWidow)[0]; 当然我们也同样会发现，这样的效率并不高。因为filter函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数： 123456789function find(predicate, arr) { for (let item of arr) { if (predicate(item)) { return item; } }}const blackWidow = find(isBlackWidow, heroes); 正如大家所预期那样，JavaScript也同样提供了内置方法find给我们，因此我们最终的代码是这样的： 1const blackWidow = heroes.find(isBlackWidow); 总结这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。 现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点： 摒弃了循环的控制结构，使代码更容易阅读。 通过使用适当的方法名称描述我们正在使用的方法。 减少了处理整个数组的问题，只需要关注我们的业务代码。 在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。 本文翻译自：JavaScript Without Loops","link":"/2017/02/21/javascript-without-loops/"},{"title":"总结JavaScript的检测方式","text":"在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。 我们都知道，JavaScript是有5种原始类型的： number string boolean undefined null 检测原始类型检测原始类型的最佳选择是使用typeof 1234typeof 'abc' // stringtypeof 123 // numbertypeof true // booleantypeof undefined // undefined typeof有一个好处就是：未声明的变量也不会报错 1typeof someVariable //此时someVariable是未定义，返回undefined 检测复合类型复合类型内置有（不只以下几种，只是举例说明）： Object Array Date Error 当我们使用typeof检测的时候，就会看到都是返回object 1234typeof {} //objecttypeof [] //objecttypeof new Date() //objecttypeof new Error() //object 此时的最佳选择是使用instanceof 123var today = new Date()today instanceof Date // true 到这里好像全部的检测类型都搞定了。 但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。 检测函数当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题： 12345678// 在frame A定义的函数testfunction test(){}// 在frame B检测test instanceof Function //false// 而使用typeof则可以正确返回typeof test // function 故检测函数的时候，最佳选择是使用typeof 检测数组数组的问题和函数是一样的，因为不同的构造函数。而此时typeof也不灵了，因为只返回object。 Douglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式： 123function isArray(value){ return typeof value.sort === 'function';} 其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。 最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法： 123function isArray(value){ return Object.prototype.toString.call(value) === '[object Array]' ;} 这个方法能完美地辨别是否为数组。 在ECMAScript 5则可以使用Array的内置方法： 1Array.isArray([]) // true 检测属性我发现，在检测一个对象的属性是否存在的时候，常常是这样的： 123if(object.someProps){ //一些逻辑} 或者是这样的： 123if(object.someProps != null){ //一些逻辑} 或者是这样的： 123if(object.someProps != undefined){ //一些逻辑} 其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用in运算符： 123if(someProps in object){ //一些逻辑} 以上检测数据类型的所有方式。 参考：《Maintainable JavaScript》","link":"/2016/11/15/JavaScript-detect/"},{"title":"我所理解的JavaScript闭包","text":"闭包是JavaScript的一种特性，而不是函数。 闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。 使用场景定义私有变量的时候12345678910function Application() { var password = '123456'; this.getPassword = function(){ return password; }}var app = new Application();app.getPassword(); password此时就是个私有变量，只能通过getPassword获取。 变量作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局和局部（函数）。 Javascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子： 1234567891011121314151617181920var color = 'blue';function changeColor(){ var anotherColor = 'red'; function swapColors() { var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可访问color，anotherColor和tempColor } // 这里可访问color，anotherColor，但不能访问tempColor swapColors();}// 这里只能访问colorchangeColor(); 本文主要参考： Private Members in JavaScript 学习Javascript闭包（Closure）","link":"/2017/03/05/javascript-closure/"},{"title":"web与APP的交互","text":"在移动web开发过程中，一定会遇到web端与APP端交互的情况。下面就来分析下，web端到底是如何与APP端实现交互的。 在APP端，iOS和Andriod的实现方式各不一样。 大家都知道，我们的javascript大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的javascript提供了window,navigator等宿主对象。 Andriod在Android上，实现的方式就和上面这种方式类似，就是在webview上注册一个全局变量，然后我们再js直接调用即可。下面即表示在全局环境下定义了一个对象androidEnv : 1webview.addJavascriptInterface(object, &quot;androidEnv&quot;); web调用AndriodAndriod在webview这个类里面定义的方法，我们在js都可以直接调用，这样就实现了web到Andriod的单向交互了，例如： 1AndriodEnv.sayHi(); //注意：sayHi是Andriod定义的方法 Andriod调用web然后，如果我们要实现Andriod到web的单向交互呢，道理也一样。即是js定义一个全局的函数，然后Andriod就可以直接调用了： 123function globalFunc(){ return 'hello Andriod';} iOS相反在iOS上，则没这么方便了，需要用到一个叫WebViewJavascriptBridge的桥接中间件。 在js上我们需要判断这个bridge是否已经注册，如果有就直接拿来使用；否则就监听一下brideg的变化，然后再使用。因此我们先封装好一个方法： 12345678910function connectWebViewJavascriptBridge(callback) { if (window.WebViewJavascriptBridge) { callback(WebViewJavascriptBridge); } else { document.addEventListener('WebViewJavascriptBridgeReady', function() { callback(WebViewJavascriptBridge); }, false); }; } 之后我们用一个callback来处理这个bridge： 12345connectWebViewJavascriptBridge(function(bridge) { bridge.init(function(data, responseCallback) {}); }); 到这个时候，基础工作就做完了，接下来就是web与iOS之间的交互了。 web调用iOS123bridge.callHandler('ObjC Echo', {'key':'value'}, function responseCallback(responseData) { console.log(&quot;JS received response:&quot;, responseData)}) 其中，ObjC Echo是iOS上的对应方法（其实并不是函数，只是一个token），{'key':'value'}则是web传到iOS的参数，responseData则是iOS回传的数据。 这里还有另外一种方法，就是我们可以直接利用bridge的send方法，直接将所有东西都send过去给iOS即可，例如： 12345678910111213var param = { &quot;functionName&quot; : &quot;share&quot;, &quot;params&quot;:{ &quot;title&quot; : opt.title, &quot;desc&quot; : opt.desc }};connectWebViewJavascriptBridge(function(bridge) { bridge.send(param);}); send可以接受两个参数，第二个参数就是回调函数了： 12345678connectWebViewJavascriptBridge(function(bridge) { bridge.send(param, function(data){ callback(data); });}); iOS调用web1234bridge.registerHandler('JS Echo', function(data, responseCallback) { console.log(&quot;JS Echo called with:&quot;, data) responseCallback(data)}) 这里的JS Echo则是JS上注册的一个方法名，当iOS执行玩这个方法，我们就可以马上监听到并接受到一些数据data，之后我们还可以执行responseCallback回调iOS告诉它我们的处理情况。 说说js代码知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。 12345678910111213141516171819202122232425262728293031jAPP = { getUserName: function(){ if(inAPP) { if(iOS){ //... } if(Andriod){ //... } } else { //... console.log('请在APP内打开') } }, getUserId: function(){ if(inAPP) { if(iOS){ //... } if(Andriod){ //... } } else { //... console.log('请在APP内打开') } }} 我认为的缺点： 重复判断设备信息，因为设备信息可以理解成常量，一经获取就不会更改，所以我们可以用初始化分支来优化。 重复判断是否在APP内。同样可以采用初始化分支来优化，也就是说不在APP内的话，调用的方法都不需要初始化了。 console.log没有意义，只有在测试环境下能有，上生产应该去除。 优化12345678910111213141516171819202122232425262728var ua = navigator.userAgent().toLowerCase();var inIOS = !!( ua.indexOf('iphone') &gt; -1 || ua.indexOf('ipad') &gt; -1 );var inAndriod = !!( ua.indexOf('andriod') &gt; -1 );var inAPP = !!( ua.indexOf('your APP token') &gt; -1 );var jAPP = {};if(inAPP) { if(inIOS) { jAPP.getUserId = function(){ //.. }; jAPP.getUserName = function(){ //.. }; } else if(inAndriod) { jAPP.getUserId = function(){ //.. }; jAPP.getUserName = function(){ //.. }; }} 初始化分支的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。好处在于不用重复判断分支。 如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。 参考： JS与WebView交互存在的一些问题 WebViewJavascriptBridge","link":"/2016/09/26/interact-with-app/"},{"title":"使用HTML发送邮件","text":"最近项目上的需求是在HTML上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。 使用方法 直接用a标签，然后href属性设置协议为mailto即可。然后后面可以跟一些参数 1&lt;a href=&quot;mailto:xxx@qq.com?subject=这是标题&amp;cc=这是抄送&amp;body=这是正文内容&quot;&gt;发送邮件&lt;/a&gt; 其实和上面的方法差不多，不过是换了提交的方式，就是使用form表单，然后在form的action属性设置协议mailto即可。 123456&lt;form action=&quot;mailto:xxx@qq.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;cc&quot; value=&quot;这是抄送&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;subject&quot; value=&quot;这是标题&quot;&gt; &lt;textarea name=&quot;body&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;这是内容&lt;/textarea&gt; &lt;button type=&quot;submit&quot;&gt;发送邮件&lt;/button&gt;&lt;/form&gt; 如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如： 1&lt;a href=&quot;mailto:xxx@qq.com,yyy@qq.com&quot;&gt;发送邮件&lt;/a&gt; 存在的问题很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。 由于需求的问题，需要自由输入邮件的内容，所有就没使用a标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题： 在textarea的内容格式提交到邮件系统就乱了（换行什么的丢失了） 在ios上出现的问题：点击发送的时候，safari浏览器提示“这是一张不安全的表单”。 分析： 出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用encodeURIComponent编码一下textarea的内容即可。 出现问题2：则是因为在生产上，我们是使用https协议的，如果表单提交到mailto这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉form表单的提交，自己使用location.href跳转（与此同时编码一下textarea的内容，则完美解决以上两个问题），这时就类似a标签的方式了。（其实这个时候倒不如使用a标签提交） 无法解决的问题 在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起） 参考 HTML的电子邮件链接标签mailto用法详解","link":"/2016/09/12/html-send-email/"},{"title":"如果使用Node.js的Buffers","text":"为什么要有Buffers？在纯JavaScript开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让JavaScript需要处理纯二进制数据了。 其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。 所以，记住了，别使用二进制字符串(binary strings)，用buffers代替它！ 什么是Buffers？在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。 每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。 另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1) 在哪里可以看到buffers一般情况，buffer经常可以在读取二进制数据流的时候看到，比如fs.createReadStream 用法：创建buffer有许多方法可以生成新的buffers： 1var buffer = new Buffer(8); 这个buffer是未初始化的，且包含8个字节(bytes)。 1var buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]); 这个buffer用一个数组的内容来初始化。记住了，数组里的数字表示的是字节(bytes) 1var buffer = new Buffer(&quot;I'm a string!&quot;, &quot;utf-8&quot;) 通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码： “ascii”：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。 “ucs2”：一种双字节，小端存储的编码。可以编码一个unicode的子集。 “base64”：Base64字符串编码。 “binary”：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。 写入buffer创建一个buffer：1&gt; var buffer = new Buffer(16); 开始写入字符串： 12&gt; buffer.write(&quot;Hello&quot;, &quot;utf-8&quot;)5 buffer.write的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。 buffer.write返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要： 12&gt; buffer.write(&quot; world!&quot;, 5, &quot;utf-8&quot;)7 当buffer.write有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。 读取buffertoString：这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本： 12&gt; buffer.toString('utf-8')'Hello world!\\u0000�k\\t' 再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串： 12&gt; buffer.toString(&quot;utf-8&quot;, 0, 12)'Hello world!' 独立字节：你可以看到用类似数组的语法来设置独立位(individual bits) 12345678910&gt; buffer[12] = buffer[11];33&gt; buffer[13] = &quot;1&quot;.charCodeAt();49&gt; buffer[14] = buffer[13];49&gt; buffer[15] = 3333&gt; buffer.toString(&quot;utf-8&quot;)'Hello world!!11!' 在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。 更多有趣用法Buffer.isBuffer(object)这个方法是检测一个对象是否是buffer，类似于Array.isArray Buffer.byteLength(string, encoding)通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如： 12345&gt; var snowman = &quot;☃&quot;;&gt; snowman.length1&gt; Buffer.byteLength(snowman)3 这个unicode的雪人只有两个字符，却占了3个字节。 buffer.length这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如： 12345&gt; var buffer = new Buffer(16)&gt; buffer.write(snowman)3&gt; buffer.length16 在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。 buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)buffer.copy允许拷贝一个buffer的内容到另一个buffer。 第一个参数表示目标buffer，就是要写入内容的buffer。 另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子： 12345678&gt; var frosty = new Buffer(24)&gt; var snowman = new Buffer(&quot;☃&quot;, &quot;utf-8&quot;)&gt; frosty.write(&quot;Happy birthday! &quot;, &quot;utf-8&quot;)16&gt; snowman.copy(frosty, 16)3&gt; frosty.toString(&quot;utf-8&quot;, 0, 19)'Happy birthday! ☃' 在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。 其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。 buffer.slice(start, end=buffer.length)这个方法的API可以说和Array.prototype.slice是一样的。 不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例： 1234567&gt; var puddle = frosty.slice(16, 19)&gt; puddle.toString()'☃'&gt; puddle.write(&quot;___&quot;)3&gt; frosty.toString(&quot;utf-8&quot;, 0, 19)'Happy birthday! ___' 完。","link":"/2017/10/06/how-to-use-buffers/"},{"title":"操作浏览器历史 HTML5 History API","text":"在DOM中，window对象中有一个history的对象可以用来访问浏览器的历史记录，在HTML5中，更可以通过它来操作历史记录 以前的API历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮） 12history.forward(); //前进history.back(); //后退 移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页） 12history.go(-1) //相当于history.back();history.go(1) //相当于history.forward(); 其中，history有一个length的属性，就是历史记录的长度 1var historyLength = history.length; 更强大的HTML5 Histroy API history.pushState() history.replaceState()两个方法配合window.onpopstate事件使用更佳。 其中，pushState()方法接受三个参数 状态对象（state obejct）即一个可序列化的javascript对象，与新历史记录相关联。可以使用history.state读取当前历史记录相关的数据对象。 标题（title）目前暂时会忽略这个参数，以后可能会用上。 地址（URL）新的历史记录的地址。 举个例子，假设我们现在打开的是index.html 1234var stateObj = { country: 'China' };setTimeout(function(){ history.pushState(stateObj, 'china', 'china.html');}, 1000); 页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的history.state就是stateObj的拷贝，此时我们就可以利用这个数据来进行相关的操作了。如果此时我们点击后退，则URL变成index.html，此时history.state=null 说到这里，你应该会有点困惑，好像这个API并没什么卵用，直接用hash配合window.onhashchange就可以做到啦，类似如下 1location.href = 'www.someURL.com#/china.html?country=china'; 上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应伪URL的相关的数据。 不过对比而言，pushState也有它的优势： 使用hash的方式时，如果当前hash的值不变（即url=’www.someURL.com#foo'时，设置location.href = ‘www.someURL.com#foo'），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同 url 时则会创建新的历史记录。 绑定相关数据时，history.state可以说是可以绑定任意数据，而基于hash的方式则要把所有数据转换成相关的字符串 replaceState()使用方法和pushState()基本一致。不同的是，replaceState()方法会修改当前历史记录而不是创建新的历史记录 相关DEMO，敬请期待。。。","link":"/2016/07/05/h5-history-api/"},{"title":"开始拥抱gulp","text":"前端工作流中常用的构建工具除了grunt，还有一个gulp(当然现在还有webpack)。gulp是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于nodejs流的构建工具，而且执行很快。 既然有了grunt，为啥还要来学习gulp呢？这是一个好问题，用过grunt的都知道，每次写Gruntfile.js的时候，都要先写一大片的配置文件，而gulp和grunt最大的差别在于，gulp是执行代码覆盖配置的。这样的好处在于，gulpfile.js很容易写，而且阅读起来清晰明了，并且容易维护。 gulp使用node.js的流(stream)，这让gulp构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看这篇文章（写得很好） gulp允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像grunt那样，为每一个grunt都写一些配置信息和输入输出路径。让我们看下使用grunt和gulp写的Sass编译： Grunt: 123456789101112131415161718192021222324sass: { dist: { options: { style: 'expanded' }, files: { 'dist/assets/css/main.css': 'src/styles/main.scss', } }},autoprefixer: { dist: { options: { browsers: [ 'last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4' ] }, src: 'dist/assets/css/main.css', dest: 'dist/assets/css/main.css' }},grunt.registerTask('styles', ['sass', 'autoprefixer']); Grunt需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到Sass插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给Autoprefixer输入，然后我们再将文件输出保存起来。 gulp: 12345gulp.task('sass', function() { return sass('src/styles/main.scss', { style: 'expanded' }) .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4')) .pipe(gulp.dest('dist/assets/css'))}); 使用gulp的时候，我们只需要输入一个文件，然后经过Sass插件修改，然后经过Autoprefixer插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。 安装Gulp在我们钻研配置任务信息之前，我们需要安装gulp： 1$ npm install gulp -g 以上命令会在全局环境上安装gulp，让我们可以使用gulp命令行。然后，我们需要在项目文件夹内安装本地的gulp，cd到你的项目路径，然后运行一下命令(执行命令前需确保项目下有package.json这个文件) 1$ npm install gulp --save-dev 以上命令会在项目内安装本地的gulp并保存到package.json里的devDependencies 安装gulp插件我们需要安装一些插件来完成以下的任务： 编译sass (gulp-ruby-sass) 自动添加厂商前缀 (gulp-autoprefixer) 压缩CSS (gulp-cssnano) js检测 (gulp-jshint) 合并文件 (gulp-concat) 压缩JS (gulp-uglify) 压缩图片 (gulp-imagemin) 动态加载 (gulp-livereload) 缓存图片然后只压缩改变后的图片 (gulp-cache) 提示信息 (gulp-notify) 清除文件 (del) 通过以下命令来安装这些插件： 1npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev 这将会安装全部需要的插件并将它们保存到package.json的devDependencies里面。你可以在这里找到gulp的全部插件。 加载插件之后，我们要创建一个文件夹gulpfile.js并加载这些插件： 12345678910111213var gulp = require('gulp'), sass = require('gulp-ruby-sass'), autoprefixer = require('gulp-autoprefixer'), cssnano = require('gulp-cssnano'), jshint = require('gulp-jshint'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), rename = require('gulp-rename'), concat = require('gulp-concat'), notify = require('gulp-notify'), cache = require('gulp-cache'), livereload = require('gulp-livereload'), del = require('del'); 这个时候，看起来是不是好像需要写的东西比grunt还多？其实，gulp插件和grunt插件有略微的不同——gulp插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，grunt的imagemin使用缓存来避免压缩已经压缩过的图片；而gulp则需要cache插件来协助完成这样的任务，当然cache插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？ 我们同样可以像grunt那样自动加载所有已安装的插件，不过为了这篇文章，我们就将坚持纯手工工艺！ 创建任务Compile Sass, Autoprefix and minify首先，我们先配置Sass编译，然后使用Autoprefixer添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给cssnao压缩成一个.min版本，最后再输出到另一个目的地，最后的最后调用notify提示我们任务完成了： 123456789gulp.task('styles', function() { return sass('src/styles/main.scss', { style: 'expanded' }) .pipe(autoprefixer('last 2 version')) .pipe(gulp.dest('dist/assets/css')) .pipe(rename({suffix: '.min'})) .pipe(cssnano()) .pipe(gulp.dest('dist/assets/css')) .pipe(notify({ message: 'Styles task complete' }));}); 继续往下讲之前，有一点东西需要解释一下： 1gulp.task('styles', function() {...}); 这里的gulp.taskAPI是用来创建任务的。我们在命令行工具中可以使用$ gulp styles运行上面的任务。 1return sass('src/styles/main.scss', { style: 'expanded' }) 这里是一个新的gulp-rubu-sassAPI，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用gulp.srcAPI来代替（在文章的下部分你将会看到）这同样可以使用glob pattern，比如：/**/*.scss来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.) 1.pipe(autoprefixer('last 2 version')) 我们通过.pipe()来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。 1.pipe(gulp.dest('dist/assets/css')); 这里的gulp.destAPI我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出expanded version(正常大小版本)，另一个输出minifed version(压缩版本) 我建议去看下gulp的API文档来更好地理解这些方法，它并不像听起来那么吓人！ JSHint, concat, and minify JavaScript希望你现在对如何创建一个gulp任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件： 1234567891011gulp.task('scripts', function() { return gulp.src('src/scripts/**/*.js') .pipe(jshint('.jshintrc')) .pipe(jshint.reporter('default')) .pipe(concat('main.js')) .pipe(gulp.dest('dist/assets/js')) .pipe(rename({suffix: '.min'})) .pipe(uglify()) .pipe(gulp.dest('dist/assets/js')) .pipe(notify({ message: 'Scripts task complete' }));}); 这里我们就是用gulp.srcAPI来指定我们的输入文件。有一件事情需要注意的是，我们需要为JSHint指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在JSHint官网找到更多的信息。 Compress Images接下来，我们设置图片压缩。 123456gulp.task('images', function() { return gulp.src('src/images/**/*') .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })) .pipe(gulp.dest('dist/assets/img')) .pipe(notify({ message: 'Images task complete' }));}); 这里我们将拿到一些图片，然后导到imagemin插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的gulp-cache插件。为了实现这个，我们需要改变这一行： 1.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })) 改成： 1.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true }))) 现在就只用新的图片和改变过的图片会被压缩了，nice吧？ Clean up!在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录： 123gulp.task('clean', function() { return del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img']);}); 这里我们不需要使用gulp的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.） The default task我们定义的default任务可以直接使用$ gulp运行，比如： 123gulp.task('default', ['clean'], function() { gulp.start('styles', 'scripts', 'images');}); 需要注意到的是，我们添加了一个数组到gulp.task上，在这里我们可以定义任务依赖。在这里例子里，clean任务将会在gulp.start之前先运行。gulp里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保clean任务完成之后才开始其他的任务。 注意： 建议是的不要在依赖任务中使用gulp.start，不过在这个脚本里为了确保clean完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option） watch监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用gulp.watchAPI来开始监听文件。 123456789101112gulp.task('watch', function() { // Watch .scss files gulp.watch('src/styles/**/*.scss', ['styles']); // Watch .js files gulp.watch('src/scripts/**/*.js', ['scripts']); // Watch image files gulp.watch('src/images/**/*', ['images']);}); 我们可以通过gulp.watchAPI来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行$ gulp watch，然后修改一下对应监听目录下的文件，就将会执行对应的任务。 LiveReloadgulp同样可以在文件修改的时候刷新页面，我们需要修改我们的watch任务来配置LiveReload服务： 123456789gulp.task('watch', function() { // Create LiveReload server livereload.listen(); // Watch any files in dist/, reload on change gulp.watch(['dist/**']).on('change', livereload.changed);}); 为了让实现这个梦想，你需要安装和启用LiveReload的浏览器插件。或者你也可以手动的添加这些东西 合并所有代码现在你拥有了一个完整的gulpfile了， 它来自于这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*! * gulp * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev */// Load pluginsvar gulp = require('gulp'), sass = require('gulp-ruby-sass'), autoprefixer = require('gulp-autoprefixer'), cssnano = require('gulp-cssnano'), jshint = require('gulp-jshint'), uglify = require('gulp-uglify'), imagemin = require('gulp-imagemin'), rename = require('gulp-rename'), concat = require('gulp-concat'), notify = require('gulp-notify'), cache = require('gulp-cache'), livereload = require('gulp-livereload'), del = require('del');// Stylesgulp.task('styles', function() { return sass('src/styles/main.scss', { style: 'expanded' }) .pipe(autoprefixer('last 2 version')) .pipe(gulp.dest('dist/styles')) .pipe(rename({ suffix: '.min' })) .pipe(cssnano()) .pipe(gulp.dest('dist/styles')) .pipe(notify({ message: 'Styles task complete' }));});// Scriptsgulp.task('scripts', function() { return gulp.src('src/scripts/**/*.js') .pipe(jshint('.jshintrc')) .pipe(jshint.reporter('default')) .pipe(concat('main.js')) .pipe(gulp.dest('dist/scripts')) .pipe(rename({ suffix: '.min' })) .pipe(uglify()) .pipe(gulp.dest('dist/scripts')) .pipe(notify({ message: 'Scripts task complete' }));});// Imagesgulp.task('images', function() { return gulp.src('src/images/**/*') .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))) .pipe(gulp.dest('dist/images')) .pipe(notify({ message: 'Images task complete' }));});// Cleangulp.task('clean', function() { return del(['dist/styles', 'dist/scripts', 'dist/images']);});// Default taskgulp.task('default', ['clean'], function() { gulp.start('styles', 'scripts', 'images');});// Watchgulp.task('watch', function() { // Watch .scss files gulp.watch('src/styles/**/*.scss', ['styles']); // Watch .js files gulp.watch('src/scripts/**/*.js', ['scripts']); // Watch image files gulp.watch('src/images/**/*', ['images']); // Create LiveReload server livereload.listen(); // Watch any files in dist/, reload on change gulp.watch(['dist/**']).on('change', livereload.changed);}); 我也使用grunt写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。拿好了，不送了 本文翻译自：Getting started with gulp","link":"/2016/09/23/getting-started-with-gulp/"},{"title":"前端路由","text":"路由一直都是后端控制的，然而，其实我们前端也可以使用hash实现我们前端自己的路由。下面的代码就是参考他人代码实现的： 12345678910111213141516171819202122232425262728var router = { routes: {}, currentUrl: '', lastPanel: ''};router.init = function(){ window.addEventListener('load', this.update.bind(this), false); window.addEventListener('hashchange', this.update.bind(this), false);};router.add = function(path, callback){ this.routes[path] = callback;};router.update = function(){ this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl]();}if(this === window &amp;&amp; typeof window.document !== 'undefined') { window.router = router;}else if(typeof define === 'function') { define('router', [], function(){ return router; })}","link":"/2015/09/21/front-end-router/"},{"title":"ES6 Promise","text":"由于js的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。ES6(也叫ES2015)为了解决这个问题提出了Promse对象。 出现Promise的原因当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。 123456789101112$.ajax({ //...}).then(function (data) { // 要在第一个请求成功后才可以执行下一步 $.ajax({ //... }) .then(function (data) { // ... });}); 缺点： 回调地狱，多个操作的时候就要无限嵌套回调函数了 如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了 什么是Promise？一个Promise对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了Promise对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。 resolve和reject1234567891011121314function helloWorld (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(&quot;Hello World!&quot;); } else { reject(&quot;Good bye!&quot;); } });}helloWorld(true).then(function (message) { alert(message);}, function (error) { alert(error);}); resolve 方法可以使Promise对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 Hello World! 字符串。reject 方法则是将Promise对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。 promise三种状态上面提到了 resolve 和 reject 可以改变Promise对象的状态，那么它究竟有哪些状态呢？Promise对象有三种对象1 Fulfilled 可以理解为成功的状态2 Rejected 可以理解为失败的状态3 Pending 可以理解为Promise对象实例创建时候的初始状态 then和catchhelloWorld 的例子当中利用了 then(onFulfilld, onRejected) 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。 123456789101112131415161718192021function printHello (ready) { return new Promise(function (resolve, reject) { if (ready) { resolve(&quot;Hello&quot;); } else { reject(&quot;Good bye!&quot;); } });}function printWorld () { alert(&quot;World&quot;);}function printExclamation () { alert(&quot;!&quot;);}printHello(true) .then(function(message){ alert(message); }) .then(printWorld) .then(printExclamation); catch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected 函数的一个简单的写法，也就是说可以写成then(fn).catch(fn)，相当于 then(fn).then(null, fn)。使用 catch 的写法比一般的写法更加清晰明确。 Promise.all 和 Promise.racePromise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。 12345678910111213var p1 = new Promise(function (resolve) { setTimeout(function () { resolve(&quot;Hello&quot;); }, 3000);});var p2 = new Promise(function (resolve) { setTimeout(function () { resolve(&quot;World&quot;); }, 1000);});Promise.all([p1, p2]).then(function (result) { console.log(result); // [&quot;Hello&quot;, &quot;World&quot;]}); Promise.race 在promise数组中任何一个promise对象变成resolve或者reject，马上执行函数 123456789101112131415161718// `delay`毫秒后执行resolvefunction timerPromisefy(delay) { return new Promise(function (resolve) { setTimeout(function () { resolve(delay); }, delay); });}// 任何一个promise变为resolve或reject 的话程序就停止运行Promise.race([ timerPromisefy(1), timerPromisefy(32), timerPromisefy(64), timerPromisefy(128)]).then(function (value) { console.log(value); // =&gt; 1}); 特殊地方： 12345678var promise = new Promise(function (resolve){ console.log(&quot;inner promise&quot;); // 1 resolve(42);});promise.then(function(value){ console.log(value); // 3});console.log(&quot;outer promise&quot;); // 2 输出结果是：inner promise -&gt; outer promise -&gt; 42","link":"/2016/08/05/es6-promise/"},{"title":"探索CSS盒模型","text":"从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。 现在开发基本遇到的基本样式(CSS)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。 块级元素毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图： 水平格式化水平方向的大小也是有些复杂，主要一个原因是width影响的是内容(content)区域的宽度，而不是整个可见的元素框。 大多数开发者以为，widht指的就是可见元素框的宽度，其实不是这样的(不过CSS3的box-sizing可以修改盒模型，这里暂不讨论)。 可见元素框的宽 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right 知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。 以上7个属性中，只有margin-left、margin-right和width这三个属性可以设置为auto，其他必须设置特定的值或0 使用auto首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的width。 设置一个auto假定父元素width: 400px 12345p { magrin-left: auto; /* 等于200px */ margin-right: 100px; width: 100px;} 此时margin-left就是弥补剩余的宽度即400-100-100=200 不设置auto如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的width: 12345p { magrin-left: 100px; margin-right: 100px; /* 等于200px */ width: 100px; } 其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(overconstrained)，因此此时的margin-right会被强制设置成auto，即margin-right=200px而不是我们想当然的那样等于100px。 (ps:在英语这种从左向右读的语言是强制设置marin-right，而在从右向左的语言则是强制设置margin-left为auto了) 设置两个auto首先先考虑常用的，设置两个margin为auto，此时就可以实现水平居中的效果。 如果设置其中一个margin和width为auto的话，margin的值则会减为0，而widht会水平延伸直至充满父元素。 设置三个auto即margin-left、margin-right和widht都为auto。此时和上面那个例子比较类似，就是margin都减为0，width则填满父元素。 负的margin值前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子： 12345678910.parent { widht: 400px; border: 2px solid black;}.child { margin-left: 10px; width: auto; margin-right: -50px;} 这个时候child这个子元素的widht是多少呢？ 根据前面提到的算法可以得到：10px + 0 + 0 + width + -50px = 400px，此时可以得到width=440px 另外需要注意的是：padding、border和width都不能设置为负值。 垂直格式化垂直方向和水平的大部分都比较类似，比如： 可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom 如果此时子元素的height大于父元素的height时，具体效果就要取决于overflow属性的值了，这里暂不讨论。 有一点不一样的是：margin-top和margin-bottom设置为auto的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。 设置margin-top、margin-bottom经常会有这么一个情况：子元素设置了margin-top或者margin-bottom，但是父元素不会撑开这部分的margin高度，这部分出现在父元素以外: 123&lt;div class=&quot;parent&quot; style=&quot;background-color: silver&quot;&gt; &lt;p class=&quot;child&quot; style=&quot;margin-top: 100px; margin-bottom: 100px&quot;&gt;test&lt;/p&gt;&lt;/div&gt; 此时效果是这样的： 因为块级元素只有块级子元素的话，其高度是子元素的border-top + padding-top + height + padding-bottom + border-bottom的总和。 但是如果该块级元素有padding或者border的话，则其高度等于子元素的margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom总和。比如： 123&lt;div class=&quot;parent&quot; style=&quot;background-color: silver; border: 1px solid black&quot;&gt; &lt;p class=&quot;child&quot; style=&quot;margin-top: 100px; margin-bottom: 100px&quot;&gt;test&lt;/p&gt;&lt;/div&gt; 合并margin-top和margin-bottom众所周知的是，如果有上下两个元素，上元素的margin-bottom和下元素的margin-top是会合并的，大小等于这两个的最大值。 这时又有一个例外，就是如果元素含有padding或者border的话，则不会合并。","link":"/2017/08/16/css-box-model/"},{"title":"CSS background","text":"WEB开发常用到background但是没有去深究，仔细看了之后，发现background里面的知识点还是挺多不懂的。 background-size设置背景图大小[初始值auto auto-非继承-适用所有元素] 1backgrount-size: (&lt;length&gt; | &lt;percentage&gt; | auto){1,2} | contain | cover length：直接指定背景图大小 percentage：指定背景图片相对背景区的百分比 auto：以背景图片的比例缩放背景图片 contain：缩放背景图片以完全装入背景区，可能背景区部分空白。 cover：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。 补充： &lt;length&gt;/&lt;percentage&gt;/auto 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成auto 逗号分隔的多个值：设置多重背景 contain/cover 会保留图片的原来比例 background-origin规定了指定背景图片background-image属性的原点位置的背景相对区域[初始值padding-box-非继承-适用所有元素] 1backgrount-origin: border-box | padding-box | content-box border-box: 背景图将显示在border上，设置border-style:dashed即可以看到效果 padding-box: 背景图将显示到padding上。 content-box: 背景图只显示在内容区域 如果还不明白，可以看这个例子 补充： 当使用 background-attachment 为fixed时，该属性将被忽略不起作用。 background-clip效果同上面的background-origin，差别在于指定的是背景色不是图片 例子才此，可以和上面对比一下 background-attachment如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的[初始值scroll-非继承-适用所有元素] 1background-attachment: scroll | fixed | local scroll： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。 fixed：表示背景相对于视口固定 local：表示背景相对于元素的内容固定。 解释： fixed和其他两个的差别在于：fixed是相对于视窗（可以理解成屏幕）固定的。 scroll和local的差别在于：scroll在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而local则是跟着滚动的。可以看下根据MDN改编的例子 background-position指定背景图片的初始位置[初始值0% 0%-非继承-适用所有元素] 12background-position: (top, bottom, left, right){1,2} | &lt;percentage&gt; | &lt;length&gt; top: 等于垂直方向的0% bottom：等于垂直方向的100% left：等于水平方向的0% right：等于水平方向的100%","link":"/2015/10/17/css-background/"},{"title":"从零开始，部署一个Web应用（三）Vue.js &amp; Redis","text":"这篇文章，就总结一些Vue.js和Redis遇到的问题。 Vue.js非index页面刷新报404由于采用了Vue-router前端路由。因此在非index页面刷新会出现404的问题。 原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。 以下是nginx的解决方案： 1234567891011server { listen 80; server_name favweb.cn; access_log off; root /home/vuejs/dist; location / { try_files $uri $uri/ /index.html; }} 页面统计问题由于Google Analytics的不可用，采用的是百度统计。 发现统计数据都是只有主页，因此又是因为SPA的问题。 解决方案是在前端路由切换的时候，手动调用PV追踪代码： 1_hmt.push(['_trackPageview', pageURL]); Vuejs的配置为： 123456789import Router from 'vue-router'const router = new Router(config)router.afterEach((to, from, next) =&gt; { try { window._hmt.push(['_trackPageview', to.path]) } catch (e) { }}) Redis安装：1234wget http://download.redis.io/releases/redis-4.0.2.tar.gztar xzf redis-4.0.2.tar.gzcd redis-4.0.2make 常用配置以MacOS的homebrew安装方式为例。其中redis.conf文件在/usr/local/etc/。 后台运行12345# 原来daemonize no# 改成daemonize yes 增加密码找到requirepass，去掉前面的注释符号#，后面改成自己的密码 12345#原来#requirepass yourPassword#改成requirepass yourPassword 远程访问找到bind，将127.0.0.1改成0.0.0.0即可。 因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。 因此要开启这个之前，一定要先设置好密码。","link":"/2017/10/27/about-deploly-favweb-3/"},{"title":"从零开始，部署一个Web应用（二）MongoDB &amp; nginx","text":"这篇文章，就总结一些部署MongoDB和nginx遇到的问题。 MongoDB安装的是社区版本(MongoDB Community Edition)。 安装先创建Mongodb在yum的配置文件： 123456[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc 可动态改变版本号 然后使用yum安装： 1sudo yum install -y mongodb-org 安全相关如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。 在MongoDB中，常用的是增加用户访问限制。 高级管理员第一步，是先创建一个高级管理员。这个高级管理员可管理其他用户： 12345678&gt; use admin&gt; db.createUser( { user: &quot;myUserAdmin&quot;, pwd: &quot;abc123&quot;, roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ] }) 注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。 可以这样以该角色进入MongoDB的命令行： 1mongo --port 27017 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot; 增加其他用户MongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入test数据库： 1use test 然后创建角色时，设置账户，密码以及对应的数据库权限，比如： 12345678db.createUser( { user: &quot;testAdmin&quot;, pwd: &quot;abc123&quot;, roles: [ { role: &quot;readWrite&quot;, db: &quot;test&quot; }, { role: &quot;read&quot;, db: &quot;reporting&quot; } ] }) nginx安装nginx之前，需要先将nginx的依赖安装完： gcc 安装：yum install gcc-c++ PCRE pcre-devel 安装：yum install -y pcre pcre-devel zlib 安装: yum install -y zlib zlib-devel OpenSSL 安装: yum install -y openssl openssl-devel 安装123456789101112131415161718# 下载Nginxwget -c https://nginx.org/download/nginx-1.10.1.tar.gz# 解压：tar -zxvf nginx-1.10.1.tar.gz# 进入nginx解压目录cd nginx-1.10.1 # 配置：./configure# 编译安装:makemake install# 查找安装路径：whereis nginx 环境变量因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用nginx命令。 设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下： 1cp /usr/local/nginx/sbin/nginx /usr/local/bin 假设上面的whereis nginx返回的是/usr/local/nginx 开启SSL模块切换到安装的源码包，我是安装在/usr/local/src/nginx-1.11.3。 修改配置： 1./configure --prefix=/usr/local/nginx --with-http_ssl_modul 执行make之后，切记不要执行make install，否则就覆盖安装了。 先备份已安装好的nginx: 1cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak 然后关闭已启动的nginx： 123# 查看进程号ps -ef|grep nginxkill -QUIT [进程号] 将刚刚编译好的nginx覆盖掉原有的nginx: 1cp ./objs/nginx /usr/local/nginx/sbin/ 启动nginx，仍可以通过命令查看是否已经加入成功 1/usr/local/nginx/sbin/nginx -V","link":"/2017/10/21/about-deploly-favweb-2/"},{"title":"从零开始，部署一个Web应用（一）","text":"起始篇，先介绍一个整个系列文章涉及到的开发环境，技术盏。 环境开发环境： 设备：MacBook Pro 2015环境：Node.js v8.9.3 + WebPack v3.0IDE：Sublime Text + Visual Studio Code 生产环境： 设备：腾讯云CVM(香港)系统：CentOS 7.2 64位 技术盏前端采用了Vue.js + Vue-router + Element-UI 采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。 而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。 后端采用 Node.js + Think.js 因为个人技术盏限制，故采用比较擅长的Node.js。 采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。 数据库采用MongoDB + Redis MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。 Redis是用来保存Session，邀请码等数据。 服务器部署：Nginx + Node.js反向代理 利用Nginx来实现负载均衡 代码管理：Coding 由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。","link":"/2017/10/14/about-deploly-favweb-1/"},{"title":"JavaScript 内存管理","text":"JavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。 内存生命周期不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读／写） 不需要时将其回收 其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。 垃圾回收JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。 我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种： － Reference-counting（引用计数）－ Mark-and-sweep（标记清除） 引用一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。 引用计数其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决循环引用的问题： 123456var div;window.onload = function(){ div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);}; 这时DOM 元素myDivElement就永远不会被回收了。 标记清除这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象window。 然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。 这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。 这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。 本文主要内容参考：Memory Management","link":"/2017/03/05/memory-management/"},{"title":"组件封装的思考","text":"前言在小程序开发的早期，是没有 **自定义组件(component)**，仅有 自定义模板(template) 的。最早接触到组件开发还是在使用 React、Vue 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多 为什么要有组件？对于这个问题，很多人的第一反应也许是：代码复用 的确，代码复用是组件的核心职责，但它还有更大的使命：性能 因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果 生命周期在 Vue 中，每个页面是一个 Vue 实例，而组件又是可复用的 Vue 实例，因此可以理解成，页面和组件是相同的生命周期 而小程序就将页面和组件拆分成两个类：Page 和 Component，因此接收的生命周期函数也是不一样的。比如，Page 接收的是：onLoad、onShow、onReady等函数，而 Component 则接收 created、attached、ready 等函数 命名风格都不一致，真是让人头大 数据传递VueVue 的组件间数据传递的机制是这样的：父组件通过property传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件 在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境 为了解决这个问题，Vue 推出了 Vuex 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念： 小程序小程序同样有类似的机制，property和事件。此外还提供了获取 子组件实例 的方法：selectComponent() 和 定义组件间关系的字段 relations 其中常用的就是获取子组件实例，比如: 123&lt;parent-component&gt; &lt;child-component id=&quot;child&quot;&gt;&lt;/child-component&gt;&lt;/parent-component&gt; 此时，在parent-component组件中可以直接获取child-component的实例： 1234567Component({ attached() { let $child = this.selectComponent('#child') // $child.doSomeThing() }}) 实战背景 制作一个 对话框(modal) 组件 也许有的读者会感到困惑，官方不是有提供 wx.showModal 可以直接用吗，为什么要重复造轮子 其实，当你的产品想要结合 Modal 和 Button 的 open-type 能力时，你就会明白重复造轮子的必要性以及wx.showModal的局限性 属性定义对话框的常见属性可以参考wx.showModal 除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：visible 此时，有两种选择，第一种是将这个变量存在页面上，通过property传递给Modal组件；另外一种，就是作为Modal组件data中的一员 property传递通过property传递的话，就相当于将 Modal 的控制权交到对应的页面，举例： 123&lt;!-- home.wxml --&gt;&lt;modal visible=&quot;{{visible}}&quot; /&gt; 12345678910// home.jsPage({ data: { visible: false }, toggleModal() { this.setData({ visible: !this.data.visible }) }}) 此时对应的 Modal： 12345678910111213// modal.jsComponent({ properties: { visible: { type: Boolean, value: false, observer(newVal, oldVal) { this.setData({ visible: newVal }) } } }}) 这里和Vue框架有个差异，Vue对于传进来的property会自动赋值，而小程序则需要自己手动赋值 问题与办法当 visible 这个变量被 Modal 和 Page 同时使用时，会出现不显示的问题。 为了便于描述，我通过描述真实场景来讲解： 当页面需要显示对话框时，Page 传递 visible=true 给 Modal 经过一段时间之后，用户关闭了对话框，此时 Modal 将自身的 visible 设置为 false 当页面需要再次出现对话框时，Page 继续传递visible=true 给 Modal，此时发现对话框不会显示 通过分析可以发现，由于 Page 两次传递相同的 visible=true 给 Modal ，因此第二次传递的时候，被 Modal 直接忽略掉了。 这个问题也很好解决，大致思路就是保证每次传递的值不同即可： 传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便） 利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如{ visible: true } !== { visible: true }) 组件自身属性这种是我推荐的方案。将 visible 属性交由组件 Modal 自行管理： 123456789101112// modal.jsComponent({ data: { visible: false }, methods: { show() { this.setData({ visible: true }) } }}) 由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的setData，如： 123let $modal = this.selectComponent('#modal')$modal.setData({ visible: true }) 但是不建议这样使用，而是组件暴露方法让外部调用： 123let $modal = this.selectComponent('#modal')$modal.show() 组件的事件通常，对话框都会有按钮，一个或两个。 因此 Modal 需要与父组件通过 事件(event) 的方式传递信息：当前点击了取消还是确定按钮： 123&lt;!-- home.wxml --&gt;&lt;modal id=&quot;modal&quot; bind:btntap=&quot;handleModalTap&quot; /&gt; 1234567891011121314151617// home.jsPage({ showModal() { let $modal = this.selectComponent('#modal') $modal.show() }, // 其他方法 handleModalTap(e) { let { type } = e.detail // type = cancel or confirm }}) 在 Modal 的构造函数则是这样的： 1234567891011121314// modal.jsComponent({ data: { visible: false } methods: { handleBtnTap(e) { let { type } = e.target.dataset this.triggerEvent('btntap', { type }) } }}) 123456789&lt;!-- modal.wxml --&gt;&lt;view class=&quot;wrapper&quot;&gt; &lt;!-- 省略其他结构 --&gt; &lt;view class=&quot;foot&quot; bindtap=&quot;handleBtnTap&quot;&gt; &lt;button data-type=&quot;cancel&quot;&gt;取消&lt;/button&gt; &lt;button data-type=&quot;confirm&quot;&gt;确定&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; 这样设计 Modal 组件，的确可以满足使用，但是不够好用 因为展示对话框时使用的是 showModal 而用户操作之后又是通过另外一个方法 handleModalTap 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护 所以，我建议结合 Promise 来封装 Modal 省略事件由于展示对话框之后，用户必然要操作，因此可以在 showModal 的时候，通过 Promise 返回对应的操作信息即可 另外，需要引入发布订阅机制（以下使用 Node.js 的 Events 举例）： 1234567891011121314151617181920212223242526272829303132// modal.jsconst EventEmitter = require('events');const ee = new EventEmitter();Component({ data: { visible: false }, methods: { show() { this.setData({ visible: true }) return new Promise((resolve, reject) =&gt; { ee.on('cancel', () =&gt; { reject() }) ee.on('confirm', () =&gt; { resolve() }) }) }, handleBtnTap(e) { let { type } = e.target.dataset ee.emit(type) this.triggerEvent('btntap', { type }) } }}) 此时，在 Page 即可这样展示对话框： 12345678910111213// home.jsPage({ onLoad() { let $modal = this.selectComponent('#modal') $moda.show().then(() =&gt; { // 当点击确认时 }).catch(() =&gt; { // 当点击取消时 }) }}) 总结组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！","link":"/2020/05/23/mini-program/thinking-about-components/"},{"title":"订阅消息的思考","text":"前言小程序的早期定位是“即用即走”或者说是“用完即走”。但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。让用户回流的关键手段就是 订阅消息，通过点击订阅消息，可直接回到小程序。 背景早期小程序提供的是 模板消息，用户每次点击或者完成支付，都会生成一个formId或者paypay_id，开发者可以通过这个formId给用户发送一次模板消息。 因此，开发者的常规做法：尽可能地在每个按钮上都封装form，用以收集formId；收集的formId并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些formId发送模板消息。 这样会存在几个问题： 用户会被莫名的骚扰（因为formId有7天的有效期） 用户收到的模板消息是无预期的（因为formId可以发任意的模板消息） 开发者在每个页面每个可点击区域都封装了form，导致代码混乱 为了解决以上问题，小程序团队就采用了 订阅消息 来替换 模板消息。 小程序模板消息接口于2020年1月10日下线 订阅消息的优势订阅消息 与 模板消息 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如： 另外，对订阅消息的发送时限不做限制，即可以在任意时间给用户发送一条模板消息，而不像以前的formId有7天的有效期。 从开发者的角度看：订阅消息是使用接口调用(wx.requestSubscribeMessage)，不再是以前那样，一定要用Button。对于代码维护和开发效率来说，都是利好的。 从代码维护上讲，开发者不用再层层嵌套form了，简化了许多代码；另外，以前模板消息是通过Button封装的，拜托了这层束缚之后，就不用再重置Button的样式了，对于开发效率也是有一定的帮助。 模板消息12345&lt;form bindsubmit=&quot;addFormId&quot; report-submit&gt; &lt;button class=&quot;invite-btn&quot; form-type=&quot;submit&quot;&gt; 邀请好友 &lt;/button&gt;&lt;/form&gt; 1234567Page({ data: {}, addFormId(e) { let { formId } = e.detail; // save formId }}) 订阅消息1&lt;view class=&quot;invite-btn&quot; bindtap=&quot;handleInvite&quot;&gt;邀请好友&lt;/view&gt; 1234567Page({ handleInvite() { wx.requestSubscribeMessage({ tmplIds: [''] // 订阅的模板ID }) }}) 但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。 订阅消息的类型以往的模板消息，每次发送消息需要消耗一个formId，而formId有7天的有效期，因此小程序无法召回7天以前的活跃用户。 而订阅消息则提供了两种类型： 一次性订阅 长期订阅 其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。 不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。 开发的差异小程序端以往的模板消息方式，需要前端将每次收集到的formId，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。 另外每次发起消息订阅，都会有弹窗出现： 用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。 若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息： 其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。 如果用户关闭接收所有订阅消息，那么调用wx.requestSubscribeMessage时，会触发fail，并返回如下信息： 12345{ errCode: 20004, errMsg: 'The main switch is switched off', // 用户关闭了主开关，无法进行订阅} 总结订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往formId的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。 因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。","link":"/2020/05/23/mini-program/think-about-subscribe/"},{"title":"全局变量的管理","text":"前言 在浏览器的环境下有一个全局变量：window。若定义变量时，遗漏了var，此时声明的变量就变成了全局变量，自动挂载到window下，可当做window的属性来访问，也可以直接访问。 小程序的底层也是通过Web实现的，因此同样存在window对象，但是微信团队做了些处理： 微信团队将window设置成了writable:false，且值也为undefined。 即我们无法像在web那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的wx、global。 问题虽然window是只读的，但是global是可写的: 因此常见的做法，就是将需要全局访问的变量都保存到global下，间接声明了全局变量。 全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。 另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。 同理，setStorage也存在同样的问题。 思考简单地将这些变量改成readonly肯定是不可取的，这影响了日常的开发。 在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案： 命名空间 模块化 其中 模块化 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。 因此 命名空间 是可以深入探索的思路。 实践命名空间命名空间是一种常用的代码组织形式。 大致做法是，先通过命名分配空间，再使用空间。 我的习惯是，用业务或者功能来命名空间 12345678910global.localStorage = { doSet() {}, doGet() {}, doClear() {}}global.util = { format() {}, valide() {}} 命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。 SymbolSymbol是ES2015中新增的基本数据类型。这个类型有个特别之处，每个Symbol()返回的值都是独一无二的，举个例子： 1Symbol('foo') === Symbol('foo') // false 因此通过Symbol的方式，可以完美避免变量被覆盖： 1234567// car.jslet car = Symbol()global[car] = {}// health.jslet health = Symbol()global[health] = {} 由于每个Symbol返回的值是唯一的，因此这个Symbol可以单独保存，以便各个文件引用。 由于 Symbol 属于新特性，因此需要关注下兼容性 管理声明通过Symbol的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。 我想到的办法就是给 global 增加个代理，对 global 的任何操作，都先经过代理检测，这样就有了强力的保障。 因此，可以使用新特性：Proxy 来监听 global 的变更，举例说明： 123456789101112global = new Proxy(global, { set(obj, prop, val) { if (prop in obj) { throw new TypeError(`${prop}: 该属性已定义！`) } // 可以做其他策略 // 或者上报数据，让你知道有哪些人偷偷定义了全局对象 obj[prop] = val return true },}) 由于 Proxy 属于新特性，因此需要关注下兼容性 总结使用 Proxy 之后，能对 global 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。","link":"/2020/05/23/mini-program/global-data-manage/"},{"title":"小程序框架设计","text":"前言其实说是框架设计，有点“夸大其词”。 实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。 封装Page对小程序的Page进行封装，是一个框架的基础，也是解决许多通用问题的利刃。 如每个页面都需要设置分享onShareAppMessage，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装Page。 一种方案是，通过Page来定义一个新的Page，如：JPage，然后每个页面不再使用Page注册页面，而是使用JPage。 还有一种更好的方案，也是我所采取的方案：劫持Page。以至于不用改变每个页面的注册方式： 123456789101112131415// app.jslet realPage = PagePage = function Page(obj) { let defaultPageConfig = { onShareAppMessage() { return { title: '这里有很多有趣的壁纸', path: `/pages/index/index`, imageUrl: 'http://resoure.africans.cn/1.jpg', } } } return realPage({ ...defaultPageConfig, ...obj })} 这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子： 如果使用过 云开发 的读者，应该知道 获取集合 的步骤是这样的： 12let db = wx.cloud.database()let table = db.collection('wallpapers') 可以将这个 获取集合 的方法抽象成这样: 1234let getTable = (tableName) =&gt; { let db = wx.cloud.database() return db.collection(tableName)} 将这个方法放在defaultPageConfig里，以后每个页面都可以这样获取集合： 1this.getTable('wallpapers') 环境每个小程序都有三种版本：开发版、体验版、正式版。 往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？ 微信官网提供了 wx.getAccountInfoSync，为了避免在Page对象里冗余太多信息，因此env添加至App： 123456App({ env: (function() { let { miniProgram } = wx.getAccountInfoSync() return miniProgram.envVersion }())}) 需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案 后续可以这样使用： 12let app = getApp()console.log(app.env) // develop 设备信息由于每个用户进入小程序之后，设备信息不可能发生变更。 但在每个Page都封装这个信息会有点冗余，因此可以放进App里： 12345678App({ getSystemInfo() { let info = wx.getSystemInfoSync() this.getSystemInfo = () =&gt; info return info }}) 采用了缓存的机制，第一次调用时，调用getSystemInfoSync获取，第二次就直接返回缓存的设备信息了","link":"/2020/05/23/mini-program/frame-design/"},{"title":"自定义tabbar","text":"前言由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。 因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比： 分析原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。 从 小程序的官网文档 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下： 123&quot;tabbar&quot;: { &quot;custom&quot;: true} 设置了custom之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。 而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了） 实践按照官网文档的描述，在根目录上创建组件的文件夹，命名custom-tab-bar，里面的文件和正常的组件保持一致。 此时就可以将组件的样式和逻辑稍作调整： 当进入首页时，背景色改成透明 进入其他页面，背景色改回白色 这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的WXML里显式引用。 选中态由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？ 根据官网的描述，即是提供了接口getTabBar，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢） 需要在tabbar包含的每个页面的onShow里这样设置： 1234567Page({ onShow() { if (typeof this.getTabBar === 'function') { this.getTabBar().setData({ selected: 0 }) // 0代表第一个 } }}) 此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router 兼容性为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉custom:true才会恢复渲染tabbar。 所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。 如果你知道有什么兼容办法，欢迎和我联系。","link":"/2020/05/23/mini-program/custom-tabbar/"},{"title":"自定义导航栏","text":"小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。 自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域 作用最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。 其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。 需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过wx.getMenuButtonBoundingClientRect获取胶囊按钮的布局位置信息。 布局信息由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。 如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过wx.getSystemInfo获取系统信息，其中的statusBarHeight即是状态栏的高度。 另外前文也提到了，胶囊按钮的信息可以通过wx.getMenuButtonBoundingClientRect获取。胶囊按钮与状态栏的距离可以这样计算： 1234let mb = wx.getMenuButtonBoundingClientRect();let sh = wx.getSystemInfoSync().statusBarHeight // 为getSystemInfo的同步版本let distance = mb.top - sh 基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的distance是一致的。所以，导航栏的高度是： 1let nh = mb.height + distance * 2 // navigatorHeight 总计一下，导航栏的布局信息如下： 12345678let navigator = { top: sh bottom: mb.bottom + distance left: 0, right: 0, height: mb.height + distance * 2 width: wx.getSystemInfoSync().screenWidth} 兼容问题前文提到页面设置导航栏是要求客户端7.0.0以上； 另外计算 状态栏高度(statusBarHeight) 需要基础库版本1.9.0以上； 计算胶囊按钮的布局信息wx.getMenuButtonBoundingClientRect则要求基础库2.1.0； 由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为2.4.3 因此，只要判断当前用户的客户端是否为7.0.0或以上即可。 注意事项由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意position: fixed的元素，此时应该将top对应的数值加上statusBarHeight和navigator.height，才能渲染正确。","link":"/2020/05/23/mini-program/custom-navigator/"},{"title":"编码规范的一些思考","text":"引言古人常说，无规矩不成方圆。在编程的世界里也同样如此。 从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。 然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。 现实在笔者呆过的团队，似乎都在重蹈覆辙： 一开始不重视文档、规范，快速启动，敏捷开发 等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码 由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码 如此往复，无形中浪费了许多因修复历史代码而产生的工作量。 笔者认为，有可能是以下几种原因导致这种现象： 团队早期人员少，项目急，人力不足 前端开发仍不够成熟，没可落地的完整方案 经验不足，无法意识到规范的重要性 范围我们常说的代码规范属于编码规范的子集。 笔者理解的编码规范包括一下几种： 代码规范 文件规范 项目结构规范 其中，代码规范 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。 代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。 文件规范 则包含：文件的命名规范，以及文件的类型规范（如图片）。 项目结构规范 是规范化项目的结构，有利于项目的可读性。 由于篇幅有限，文本将主要阐述 代码规范 的制定与落地实施。 前端的特殊性若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。 但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多： 编程语言：JavaScript、CSS、HTML 框架：Vue、React、Angular runtime：Node.js、小程序、浏览器 语法糖：CoffeeScript、TypeScript 其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。 上述的runtime和语法糖都是针对于JavaScript而言，因此确定JavsScript的代码规范是首要任务。 最好的结果就是每个人写得代码都是一样的。 快速开始导致团队的代码规范难以指定的一个很大原因就是无法快速开始。 因此笔者提供一种思路：工具驱动规范(Tool Drive Specification) 通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。 对于JavaScript来说，最强力的代码分析检测工具非ESLint莫属，其涵盖了代码质量和编码风格的检测。 ESLint ESLint官方有提供一个推荐方案，通过配置文件.eslintrc： 123{ &quot;extends&quot;: &quot;eslint:recommended&quot;} 或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。 使用ESlint --init即可开启交互式初始化ESLint配置。 对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架Vue举例说明： Vue官方提供了ESLint的插件：eslint-plugin-vue 通过此插件，可以利用ESLint检测.vue文件的&lt;template&gt;和&lt;script&gt;模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置： 123456{ &quot;extends&quot;: &quot;plugin:vue/vue3-recommended&quot;, &quot;rules&quot;: { }} 另外，可以在rules里覆盖推荐的规范 执行检测： 1npx eslint **/*.{js,vue} HTMLHint 因为HTML不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：HTMLHint Rules 通过配置文件.htmlhintrc配置，默认配置如下： 123456789101112{ &quot;tagname-lowercase&quot;: true, &quot;attr-lowercase&quot;: true, &quot;attr-value-double-quotes&quot;: true, &quot;doctype-first&quot;: true, &quot;tag-pair&quot;: true, &quot;spec-char-escape&quot;: true, &quot;id-unique&quot;: true, &quot;src-not-empty&quot;: true, &quot;attr-no-duplication&quot;: true, &quot;title-require&quot;: true} 执行检测： 1npx htmlhint **/*.html stylelint stylelint是CSS的代码分析工具，类似于ESLint，stylelint也提供了 **标准配置(standard configuration)**，安装方式： 1npm install --save-dev stylelint stylelint-config-standard 在项目根目录创建配置文件.stylelintrc.json： 123{ &quot;extends&quot;: &quot;stylelint-config-standard&quot;} 执行检测： 1npx stylelint &quot;**/*.css&quot; 实施方案如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以GitLab举例： 每个仓库均可设置多个分支，在GitLab上对关键分支（比如master）的权限做严格把控，比如： 不允许任何人直接push到关键分支（Allowed to push: No one) 仅允许通过pipeline的 合并请求(merge requests) 进行合并 最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。 总结编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。 另外，需要切记的是，规范文档的落地不一定需要正式的word格式，markdown、html乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。","link":"/2020/05/23/mini-program/code-style-guide/"},{"title":"API Promise化","text":"前言众所周知，前端一大坑就是回调函数。 相信很多人是从async/await的温柔乡，掉到小程序重新写回调的大坑里的。 由于开发者工具新增了 增强编译 从而原生支持了async\\await，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 异步调用 方式改成 Promise的方式 即可。 分析与实践大致上可以有两种思路，第一种就是，逐个函数封装： 12345678910let promisify = func =&gt; args =&gt; new Promise((resolve, reject) =&gt; { func(Object.assign(args, { success: resolve, fail: reject, }))})let _login = promisify(wx.login) // 将wx.login转成Promise形式的方法_login().then(res =&gt; console.log) 这种方式比较麻烦，每次调用都需要手动转换。 劫持WX第二种就类似Page封装那样，劫持wx对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的： 同步方法是以Sync结尾的 通过typeof判断是否为函数 123456789101112// promisify.jslet originalWX = wxlet props = Object.keys(wx)for (let name of props) { let fn = wx[name] if (typeof fn === 'function' &amp;&amp; !name.endsWith('Sync')) { wx[name] = promisify(fn) }} 尝试封装之后，发现报错了。因为wx.drawCanvas只有getter没有setter，无法给它赋值。相当于这个方法是readonly。 既然存在没有setter的方法，那么我看有多少方法是有setter的： 1234Object.keys(wx).filter(name =&gt; { let descriptor = Object.getOwnPropertyDescriptor(wx, name) return typeof descriptor.set === 'function'}) 结果是[]，相当于无法改变wx对象的每个属性值。 复制模式虽然wx的属性都是readonly，不能劫持wx，但我发现wx是writable的。 那么可以采用复制模式，将它的所有异步方法拷贝一份并promisify之后赋值到新对象，最后再将整个对象赋值给wx即可： 1234567891011121314let props = Object.keys(wx)let jwx = {}for (let name of props) { let fn = wx[name] if (typeof fn === 'function' &amp;&amp; !name.endsWith('Sync')) { jwx[name] = promisify(fn) } else { jwx[name] = fn }}wx = jwx 这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了promisify。 代理模式熟悉ES新特性的读者应该知道Proxy。 它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上Proxy之后，对这个属性的任何行为都可以被代理。 那么我们就可以给wx挂上代理： 1234567891011121314let originalWX = wxwx = new Proxy({}, { get(target, name) { if (name in originalWX ) { let fn = originalWX[name] let isSyncFunc = name.endsWith('Sync') // 同步函数 let isNotFunc = typeof fn !== 'function' // 非函数 if (isSyncFunc || isNotFunc) return fn return promisify(fn) } }}); 代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。 在实践中，我发现并不是所有同步方法都是以Sync结尾的。比如：wx.getMenuButtonBoundingClientRect。 因此打算手动维护一个同步方法列表，将这项方法过滤掉： 123let syncFuncList = ['getMenuButtonBoundingClientRect']// name为函数名let isSync = name.endsWith('Sync') || syncFuncList.includes(name) 优化考虑到要兼容已上线的小程序，若匆忙替换wx，必会导致全局报错，因此可以如下处理： 当用户调用API时，如果传入了success、fail、complete等回调方法的话，则仍继续使用回调的方式继续执行。那么promisify可以如下优化： 12345678910111213141516171819202122let originalWX = wxlet hasCallback = obj =&gt; { let cbs = ['success', 'fail', 'complete'] return Object.keys(obj).some(k =&gt; cbs.includes(k))}wx = new Proxy({}, { get(target, name) { if (name in originalWX ) { let fn = originalWX[name] let isSyncFunc = name.endsWith('Sync') // 同步函数 let isNotFunc = typeof fn !== 'function' // 非函数 if (isSyncFunc || isNotFunc) return fn return (obj) =&gt; { if (!obj) return fn() if (hasCallback(obj)) return fn(obj) return promisify(fn)(obj) } } }}); 由于本文的前提是开启 增强编译，而该模式下也新增支持Array.prototype.includes，因此可以放心使用该ES7的新特性。 后续由于发现了微信官方也提供了一个 API Promise化 的工具类库，因此增加了本章节。 通过阅读源代码，发现官方的工具类库提供两个方法：promisify 和 promisifyAll 其中promisify与前文的同名方法是几乎一致的。而promisifyAll则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似： 1234567import { promisifyAll } from 'miniprogram-api-promise';let jwx = {}promisifyAll(wx, jwx)wx = jwx 另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。 相当于我的做法是黑名单机制，而官方采用了白名单机制。 最后再提醒下，开发者工具记得打开 增强编译","link":"/2020/05/23/mini-program/api-promisify/"},{"title":"小程序自定义组件的函数属性及事件触发","text":"开发小程序组件库 TDesign 有感 微信小程序，从基础库 2.0.9 开始，自定义组件的 type: Object 属性（properties）支持函数类型的值了，但仍不支持函数类型的属性，即： 1234567891011121314151617// dialog.jsComponent({ properties: { confirmBtn: { type: Object, // ok }, cancelBtn: { type: Function // wrong } }, observer: { confirmBtn(obj) { console.log(obj.bindgetuserinfo) // function } }}) 这种能力，在实现 Dialog 组件的时候，非常有用。这样在 Dialog 组件的 cancel 和 confirm 按钮可以方便地支持 Button 的各种开放能力。 于是，就会想当然地这样实现： 1234567891011121314151617181920212223242526&lt;view class=&quot;t-dialog&quot;&gt; &lt;!-- ... --&gt; &lt;button class=&quot;cancel-btn&quot; size=&quot;{{cancelBtn.size}}&quot; type=&quot;{{cancelBtn.type}}&quot; plain=&quot;{{cancelBtn.plain}}&quot; disabled=&quot;{{cancelBtn.disabled}}&quot; open-type=&quot;{{cancelBtn.openType}}&quot; bindgetuserinfo=&quot;{{cancelBtn.bindgetuserinfo}}&quot; &gt; 取消 &lt;/button&gt; &lt;button class=&quot;confirm-btn&quot; size=&quot;{{confirmBtn.size}}&quot; type=&quot;{{confirmBtn.type}}&quot; plain=&quot;{{confirmBtn.plain}}&quot; disabled=&quot;{{confirmBtn.disabled}}&quot; open-type=&quot;{{confirmBtn.openType}}&quot; bindgetuserinfo=&quot;{{confirmBtn.bindgetuserinfo}}&quot; &gt; 确认 &lt;/button&gt;&lt;/view&gt; 这样就会出现几个问题： 属性透传写法太冗余 事件不会触发 按钮内容没法传入 属性透传Dialog 组件存在两个按钮，所以两个按钮都需要透传 button 属性，直观的想法就是采用 template 来处理: 1234567891011121314&lt;!-- button.wxml --&gt;&lt;template name=&quot;button&quot;&gt; &lt;button class=&quot;{{class}}&quot; size=&quot;{{size}}&quot; type=&quot;{{type}}&quot; plain=&quot;{{plain}}&quot; disabled=&quot;{{disabled}}&quot; open-type=&quot;{{openType}}&quot; bindgetuserinfo=&quot;{{bindgetuserinfo}}&quot; &gt; 确认 &lt;/button&gt;&lt;/template&gt; 于是 Dialog 的代码就可以省略成这样： 1234567&lt;import src=&quot;./button.wxml&quot; /&gt; &lt;view class=&quot;t-dialog&quot;&gt; &lt;!-- ... --&gt; &lt;template is=&quot;button&quot; data={{...cancelBtn, class: 'cancel-btn'}}&gt; &lt;template is=&quot;button&quot; data={{...confirmBtn, class: 'confirm-btn'}}&gt;&lt;/view&gt; 这里确实挺奇怪的，可以直接传入了一个解构后的值。 这里可以直接合并对象 事件不会触发一开始以为是 template 的值传递过程，不支持 function 类型的值，因此丢失了。 比如在 template 里面使用 wxs 打印类型，居然是空的。 后来经过各种测试，最后在官网文档找到答案：小程序框架/事件系统 在小程序的事件绑定，只需要传入的是字符串: 1&lt;view bindtap=&quot;handletap&quot;&gt;Tap me!&lt;/view&gt; 也可以是一个数据绑定: 1&lt;view bindtap=&quot;{{ handlerName }}&quot;&gt;Tap me!&lt;/view&gt; 但，这个数据的返回值类型应该是 string 而不是 function。 通过这点，恍然大悟，想起了小程序的双线程模型： 为了减轻线程之间的传输负担，是不需要将 function 传到渲染层的，只需要给一个函数名，然后在逻辑层执行对应的函数即可。 因此没有办法在 wxml 里面执行对象属性的函数，需要找一个代理函数（Proxy function）处理。 为了区分对应的按钮，因此 template 做了小改动，增加了一个 data-token 的属性： 123&lt;template name=&quot;button&quot;&gt; &lt;button data-token=&quot;{{token}}&quot; bindtap=&quot;onTplButtonTap&quot;&gt;&lt;/template&gt; 对应的 Dialog 的 wxml 的改动是这样的： 1234567&lt;import src=&quot;button.wxml&quot; /&gt; &lt;view class=&quot;t-dialog&quot;&gt; &lt;!-- ... --&gt; &lt;template is=&quot;button&quot; data={{...cancelBtn, token: 'cancel', class: 'cancel-btn'}}&gt; &lt;template is=&quot;button&quot; data={{...confirmBtn, token: 'confirm', class: 'confirm-btn'}}&gt;&lt;/view&gt; 对应的 JS 是这样的： 1234567891011121314Component({ methods: { onTplButtonTap(e) { const { token } = e.target.dataset // cancel or confirm const evtType = e.type // 对应的事件名，如 getuserinfo/getphonenumber 等 const evtName = `bind${evtType}` const targetBtn = this.data[`${type}Btn`] if (typeof targetBtn[evtName] == 'function') { targetBtn[evtName](e.detail) } } }}) 这样就能完美透传并触发各种 button 事件了。 按钮内容传入其事这个倒是个小问题，因为 TDesign 组件在规划的时候，就已经充分地考虑了多框架之间的差异。为了弥补框架之间的差异，都可以通过 content 的属性来传入插槽的内容，起初我还不理解，直到遇到了这个问题。 以前总觉得，可以通过 slot 的方式传入，又支持一个 content 有点多此一举。直到我遇到了需要透传 button 属性的 dialog 组件。 总结小程序的黑盒子运行时，在遇到问题的时候真的很容易陷入盲调的困境，此时应该去看看官方文档的资料，或者网上搜一下是否其他人也遇到类似的问题，这样才可能破局。 毕竟只有他们才知道代码是怎么跑的。","link":"/2022/01/06/miniprogram-function-property/"}],"tags":[{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"BFC","slug":"BFC","link":"/tags/BFC/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Storage","slug":"Storage","link":"/tags/Storage/"},{"name":"underscore.js","slug":"underscore-js","link":"/tags/underscore-js/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"promise 宏任务 微任务","slug":"promise-宏任务-微任务","link":"/tags/promise-%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"事件","slug":"事件","link":"/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"模块化","slug":"模块化","link":"/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"键盘","slug":"键盘","link":"/tags/%E9%94%AE%E7%9B%98/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Buffers","slug":"Buffers","link":"/tags/Buffers/"},{"name":"History API","slug":"History-API","link":"/tags/History-API/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"路由","slug":"路由","link":"/tags/%E8%B7%AF%E7%94%B1/"},{"name":"盒模型","slug":"盒模型","link":"/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"垃圾回收","slug":"垃圾回收","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"编码规范","slug":"编码规范","link":"/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"函数属性","slug":"函数属性","link":"/tags/%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"属性","slug":"属性","link":"/tags/%E5%B1%9E%E6%80%A7/"},{"name":"tdesign","slug":"tdesign","link":"/tags/tdesign/"}],"categories":[]}