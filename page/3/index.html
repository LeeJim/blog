<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Jim Home</title><link rel="manifest" href="/blog/manifest.json"><meta name="application-name" content="leejimqiu"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="leejimqiu"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="技术博客，前端开发，微信小程序，VSCode"><meta property="og:type" content="blog"><meta property="og:title" content="Jim Home"><meta property="og:url" content="https://leejim.github.io/blog"><meta property="og:site_name" content="Jim Home"><meta property="og:description" content="技术博客，前端开发，微信小程序，VSCode"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://leejim.github.io/blog/img/og_image.png"><meta property="article:author" content="leejimqiu"><meta property="article:tag" content="leejimqiu,"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/blog/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://leejim.github.io/blog"},"headline":"Jim Home","image":["https://leejim.github.io/blog/img/og_image.png"],"author":{"@type":"Person","name":"leejimqiu"},"publisher":{"@type":"Organization","name":"Jim Home","logo":{"@type":"ImageObject","url":"https://leejim.github.io/img/logo.svg"}},"description":"技术博客，前端开发，微信小程序，VSCode"}</script><link rel="icon" href="/blog/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?6638f74329d0f52c5cdafdadb58010af";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/blog/"><img src="/blog/img/logo.svg" alt="Jim Home" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/blog/">Home</a><a class="navbar-item" href="/blog/archives">Archives</a><a class="navbar-item" href="/blog/categories">Categories</a><a class="navbar-item" href="/blog/tags">Tags</a><a class="navbar-item" href="/blog/projects">Projects</a><a class="navbar-item" href="/blog/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leejim"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-27T16:00:00.000Z" title="3/27/2020, 4:00:00 PM">2020-03-28</time>发表</span><span class="level-item"><time dateTime="2023-08-04T10:45:18.563Z" title="8/4/2023, 10:45:18 AM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></span><span class="level-item">5 分钟读完 (大约704个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/03/27/miniprogram/frame-design/">浅谈小程序的框架设计</a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实说是框架设计，有点“夸大其词”。</p>
<p>实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。</p></div><a class="article-more button is-small is-size-7" href="/blog/2020/03/27/miniprogram/frame-design/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-23T10:53:52.000Z" title="3/23/2020, 10:53:52 AM">2020-03-23</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.484Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item">7 分钟读完 (大约1090个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/03/23/miniprogram/handle-error/">浅谈小程序的错误处理</a></h1><div class="content"><blockquote>
<p>其实，错误（异常）处理在任何编程语言里，都是不可避免的。正确处理异常，是一个程序/应用保持健壮的关键。</p>
</blockquote></div><a class="article-more button is-small is-size-7" href="/blog/2020/03/23/miniprogram/handle-error/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-14T10:42:32.000Z" title="3/14/2020, 10:42:32 AM">2020-03-14</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.484Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></span><span class="level-item">7 分钟读完 (大约1124个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/03/14/miniprogram/how-to-resue-method/">小程序复用函数的五种方式</a></h1><div class="content"><p>开发过小程序的朋友们应该都遇到这样的情况，可能很多个页面有相同的函数，例如<code>onShareAppMessage</code>，有什么最佳实践吗，应该如何处理呢？</p>
<p>本次开发技巧，我从以下几种解决办法剖析：</p>
<ol>
<li> 将它复制粘贴到每个地方（最烂的做法）</li>
<li> 抽象成一个公共函数，每个<code>Page</code>都手动引用</li>
<li> 提取一个behavior，每个页面手动注入</li>
<li> 通过<code>Page</code>封装一个新的<code>newPage</code>，以后每个页面都通过<code>newPage</code>注册</li>
<li> 劫持Page函数，注入预设方法，页面仍可使用<code>Page</code>注册</li>
</ol></div><a class="article-more button is-small is-size-7" href="/blog/2020/03/14/miniprogram/how-to-resue-method/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-21T12:49:01.000Z" title="2/21/2020, 12:49:01 PM">2020-02-21</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">13 分钟读完 (大约1950个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/02/21/browser/how-broswers-work-7/">手把手教你实现一个浏览器引擎（七）Paint</a></h1><div class="content"><h2 id="第七部分：Painting-101"><a href="#第七部分：Painting-101" class="headerlink" title="第七部分：Painting 101"></a>第七部分：Painting 101</h2><p>欢迎回到我的关于构建玩具HTML渲染引擎的系列文章的最后一篇：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00086eef5fcff8f5b3c97d08551413">第一部分：起步</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">第二部分：HTML</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/0004ae6f0b4c80883de95cfaa59413">第三部分：CSS</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000c0e53584310a068e9f0f7c5fc13">第四部分：Style</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00020e5163044868e4e974bf452813">第五部分：Boxes</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000c06035e4620edf2e9e0aa756c13">第六部分：Block layout</a></li>
</ul>
<p>本文我将添加非常基础的绘制代码。此代码将布局模块生成的由盒子组成的树转换成一个像素数组。这个过程也被称为”栅格化“。</p>
<p><img src="/blog/images/browsers/paint-1.jpg"></p>
<p>浏览器通常借助图形API和一些例如 Skia，Cairo，Direct2D 等等的库来实现栅格化。这些APIs提供函数来绘制多边形，线条，曲线，渐变色和文本。目前为止，我打算写我自己的栅格化工具，它只能绘制一种图形：矩形。</p>
<p>最终我想实现文本渲染。到那时，我可能会丢弃这个玩具绘制代码，并切换到一个”真正“的2D图形库。不过目前为止，矩形是足以将我的块布局算法的输出转换成图片。</p>
<h2 id="追赶-Catching-Up"><a href="#追赶-Catching-Up" class="headerlink" title="追赶 Catching Up"></a>追赶 Catching Up</h2><p>从上篇文章开始，我对以前的文章中的代码做了一些小的改变。其中包含一些小的重构，和一些更新，以保持代码和最新的Rust每晚构建版本兼容。这些改变对理解代码都不重要，不过如果你觉得困惑，可以查看下 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/commits/master">提交历史</a></p>
<h2 id="构建显示列表-Building-the-Display-List"><a href="#构建显示列表-Building-the-Display-List" class="headerlink" title="构建显示列表 Building the Display List"></a>构建显示列表 Building the Display List</h2><p>开始绘制之前，我们要遍历布局树构建一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Display_list">显示列表</a>。这是一个例如”画一个圆圈“或”画一个文本字符串“的图形操作列表。或者在我们这个例子，就是”画一个矩形“。</p>
<p>为什么将这些命令放在一个显示列表而不是直接执行他们呢？显示列表之所以有用，有几个原因。你可以在其中搜索到被后续操作完全覆盖的项目，然后将他们移除来消除冗余的绘制。当你知道只有一个确定的项目被修改时，可以修改和重复使用这个显示列表。你可以使用相同的列表来生成不同类型的输出：例如，屏幕的显示，或者以矢量图的形式发送到打印机。</p>
<p>Robinson的显示列表是一个<code>DisplayCommands</code>的向量。目前只有一个类型的<code>DisplayCommands</code>，一个纯色的矩形。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">DisplayList</span></span> = <span class="built_in">Vec</span>&lt;DisplayCommand&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DisplayCommand</span></span> &#123;</span><br><span class="line">    SolidColor(Color, Rect),</span><br><span class="line">    <span class="comment">// insert more commands here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了构建显示列表，我们需要遍历布局树和为每个盒子生成一系列的命令。首先我们绘制盒子的背景，然后位置它的边框和背景上的内容。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_display_list</span></span>(layout_root: &amp;LayoutBox) -&gt; DisplayList &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list = <span class="built_in">Vec</span>::new();</span><br><span class="line">    render_layout_box(&amp;<span class="keyword">mut</span> list, layout_root);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">render_layout_box</span></span>(list: &amp;<span class="keyword">mut</span> DisplayList, layout_box: &amp;LayoutBox) &#123;</span><br><span class="line">    render_background(list, layout_box);</span><br><span class="line">    render_borders(list, layout_box);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> render text</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> &amp;layout_box.children &#123;</span><br><span class="line">        render_layout_box(list, child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，HTML元素依照出现它们出现顺序来叠放的：如果两个元素重叠，后面的那个将绘制在前面那个上方。这反映到我们的显示列表中，该列表将按照于它们在DOM树种出现的顺序相同的顺序绘制元素。如果这代码支持 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/visuren.html#z-index">z-index</a> 属性，则单个元素能够覆盖此堆叠顺序，并且我们需要相应地对显示列表进行排序。</p>
<p>背景比较简单。这仅仅是实心的矩形。如果没指定背景的颜色，那么背景是透明的，然后我们也就不需要生成一个显示命令了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">render_background</span></span>(list: &amp;<span class="keyword">mut</span> DisplayList, layout_box: &amp;LayoutBox) &#123;</span><br><span class="line">    get_color(layout_box, <span class="string">&quot;background&quot;</span>).map(|color|</span><br><span class="line">        list.push(DisplayCommand::SolidColor(color, layout_box.dimensions.border_box())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the specified color for CSS property `name`, or None if no color was specified.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_color</span></span>(layout_box: &amp;LayoutBox, name: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Option</span>&lt;Color&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> layout_box.box_type &#123;</span><br><span class="line">        BlockNode(style) | InlineNode(style) =&gt; <span class="keyword">match</span> style.value(name) &#123;</span><br><span class="line">            <span class="literal">Some</span>(Value::ColorValue(color)) =&gt; <span class="literal">Some</span>(color),</span><br><span class="line">            _ =&gt; <span class="literal">None</span></span><br><span class="line">        &#125;,</span><br><span class="line">        AnonymousBlock =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>边框也是类似的。不过我们绘制的不是一个矩形，而是四个——对应盒子的各个边缘。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">render_borders</span></span>(list: &amp;<span class="keyword">mut</span> DisplayList, layout_box: &amp;LayoutBox) &#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="keyword">match</span> get_color(layout_box, <span class="string">&quot;border-color&quot;</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(color) =&gt; color,</span><br><span class="line">        _ =&gt; <span class="keyword">return</span> <span class="comment">// bail out if no border-color is specified</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> d = &amp;layout_box.dimensions;</span><br><span class="line">    <span class="keyword">let</span> border_box = d.border_box();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Left border</span></span><br><span class="line">    list.push(DisplayCommand::SolidColor(color, Rect &#123;</span><br><span class="line">        x: border_box.x,</span><br><span class="line">        y: border_box.y,</span><br><span class="line">        width: d.border.left,</span><br><span class="line">        height: border_box.height,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Right border</span></span><br><span class="line">    list.push(DisplayCommand::SolidColor(color, Rect &#123;</span><br><span class="line">        x: border_box.x + border_box.width - d.border.right,</span><br><span class="line">        y: border_box.y,</span><br><span class="line">        width: d.border.right,</span><br><span class="line">        height: border_box.height,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Top border</span></span><br><span class="line">    list.push(DisplayCommand::SolidColor(color, Rect &#123;</span><br><span class="line">        x: border_box.x,</span><br><span class="line">        y: border_box.y,</span><br><span class="line">        width: border_box.width,</span><br><span class="line">        height: d.border.top,</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bottom border</span></span><br><span class="line">    list.push(DisplayCommand::SolidColor(color, Rect &#123;</span><br><span class="line">        x: border_box.x,</span><br><span class="line">        y: border_box.y + border_box.height - d.border.bottom,</span><br><span class="line">        width: border_box.width,</span><br><span class="line">        height: d.border.bottom,</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的渲染函数将绘制每个盒子的子级，直到整个布局树都被翻译成 **显示命令(display commands)**。</p>
<h2 id="栅格化-Rasterization"><a href="#栅格化-Rasterization" class="headerlink" title="栅格化 Rasterization"></a>栅格化 Rasterization</h2><p>现在我们完成了显示列表的构建，我们需要执行每个<code>DisplayCommand</code>并将它转换成像素。我们将像素存储到 **画布(Canvas)**。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Canvas</span></span> &#123;</span><br><span class="line">    pixels: <span class="built_in">Vec</span>&lt;Color&gt;,</span><br><span class="line">    width: <span class="built_in">usize</span>,</span><br><span class="line">    height: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Canvas &#123;</span><br><span class="line">    <span class="comment">// Create a blank canvas</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(width: <span class="built_in">usize</span>, height: <span class="built_in">usize</span>) -&gt; Canvas &#123;</span><br><span class="line">        <span class="keyword">let</span> white = Color &#123; r: <span class="number">255</span>, g: <span class="number">255</span>, b: <span class="number">255</span>, a: <span class="number">255</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> Canvas &#123;</span><br><span class="line">            pixels: repeat(white).take(width * height).collect(),</span><br><span class="line">            width: width,</span><br><span class="line">            height: height,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在画布上绘制矩形，我们只需要借助辅助函数来遍历其行和列，以确保我们不会超出画布边界。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">paint_item</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, item: &amp;DisplayCommand) &#123;</span><br><span class="line">    <span class="keyword">match</span> item &#123;</span><br><span class="line">        &amp;DisplayCommand::SolidColor(color, rect) =&gt; &#123;</span><br><span class="line">            <span class="comment">// Clip the rectangle to the canvas boundaries.</span></span><br><span class="line">            <span class="keyword">let</span> x0 = rect.x.clamp(<span class="number">0.0</span>, <span class="keyword">self</span>.width <span class="keyword">as</span> <span class="built_in">f32</span>) <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">            <span class="keyword">let</span> y0 = rect.y.clamp(<span class="number">0.0</span>, <span class="keyword">self</span>.height <span class="keyword">as</span> <span class="built_in">f32</span>) <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">            <span class="keyword">let</span> x1 = (rect.x + rect.width).clamp(<span class="number">0.0</span>, <span class="keyword">self</span>.width <span class="keyword">as</span> <span class="built_in">f32</span>) <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">            <span class="keyword">let</span> y1 = (rect.y + rect.height).clamp(<span class="number">0.0</span>, <span class="keyword">self</span>.height <span class="keyword">as</span> <span class="built_in">f32</span>) <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> (y0 .. y1) &#123;</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> (x0 .. x1) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> alpha compositing with existing pixel</span></span><br><span class="line">                    <span class="keyword">self</span>.pixels[x + y * <span class="keyword">self</span>.width] = color;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这些代码能只绘制不透明的颜色。如果我们添加透明度（通过读取<code>opacity</code>属性，或者在CSS解析器增加支持<code>rgba()</code>值），然后它需要将每个新像素与它所绘制的内容混合。</p>
<p>现在我们可以将所有内容组合到<code>paint</code>函数中，来构建显示列表，然后将其格栅化成画布：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Paint a tree of LayoutBoxes to an array of pixels.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">paint</span></span>(layout_root: &amp;LayoutBox, bounds: Rect) -&gt; Canvas &#123;</span><br><span class="line">    <span class="keyword">let</span> display_list = build_display_list(layout_root);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> canvas = Canvas::new(bounds.width <span class="keyword">as</span> <span class="built_in">usize</span>, bounds.height <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> display_list &#123;</span><br><span class="line">        canvas.paint_item(&amp;item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们可以写 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/8feb394e9c87663e35a4e8e5040d6e964ffc2396/src/main.rs#L60-L65">几行代码</a>，使用 <a target="_blank" rel="noopener" href="https://github.com/PistonDevelopers/image/">Rust Image</a> 库将像素数组另存为PNG文件。</p>
<h2 id="漂亮的图片-Pretty-Pictures"><a href="#漂亮的图片-Pretty-Pictures" class="headerlink" title="漂亮的图片 Pretty Pictures"></a>漂亮的图片 Pretty Pictures</h2><p>最后，我们抵达了我们的渲染流程的尾部。在不到1000行代码里，Robinson现在可以解析这个HTML文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;e&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;f&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和这个CSS文件：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* &#123; <span class="attribute">display</span>: block; <span class="attribute">padding</span>: <span class="number">12px</span>; &#125;</span><br><span class="line"><span class="selector-class">.a</span> &#123; <span class="attribute">background</span>: <span class="number">#ff0000</span>; &#125;</span><br><span class="line"><span class="selector-class">.b</span> &#123; <span class="attribute">background</span>: <span class="number">#ffa500</span>; &#125;</span><br><span class="line"><span class="selector-class">.c</span> &#123; <span class="attribute">background</span>: <span class="number">#ffff00</span>; &#125;</span><br><span class="line"><span class="selector-class">.d</span> &#123; <span class="attribute">background</span>: <span class="number">#008000</span>; &#125;</span><br><span class="line"><span class="selector-class">.e</span> &#123; <span class="attribute">background</span>: <span class="number">#0000ff</span>; &#125;</span><br><span class="line"><span class="selector-class">.f</span> &#123; <span class="attribute">background</span>: <span class="number">#4b0082</span>; &#125;</span><br><span class="line"><span class="selector-class">.g</span> &#123; <span class="attribute">background</span>: <span class="number">#800080</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>和生成这个：</p>
<p><img src="/blog/images/browsers/paint-2.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-20T12:49:01.000Z" title="2/20/2020, 12:49:01 PM">2020-02-20</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">16 分钟读完 (大约2455个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/02/20/browser/how-broswers-work-6/">手把手教你实现一个浏览器引擎（六）Block Layout</a></h1><div class="content"><h2 id="第六部分：Block-layout"><a href="#第六部分：Block-layout" class="headerlink" title="第六部分：Block layout"></a>第六部分：Block layout</h2><p>欢迎回到我的关于构建玩具HTML渲染引擎的系列文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00086eef5fcff8f5b3c97d08551413">第一部分：起步</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">第二部分：HTML</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/0004ae6f0b4c80883de95cfaa59413">第三部分：CSS</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000c0e53584310a068e9f0f7c5fc13">第四部分：Style</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00020e5163044868e4e974bf452813">第五部分：Boxes</a></li>
</ul>
<p>本文将继续讨论我们在第五部分开始讨论的布局模块。此时，我们将增添布局块状盒子的能力。例如标题和段落这些都是垂直堆叠的盒子。</p>
<p>为简单起见，此代码仅实现<strong>正常流</strong>(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/visuren.html#positioning-scheme">normal flow</a>)：没有<strong>浮动</strong>(floats)，没有<strong>绝对定位</strong>(absolute positioning)，也没有<strong>固定定位</strong>(fixed positioning)。</p>
<h2 id="遍历布局树-Traversing-the-Layout-Tree"><a href="#遍历布局树-Traversing-the-Layout-Tree" class="headerlink" title="遍历布局树 Traversing the Layout Tree"></a>遍历布局树 Traversing the Layout Tree</h2><p>代码的入口是<code>layout</code>函数，它利用<code>LayoutBox</code>来计算它的尺寸。我将这个函数拆分三种情况，然后目前只实现其中的一种：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> LayoutBox &#123;</span><br><span class="line">    <span class="comment">// Lay out a box and its descendants.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">layout</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, containing_block: Dimensions) &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.box_type &#123;</span><br><span class="line">            BlockNode(_) =&gt; <span class="keyword">self</span>.layout_block(containing_block),</span><br><span class="line">            InlineNode(_) =&gt; &#123;&#125; <span class="comment">// TODO</span></span><br><span class="line">            AnonymousBlock =&gt; &#123;&#125; <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>块(block)</strong> 的布局取决于其 <strong>包含块(containing block)</strong> 的尺寸。对于正常流的块级盒子，这就是盒子的父级。对于根元素来说，就是浏览器窗口（或者视图）的大小了。</p>
<p>你应该记得上篇文章说过，<strong>块(block)</strong> 的宽度取决于它的父级，而它的高度则取决于子级。这意味着我们的代码需要自上而下地遍历树来计算宽度，这样才可以在知道父级的宽度之后布局子级。接着要自下而上遍历树来计算高度，这样计算完子级的高度就自然可以得到父级的高度。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">layout_block</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, containing_block: Dimensions) &#123;</span><br><span class="line">    <span class="comment">// Child width can depend on parent width, so we need to calculate</span></span><br><span class="line">    <span class="comment">// this box&#x27;s width before laying out its children.</span></span><br><span class="line">    <span class="keyword">self</span>.calculate_block_width(containing_block);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine where the box is located within its container.</span></span><br><span class="line">    <span class="keyword">self</span>.calculate_block_position(containing_block);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively lay out the children of this box.</span></span><br><span class="line">    <span class="keyword">self</span>.layout_block_children();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent height can depend on child height, so `calculate_height`</span></span><br><span class="line">    <span class="comment">// must be called *after* the children are laid out.</span></span><br><span class="line">    <span class="keyword">self</span>.calculate_block_height();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数执行了布局树的单个遍历，通过向下的路径计算宽度，向上的路径来计算高度。一个真正的布局引擎可能会执行多次树的遍历，有时自上而下，有时自下向上。</p>
<h2 id="计算宽度-Calculating-the-width"><a href="#计算宽度-Calculating-the-width" class="headerlink" title="计算宽度 Calculating the width"></a>计算宽度 Calculating the width</h2><p>块的布局函数的第一步就是计算宽度，也是最复杂的步骤。我将逐步介绍。首先，我们需要CSS的<code>width</code>属性的值和所有左右边缘的大小：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_block_width</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, containing_block: Dimensions) &#123;</span><br><span class="line">    <span class="keyword">let</span> style = <span class="keyword">self</span>.get_style_node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `width` has initial value `auto`.</span></span><br><span class="line">    <span class="keyword">let</span> auto = Keyword(<span class="string">&quot;auto&quot;</span>.to_string());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> width = style.value(<span class="string">&quot;width&quot;</span>).unwrap_or(auto.clone());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// margin, border, and padding have initial value 0.</span></span><br><span class="line">    <span class="keyword">let</span> zero = Length(<span class="number">0.0</span>, Px);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> margin_left = style.lookup(<span class="string">&quot;margin-left&quot;</span>, <span class="string">&quot;margin&quot;</span>, &amp;zero);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> margin_right = style.lookup(<span class="string">&quot;margin-right&quot;</span>, <span class="string">&quot;margin&quot;</span>, &amp;zero);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> border_left = style.lookup(<span class="string">&quot;border-left-width&quot;</span>, <span class="string">&quot;border-width&quot;</span>, &amp;zero);</span><br><span class="line">    <span class="keyword">let</span> border_right = style.lookup(<span class="string">&quot;border-right-width&quot;</span>, <span class="string">&quot;border-width&quot;</span>, &amp;zero);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> padding_left = style.lookup(<span class="string">&quot;padding-left&quot;</span>, <span class="string">&quot;padding&quot;</span>, &amp;zero);</span><br><span class="line">    <span class="keyword">let</span> padding_right = style.lookup(<span class="string">&quot;padding-right&quot;</span>, <span class="string">&quot;padding&quot;</span>, &amp;zero);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这使用了一个名为<code>lookup</code>的辅助函数，该函数仅按顺序尝试一系列的值。如果第一个属性没设置，它会尝试第二个属性。如果都没有设置，它会返回所设置的默认值。这里提供了一个不完善（但是简单）的 <strong>快捷属性(shorthand properties)</strong> 和 <strong>初始值(initial values)</strong> 的实现版本。</p>
<blockquote>
<p>Rust笔记：下面的代码和JavaScript或者Ruby类似</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margin_left = style[<span class="string">&quot;margin-left&quot;</span>] || style[<span class="string">&quot;margin&quot;</span>] || zero;</span><br></pre></td></tr></table></figure>

<p>由于子级无法改变父级的宽度，因此需要确保自己的宽度适合父级的宽度。CSS规范将其表示为一组约束和求解约束的算法。以下代码实现了该算法。</p>
<p>首先我们将<code>margin</code>，<code>padding</code>，<code>border</code>和内容宽度加在一起。<code>to_px</code>辅助函数将长度转换成他们的数值。如果属性设置为<code>auto</code>，则返回0，因此它无法影响总数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = [&amp;margin_left, &amp;margin_right, &amp;border_left, &amp;border_right,</span><br><span class="line">             &amp;padding_left, &amp;padding_right, &amp;width].iter().map(|v| v.to_px()).sum();</span><br></pre></td></tr></table></figure>

<p>这就是盒子需要的最小水平空间。如果他和容器的宽度不相等，那我们需要做些调整使其相等。</p>
<p>如果<code>width</code>或者<code>margins</code>设置成<code>auto</code>，他们可以扩展或者收缩以适应可用的空间。根据规范，我们首先要检查盒子是否太大。如果太大，我们将所有可扩展的<code>margins</code>设置为0。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If width is not auto and the total is wider than the container, treat auto margins as 0.</span></span><br><span class="line"><span class="keyword">if</span> width != auto &amp;&amp; total &gt; containing_block.content.width &#123;</span><br><span class="line">    <span class="keyword">if</span> margin_left == auto &#123;</span><br><span class="line">        margin_left = Length(<span class="number">0.0</span>, Px);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> margin_right == auto &#123;</span><br><span class="line">        margin_right = Length(<span class="number">0.0</span>, Px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果盒子比容器还大。它就 <strong>溢出(overflow)</strong> 了容器。如果他太小，他将 **下溢(underflow)**，留下额外的空间。我们将计算下溢量——容器中剩余的额外空间量。（如果数字为负数，实际上是一个溢出）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> underflow = containing_block.content.width - total;</span><br></pre></td></tr></table></figure>

<p>现在我们依照规范的算法，通过调整可扩展的尺寸来消除任何溢出或下溢。如果没有<code>auto</code>的尺寸，我们就调整右边的<code>margin</code>（是的，这意味着溢出时<code>margin</code>可能为负值）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> (width == auto, margin_left == auto, margin_right == auto) &#123;</span><br><span class="line">    <span class="comment">// If the values are overconstrained, calculate margin_right.</span></span><br><span class="line">    (<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">        margin_right = Length(margin_right.to_px() + underflow, Px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If exactly one size is auto, its used value follows from the equality.</span></span><br><span class="line">    (<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>) =&gt; &#123; margin_right = Length(underflow, Px); &#125;</span><br><span class="line">    (<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>) =&gt; &#123; margin_left  = Length(underflow, Px); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If width is set to auto, any other auto values become 0.</span></span><br><span class="line">    (<span class="literal">true</span>, _, _) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> margin_left == auto &#123; margin_left = Length(<span class="number">0.0</span>, Px); &#125;</span><br><span class="line">        <span class="keyword">if</span> margin_right == auto &#123; margin_right = Length(<span class="number">0.0</span>, Px); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> underflow &gt;= <span class="number">0.0</span> &#123;</span><br><span class="line">            <span class="comment">// Expand width to fill the underflow.</span></span><br><span class="line">            width = Length(underflow, Px);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Width can&#x27;t be negative. Adjust the right margin instead.</span></span><br><span class="line">            width = Length(<span class="number">0.0</span>, Px);</span><br><span class="line">            margin_right = Length(margin_right.to_px() + underflow, Px);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If margin-left and margin-right are both auto, their used values are equal.</span></span><br><span class="line">    (<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>) =&gt; &#123;</span><br><span class="line">        margin_left = Length(underflow / <span class="number">2.0</span>, Px);</span><br><span class="line">        margin_right = Length(underflow / <span class="number">2.0</span>, Px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，约束已得到解决，并且所有<code>auto</code>的值都被转换成长度。结果就是盒子水平尺寸的 **使用值(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html#used-value">used values</a>)**，我们将它存储在 **布局树(layout tree)**。你可以在 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/619a03bea918a0c756655fae02a004e6b4a3974c/src/layout.rs#L132-L217">layout.rs</a> 看到最终的代码。</p>
<h2 id="定位-Positioning"><a href="#定位-Positioning" class="headerlink" title="定位 Positioning"></a>定位 Positioning</h2><p>下个步骤相对比较简单。这个函数查找剩余的<code>margin</code>/<code>padding</code>/<code>border</code>样式，然后使用它们和 <strong>包含块(containing block)</strong> 的尺寸决定这个块在页面的位置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_block_position</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, containing_block: Dimensions) &#123;</span><br><span class="line">    <span class="keyword">let</span> style = <span class="keyword">self</span>.get_style_node();</span><br><span class="line">    <span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.dimensions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// margin, border, and padding have initial value 0.</span></span><br><span class="line">    <span class="keyword">let</span> zero = Length(<span class="number">0.0</span>, Px);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If margin-top or margin-bottom is `auto`, the used value is zero.</span></span><br><span class="line">    d.margin.top = style.lookup(<span class="string">&quot;margin-top&quot;</span>, <span class="string">&quot;margin&quot;</span>, &amp;zero).to_px();</span><br><span class="line">    d.margin.bottom = style.lookup(<span class="string">&quot;margin-bottom&quot;</span>, <span class="string">&quot;margin&quot;</span>, &amp;zero).to_px();</span><br><span class="line"></span><br><span class="line">    d.border.top = style.lookup(<span class="string">&quot;border-top-width&quot;</span>, <span class="string">&quot;border-width&quot;</span>, &amp;zero).to_px();</span><br><span class="line">    d.border.bottom = style.lookup(<span class="string">&quot;border-bottom-width&quot;</span>, <span class="string">&quot;border-width&quot;</span>, &amp;zero).to_px();</span><br><span class="line"></span><br><span class="line">    d.padding.top = style.lookup(<span class="string">&quot;padding-top&quot;</span>, <span class="string">&quot;padding&quot;</span>, &amp;zero).to_px();</span><br><span class="line">    d.padding.bottom = style.lookup(<span class="string">&quot;padding-bottom&quot;</span>, <span class="string">&quot;padding&quot;</span>, &amp;zero).to_px();</span><br><span class="line"></span><br><span class="line">    d.content.x = containing_block.content.x +</span><br><span class="line">                  d.margin.left + d.border.left + d.padding.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position the box below all the previous boxes in the container.</span></span><br><span class="line">    d.content.y = containing_block.content.height + containing_block.content.y +</span><br><span class="line">                  d.margin.top + d.border.top + d.padding.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看最后的一条设置y位置的语句。这就是使 <strong>块布局(block layout)</strong> 具有独特的 <strong>垂直堆叠(vertical stacking)</strong> 行为的原因。为此，我们需要确保在对每个子级布局之后，更新父级的<code>content.height</code>。</p>
<h2 id="子级-Child"><a href="#子级-Child" class="headerlink" title="子级 Child"></a>子级 Child</h2><p>这是递归排列盒子内容的代码。当遍历子级盒子时，它会跟踪总内容的高度。这被计算定位（上述）的代码用来查找下个子级的 <strong>垂直位置(vertical position)</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">layout_block_children</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.dimensions;</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.children &#123;</span><br><span class="line">        child.layout(*d);</span><br><span class="line">        <span class="comment">// Track the height so each child is laid out below the previous content.</span></span><br><span class="line">        d.content.height = d.content.height + child.dimensions.margin_box().height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个子级占用的垂直空间总和就是它的<code>margin box</code>的高度。我们这样计算：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Dimensions &#123;</span><br><span class="line">    <span class="comment">// The area covered by the content area plus its padding.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">padding_box</span></span>(<span class="keyword">self</span>) -&gt; Rect &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.expanded_by(<span class="keyword">self</span>.padding)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The area covered by the content area plus padding and borders.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">border_box</span></span>(<span class="keyword">self</span>) -&gt; Rect &#123;</span><br><span class="line">        <span class="keyword">self</span>.padding_box().expanded_by(<span class="keyword">self</span>.border)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The area covered by the content area plus padding, borders, and margin.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">margin_box</span></span>(<span class="keyword">self</span>) -&gt; Rect &#123;</span><br><span class="line">        <span class="keyword">self</span>.border_box().expanded_by(<span class="keyword">self</span>.margin)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rect &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">expanded_by</span></span>(<span class="keyword">self</span>, edge: EdgeSizes) -&gt; Rect &#123;</span><br><span class="line">        Rect &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x - edge.left,</span><br><span class="line">            y: <span class="keyword">self</span>.y - edge.top,</span><br><span class="line">            width: <span class="keyword">self</span>.width + edge.left + edge.right,</span><br><span class="line">            height: <span class="keyword">self</span>.height + edge.top + edge.bottom,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了简单起见，不实现 **外边距折叠(margin collapsing)**。一个真正的布局引擎会允许一个盒子的<code>bottom margin</code>和下个盒子的<code>top magin</code>重叠，而不是将每个<code>margin box</code>完全放在前一个的下方。</p>
<h2 id="高度属性-The-‘height’-Property"><a href="#高度属性-The-‘height’-Property" class="headerlink" title="高度属性 The ‘height’ Property"></a>高度属性 The ‘height’ Property</h2><p>默认情况下，盒子的高度和它的内容高度相等。不过如果<code>height</code>属性设置了一个指定的长度，我们将改用它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_block_height</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// If the height is set to an explicit length, use that exact length.</span></span><br><span class="line">    <span class="comment">// Otherwise, just keep the value set by `layout_block_children`.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(Length(h, Px)) = <span class="keyword">self</span>.get_style_node().value(<span class="string">&quot;height&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dimensions.content.height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此结束了块的布局算法。现在你可以在一个有样式的HTML文档上调用<code>layout()</code>，它将吐出一群具有宽度，高度，边距等等的矩形。这很酷，对吧？</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-19T12:49:01.000Z" title="2/19/2020, 12:49:01 PM">2020-02-19</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">12 分钟读完 (大约1800个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/02/19/browser/how-broswers-work-5/">手把手教你实现一个浏览器引擎（五）Boxes</a></h1><div class="content"><h2 id="第五部分：Boxes"><a href="#第五部分：Boxes" class="headerlink" title="第五部分：Boxes"></a>第五部分：Boxes</h2><p>这是关于编写一个简单HTML渲染引擎系列文章的最后一篇（译者注：后续两篇是对这部分内容的补充）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00086eef5fcff8f5b3c97d08551413">第一部分：起步</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">第二部分：HTML</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/0004ae6f0b4c80883de95cfaa59413">第三部分：CSS</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000c0e53584310a068e9f0f7c5fc13">第四部分：Style</a></li>
</ul>
<p>这篇文章将开始讨论 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/master/src/layout.rs">布局(layout)</a> 模块，它将输入的样式树，转换成二维空间的一堆矩形。这是一个庞大的模块，因此我将它拆分成多篇文章。另外，我为后面部分内容写代码时，可能会改动这篇文章分享的一些代码。</p>
<p>布局模块的输入是来自 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000c0e53584310a068e9f0f7c5fc13">第四部分</a> 的样式树，输出的是其他的树——**布局树(layout tree)**。这让我们的迷你渲染流程向前迈进了一步：</p>
<p><img src="/blog/images/browsers/boxes-1.jpg"></p>
<p>我将从基础的HTML/CSS布局模型开始讲起。如果你曾经学过开发网页，则可能已经对这些比较熟悉——不过它可能和开发者的视角不太一样。</p>
<h2 id="盒模型-The-Box-Model"><a href="#盒模型-The-Box-Model" class="headerlink" title="盒模型 The Box Model"></a>盒模型 The Box Model</h2><p>布局与 <strong>盒子(boxes)</strong> 有关。盒子是网页的矩形部分。它有 **宽度(width)<strong>，</strong>高度(height)**，和在页面上的 **位置(position)**。这个矩形被称为 <strong>内容区域(content area)</strong> ，因为它是盒子内容绘制的位置。内容可能是文本，图片，视频或者其他盒子。</p>
<p>盒子可能也有 <strong>内边距(padding)<strong>，</strong>边框(borders)<strong>，</strong>外边距(margins)</strong> 围绕着它的内容区域。CSS规范有一张 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/box.html#box-dimensions">例图</a> 展示了所有这些层是如何组合在一起的。</p>
<p>Robinson使用以下的结构来存储盒子的内容区域和周围区域。</p>
<blockquote>
<p>Rust笔记：<code>f32</code>是32位浮点类型。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSS box model. All sizes are in px.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dimensions</span></span> &#123;</span><br><span class="line">    <span class="comment">// Position of the content area relative to the document origin:</span></span><br><span class="line">    content: Rect,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Surrounding edges:</span></span><br><span class="line">    padding: EdgeSizes,</span><br><span class="line">    border: EdgeSizes,</span><br><span class="line">    margin: EdgeSizes,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">f32</span>,</span><br><span class="line">    y: <span class="built_in">f32</span>,</span><br><span class="line">    width: <span class="built_in">f32</span>,</span><br><span class="line">    height: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeSizes</span></span> &#123;</span><br><span class="line">    left: <span class="built_in">f32</span>,</span><br><span class="line">    right: <span class="built_in">f32</span>,</span><br><span class="line">    top: <span class="built_in">f32</span>,</span><br><span class="line">    bottom: <span class="built_in">f32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="块和内联布局-Block-and-Inline-Layout"><a href="#块和内联布局-Block-and-Inline-Layout" class="headerlink" title="块和内联布局 Block and Inline Layout"></a>块和内联布局 Block and Inline Layout</h2><p>CSS的<code>display</code>属性决定元素生成哪种类型的盒子。CSS定义了多种盒类型，各自有自己的布局规则。我只打算介绍其中两种：<strong>块(block)</strong> 和 **内联(inline)**。</p>
<p>我使用伪HTML来说明两者的差别：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c</span>&gt;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">d</span>&gt;</span><span class="tag">&lt;/<span class="name">d</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>块状盒子(Block boxes)</strong> 自上而下垂直地在他们的容器内排列。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c, d &#123; <span class="attribute">display</span>: block; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/browsers/boxes-2.jpg"></p>
<p><strong>内联盒子(inline boxes)</strong> 自左向右水平地在他们的容器里排列。如果他们触碰到容器的右边缘，将会环绕着容器，并继续在下面起新的一行排列。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c, d &#123; <span class="attribute">display</span>: inline; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/browsers/boxes-3.jpg"></p>
<p>每个盒子只能包含 **块级子元素(block children)**，或者 **内联子元素(inline children)**。当一个DOM元素包含了混合块级子元素和内联子元素时，布局引擎插入一个 <strong>匿名盒子(anonymous boxes)</strong> 去分隔两种类型。（这些盒子是“匿名的”，因为他们与DOM树种的节点没有关联）</p>
<p>在这个例子中，内联盒子 b 和 c 被一个匿名块状盒子围绕着，用粉色显示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>    &#123; <span class="attribute">display</span>: block; &#125;</span><br><span class="line"><span class="selector-tag">b</span>, c &#123; <span class="attribute">display</span>: inline; &#125;</span><br><span class="line">d    &#123; <span class="attribute">display</span>: block; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/browsers/boxes-4.jpg"></p>
<p>注意，默认情况下内容是纵向增长的。也就是说，添加子元素到容器内，通常使其变得更高，而不是更宽。换句话说，一块或者一行的宽度是依赖它们容器的宽度，而容器的高度则依赖子元素的高度。</p>
<p>如果你覆盖了例如<code>width</code>和<code>height</code>属性的默认值的话，情况将变得更加复杂。如果要支持垂直书写这样的特性的话，则情况会更加复杂。</p>
<h2 id="布局树-The-Layout-Tree"><a href="#布局树-The-Layout-Tree" class="headerlink" title="布局树 The Layout Tree"></a>布局树 The Layout Tree</h2><p>布局树是盒子的集合。盒子有尺寸，并且可能包含 **子盒子(child boxes)**。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutBox</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    dimensions: Dimensions,</span><br><span class="line">    box_type: BoxType&lt;<span class="symbol">&#x27;a</span>&gt;,</span><br><span class="line">    children: <span class="built_in">Vec</span>&lt;LayoutBox&lt;<span class="symbol">&#x27;a</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>盒子可以是一个块级节点，一个内联节点，或者是一个匿名块状盒子（如果我实现文本布局，这个将需要改变，因为换行会导致单个内联节点拆分为多个盒子。不过目前这样也是可以的）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BoxType</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    BlockNode(&amp;<span class="symbol">&#x27;a</span> StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    InlineNode(&amp;<span class="symbol">&#x27;a</span> StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;),</span><br><span class="line">    AnonymousBlock,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构建布局树，我们需要查看每个DOM节点的<code>display</code>属性。为了获得节点的<code>display</code>的值，我在<code>style</code>模块添加了一些代码。如果没有指定的值，则返回默认值<code>inline</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">enum Display &#123;</span><br><span class="line">    Inline,</span><br><span class="line">    Block,</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl StyledNode &#123;</span><br><span class="line">    // Return the specified value of a property if it exists, otherwise `None`.</span><br><span class="line">    fn value(&amp;self, name: &amp;str) -&gt; Option&lt;Value&gt; &#123;</span><br><span class="line">        self.specified_values.get(name).map(|v| v.clone())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The value of the `display` property (defaults to inline).</span><br><span class="line">    fn display(&amp;self) -&gt; Display &#123;</span><br><span class="line">        match self.value(&quot;display&quot;) &#123;</span><br><span class="line">            Some(Keyword(s)) =&gt; match &amp;*s &#123;</span><br><span class="line">                &quot;block&quot; =&gt; Display::Block,</span><br><span class="line">                &quot;none&quot; =&gt; Display::None,</span><br><span class="line">                _ =&gt; Display::Inline</span><br><span class="line">            &#125;,</span><br><span class="line">            _ =&gt; Display::Inline</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以遍历样式树，为每个节点构建一个<code>LayoutBox</code>，然后为改节点的子级插入盒子。如果一个节点的<code>display</code>属性设置成<code>none</code>，那么它将不会被包含在布局树里。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build the tree of LayoutBoxes, but don&#x27;t perform any layout calculations yet.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_layout_tree</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(style_node: &amp;<span class="symbol">&#x27;a</span> StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;) -&gt; LayoutBox&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// Create the root box.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> root = LayoutBox::new(<span class="keyword">match</span> style_node.display() &#123;</span><br><span class="line">        Block =&gt; BlockNode(style_node),</span><br><span class="line">        Inline =&gt; InlineNode(style_node),</span><br><span class="line">        DisplayNone =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Root node has display: none.&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the descendant boxes.</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> &amp;style_node.children &#123;</span><br><span class="line">        <span class="keyword">match</span> child.display() &#123;</span><br><span class="line">            Block =&gt; root.children.push(build_layout_tree(child)),</span><br><span class="line">            Inline =&gt; root.get_inline_container().children.push(build_layout_tree(child)),</span><br><span class="line">            DisplayNone =&gt; &#123;&#125; <span class="comment">// Skip nodes with `display: none;`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> LayoutBox &#123;</span><br><span class="line">    <span class="comment">// Constructor function</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(box_type: BoxType) -&gt; LayoutBox &#123;</span><br><span class="line">        LayoutBox &#123;</span><br><span class="line">            box_type: box_type,</span><br><span class="line">            dimensions: <span class="built_in">Default</span>::default(), <span class="comment">// initially set all fields to 0.0</span></span><br><span class="line">            children: <span class="built_in">Vec</span>::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个块级节点包含一个内联子级，创建一个匿名块级盒子去包含它。如果有多个内联子级在同一行，那么将他们都放在同一个匿名容器里。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Where a new inline child should go.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_inline_container</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> LayoutBox &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.box_type &#123;</span><br><span class="line">        InlineNode(_) | AnonymousBlock =&gt; <span class="keyword">self</span>,</span><br><span class="line">        BlockNode(_) =&gt; &#123;</span><br><span class="line">            <span class="comment">// If we&#x27;ve just generated an anonymous block box, keep using it.</span></span><br><span class="line">            <span class="comment">// Otherwise, create a new one.</span></span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.children.last() &#123;</span><br><span class="line">                <span class="literal">Some</span>(&amp;LayoutBox &#123; box_type: AnonymousBlock,..&#125;) =&gt; &#123;&#125;</span><br><span class="line">                _ =&gt; <span class="keyword">self</span>.children.push(LayoutBox::new(AnonymousBlock))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.children.last_mut().unwrap()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是从标准CSS <strong>盒子生成(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/visuren.html#box-gen">box generation</a>)</strong> 算法刻意通过多种方式简化后的版本。例如，这版本无法处理一个内联盒子包含块级子级的情况。还有，如果一个块级节点仅有一个内联子级，这会生成一个不必要的匿名盒子。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://limpet.net/mbrubeck/2014/09/08/toy-layout-engine-5-boxes.html">https://limpet.net/mbrubeck/2014/09/08/toy-layout-engine-5-boxes.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-12T12:49:01.000Z" title="2/12/2020, 12:49:01 PM">2020-02-12</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">19 分钟读完 (大约2877个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/02/12/browser/how-broswers-work-4/">手把手教你实现一个浏览器引擎（四）Style</a></h1><div class="content"><h2 id="第四部分-Style"><a href="#第四部分-Style" class="headerlink" title="第四部分 Style"></a>第四部分 Style</h2><p>欢迎回到关于构建你自己的玩具浏览器引擎的系列文章。如果你是刚开始收看文章，你可以从下面找到以前的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00086eef5fcff8f5b3c97d08551413">第一部分：起步</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">第二部分：HTML</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/0004ae6f0b4c80883de95cfaa59413">第三部分：CSS</a></li>
</ul>
<p>本文将会介绍在CSS标准中所谓的 分配属性值(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html">assigning vproperty values</a>) 或者 样式模块(<a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/275ea716d50565b10ce91c0054fbf527281180bb/src/style.rs">style</a> module)。这个模块将拿DOM节点和CSS规则作为输入，将他们互相匹配，为所给的所有节点确定每个CSS属性的值。</p>
<p>这部分不会包含很多代码，因为我还没有实现相对复杂的部分。然而，我觉得剩下的仍然相当有趣，我还会解释如何实现一些缺失的部分。</p>
<h2 id="样式树-The-Style-Tree"><a href="#样式树-The-Style-Tree" class="headerlink" title="样式树 The Style Tree"></a>样式树 The Style Tree</h2><p>我将Robinson的样式模块的输出称为 **样式树(style tree)**， 在树里的每个节点都指向一个DOM节点，加上它的CSS属性值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map from CSS property names to values.</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">PropertyMap</span></span> = HashMap&lt;<span class="built_in">String</span>, Value&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A node with associated style data.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StyledNode</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    node: &amp;<span class="symbol">&#x27;a</span> Node, <span class="comment">// pointer to a DOM node</span></span><br><span class="line">    specified_values: PropertyMap,</span><br><span class="line">    children: <span class="built_in">Vec</span>&lt;StyledNode&lt;<span class="symbol">&#x27;a</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&#39;a</code>是什么意思呢？这是都是生命周期，是Rust保证指针是内存安全的且不需要进行垃圾收集的一部分。如果你不是使用Rust工作的话，你可以忽略他们。他们对代码的意义影响不是很大。</p>
</blockquote>
<p>其实，我们可以给<code>dom:Node</code>的结构增加字段，而不是创建一个新的树。但是我想抱着样式的代码和之前的“课程”相对独立。这也是给了我一个机会讲一下在大部分渲染引擎都会出现的 <strong>平行树(parallel trees)</strong> </p>
<p>浏览器引擎模块经常会将一个树当做输入，然后输出一个不同但是相关的树 。比如，Gecko的 <a target="_blank" rel="noopener" href="https://wiki.mozilla.org/Gecko:Key_Gecko_Structures_And_Invariants">布局代码(layout code)</a> 利用 <strong>DOM树</strong> 生成 **框架树(frame tree)**，然后将用于构建 **视图树(view tree)**。Blink 和 WebKit 将 DOM树 转换成 **渲染树(render tree)**。在这些引擎的后面阶段还会生成很多树，包括 <strong>层级树(layer tree)</strong> 和 **部件树(widget tree)**。</p>
<p>在完成其他几个阶段之后，我们的玩具浏览器引擎的流水线(pipeline)将会看起来像是这样：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/qpiaQcgGBL79wMzjlEyguV4WXTXbgtCwIOX8zNJ9KlOP8TScxxusxZbvAtic8qkmKC54PicgBRUe5iaRibIQIY764oQ/0?wx_fmt=jpeg"></p>
<p>在我的实现方式里，DOM树里的每个节点在样式树里都只有一个节点。但是在更复杂的流水线阶段，几个输入的节点可能会合并成一个输出节点。或者，一个输入节点可能会扩展为多个输出节点，或者被完全跳过。例如，样式树可能移除一个<code>display</code>属性设置成<code>none</code>的元素。（相反，我将在布局阶段移除这些，因为我的代码反而比较简单）</p>
<h2 id="匹配选择器-Selector-Matching"><a href="#匹配选择器-Selector-Matching" class="headerlink" title="匹配选择器 Selector Matching"></a>匹配选择器 Selector Matching</h2><p>构建 <strong>样式树(style tree)</strong> 的第一步就是匹配选择器。因为我的CSS解析器只支持简单选择器，因此这将是很简单。可以通过查看元素本身来判断简单选择器是否与元素匹配。匹配复合选择器则需要遍历整个DOM树来查看元素的 <strong>兄弟元素(siblings)<strong>，</strong>父元素(parents)</strong> 等等。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matches</span></span>(elem: &amp;ElementData, selector: &amp;Selector) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> *selector &#123;</span><br><span class="line">        Simple(<span class="keyword">ref</span> simple_selector) =&gt; matches_simple_selector(elem, simple_selector)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了提供帮助，我们将给我们的 DOM元素类型 增加一些遍历的ID和class访问器。class属性可以包含多个用空格分隔的类名，最后将这些类名通过哈希表的形式返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> ElementData &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">id</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.attributes.get(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">classes</span></span>(&amp;<span class="keyword">self</span>) -&gt; HashSet&lt;&amp;<span class="built_in">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.attributes.get(<span class="string">&quot;class&quot;</span>) &#123;</span><br><span class="line">            <span class="literal">Some</span>(classlist) =&gt; classlist.split(<span class="string">&#x27; &#x27;</span>).collect(),</span><br><span class="line">            <span class="literal">None</span> =&gt; HashSet::new()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要测试一个简单选择器是否匹配了元素，只需要查看每个选择器的 <strong>组件(component)</strong> ，如果一个元素没有一个匹配上的class，ID或者标签名就返回<code>false</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matches_simple_selector</span></span>(elem: &amp;ElementData, selector: &amp;SimpleSelector) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="comment">// Check type selector</span></span><br><span class="line">    <span class="keyword">if</span> selector.tag_name.iter().any(|name| elem.tag_name != *name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check ID selector</span></span><br><span class="line">    <span class="keyword">if</span> selector.id.iter().any(|id| elem.id() != <span class="literal">Some</span>(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check class selectors</span></span><br><span class="line">    <span class="keyword">let</span> elem_classes = elem.classes();</span><br><span class="line">    <span class="keyword">if</span> selector.class.iter().any(|class| !elem_classes.contains(&amp;**class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We didn&#x27;t find any non-matching selector components.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Rust笔记：这个函数使用<code>any</code>这个方法，如果迭代器包含一个可以通过提供的测试函数的元素则返回true。类似于 Python 或者 Haskell 里的 <code>any</code> 函数，JavaScript 里的 <code>some</code> 方法</p>
</blockquote>
<h2 id="构建样式树-Build-the-Style-Tree"><a href="#构建样式树-Build-the-Style-Tree" class="headerlink" title="构建样式树 Build the Style Tree"></a>构建样式树 Build the Style Tree</h2><p>接下来，我们需要遍历整个DOM树，对于树中的每个元素，我们将在样式表中搜索匹配的规则。</p>
<p>比较两个匹配相同元素的规则时，我们需要使用每个匹配项中 <strong>最高明确性(highest specificity)</strong> 的选择器。因为我们CSS解析器储存的选择器是按明确性从高往低排序的，所以我们可以在找到匹配的选择器后立即停止，然后返回其明确性以及规则的指针。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">MatchedRule</span></span>&lt;<span class="symbol">&#x27;a</span>&gt; = (Specificity, &amp;<span class="symbol">&#x27;a</span> Rule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If `rule` matches `elem`, return a `MatchedRule`. Otherwise return `None`.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">match_rule</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(elem: &amp;ElementData, rule: &amp;<span class="symbol">&#x27;a</span> Rule) -&gt; <span class="built_in">Option</span>&lt;MatchedRule&lt;<span class="symbol">&#x27;a</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Find the first (highest-specificity) matching selector.</span></span><br><span class="line">    rule.selectors.iter()</span><br><span class="line">        .find(|selector| matches(elem, *selector))</span><br><span class="line">        .map(|selector| (selector.specificity(), rule))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了找到与某个元素匹配的所有规则，我们调用<code>filter_map</code>方法，它可以线性扫描整个样式表，检查每个规则并丢弃不匹配的规则。真正的浏览器引擎会通过基于标签名，ID，class等将规则存储在多个哈希表，从而实现快速匹配。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all CSS rules that match the given element.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">matching_rules</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(elem: &amp;ElementData, stylesheet: &amp;<span class="symbol">&#x27;a</span> Stylesheet) -&gt; <span class="built_in">Vec</span>&lt;MatchedRule&lt;<span class="symbol">&#x27;a</span>&gt;&gt; &#123;</span><br><span class="line">    stylesheet.rules.iter().filter_map(|rule| match_rule(elem, rule)).collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦有了匹配的规则，我们就可以找到元素的 **指定值(specified value)**。将每个规则的属性值插入到<code>HashMap</code>。将规则按 <strong>明确性(specificity)</strong> 排序，这样较高明确性的规则会在较低的之后进行处理，可以在<code>HashMap</code>将它们的值覆盖。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply styles to a single element, returning the specified values.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">specified_values</span></span>(elem: &amp;ElementData, stylesheet: &amp;Stylesheet) -&gt; PropertyMap &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> values = HashMap::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rules = matching_rules(elem, stylesheet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go through the rules from lowest to highest specificity.</span></span><br><span class="line">    rules.sort_by(|&amp;(a, _), &amp;(b, _)| a.cmp(&amp;b));</span><br><span class="line">    <span class="keyword">for</span> (_, rule) <span class="keyword">in</span> rules &#123;</span><br><span class="line">        <span class="keyword">for</span> declaration <span class="keyword">in</span> &amp;rule.declarations &#123;</span><br><span class="line">            values.insert(declaration.name.clone(), declaration.value.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们拥有了遍历DOM树并构建样式树所需的一切。需要注意的是，选择器匹配仅适用于元素，因此文本节点的指定值只是一个空的<code>map</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply a stylesheet to an entire DOM tree, returning a StyledNode tree.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">style_tree</span></span>&lt;<span class="symbol">&#x27;a</span>&gt;(root: &amp;<span class="symbol">&#x27;a</span> Node, stylesheet: &amp;<span class="symbol">&#x27;a</span> Stylesheet) -&gt; StyledNode&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    StyledNode &#123;</span><br><span class="line">        node: root,</span><br><span class="line">        specified_values: <span class="keyword">match</span> root.node_type &#123;</span><br><span class="line">            Element(<span class="keyword">ref</span> elem) =&gt; specified_values(elem, stylesheet),</span><br><span class="line">            Text(_) =&gt; HashMap::new()</span><br><span class="line">        &#125;,</span><br><span class="line">        children: root.children.iter().map(|child| style_tree(child, stylesheet)).collect(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是Robinson关于构建样式树的所有代码。接下来，我将谈论一些明显的遗漏。</p>
<h2 id="层叠-Cascade"><a href="#层叠-Cascade" class="headerlink" title="层叠 Cascade"></a>层叠 Cascade</h2><p>由网页作者提供的样式表称为 **作者样式表(author stlye sheets)**，除此之外，浏览器还通过 <strong>用户代理样式表(user agent style sheets)</strong> 提供了<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/sample.html">默认样式</a>。还有它可以允许用户通过 <strong>用户样式表(user style sheets)</strong> 添加自定义样式（比如 Gecko 的 <a target="_blank" rel="noopener" href="http://www-archive.mozilla.org/unix/customizing.html#usercss">userContent.css</a>）。</p>
<p>层叠(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html#cascade">cascade</a>) 定义了这三个“数据源”哪个优先权更高。层叠有六个级别：每个数据源都有”普通(normal)“声明，加上每个数据源还有<code>!important</code>声明。</p>
<p>Robinson的样式代码没有实现层叠的功能。它仅读取一个样式表。缺少默认样式表意味着HTML元素不会有你预期的任何默认样式。例如：<code>&lt;head&gt;</code>元素的内容不会被隐藏，除非你明确在你的样式表中添加这个规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head &#123; <span class="attribute">display</span>: none &#125;</span><br></pre></td></tr></table></figure>

<p>实现层叠应该相当容易：只需跟踪每条规则的起源，并根据明确性排序，其中明确性要加入数据源和重要性这些权重。一个简化的两级层叠应该足以支持最常见的情况：普通用户代理样式 和 普通作者样式。</p>
<h2 id="计算值-Computed-Values"><a href="#计算值-Computed-Values" class="headerlink" title="计算值 Computed Values"></a>计算值 Computed Values</h2><p>除了上述提到的“指定值(sepecified values)”之外，CSS还定义了 <strong>初始值(initial values)<strong>，</strong>计算值(computed values)<strong>，</strong>使用值(used values)</strong> 和 **实际值(actual values)**。<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html#value-stages">CSS标准链接</a></p>
<p>初始值是层叠中没有指定的属性默认值。计算值则是基于指定值的，但可能会应用一些特定属性的规范化规则。</p>
<p>根据CSS规范的定义，正确实现这些属性需要为每个属性使用的单独的代码。这是现实浏览器引擎的必要工作，但希望在我的玩具项目中避免这些。在后面阶段，在缺少指定值的时候，使用这些值的代码会（通过某种方式）使用默认值来模拟初始值。</p>
<p>使用值 和 实际值则是在布局期间和布局之后计算的，我将在以后的文章中介绍。</p>
<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h2><p>如果文本节点不匹配任何选择器，那么它如何得到颜色和字体和其他样式呢？答案就是 <strong>继承</strong>(<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/cascade.html#inheritance">inheritance</a>)。</p>
<p>继承属性后，没有层叠值(cascaded value)的任何节点都将收到该属性的父元素的值。默认情况下，某些属性（如颜色）都是继承过来的；其他的属性只有在层叠值指定特殊值<code>inherit</code>时才会继承父元素。</p>
<p>我的代码没有支持继承。要实现这个，可以将父元素的样式数据传入<code>specified_values</code>函数，并使用硬编码的查找表来决定应继承哪些属性。</p>
<h2 id="样式属性-Style-Attributes"><a href="#样式属性-Style-Attributes" class="headerlink" title="样式属性 Style Attributes"></a>样式属性 Style Attributes</h2><p>任何HTML元素都可以包括一个<code>style</code>属性，其中包含一系列的CSS声明。它们没有选择器，因为这些声明自动应用到这个元素本身。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red; background: yellow;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  如果你想支持<code>style</code>属性，让<code>specified_values</code>函数检查属性即可。如果存在该属性，则将它从CSS解析器传入<code>parse_declarations</code>。由于这些属性比任何CSS选择器都更明确，因此在在 <strong>普通作者声明(normal author declarations)</strong> 之后应用这些 **结果声明(resulting declarations)**。</p>
<p>  原文链接：<a target="_blank" rel="noopener" href="https://limpet.net/mbrubeck/2014/08/23/toy-layout-engine-4-style.html">https://limpet.net/mbrubeck/2014/08/23/toy-layout-engine-4-style.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-10T12:49:01.000Z" title="2/10/2020, 12:49:01 PM">2020-02-10</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">12 分钟读完 (大约1839个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/02/10/browser/how-broswers-work-3/">手把手教你实现一个浏览器引擎（三）CSS</a></h1><div class="content"><h2 id="第三部分：CSS"><a href="#第三部分：CSS" class="headerlink" title="第三部分：CSS"></a>第三部分：CSS</h2><p>这是关于构建玩具浏览器渲染引擎的系列文章中的第三篇。想要构建你自己的吗？从开始的文章了解更多吧：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/00086eef5fcff8f5b3c97d08551413">第一部分：起步</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">第二部分：HTML</a></li>
</ul>
<p>本文介绍如何关于如何读取并解析 层叠样式表（Cascading Style Sheets，缩写为 CSS）的代码。和往常一样，我不会尝试去涵盖规范中的所有内容。取而代之的是，我会尝试实现这样一个渲染引擎：足以说明一些概念，并为渲染流程的后续阶段提供输入。</p>
<h2 id="解剖样式"><a href="#解剖样式" class="headerlink" title="解剖样式"></a>解剖样式</h2><p>这是CSS源代码的示例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123; <span class="attribute">margin</span>: auto; <span class="attribute">color</span>: <span class="number">#cc0000</span>; &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.note</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">20px</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; &#125;</span><br><span class="line"><span class="selector-id">#answer</span> &#123; <span class="attribute">display</span>: none; &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我将通过我的玩具渲染引擎 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson">Robinson</a> 来详细介绍 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/master/src/css.rs">css module</a>。代码是由 Rust 编写的，尽管这些概念可以轻松地转换成其他编程语言。先阅读前面的文章会帮助你更好理解下面的代码。</p>
<p>CSS样式表是一系列的规则（上面的示例，每一行包含一条规则）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stylesheet</span></span> &#123;</span><br><span class="line">    rules: <span class="built_in">Vec</span>&lt;Rule&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个规则包含一个或多个选择器（由逗号隔开）。后跟着一系列由大括号括起来的声明（declaration）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rule</span></span> &#123;</span><br><span class="line">    selectors: <span class="built_in">Vec</span>&lt;Selector&gt;,</span><br><span class="line">    declarations: <span class="built_in">Vec</span>&lt;Declaration&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择器可以是<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/selector.html#selector-syntax">简单选择器</a>，也可以是通过组合器连接的选择器链。Robinson 目前只支持简单选择器。</p>
<blockquote>
<p>令人困惑的是，在较新的 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/css3-selectors/">Selectors Level3</a> 标准中，使用了相同的术语表示稍有不同的东西。本文将主要参考 CSS2.1。尽管内容有些过时，但这是一个有用的起点，因为这更小且更独立（与CSS3相比，CSS3分为无数的规范，这些规范和CSS2.1各自相互依赖）</p>
</blockquote>
<p>在 Robinson，一个简单选择器可以包括一个标签名，一个带有 <code>#</code> 前缀的ID，任何以 <code>.</code> 为前缀的类名，或者以上的一些组合。如果标签名为空或者是 <code>*</code>，这是一个“通用选择器”，意味着将匹配所有标签。</p>
<p>还有很多其他类型的选择器（特别是CSS3），不过现在这就可以了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Selector</span></span> &#123;</span><br><span class="line">    Simple(SimpleSelector),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleSelector</span></span> &#123;</span><br><span class="line">    tag_name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    id: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    class: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明（declaration）是一个键值对，由冒号隔开，以分号结尾。举个例子：<code>margin: auto;</code>就是一个声明。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Declaration</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    value: Value,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的玩具引擎只支持CSS众多的值类型（value types）的少数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">    Keyword(<span class="built_in">String</span>),</span><br><span class="line">    Length(<span class="built_in">f32</span>, Unit),</span><br><span class="line">    ColorValue(Color),</span><br><span class="line">    <span class="comment">// insert more values here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Unit</span></span> &#123;</span><br><span class="line">    Px,</span><br><span class="line">    <span class="comment">// insert more units here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    r: <span class="built_in">u8</span>,</span><br><span class="line">    g: <span class="built_in">u8</span>,</span><br><span class="line">    b: <span class="built_in">u8</span>,</span><br><span class="line">    a: <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Rust提示：u8是一个8位的无符号整型，而 f32 则是 32位浮点型。</p>
</blockquote>
<p>其他的所有语法都不支持。包括 @规则，注释，其他上面没提到的选择器，值，单位。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>CSS具有常规的语法，相比起怪异的HTML更易于正确解析。一个符合标准的CSS解析器，遇到解析错误时，会丢弃样式表中不可识别的部分，然后继续处理剩余的部分。这很有用，因为它允许样式表包含新的语法，但仍在较旧的浏览器中产生定义良好的输出。</p>
<p>Robinson 使用了一个简化的（完全不符合标准的）解析器，和第二部分的HTML解析器构建方式相同。我将不再粘贴所有内容，而只是粘贴一些代码片段。例如，下面是解析单个选择器的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse one simple selector, e.g.: `type#id.class1.class2.class3`</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_simple_selector</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; SimpleSelector &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> selector = SimpleSelector &#123; tag_name: <span class="literal">None</span>, id: <span class="literal">None</span>, class: <span class="built_in">Vec</span>::new() &#125;;</span><br><span class="line">    <span class="keyword">while</span> !<span class="keyword">self</span>.eof() &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.next_char() &#123;</span><br><span class="line">            <span class="string">&#x27;#&#x27;</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.consume_char();</span><br><span class="line">                selector.id = <span class="literal">Some</span>(<span class="keyword">self</span>.parse_identifier());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">&#x27;.&#x27;</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.consume_char();</span><br><span class="line">                selector.class.push(<span class="keyword">self</span>.parse_identifier());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="string">&#x27;*&#x27;</span> =&gt; &#123;</span><br><span class="line">                <span class="comment">// universal selector</span></span><br><span class="line">                <span class="keyword">self</span>.consume_char();</span><br><span class="line">            &#125;</span><br><span class="line">            c <span class="keyword">if</span> valid_identifier_char(c) =&gt; &#123;</span><br><span class="line">                selector.tag_name = <span class="literal">Some</span>(<span class="keyword">self</span>.parse_identifier());</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的时，这缺少了错误检查。一些类似 <code>###</code> 或者 <code>*foo*</code> 的错误输入都会被成功解析，然后输出奇怪的结果。一个真正的CSS解析器将会忽略这些无效的选择器。</p>
<h2 id="明确性-Specificity"><a href="#明确性-Specificity" class="headerlink" title="明确性 Specificity"></a>明确性 Specificity</h2><p>明确性是渲染引擎在样式冲突时，决定哪个覆盖哪个的一种方式。</p>
<p>如果一个样式表中两个规则匹配同一个元素，那么具有较高明确性（high specificity)的匹配选择器的规则可以覆盖具有较低明确性的规则的值。</p>
<p>选择器的明确性取决于其组成部分。ID选择器比class选择器更明确，而class选择器比tag选择器更明确。重点是，选择器越多越明确。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">type</span> <span class="title">Specificity</span></span> = (<span class="built_in">usize</span>, <span class="built_in">usize</span>, <span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Selector &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">specificity</span></span>(&amp;<span class="keyword">self</span>) -&gt; Specificity &#123;</span><br><span class="line">        <span class="comment">// http://www.w3.org/TR/selectors/#specificity</span></span><br><span class="line">        <span class="keyword">let</span> Selector::Simple(<span class="keyword">ref</span> simple) = *<span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">let</span> a = simple.id.iter().count();</span><br><span class="line">        <span class="keyword">let</span> b = simple.class.len();</span><br><span class="line">        <span class="keyword">let</span> c = simple.tag_name.iter().count();</span><br><span class="line">        (a, b, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（如果我们支持链式选择器，我们可以通过将各个部分的明确性相加来计算一条链式选择器的明确性）</p>
<p>每个规则的选择器都存储在有序的数组（译者注：原文为vector，vector在rust表示自增长的数组）中，最具体的放前面。这对于匹配非常重要，我将在下一篇文章介绍。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a rule set: `&lt;selectors&gt; &#123; &lt;declarations&gt; &#125;`.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_rule</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; Rule &#123;</span><br><span class="line">    Rule &#123;</span><br><span class="line">        selectors: <span class="keyword">self</span>.parse_selectors(),</span><br><span class="line">        declarations: <span class="keyword">self</span>.parse_declarations()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse a comma-separated list of selectors.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_selectors</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;Selector&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> selectors = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        selectors.push(Selector::Simple(<span class="keyword">self</span>.parse_simple_selector()));</span><br><span class="line">        <span class="keyword">self</span>.consume_whitespace();</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.next_char() &#123;</span><br><span class="line">            <span class="string">&#x27;,&#x27;</span> =&gt; &#123; <span class="keyword">self</span>.consume_char(); <span class="keyword">self</span>.consume_whitespace(); &#125;</span><br><span class="line">            <span class="string">&#x27;&#123;&#x27;</span> =&gt; <span class="keyword">break</span>, <span class="comment">// start of declarations</span></span><br><span class="line">            c   =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unexpected character &#123;&#125; in selector list&quot;</span>, c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return selectors with highest specificity first, for use in matching.</span></span><br><span class="line">    selectors.sort_by(|a,b| b.specificity().cmp(&amp;a.specificity()));</span><br><span class="line">    <span class="keyword">return</span> selectors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS解析器的剩余部分是相当的直截了当的了。你可以在 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/master/src/css.rs">GitHub</a> 上看到完整的代码。如果你还没有阅读 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/community/develop/article/doc/000042df060558bcb3c9361ce5b013">系列文章第二部分</a>，这是一个很好的机会去尝试做一个分析程序生成器（parser generator）。我的手动（译者注：原文为hand-rolled，想表达的意思是作者的解析器是不完善的，只能手动读取文件）解析器可以完成简单文件的解析工作，但是如果你违反了其中的假设，那么将会有很多棘手的地方，且会运行失败。总有一天，我可能会用内置在 <a target="_blank" rel="noopener" href="https://github.com/kevinmehall/rust-peg/">rust-peg</a>的东西 或者 类似的东西替换它。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://limpet.net/mbrubeck/2014/08/13/toy-layout-engine-3-css.html">https://limpet.net/mbrubeck/2014/08/13/toy-layout-engine-3-css.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-01-23T12:49:01.000Z" title="1/23/2020, 12:49:01 PM">2020-01-23</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">13 分钟读完 (大约1974个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/01/23/browser/how-broswers-work-2/">手把手教你实现一个浏览器引擎（二）HTML</a></h1><div class="content"><p>这是关于构建一个玩具浏览器引擎这个系列文章的第二篇。</p>
<p>本文主要阐述如何将HTML源代码转化成Node节点树。解析（Parsing）是一个吸引人的主题，但是我没有足够的时间或专业知识来详细介绍它。你可以通过任何关于编译器（compilers）的好课程或书中获得有关解析（parsing）的详细介绍。或者选择你自己的编程语言，通过分析程序生成器(parser generator)的文档着手开始做项目也可以。</p>
<p>HTML拥有自己独特(unique)的解析算法。不像其他大部分编程语言和文件格式，HTML解析算法不拒绝非法输入。相反，它包含特定的错误处理操作指南，因此网络浏览器可以一致地显示每个网页，甚至是不符合语法规则的网页。网络浏览器不得不使这些不符合语法规则的页面正常显示：由于自web早期以来，就一直支持这些不符合要求的HTML，因此现在已有大量现有的页面正在使用这些不符合语法规则的HTML。</p>
<h1 id="一个简单的HTML例子"><a href="#一个简单的HTML例子" class="headerlink" title="一个简单的HTML例子"></a>一个简单的HTML例子</h1><p>我不打算尝试去实现标准的HTML解析算法。相反我写了一个基础的解析器，支持HTML语法的子集。我的解析器可以处理这样简单的页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">em</span>&gt;</span>world<span class="tag">&lt;/<span class="name">em</span>&gt;</span>!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下语法是允许的：</p>
<ul>
<li>平衡的标签(Balanced tags)：<code>&lt;p&gt;...&lt;/p&gt;</code></li>
<li>带上引号的属性值：<code>id=&quot;main&quot;</code></li>
<li>文本节点：<code>&lt;em&gt;world&lt;/em&gt;</code></li>
</ul>
<p>所有其他都是不支持的，包括以下：</p>
<ul>
<li>注释（Comments）</li>
<li>Doctype申明</li>
<li>转义字符（比如 $amp;) 和 CDATA sections</li>
<li>自闭合标签: <br/> 或者 <br> 没有闭合的标签</li>
<li>错误处理（如 标签不平衡 或者 不合理的嵌套标签）</li>
<li>命名空间（Namespaces） 和 其他 XHTML语法：<a href="html:body">html:body</a></li>
<li>字符编码检测</li>
</ul>
<p>在该项目的每个阶段，我都会或多或少地编写支持后续阶段所需的最少的代码。不过如果你想学习更多有关解析理论和工具的信息，你可以尽可能地完善你自己的项目。</p>
<h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><p>接下来，让我们来看一下我的玩具HTML解析器。切记这只是其中一种实现方式（可能不是最好的方式）。它的结构大致基于Servo的 cssparser 库的 tokenizer 模块。它没有真正的错误处理，在大部分的情况，只会在遇到不预期的语法时才会中断。代码是基于 Rust，但我希望对使用外观看似相似的语言如Java，C++或者C#的人来说，是可以理解的。可以看到，这使用了该系列文章第一部分的DOM数据结构。</p>
<p>解析器保存其输入的字符串（input）和该字符串当前的位置（pos）。这个位置是下一个我们还为处理的字符的索引（index）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Parser</span></span> &#123;</span><br><span class="line">    pos: <span class="built_in">usize</span>, <span class="comment">// &quot;usize&quot; is an unsigned integer, similar to &quot;size_t&quot; in C</span></span><br><span class="line">    input: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用它来实现一些简单的方法来寻找输入中的下一个字符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Parser &#123;</span><br><span class="line">    <span class="comment">// Read the current character without consuming it.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next_char</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">char</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.input[<span class="keyword">self</span>.pos..].chars().next().unwrap()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the next characters start with the given string?</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">starts_with</span></span>(&amp;<span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.input[<span class="keyword">self</span>.pos ..].starts_with(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if all input is consumed.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">eof</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pos &gt;= <span class="keyword">self</span>.input.len()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 的字符串是以 UTF-8 字节数组 的形式存储的。要跳转到到下一个字符，我们不能简单地前进一个字节。相反，我们使用 char_indices 来正确处理多字节字符（如果我们使用等宽字符的字符串，那我们可以仅给 pos 加一即可）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the current character, and advance self.pos to the next character.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">consume_char</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> iter = <span class="keyword">self</span>.input[<span class="keyword">self</span>.pos..].char_indices();</span><br><span class="line">    <span class="keyword">let</span> (_, cur_char) = iter.next().unwrap();</span><br><span class="line">    <span class="keyword">let</span> (next_pos, _) = iter.next().unwrap_or((<span class="number">1</span>, <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">    <span class="keyword">self</span>.pos += next_pos;</span><br><span class="line">    <span class="keyword">return</span> cur_char;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，我们会想要消耗一串连续的字符。consume_while 方法会一直收集字符，直到满足给定的条件，最终将他们以字符串的形式返回。这个方法的参数是一个接收字符返回布尔值的函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consume characters until `test` returns false.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">consume_while</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, test: F) -&gt; <span class="built_in">String</span></span><br><span class="line">        <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">char</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> result = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="keyword">while</span> !<span class="keyword">self</span>.eof() &amp;&amp; test(<span class="keyword">self</span>.next_char()) &#123;</span><br><span class="line">        result.push(<span class="keyword">self</span>.consume_char());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用这个来忽略一连串的空格字符。或者是消耗字母数字组成的字符串：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consume and discard zero or more whitespace characters.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">consume_whitespace</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.consume_while(CharExt::is_whitespace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse a tag or attribute name.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_tag_name</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.consume_while(|c| <span class="keyword">match</span> c &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>...<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>...<span class="string">&#x27;Z&#x27;</span> | <span class="string">&#x27;0&#x27;</span>...<span class="string">&#x27;9&#x27;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">        _ =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已做好准备开始解析HTML。解析一个独立的节点，我们先看它的第一个字符，可以区分这是一个元素（element）还是文本节点（text node）。在我们HTML的简化版本，一个文本节点可以包含非 &lt; 的任何字符。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a single node.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_node</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; dom::Node &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.next_char() &#123;</span><br><span class="line">        <span class="string">&#x27;&lt;&#x27;</span> =&gt; <span class="keyword">self</span>.parse_element(),</span><br><span class="line">        _   =&gt; <span class="keyword">self</span>.parse_text()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse a text node.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_text</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; dom::Node &#123;</span><br><span class="line">    dom::text(<span class="keyword">self</span>.consume_while(|c| c != <span class="string">&#x27;&lt;&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元素（element）则会更复杂一些。它包含开始和结束标签，以及标签之间的若干个子节点：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a single element, including its open tag, contents, and closing tag.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_element</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; dom::Node &#123;</span><br><span class="line">    <span class="comment">// Opening tag.</span></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.consume_char() == <span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> tag_name = <span class="keyword">self</span>.parse_tag_name();</span><br><span class="line">    <span class="keyword">let</span> attrs = <span class="keyword">self</span>.parse_attributes();</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.consume_char() == <span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Contents.</span></span><br><span class="line">    <span class="keyword">let</span> children = <span class="keyword">self</span>.parse_nodes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closing tag.</span></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.consume_char() == <span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.consume_char() == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.parse_tag_name() == tag_name);</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.consume_char() == <span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dom::elem(tag_name, attrs, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的简化语法，解析属性则是相对的简单。直到我们到达开始标签（&gt;）的末尾，我们反复查找名称，后跟=，然后是用引号引起来的字符串。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a single name=&quot;value&quot; pair.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_attr</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="keyword">self</span>.parse_tag_name();</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.consume_char() == <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">self</span>.parse_attr_value();</span><br><span class="line">    <span class="keyword">return</span> (name, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse a quoted value.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_attr_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> open_quote = <span class="keyword">self</span>.consume_char();</span><br><span class="line">    <span class="built_in">assert!</span>(open_quote == <span class="string">&#x27;&quot;&#x27;</span> || open_quote == <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">self</span>.consume_while(|c| c != open_quote);</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="keyword">self</span>.consume_char() == open_quote);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse a list of name=&quot;value&quot; pairs, separated by whitespace.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_attributes</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; dom::AttrMap &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> attributes = HashMap::new();</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.consume_whitespace();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.next_char() == <span class="string">&#x27;&gt;&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> (name, value) = <span class="keyword">self</span>.parse_attr();</span><br><span class="line">        attributes.insert(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析子节点，我们可以递归地调用 parse_node 在循环里，直到我们遇到结束标签。这个方法返回一个 Vec，是 Rust 的自增长数组。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse a sequence of sibling nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_nodes</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Vec</span>&lt;dom::Node&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nodes = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.consume_whitespace();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.eof() || <span class="keyword">self</span>.starts_with(<span class="string">&quot;&lt;/&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.push(<span class="keyword">self</span>.parse_node());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好，我们将以上的所有代码整合一起，就可以将完整的HTML文档解析成DOM树了。这个函数将会未包含根节点的文档创建根节点。这类似于真正的HTML解析器所做的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse an HTML document and return the root element.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">parse</span></span>(source: <span class="built_in">String</span>) -&gt; dom::Node &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nodes = Parser &#123; pos: <span class="number">0</span>, input: source &#125;.parse_nodes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the document contains a root element, just return it. Otherwise, create one.</span></span><br><span class="line">    <span class="keyword">if</span> nodes.len() == <span class="number">1</span> &#123;</span><br><span class="line">        nodes.swap_remove(<span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dom::elem(<span class="string">&quot;html&quot;</span>.to_string(), HashMap::new(), nodes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 robinson HTML parser 的完整代码！整个过程仅包含100多行代码（不包含空行和注释）。如果你使用好的库 或 解析器生成器，你可以使用更少的空间实现类似的玩具解析器。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-01-22T12:49:01.000Z" title="1/22/2020, 12:49:01 PM">2020-01-22</time>发表</span><span class="level-item"><time dateTime="2023-08-04T13:18:20.480Z" title="8/4/2023, 1:18:20 PM">2023-08-04</time>更新</span><span class="level-item"><a class="link-muted" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span> / </span><a class="link-muted" href="/blog/categories/%E8%AF%91%E6%96%87/">译文</a></span><span class="level-item">16 分钟读完 (大约2424个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/blog/2020/01/22/browser/how-broswers-work-1/">手把手教你实现一个浏览器引擎（一）Start</a></h1><div class="content"><h2 id="第一部分：起步"><a href="#第一部分：起步" class="headerlink" title="第一部分：起步"></a>第一部分：起步</h2><p>我正在打造一个玩具HTML渲染引擎，与此同时，我觉得你也应该尝试一下。这是这个系列文章的第一篇：</p>
<ul>
<li>第一部分：起步</li>
<li>第二部分：HTML</li>
<li>第三部分：CSS</li>
<li>第四部分：Style</li>
<li>第五部分：Boxes</li>
<li>第六部分：Block layout</li>
<li>第七部分：Painting 101</li>
</ul>
<p>完整的系列文章将会通过描述我编写的代码，让大家学会如何制作自己的专属浏览器引擎。但是首先，让我解释一些东西。</p>
<h2 id="我们准备做的是一个什么东西？"><a href="#我们准备做的是一个什么东西？" class="headerlink" title="我们准备做的是一个什么东西？"></a>我们准备做的是一个什么东西？</h2><p>首先，我们先谈谈一些术语(terminology)。</p>
<p><strong>浏览器引擎(browser engine)</strong> 是网络浏览器(web browser)的一部分，作用是“在幕后”从互联网上获取网页，并将其内容转换为你可以阅读，观看的形式。</p>
<p>Blink，Gecko，WebKit 和 Trident 都是浏览器引擎。</p>
<p>相反，浏览器自己的用户界面（UI），如：标签（tabs）、工具栏（toolbar），菜单（menu）等等，我们称之为 chrome。</p>
<p>Firefox 和 SeaMonkey 是两个采用不同chrome，相同Gecko 引擎的浏览器。</p>
<p>一个浏览器还有其他很多子组件（sub-components）：一个HTTP 客户端，一个HTML解析器（parser），一个CSS解析器（parser），一个JavaScript引擎（包含解析器parsers、解释器interpreters、编译器compilers）等等。这些组件涉及到HTML，CSS等网络格式的解析，并转换成我们在浏览器看到的内容。有时，也将它们称之为布局引擎（layout engine）或者渲染引擎（rendering engine）。</p>
<h2 id="为什么是一个玩具引擎？"><a href="#为什么是一个玩具引擎？" class="headerlink" title="为什么是一个玩具引擎？"></a>为什么是一个玩具引擎？</h2><p>一个完整的浏览器引擎是相当的复杂的。</p>
<p>Blink，Gecko，WebKit这些引擎每个都是需要通过数百万行代码实现的。甚至一些如 <a target="_blank" rel="noopener" href="https://github.com/servo/servo/">Servo</a> 和 <a target="_blank" rel="noopener" href="http://weasyprint.org/">WeasyPrint</a> 这样比较新，比较简单的渲染引擎都是数万行代码的级别。对于新人来说，不是一个简单能完成的事。</p>
<p>说到巨型复杂软件：如果你上过编译器或操作系统的课，你可能做过或者修改过一个“玩具型”编译器或者内核。这是一个为学习而设计的简单模型；这可能是除了作者以外没人会运行的代码。不过制作一个“玩具型”的系统是一个很有用的学习方式，有助于我们的真正的编程工作。如果你从未做过真正的编译器或者内核，理解它们的工作机制也能在我们写代码的时候帮助我们更好地使用它们。</p>
<h2 id="在家里尝试-try-this-at-home"><a href="#在家里尝试-try-this-at-home" class="headerlink" title="在家里尝试 try this at home"></a>在家里尝试 try this at home</h2><p>我希望我已经说服你去做个尝试。如果你已有一定的编程经验，且懂得一些HTML和CSS的高阶概念的话，这个系列的内容就不会难倒你。</p>
<p>然而，如果你刚开始编程的话，或者有些地方不懂，可以自由提问，我尝试讲得更通俗易懂些。</p>
<p>在开始之前，先谈一下，你可以有哪些选择：</p>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>你可以使用任何语言来编写渲染引擎，真的，你可以使用你熟悉或者喜欢的任何语言。或者如果听起来很有趣，也可以以此为借口来学习一种新语言。</p>
<p>如果你想开始对一些主流的浏览器引擎如：Gecko 或 WebKit做贡献的话，你可能要使用C++，因为它是这些引擎的主要语言，并且使用它可以使将代码与其代码进行比较变得更加容易。</p>
<p>我的玩具项目：<a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson">robinson</a> 是使用 <a target="_blank" rel="noopener" href="http://www.rust-lang.org/">Rust</a> 编写的。我是 Moziila 的 Servo team 成员，因此我非常喜欢使用Rust编程。另外，我在该项目中的目标之一，是了解Servo的更多实现。Ronbison偶尔也会用到Servo简化版的数据结构和代码。</p>
<h2 id="关于库与捷径-On-Libraries-and-Shortcuts"><a href="#关于库与捷径-On-Libraries-and-Shortcuts" class="headerlink" title="关于库与捷径 On Libraries and Shortcuts"></a>关于库与捷径 On Libraries and Shortcuts</h2><p>在像这样的学习练习中，你需要决定到底是 直接使用他人的代码还是自己重写实现一遍。我的建议是，如果你想真正得理解的话，你应该自己重新实现一遍，不过千万不要愧于使用第三方库或者参考别人的代码。学习如何使用特定的库本身可能是一个有价值的练习。</p>
<p>我编写的Robinson，不仅要为了自己，而且还要作为这些文章和练习的示例代码。为了这样和那样的理由，我希望它尽可能的小且独立。目前为止，我没使用任何第三方代码除了 Rust 的标准库（这也避免了在语言仍处于开发阶段时使用相同版本的Rust来构建多个依赖项的麻烦。）当然，这些规则也不是一成不变的。举例来说，我可能决定之后使用第三方图形库而不是自己手写低级的绘制代码。</p>
<p>还有一种避免写代码的捷径就是，让这些功能都不要了吧。比如 robinson 是没有任何联网的代码，它仅仅可以读取本地文件。在一个玩具项目里，你可以随心所欲地跳过任何东西。因此，读这个系列文章，你可以随时跳过你不感兴趣的部分，直接阅读你觉得有趣的部分。在你回心转意时，再去补回前面的跳过的内容。</p>
<h2 id="第一步：The-DOM"><a href="#第一步：The-DOM" class="headerlink" title="第一步：The DOM"></a>第一步：The DOM</h2><p>你准备好写一些代码了吗？我们从一些小方面开始着手：<a target="_blank" rel="noopener" href="http://dom.spec.whatwg.org/">DOM</a>的数据结构。我们一起来看看 robinson 的 <a target="_blank" rel="noopener" href="https://github.com/mbrubeck/robinson/blob/master/src/dom.rs">DOM Module</a></p>
<p>DOM是由许多的节点（nodes）组成的树（tree），一个节点（node）有零个或者多个子节点（Child）。（另外，它还有许多其他属性或者方法，不过我们可以暂时忽略这部分）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="comment">// data common to all nodes:</span></span><br><span class="line">    children: <span class="built_in">Vec</span>&lt;Node&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data specific to each node type:</span></span><br><span class="line">    node_type: NodeType,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实节点是有许多的节点类型（node types），不过目前我们将忽略其中的大多数，并当做只有两种类型的节点：元素（Element）或者文本节点（Text node）。在具有继承性的语言中，这些将是Node的子类型。在Rust里，他们可以是枚举（enum ）类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NodeType</span></span> &#123;</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">    Element(ElementData),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个元素包含：一个标签名（tag name）、任意个属性（attributes），可以将属性其存储为从名称到值的映射。Robinson不支持任何命名空间，因此只是将标签名（tag name）和属性名（attribute name）存成简单的字符串类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ElementData</span></span> &#123;</span><br><span class="line">    tag_name: <span class="built_in">String</span>,</span><br><span class="line">    attributes: AttrMap,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">AttrMap</span></span> = HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>最后是一些便于创建新节点的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn text(data: String) -&gt; Node &#123;</span><br><span class="line">    Node &#123; children: Vec::new(), node_type: NodeType::Text(data) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn elem(name: String, attrs: AttrMap, children: Vec&lt;Node&gt;) -&gt; Node &#123;</span><br><span class="line">    Node &#123;</span><br><span class="line">        children: children,</span><br><span class="line">        node_type: NodeType::Element(ElementData &#123;</span><br><span class="line">            tag_name: name,</span><br><span class="line">            attributes: attrs,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这样！全面的DOM实现将包含更多数据和数十种方法，但这就是我们开始所需要的</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>以下是一些建议的练习方法。你可以做一些感兴趣的练习，然后跳过所有您不感兴趣的练习。</p>
<ol>
<li>开始一个新项目，自由选择一种语言，编写代码实现包含text nodes 和 elements的DOM tree</li>
<li>安装最新版本的Rust，然后下载和构建 Robinson，打开 <code>dom.rs</code> 然后继承 <code>NodeType</code> 追加实现其他类型，如comment nodes</li>
<li>编写代码输出一个漂亮的树形DOM nodes</li>
</ol>
<p>在下篇文章里，我们将会添加一个解析器（parser），把HTML源代码（source code）转换成包含DOM nodes的树</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>有关浏览器引擎内部的更多详细信息，请参阅 Tali Garsiel 精彩的 <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">How Browsers Work </a>及其指向更多资源的链接。</p>
<p>有关参考代码，以下是“小型”开源渲染引擎的清单。其中大部分都比 robinson 大好几倍，但仍远远小于 Gecko 和 WebKit。</p>
<p>其中 WebWHirr 只有2000行代码，这是唯一一个我会称之为玩具的一个引擎。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/philborlin/CSSBox">CSSBox</a> (Java)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/silexlabs/Cocktail">Cocktail</a> (Haxe)</li>
<li><a target="_blank" rel="noopener" href="https://gngr.info/">gngr</a> (Java)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tordex/litehtml">litehtml</a> (C++)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/admin36/LURE">LURE</a> (Lua)</li>
<li><a target="_blank" rel="noopener" href="http://www.netsurf-browser.org/">NetSurf</a> （C）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/servo/servo/">Servo</a> (Rust)</li>
<li><a target="_blank" rel="noopener" href="http://hsbrowser.wordpress.com/3s-functional-web-browser/">Simple San Simon</a> (Haskell)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Kozea/WeasyPrint">WeasyPrint</a> (Python)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/reesmichael1/WebWhirr">WebWhirr</a> (C++)</li>
</ul>
<p>你可能会发现这些项目可以给你很多灵感或者参考。如果你知道其他类似的项目或者如果你开始自己的项目，请让我知道！</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/blog/page/2/">上一页</a></div><div class="pagination-next"><a href="/blog/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/blog/">1</a></li><li><a class="pagination-link" href="/blog/page/2/">2</a></li><li><a class="pagination-link is-current" href="/blog/page/3/">3</a></li><li><a class="pagination-link" href="/blog/page/4/">4</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/blog/page/7/">7</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://wx.qlogo.cn/mmhead/PiajxSqBRaEKzztxtaqGaVk8KzgrnxCBJkB6RD6rEqGOicBLVhnzxM7g/0" alt="leejimqiu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">leejimqiu</p><p class="is-size-6 is-block">Senior Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/blog/archives"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/blog/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/blog/tags"><p class="title">30</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/leejim" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/leejim"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weixin" href="https://developers.weixin.qq.com/community/personal/oCJUsw4DgF0046Dd6X7b5Lm-INBA"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/blog/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://tdesign.tencent.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TDesign</span></span><span class="level-right"><span class="level-item tag">tdesign.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://tdesign.tencent.com/miniprogram" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TDesign Miniprogram</span></span><span class="level-right"><span class="level-item tag">tdesign.tencent.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/blog/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/Node-js/"><span class="level-start"><span class="level-item">Node.js</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">前端基础</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"><span class="level-start"><span class="level-item">前端工程化</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="level-start"><span class="level-item">小程序</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"><span class="level-start"><span class="level-item">工程实践</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"><span class="level-start"><span class="level-item">浏览器</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><span class="level-start"><span class="level-item">源码解析</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/blog/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/underscore/"><span class="level-start"><span class="level-item">underscore</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/blog/categories/%E7%BB%84%E4%BB%B6%E5%BA%93/"><span class="level-start"><span class="level-item">组件库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/categories/%E8%AF%91%E6%96%87/"><span class="level-start"><span class="level-item">译文</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-10T04:11:49.000Z">2022-12-10</time></p><p class="title"><a href="/blog/2022/12/10/miniprogram/with-github-action/">当 TDesign 小程序遇上 GitHub Actions</a></p><p class="categories"><a href="/blog/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a> / <a href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-25T14:40:19.000Z">2022-01-25</time></p><p class="title"><a href="/blog/2022/01/25/miniprogram/component-button/">小程序按钮组件的亿点细节</a></p><p class="categories"><a href="/blog/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-06T12:21:28.000Z">2022-01-06</time></p><p class="title"><a href="/blog/2022/01/06/miniprogram/miniprogram-function-property/">关于小程序组件透传函数的实践</a></p><p class="categories"><a href="/blog/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-01T03:31:30.000Z">2021-12-01</time></p><p class="title"><a href="/blog/2021/12/01/about-code-reuse-for-uilib/">关于组件库的代码复用</a></p><p class="categories"><a href="/blog/categories/%E7%BB%84%E4%BB%B6%E5%BA%93/">组件库</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-28T09:43:34.000Z">2021-05-28</time></p><p class="title"><a href="/blog/2021/05/28/vue/vue3-on-tdesign/">关于 Vue3 的 Proxy 引起的问题</a></p><p class="categories"><a href="/blog/categories/vue/">vue</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/blog/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/10/"><span class="level-start"><span class="level-item">十月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/08/"><span class="level-start"><span class="level-item">八月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/07/"><span class="level-start"><span class="level-item">七月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2017/02/"><span class="level-start"><span class="level-item">二月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2016/11/"><span class="level-start"><span class="level-item">十一月 2016</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2016/10/"><span class="level-start"><span class="level-item">十月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2016/09/"><span class="level-start"><span class="level-item">九月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2016/08/"><span class="level-start"><span class="level-item">八月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2016/07/"><span class="level-start"><span class="level-item">七月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2016/05/"><span class="level-start"><span class="level-item">五月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2015/10/"><span class="level-start"><span class="level-item">十月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/blog/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/blog/tags/Array/"><span class="tag">Array</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/BFC/"><span class="tag">BFC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Buffers/"><span class="tag">Buffers</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/CSS/"><span class="tag">CSS</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/ES6/"><span class="tag">ES6</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/HTTP/"><span class="tag">HTTP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/History-API/"><span class="tag">History API</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Session/"><span class="tag">Session</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/Storage/"><span class="tag">Storage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/cookie/"><span class="tag">cookie</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/gulp/"><span class="tag">gulp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/promise/"><span class="tag">promise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/underscore-js/"><span class="tag">underscore.js</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/vue-js/"><span class="tag">vue.js</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E4%BA%8B%E4%BB%B6/"><span class="tag">事件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="tag">内存管理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="tag">垃圾回收</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"><span class="tag">模块化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"><span class="tag">盒模型</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"><span class="tag">编码规范</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"><span class="tag">网络安全</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"><span class="tag">自定义组件</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E8%B7%AF%E7%94%B1/"><span class="tag">路由</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/blog/tags/%E9%97%AD%E5%8C%85/"><span class="tag">闭包</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/blog/"><img src="/blog/img/logo.svg" alt="Jim Home" height="28"></a><p class="is-size-7"><span>&copy; 2023 leejimqiu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leejim"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="粤ICP备19015289号" href="https://beian.miit.gov.cn">粤ICP备19015289号</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/blog/js/column.js"></script><script src="/blog/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/blog/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>