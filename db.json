{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/images/subscribe/WechatIMG198.jpg","path":"images/subscribe/WechatIMG198.jpg","modified":0,"renderable":0},{"_id":"source/images/subscribe/WechatIMG199.jpg","path":"images/subscribe/WechatIMG199.jpg","modified":0,"renderable":0},{"_id":"source/images/subscribe/request-subscribe-message.jpg","path":"images/subscribe/request-subscribe-message.jpg","modified":0,"renderable":0},{"_id":"source/images/update/least-version-config.c2b188c7.png","path":"images/update/least-version-config.c2b188c7.png","modified":0,"renderable":0},{"_id":"source/images/update/least-version-tips.d8a1b4d4.jpg","path":"images/update/least-version-tips.d8a1b4d4.jpg","modified":0,"renderable":0},{"_id":"source/images/update/mock-update.jpg","path":"images/update/mock-update.jpg","modified":0,"renderable":0},{"_id":"source/images/update/update-logic.jpg","path":"images/update/update-logic.jpg","modified":0,"renderable":0},{"_id":"source/images/update/work-flow.png","path":"images/update/work-flow.png","modified":0,"renderable":0},{"_id":"source/images/custom-navigator/full-screen.jpeg","path":"images/custom-navigator/full-screen.jpeg","modified":0,"renderable":0},{"_id":"source/images/custom-navigator/interface.jpg","path":"images/custom-navigator/interface.jpg","modified":0,"renderable":0},{"_id":"source/images/custom-navigator/navigator.jpg","path":"images/custom-navigator/navigator.jpg","modified":0,"renderable":0},{"_id":"source/images/code-guide/eslint.png","path":"images/code-guide/eslint.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/eslint.svg","path":"images/code-guide/eslint.svg","modified":0,"renderable":0},{"_id":"source/images/code-guide/htmlhint.png","path":"images/code-guide/htmlhint.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/merge-request.png","path":"images/code-guide/merge-request.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/protect-branch.png","path":"images/code-guide/protect-branch.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/stylelint.png","path":"images/code-guide/stylelint.png","modified":0,"renderable":0},{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/qrcode.png","path":"images/qrcode.png","modified":0,"renderable":0},{"_id":"source/images/global-window.png","path":"images/global-window.png","modified":0,"renderable":0},{"_id":"source/images/promisify-error1.jpg","path":"images/promisify-error1.jpg","modified":0,"renderable":0},{"_id":"source/images/promisify-console1.jpg","path":"images/promisify-console1.jpg","modified":0,"renderable":0},{"_id":"source/images/global-global.png","path":"images/global-global.png","modified":0,"renderable":0},{"_id":"source/images/compatibility-proxy.jpg","path":"images/compatibility-proxy.jpg","modified":0,"renderable":0},{"_id":"source/images/compatibility-symbol.jpg","path":"images/compatibility-symbol.jpg","modified":0,"renderable":0},{"_id":"source/images/compare.jpg","path":"images/compare.jpg","modified":0,"renderable":0},{"_id":"source/images/qrcode/wallpaper.jpg","path":"images/qrcode/wallpaper.jpg","modified":0,"renderable":0},{"_id":"source/images/qrcode/weather.jpg","path":"images/qrcode/weather.jpg","modified":0,"renderable":0},{"_id":"source/images/components/vuex.png","path":"images/components/vuex.png","modified":0,"renderable":0},{"_id":"source/images/components/miniprogram-lifecycle.png","path":"images/components/miniprogram-lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/components/lifecycle.png","path":"images/components/lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/components/components-graph.png","path":"images/components/components-graph.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1641017497024},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586452},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586484},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586549},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586578},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586599},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017585735},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586132},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586253},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586359},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586421},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1641017587609},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1641017586617},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1641017587613},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"eeefa2a465ff37e08499efb1d4f1c72517e5d103","modified":1641017587204},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1641017586679},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1641017586755},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1641017586789},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1641017587791},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1641017587793},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1641017587795},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1641017587798},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1641017587798},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1641017587804},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1641017587803},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1641017587804},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1641017587806},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1641017587808},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1641017587811},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1641017587813},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1641017587816},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1641017587818},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1641017587819},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1641017587374},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1641017587339},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1641017587481},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1641017587499},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1641017587503},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1641017587580},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1641017587587},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1641017587599},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1641017586771},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1641017587600},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1641017586764},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1641017586969},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1641017586800},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1641017587161},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1641017587680},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1641017587685},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1641017587689},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1641017587691},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1641017587697},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1641017587718},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1641017587717},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1641017587718},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1641017587720},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1641017587721},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1641017587723},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1641017587727},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1641017587728},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1641017587730},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1641017587734},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1641017586718},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"e2765287c6bc6eb97975a1bb4e325b046e95b392","modified":1641017587353},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1641017587485},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1641017587487},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1641017587491},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1641017587497},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1641017587573},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1641017587585},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1641017587592},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1641017587594},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1641017587597},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"251263b97de12f2b8d1fce2514e83430f2515b94","modified":1641017587603},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1641017587308},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1641017587370},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1641017587591},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1641017587710},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1641017587715},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1641017587730},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1641017587652},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1641017587735},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1641017587774},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1641017587778},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1641017587677},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1641017587782},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1641017586627},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1641017586631},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1641017586638},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1641017587102},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1641017586781},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1641017587143},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1641017587169},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1641017587183},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1641017587198},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1641017587203},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1641017587212},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1641017587231},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1641017587233},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1641017587263},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1641017587269},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1641017587276},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1641017587033},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1641017587136},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1641017587217},{"_id":"source/projects/index.md","hash":"3b8deb0a08468b489eb60b925dc6aba09e472202","modified":1590217848000},{"_id":"source/images/update/least-version-tips.d8a1b4d4.jpg","hash":"a782cd41abb91496e13706f7a7db4ce624455f03","modified":1585490501000},{"_id":"source/images/update/update-logic.jpg","hash":"70d151e85ae0679408fa39e6f2bf94433947cd6b","modified":1588952467000},{"_id":"source/images/update/work-flow.png","hash":"1b2e729bfadf4f08cf83fb592b1b2bb042c5295e","modified":1587999305000},{"_id":"source/images/subscribe/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1589614274000},{"_id":"source/images/subscribe/WechatIMG198.jpg","hash":"c000f7794a8789579e16d68a716b213c4ee1cba7","modified":1589614404000},{"_id":"source/images/subscribe/request-subscribe-message.jpg","hash":"b3271488a580dbce98a3bcfac111610ccfe821ae","modified":1589614707000},{"_id":"source/images/subscribe/WechatIMG199.jpg","hash":"981ae8012bf1648d9174f61b74d99e4946122590","modified":1589614310000},{"_id":"source/images/update/least-version-config.c2b188c7.png","hash":"a1ff51d63b4abfcefc659b685c32f859dbaf7890","modified":1585490486000},{"_id":"source/images/update/mock-update.jpg","hash":"7138fad05e68518c6ad395fe7f98c43c8d7a6a39","modified":1588950948000},{"_id":"source/images/compare.jpg","hash":"e726bb3dbeda342f8a64d3452e702c16a3d18e16","modified":1585475421000},{"_id":"source/images/global-global.png","hash":"85b94a1df6b3621067f5d6b28f550e04f7b96611","modified":1585575779000},{"_id":"source/images/promisify-console1.jpg","hash":"1b58397722b57e3bb4c96afbaca37ac7c4a0891a","modified":1585470367000},{"_id":"source/images/global-window.png","hash":"2b653f4236257e9c71668b59ed5d146efaf3525f","modified":1585575779000},{"_id":"source/images/promisify-error1.jpg","hash":"508698512945cd806429e8997cc950021a59a32e","modified":1585468844000},{"_id":"source/images/.DS_Store","hash":"5a9e9a8bbf85c5988f69aeb7a306d15093074ba8","modified":1590217795000},{"_id":"source/images/compatibility-symbol.jpg","hash":"45b033a76470731c16fec881e42ea54d310f63f4","modified":1585750906000},{"_id":"source/images/qrcode.png","hash":"0d7e51470337e44db91f9b0f6f7f02418104e229","modified":1585403103000},{"_id":"source/images/compatibility-proxy.jpg","hash":"fb4df64fc6be08b321b8677ab5f932e31bd34246","modified":1585750866000},{"_id":"source/images/custom-navigator/full-screen.jpeg","hash":"247b54a31fab005f31680808a7beae3c236bdbf1","modified":1588774602000},{"_id":"source/images/custom-navigator/navigator.jpg","hash":"6d91b3c9ec53e8d07c713a38ed9e65b0f446a02c","modified":1588777688000},{"_id":"source/images/custom-navigator/interface.jpg","hash":"9397a1ab3af50c5c8229ea2355e307b796fdcf21","modified":1588261085000},{"_id":"source/images/code-guide/eslint.png","hash":"0c39ed32c2895715d25ed1115b23e97dedc69fc2","modified":1588085168000},{"_id":"source/images/code-guide/eslint.svg","hash":"204482ca413433c80cd14fe369e2181dd97a2a40","modified":1588085073000},{"_id":"source/images/code-guide/htmlhint.png","hash":"85a5fbc53e53d6414bef948c5a0eb17529a7e3d2","modified":1588085228000},{"_id":"source/images/code-guide/merge-request.png","hash":"aac6b6747a65c362018441d58a0eb4709bc70b2f","modified":1586672835000},{"_id":"source/images/code-guide/protect-branch.png","hash":"fb4acac70517280f545cf8397ec24eb747ccd4f8","modified":1586672771000},{"_id":"source/images/code-guide/stylelint.png","hash":"0f4d319e4c5e20284d59dc420ca96e6b55ddd92c","modified":1588085210000},{"_id":"source/_posts/mini-program/update.md","hash":"f920d7fb9e6f10e5ecdb59ff927dae5cebf5c463","modified":1590216056000},{"_id":"source/_data/projects.json","hash":"1675d653e65ed3863b18dfcc47711873710f18ef","modified":1512728601000},{"_id":"source/.DS_Store","hash":"e9158d3c9871b7ddcd5794aa24438b4dfaeff9c9","modified":1610866432000},{"_id":"source/_posts/.DS_Store","hash":"4fb061a3bc286069f198f429aa37d5069f348bbd","modified":1610866397000},{"_id":"source/favicon.png","hash":"267cfd461bbe03e88577f6e4c96b41d743aeadc4","modified":1590216278000},{"_id":"source/CNAME","hash":"71a4f395b9bbb9c0f326b3b124d584ea9e26010e","modified":1590217976000},{"_id":"source/_posts/about-deploly-favweb-2.md","hash":"a6d0dc699c5e7007403e148924dd9cda762591ba","modified":1590213599000},{"_id":"source/_posts/about-deploly-favweb-3.md","hash":"cedad331d53924a2dfcc968a3d7c1b54f75eedb4","modified":1590213602000},{"_id":"source/_posts/about-deploly-favweb-1.md","hash":"e8c7bd30047bcf51af6da29cee87fa701c91bf47","modified":1590213595000},{"_id":"source/_posts/JavaScript-detect.md","hash":"7b081c37b4817792e1c1d32df32f15bbf425c310","modified":1590214023000},{"_id":"source/_posts/css-background.md","hash":"0af094432e5e99a94568f54a06b85e87e07d7144","modified":1590214358000},{"_id":"source/_posts/front-end-router.md","hash":"54215e964aeccb81f11a1dc62709c12f81af1bf2","modified":1590214473000},{"_id":"source/_posts/es6-promise.md","hash":"9f7435516508e04e6c70ad43c8f1911b4415028b","modified":1590213951000},{"_id":"source/_posts/css-box-model.md","hash":"dd50bee88b495305b49e46b4091aa12d7eedb50d","modified":1590213956000},{"_id":"source/_posts/h5-history-api.md","hash":"163a9c360f23b1c5b3a3d185dfa7b5af8539ac1a","modified":1590213674000},{"_id":"source/_posts/getting-started-with-gulp.md","hash":"3531751088e185f2f5b83480cd0cb71f2bde48a4","modified":1510244125000},{"_id":"source/_posts/how-to-use-buffers.md","hash":"bbd9b6ba0f41bb74d59ee5661ef87bbded37d2e9","modified":1590213936000},{"_id":"source/_posts/html-send-email.md","hash":"f86dbdfb2a6e4549e32892c00c1fb1b9d9a31282","modified":1590214573000},{"_id":"source/_posts/interact-with-app.md","hash":"99770b42d24328c98a67843a7127ead18c8c67ce","modified":1590214431000},{"_id":"source/_posts/javascript-closure.md","hash":"66567fcf7b52e2723839ce502a63307c69dbe832","modified":1590214013000},{"_id":"source/_posts/memory-management.md","hash":"9938b1b6be3d0649f649a3cd142ac9db3948df36","modified":1590214053000},{"_id":"source/_posts/javascript-without-loops.md","hash":"81d2331389e9c26ac6d2547fad1c66c9ff722c99","modified":1590214038000},{"_id":"source/_posts/mobile-web-soft-keyboard.md","hash":"1e5873d1756fda5387fdaf08100f5c031cc336e7","modified":1590214403000},{"_id":"source/_posts/module-es6-vs-amd.md","hash":"00f40e22e59a2781b6f33097f559f408c27646e2","modified":1590214106000},{"_id":"source/_posts/mongodb.md","hash":"bd3d189a0dcf5915997c44729228d99e4cf628b6","modified":1590214113000},{"_id":"source/_posts/nvm-windows.md","hash":"1ca87e39fb81061f581cddd8f51b3f11b9b67f6a","modified":1590214118000},{"_id":"source/_posts/practice-of-wxapp-1.md","hash":"a488af1b9522d8f12282c4c26374e10b767f69df","modified":1516288438000},{"_id":"source/_posts/promise.md","hash":"8b797c5132c69783d600f7bcef838c1ec78634bf","modified":1611152870000},{"_id":"source/_posts/some-summarize-about-event.md","hash":"7f5cd473494c670eedbe96b01f9426ee08663982","modified":1590214136000},{"_id":"source/_posts/summary-of-vuejs.md","hash":"d4758ebe0641d453df14babf7e5dc5c47b5624a2","modified":1590214539000},{"_id":"source/_posts/underscore-base-function.md","hash":"76f29692d7db37eab10d71d60b45ea42350e2313","modified":1590214162000},{"_id":"source/_posts/underscore-featured-function.md","hash":"52b163aa4dc0d61b7bd7cfbffdbe1be13c0cd278","modified":1590214174000},{"_id":"source/_posts/underscore-mix.md","hash":"acce7f1a2f9df585721cfb9c1a9863045b607580","modified":1590214179000},{"_id":"source/_posts/underscore-wrapper.md","hash":"da1e711311c1999e78d199ae3b5ebb16d6d88e6c","modified":1590214184000},{"_id":"source/_posts/using-web-storage-api.md","hash":"d1c849c300ac00e5147eb482049196ff5df9c178","modified":1590214197000},{"_id":"source/_posts/web-safe-http-header.md","hash":"ac918ac97d1dfb93367d2e187c89623be7049a99","modified":1590214336000},{"_id":"source/_posts/wechat-miniapp-session.md","hash":"367bd80c92ae87b56c68181a52b449cec1343fe5","modified":1590214221000},{"_id":"source/_posts/what-is-bfc.md","hash":"d645461aa513069356fe2a688e53b525f6f44768","modified":1590214230000},{"_id":"source/_posts/what-is-cookie.md","hash":"e06c10465e94cfc62bcdb9ab2f9df2677e0db751","modified":1513307140000},{"_id":"source/_posts/white-space-and-wrap.md","hash":"a56e0d4354403b8a58cd44e5eeac1ed8d88744a8","modified":1590214243000},{"_id":"source/_posts/mini-program/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1590215479000},{"_id":"source/_posts/mini-program/api-promisify.md","hash":"8d4e3864fc93d0989693ce2eb15df36418e32fa6","modified":1590215806000},{"_id":"source/_posts/mini-program/code-style-guide.md","hash":"54454a2713db137c0d7a82e24cf1984de08ba3c0","modified":1590215850000},{"_id":"source/_posts/mini-program/custom-navigator.md","hash":"f318fcb053b59044f407db788eb27b6f6c41d7bf","modified":1590215878000},{"_id":"source/_posts/mini-program/custom-tabbar.md","hash":"35fc70b8d8f5af387a23d0a9dd7f6a99086aa07a","modified":1590215894000},{"_id":"source/_posts/mini-program/frame-design.md","hash":"142cec4d76c2feda8f19f84c995a4b5fa799b96a","modified":1590215928000},{"_id":"source/_posts/mini-program/global-data-manage.md","hash":"799556cc9a9700c81de98c4d2339d1248906a73e","modified":1590215956000},{"_id":"source/_posts/mini-program/think-about-subscribe.md","hash":"999b4f49a19e18d14dc594d5e18d2e75fa92101f","modified":1590216026000},{"_id":"source/_posts/mini-program/thinking-about-components.md","hash":"ddea43de76853d11374c4a6debf33bfa7bdc94db","modified":1590216041000},{"_id":"source/images/components/components-graph.png","hash":"2f4056d9c0448a3204386ddefd84025ea8a58967","modified":1586270751000},{"_id":"source/images/components/miniprogram-lifecycle.png","hash":"ea702f0624c4c43b902648df3eed268504489b34","modified":1586350800000},{"_id":"source/images/components/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1586350800000},{"_id":"source/images/qrcode/wallpaper.jpg","hash":"20de30ec07556f5b0cf0718124d830b26eaeed30","modified":1590217835000},{"_id":"source/images/qrcode/weather.jpg","hash":"3d1f0c66c35a08c9dea8c57abe133f750d1027a4","modified":1590217765000},{"_id":"source/images/components/lifecycle.png","hash":"297c3423ba2fe66ac397a67c4547c6aae41788aa","modified":1586271195000},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1641020194999},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1641020194999},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1641020194999},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1641020194999},{"_id":"public/content.json","hash":"1dec545516091b41786cf1b30d5f1487c9e0a619","modified":1641020194999},{"_id":"public/manifest.json","hash":"071cf96d35284d890f09444a8b07f0a4b7313a0b","modified":1641020194999},{"_id":"public/projects/index.html","hash":"62b00cfb01378ad6c4174651f93e1ec43250823c","modified":1641020194999},{"_id":"public/2021/01/17/promise/index.html","hash":"0833acf25b487bcdb89c58f4b957153816daf6eb","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/update/index.html","hash":"7e0d2461b64307fae6a7450b88efbe06ec211635","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/thinking-about-components/index.html","hash":"9e60c64109a329d9fe76ee3cfd9431e2452afa25","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/think-about-subscribe/index.html","hash":"6d8628a0ce7500733c30d3857e962ca2e81771d3","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/global-data-manage/index.html","hash":"eab95ab0cca71748508eea506da5893828c4072a","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/frame-design/index.html","hash":"1db13b9b31b28cf90039b5049a3b3712746cb2b0","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/custom-tabbar/index.html","hash":"6f93cbcc6cae64352c4d340f70838db882f7d1bc","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/custom-navigator/index.html","hash":"fb0462942d62455d6e31686e27fce61defd12711","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/code-style-guide/index.html","hash":"dee6baea840d4d825bdba81a35846915f9ba3e40","modified":1641020194999},{"_id":"public/2020/05/23/mini-program/api-promisify/index.html","hash":"e875291f5f54bcf50c330d34361454d5b6f13597","modified":1641020194999},{"_id":"public/2018/01/07/practice-of-wxapp-1/index.html","hash":"cf5a3629c60068110c239d1a3ec01ca1b188528d","modified":1641020194999},{"_id":"public/2017/11/11/what-is-bfc/index.html","hash":"418cf5aed1e4fcf66c7a5e9f6c24e9098825a8d5","modified":1641020194999},{"_id":"public/2017/11/05/what-is-cookie/index.html","hash":"99af9f53c0b36d352a52d8ff72e1d51f2873eeb1","modified":1641020194999},{"_id":"public/2017/10/27/about-deploly-favweb-3/index.html","hash":"8e1a91df62363e1d9c03cb491749bf1eaf7950f7","modified":1641020194999},{"_id":"public/2017/10/21/about-deploly-favweb-2/index.html","hash":"79208d0b6f0048f8dc1fd92d2a11b6156efa8130","modified":1641020194999},{"_id":"public/2017/10/14/about-deploly-favweb-1/index.html","hash":"837567835c56d2d78681f2ec17588a63347fa24f","modified":1641020194999},{"_id":"public/2017/10/06/how-to-use-buffers/index.html","hash":"310e383828041b55ca62da92a23561f5db670de8","modified":1641020194999},{"_id":"public/2017/09/23/underscore-featured-function/index.html","hash":"52e1c2987c396554a0bc035ed32fac37fb4dac19","modified":1641020194999},{"_id":"public/2017/09/18/underscore-base-function/index.html","hash":"e292b2bfb6c83eb3d5c3eb9571cbc9eed7742124","modified":1641020194999},{"_id":"public/2017/09/11/underscore-mix/index.html","hash":"b8b6a9d1f84b2a5d5ddd4a9a918e8454a7af1ec8","modified":1641020194999},{"_id":"public/2017/09/04/underscore-wrapper/index.html","hash":"21aa72a7bef371df97a5c826da2dca23073bd141","modified":1641020194999},{"_id":"public/2017/08/16/css-box-model/index.html","hash":"a6acd76d145c42a5e3fdf611b58087abea56a590","modified":1641020194999},{"_id":"public/2017/08/07/using-web-storage-api/index.html","hash":"ff14cb4acd56067084e727b65e09b4bf40f68e25","modified":1641020194999},{"_id":"public/2017/07/18/wechat-miniapp-session/index.html","hash":"7b7eeb38a479d771690a7d4d97d452cf545c2e1c","modified":1641020194999},{"_id":"public/2017/05/19/summary-of-vuejs/index.html","hash":"1a39cf970c1aa38a7c188797136d9f11674cae04","modified":1641020194999},{"_id":"public/2017/03/05/javascript-closure/index.html","hash":"1076bdb3c26a453fb0254d6a4e49f63247fe9234","modified":1641020194999},{"_id":"public/2017/03/05/memory-management/index.html","hash":"c7ea21382d71f0c8eeed7f21a6f0eb09ed80e298","modified":1641020194999},{"_id":"public/2017/02/21/javascript-without-loops/index.html","hash":"5db33962cae3703c55566b19e6bb12396836a8e2","modified":1641020194999},{"_id":"public/2016/11/24/some-summarize-about-event/index.html","hash":"2e5f2fbbfca6105c0b80dd943efdc4330d656820","modified":1641020194999},{"_id":"public/2016/11/15/JavaScript-detect/index.html","hash":"9fa323bf6aa489e8e11a2bd41b603e8a6393c75c","modified":1641020194999},{"_id":"public/2016/11/04/module-es6-vs-amd/index.html","hash":"b848de60c783ce96db2119d45484904dc2d59b3d","modified":1641020194999},{"_id":"public/2016/11/03/nvm-windows/index.html","hash":"cbbd18949d4104147e90426908249856657334fc","modified":1641020194999},{"_id":"public/2016/10/17/mongodb/index.html","hash":"2aa7252005d01dd3fde476a9db27caab3894f050","modified":1641020194999},{"_id":"public/2016/09/26/interact-with-app/index.html","hash":"7a7a5ad1d831367f1568459bf274c6613c57900a","modified":1641020194999},{"_id":"public/2016/09/23/getting-started-with-gulp/index.html","hash":"477ea5ead5c5dc85c265d534824891ffa0fb3d26","modified":1641020194999},{"_id":"public/2016/09/12/html-send-email/index.html","hash":"26ec80c41ed427f17e9d5e93ee854ac2f64b8f2e","modified":1641020194999},{"_id":"public/2016/08/05/es6-promise/index.html","hash":"afc76547bd8a9d0a6e1c9644c68355bcf7b07440","modified":1641020194999},{"_id":"public/2016/07/22/mobile-web-soft-keyboard/index.html","hash":"b2bf8ee2398ef77954dbf7565d0d2479db530e67","modified":1641020194999},{"_id":"public/2016/07/05/h5-history-api/index.html","hash":"1fa65df5a44145d621d0560d76cc294920a74b00","modified":1641020194999},{"_id":"public/2016/05/09/web-safe-http-header/index.html","hash":"4cf879f5553dab0c45069c91e5de2a4287e1082c","modified":1641020194999},{"_id":"public/2015/10/17/css-background/index.html","hash":"dd745ff75fda1e68677f847820c5bfa027d58176","modified":1641020194999},{"_id":"public/2015/10/14/white-space-and-wrap/index.html","hash":"aacd785a7f3629ae56255a8dc85a1faf0921c7c6","modified":1641020194999},{"_id":"public/2015/09/21/front-end-router/index.html","hash":"96b2ef37a896fd1bf614296bb1cb52090e7066d3","modified":1641020194999},{"_id":"public/archives/index.html","hash":"1bea73771b85d41664240f5f06454d7917faae2a","modified":1641020194999},{"_id":"public/index.html","hash":"0bf0f58debf20977078881331df272cb6f8dec49","modified":1641020194999},{"_id":"public/page/2/index.html","hash":"4450763de6098da017e026c3948dded1d94a091d","modified":1641020194999},{"_id":"public/page/3/index.html","hash":"ba62d33fc3d5a21304c2f690aee2154b1e02ed3f","modified":1641020194999},{"_id":"public/page/4/index.html","hash":"c2f505dd58447d92534219b20b12a1dfc3e9f701","modified":1641020194999},{"_id":"public/page/5/index.html","hash":"a5a61331b06749c1bb3059a1dff643333cea8af7","modified":1641020194999},{"_id":"public/tags/小程序/index.html","hash":"610e3a6dc83d3edc23bd86cc94b7ce29adeaab23","modified":1641020194999},{"_id":"public/tags/cookie/index.html","hash":"79aca71618ebc708e8ad045e360938d522ba721c","modified":1641020194999},{"_id":"public/tags/CSS/index.html","hash":"19ec1e9aebeae717a2656793e6356367629974c2","modified":1641020194999},{"_id":"public/tags/BFC/index.html","hash":"e2950d8973539dcc80d0e098fe04d8fbcb85027f","modified":1641020194999},{"_id":"public/tags/网络安全/index.html","hash":"27bffadb81c73fb59f7a12a23abaf8392d8da8c7","modified":1641020194999},{"_id":"public/tags/HTTP/index.html","hash":"a04c3af06d5a65cf5416b7b59ef523145bcea55d","modified":1641020194999},{"_id":"public/tags/Session/index.html","hash":"b4e56881133aa32eed8b865727940b6593041b04","modified":1641020194999},{"_id":"public/tags/JavaScript/index.html","hash":"8187673b73ac7e85d326f81ee57d4a51cd286a2e","modified":1641020194999},{"_id":"public/tags/Storage/index.html","hash":"7e13d6c5fa04e2d257ec6fd0c7b80cf2b393f3cf","modified":1641020194999},{"_id":"public/tags/underscore-js/index.html","hash":"00dcb68316532be6c3368414bd0088ff29ef1ca0","modified":1641020194999},{"_id":"public/tags/vue-js/index.html","hash":"dafa2dd88df7ea98a3aaf69effa2a79825670eae","modified":1641020194999},{"_id":"public/tags/promise-宏任务-微任务/index.html","hash":"9002559c4d14dcf33f05e57bc945862749c89487","modified":1641020194999},{"_id":"public/tags/事件/index.html","hash":"dec3167eaf617ad81722d76e153836cd44223e5e","modified":1641020194999},{"_id":"public/tags/Node-js/index.html","hash":"eaebd53aec1a73552ea6108eb763ddd6acb270f7","modified":1641020194999},{"_id":"public/tags/MongoDB/index.html","hash":"b71fa99260c1a81e8bf8cdce693ec62cc421ca12","modified":1641020194999},{"_id":"public/tags/ES6/index.html","hash":"012fc2436f582e4e73338cb43cb224f01db8c699","modified":1641020194999},{"_id":"public/tags/模块化/index.html","hash":"3b6750ded17dd0ff02c9dc9e8fca15703633d6d2","modified":1641020194999},{"_id":"public/tags/键盘/index.html","hash":"c5bae7976f9900bd7bdfd13329bf0c3e63f66dc1","modified":1641020194999},{"_id":"public/tags/Array/index.html","hash":"f9cb25ac3d5094ff5eb24040a9544473d35a1c05","modified":1641020194999},{"_id":"public/tags/闭包/index.html","hash":"aa5da1698e03423dd18c02189c1e363b522237f9","modified":1641020194999},{"_id":"public/tags/HTML/index.html","hash":"1181d857d0f7343d32cd4a49f178dd47d903a36f","modified":1641020194999},{"_id":"public/tags/Buffers/index.html","hash":"0efd9016b6fd8f7b9dd471092eb9196492b80f8f","modified":1641020194999},{"_id":"public/tags/History-API/index.html","hash":"c3e48df7d4c9318e33e61dbcb5019bb13683f824","modified":1641020194999},{"_id":"public/tags/gulp/index.html","hash":"d424fcb86b79c98d636a441d62c0113f8b643ea1","modified":1641020194999},{"_id":"public/tags/路由/index.html","hash":"efe3edd5a5d91fd6e131b6cebc6651fa375626d4","modified":1641020194999},{"_id":"public/tags/盒模型/index.html","hash":"d6f8b6955f364ecba79e6e1514d407d4e2304d8b","modified":1641020194999},{"_id":"public/tags/内存管理/index.html","hash":"a2fb0ae6f78a6414ba001894f90e8eeaa7836e0c","modified":1641020194999},{"_id":"public/tags/垃圾回收/index.html","hash":"394fbef5f13983456ce4e6506730c6d702799f13","modified":1641020194999},{"_id":"public/tags/编码规范/index.html","hash":"bb6f71e9c694bd4e36970f83f5552e5270239d73","modified":1641020194999},{"_id":"public/categories/index.html","hash":"24fc09e5645d76c9280a33a9522ceda4f337defa","modified":1641020194999},{"_id":"public/tags/index.html","hash":"f8eb8b88037b683cef3a887581b1597cb45df829","modified":1641020194999},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1641020194999},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1641020194999},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1641020194999},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1641020194999},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1641020194999},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1641020194999},{"_id":"public/images/subscribe/WechatIMG198.jpg","hash":"c000f7794a8789579e16d68a716b213c4ee1cba7","modified":1641020194999},{"_id":"public/images/subscribe/WechatIMG199.jpg","hash":"981ae8012bf1648d9174f61b74d99e4946122590","modified":1641020194999},{"_id":"public/images/subscribe/request-subscribe-message.jpg","hash":"b3271488a580dbce98a3bcfac111610ccfe821ae","modified":1641020194999},{"_id":"public/images/update/least-version-tips.d8a1b4d4.jpg","hash":"a782cd41abb91496e13706f7a7db4ce624455f03","modified":1641020194999},{"_id":"public/images/update/update-logic.jpg","hash":"70d151e85ae0679408fa39e6f2bf94433947cd6b","modified":1641020194999},{"_id":"public/images/update/work-flow.png","hash":"1b2e729bfadf4f08cf83fb592b1b2bb042c5295e","modified":1641020194999},{"_id":"public/images/custom-navigator/full-screen.jpeg","hash":"247b54a31fab005f31680808a7beae3c236bdbf1","modified":1641020194999},{"_id":"public/images/custom-navigator/navigator.jpg","hash":"6d91b3c9ec53e8d07c713a38ed9e65b0f446a02c","modified":1641020194999},{"_id":"public/images/code-guide/eslint.png","hash":"0c39ed32c2895715d25ed1115b23e97dedc69fc2","modified":1641020194999},{"_id":"public/images/code-guide/eslint.svg","hash":"204482ca413433c80cd14fe369e2181dd97a2a40","modified":1641020194999},{"_id":"public/images/code-guide/htmlhint.png","hash":"85a5fbc53e53d6414bef948c5a0eb17529a7e3d2","modified":1641020194999},{"_id":"public/images/code-guide/merge-request.png","hash":"aac6b6747a65c362018441d58a0eb4709bc70b2f","modified":1641020194999},{"_id":"public/images/code-guide/stylelint.png","hash":"0f4d319e4c5e20284d59dc420ca96e6b55ddd92c","modified":1641020194999},{"_id":"public/images/code-guide/protect-branch.png","hash":"fb4acac70517280f545cf8397ec24eb747ccd4f8","modified":1641020194999},{"_id":"public/favicon.png","hash":"267cfd461bbe03e88577f6e4c96b41d743aeadc4","modified":1641020194999},{"_id":"public/CNAME","hash":"71a4f395b9bbb9c0f326b3b124d584ea9e26010e","modified":1641020194999},{"_id":"public/images/promisify-error1.jpg","hash":"508698512945cd806429e8997cc950021a59a32e","modified":1641020194999},{"_id":"public/images/global-window.png","hash":"2b653f4236257e9c71668b59ed5d146efaf3525f","modified":1641020194999},{"_id":"public/images/promisify-console1.jpg","hash":"1b58397722b57e3bb4c96afbaca37ac7c4a0891a","modified":1641020194999},{"_id":"public/images/global-global.png","hash":"85b94a1df6b3621067f5d6b28f550e04f7b96611","modified":1641020194999},{"_id":"public/images/compare.jpg","hash":"e726bb3dbeda342f8a64d3452e702c16a3d18e16","modified":1641020194999},{"_id":"public/images/qrcode/wallpaper.jpg","hash":"20de30ec07556f5b0cf0718124d830b26eaeed30","modified":1641020194999},{"_id":"public/images/components/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1641020194999},{"_id":"public/images/qrcode/weather.jpg","hash":"3d1f0c66c35a08c9dea8c57abe133f750d1027a4","modified":1641020194999},{"_id":"public/images/components/components-graph.png","hash":"2f4056d9c0448a3204386ddefd84025ea8a58967","modified":1641020194999},{"_id":"public/images/components/miniprogram-lifecycle.png","hash":"ea702f0624c4c43b902648df3eed268504489b34","modified":1641020194999},{"_id":"public/images/update/least-version-config.c2b188c7.png","hash":"a1ff51d63b4abfcefc659b685c32f859dbaf7890","modified":1641020194999},{"_id":"public/images/qrcode.png","hash":"0d7e51470337e44db91f9b0f6f7f02418104e229","modified":1641020194999},{"_id":"public/images/update/mock-update.jpg","hash":"7138fad05e68518c6ad395fe7f98c43c8d7a6a39","modified":1641020194999},{"_id":"public/images/compatibility-proxy.jpg","hash":"fb4df64fc6be08b321b8677ab5f932e31bd34246","modified":1641020194999},{"_id":"public/images/compatibility-symbol.jpg","hash":"45b033a76470731c16fec881e42ea54d310f63f4","modified":1641020194999},{"_id":"public/images/components/lifecycle.png","hash":"297c3423ba2fe66ac397a67c4547c6aae41788aa","modified":1641020194999},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1641020194999},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1641020194999},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1641020194999},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1641020194999},{"_id":"public/css/default.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1641020194999},{"_id":"public/css/cyberpunk.css","hash":"073797b87e28376604d586c48beb66f6fe9cb504","modified":1641020194999},{"_id":"public/css/style.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1641020194999},{"_id":"public/images/custom-navigator/interface.jpg","hash":"9397a1ab3af50c5c8229ea2355e307b796fdcf21","modified":1641020194999}],"Category":[],"Data":[{"_id":"projects","data":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}],"Page":[{"title":"我的项目","date":"2020-05-23T05:58:16.000Z","_content":"\n## 开源项目\n\n### Jeep-UI\n\n基于Vue.js框架的UI库，专注于快速生成form表单（因为ElementUI比较繁琐，而突发奇想做出来）\n![](https://img.shields.io/github/stars/leejim/jeep-ui?style=plastic)\n\n### smapp\n\nVSCode插件，用于小程序开发，提供了一些自己想要的功能\n![](https://img.shields.io/github/stars/leejim/smapp?style=plastic)\n\n***\n\n## 小程序\n\n### 分享壁纸\n\n通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。\n\n![](/images/qrcode/wallpaper.jpg)\n\n### 天气号\n\n初次尝试云开发，通过第三方API获取天气信息。\n\n![](/images/qrcode/weather.jpg)\n\n***\n\n## Web应用\n\n### 分享网站 [#Link](http://w.africans.cn)\n\n做为一个Web前端工程师，我希望挖掘许多有趣的网站分享给大家。\n\n另外也是拿来练手，尝试全栈开发，全流程独立完成。\n","source":"projects/index.md","raw":"---\ntitle: 我的项目\ndate: 2020-05-23 13:58:16\n---\n\n## 开源项目\n\n### Jeep-UI\n\n基于Vue.js框架的UI库，专注于快速生成form表单（因为ElementUI比较繁琐，而突发奇想做出来）\n![](https://img.shields.io/github/stars/leejim/jeep-ui?style=plastic)\n\n### smapp\n\nVSCode插件，用于小程序开发，提供了一些自己想要的功能\n![](https://img.shields.io/github/stars/leejim/smapp?style=plastic)\n\n***\n\n## 小程序\n\n### 分享壁纸\n\n通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。\n\n![](/images/qrcode/wallpaper.jpg)\n\n### 天气号\n\n初次尝试云开发，通过第三方API获取天气信息。\n\n![](/images/qrcode/weather.jpg)\n\n***\n\n## Web应用\n\n### 分享网站 [#Link](http://w.africans.cn)\n\n做为一个Web前端工程师，我希望挖掘许多有趣的网站分享给大家。\n\n另外也是拿来练手，尝试全栈开发，全流程独立完成。\n","updated":"2020-05-23T07:10:48.000Z","path":"projects/index.html","_id":"ckxvfmf4z0000brqqbgphei2y","comments":1,"layout":"page","content":"<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><h3 id=\"Jeep-UI\"><a href=\"#Jeep-UI\" class=\"headerlink\" title=\"Jeep-UI\"></a>Jeep-UI</h3><p>基于Vue.js框架的UI库，专注于快速生成form表单（因为ElementUI比较繁琐，而突发奇想做出来）<br><img src=\"https://img.shields.io/github/stars/leejim/jeep-ui?style=plastic\"></p>\n<h3 id=\"smapp\"><a href=\"#smapp\" class=\"headerlink\" title=\"smapp\"></a>smapp</h3><p>VSCode插件，用于小程序开发，提供了一些自己想要的功能<br><img src=\"https://img.shields.io/github/stars/leejim/smapp?style=plastic\"></p>\n<hr>\n<h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><h3 id=\"分享壁纸\"><a href=\"#分享壁纸\" class=\"headerlink\" title=\"分享壁纸\"></a>分享壁纸</h3><p>通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。</p>\n<p><img src=\"/images/qrcode/wallpaper.jpg\"></p>\n<h3 id=\"天气号\"><a href=\"#天气号\" class=\"headerlink\" title=\"天气号\"></a>天气号</h3><p>初次尝试云开发，通过第三方API获取天气信息。</p>\n<p><img src=\"/images/qrcode/weather.jpg\"></p>\n<hr>\n<h2 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h2><h3 id=\"分享网站-Link\"><a href=\"#分享网站-Link\" class=\"headerlink\" title=\"分享网站 #Link\"></a>分享网站 <a href=\"http://w.africans.cn/\">#Link</a></h3><p>做为一个Web前端工程师，我希望挖掘许多有趣的网站分享给大家。</p>\n<p>另外也是拿来练手，尝试全栈开发，全流程独立完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><h3 id=\"Jeep-UI\"><a href=\"#Jeep-UI\" class=\"headerlink\" title=\"Jeep-UI\"></a>Jeep-UI</h3><p>基于Vue.js框架的UI库，专注于快速生成form表单（因为ElementUI比较繁琐，而突发奇想做出来）<br><img src=\"https://img.shields.io/github/stars/leejim/jeep-ui?style=plastic\"></p>\n<h3 id=\"smapp\"><a href=\"#smapp\" class=\"headerlink\" title=\"smapp\"></a>smapp</h3><p>VSCode插件，用于小程序开发，提供了一些自己想要的功能<br><img src=\"https://img.shields.io/github/stars/leejim/smapp?style=plastic\"></p>\n<hr>\n<h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><h3 id=\"分享壁纸\"><a href=\"#分享壁纸\" class=\"headerlink\" title=\"分享壁纸\"></a>分享壁纸</h3><p>通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。</p>\n<p><img src=\"/images/qrcode/wallpaper.jpg\"></p>\n<h3 id=\"天气号\"><a href=\"#天气号\" class=\"headerlink\" title=\"天气号\"></a>天气号</h3><p>初次尝试云开发，通过第三方API获取天气信息。</p>\n<p><img src=\"/images/qrcode/weather.jpg\"></p>\n<hr>\n<h2 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h2><h3 id=\"分享网站-Link\"><a href=\"#分享网站-Link\" class=\"headerlink\" title=\"分享网站 #Link\"></a>分享网站 <a href=\"http://w.africans.cn/\">#Link</a></h3><p>做为一个Web前端工程师，我希望挖掘许多有趣的网站分享给大家。</p>\n<p>另外也是拿来练手，尝试全栈开发，全流程独立完成。</p>\n"}],"Post":[{"title":"自动更新机制","desc":"小程序自动更新机制","_content":"\n## 前言\n\n小程序的更新机制与它的运行机制有关。\n\n为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。\n\n## 运行机制\n\n首先，先看下小程序的运行机制：\n\n![](/images/update/work-flow.png)\n\n与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。\n\n## 更新机制\n\n小程序的更新机制分为：\n\n- 未启动时更新\n- 启动时更新\n\n**未启动时更新**：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。\n\n**启动时更新**：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：\n\n```js\nconst updateManager = wx.getUpdateManager()\n\nupdateManager.onCheckForUpdate(function (res) {\n  // 请求完新版本信息的回调\n  console.log(res.hasUpdate)\n})\n\nupdateManager.onUpdateReady(function () {\n  wx.showModal({\n    title: '更新提示',\n    content: '新版本已经准备好，是否重启应用？',\n    success(res) {\n      if (res.confirm) {\n        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\n        updateManager.applyUpdate()\n      }\n    }\n  })\n})\n\nupdateManager.onUpdateFailed(function () {\n  // 新版本下载失败\n})\n```\n\n> 如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。\n\n根据微信提供的能力，小程序的更新流程大致如下：\n\n![](/images/update/update-logic.jpg)\n\n由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。\n\n下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。\n\n由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。\n\n## 测试\n\n更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。\n\n笔者尝试在体验版上做测试：先打开`v0.0.1`版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是`v0.0.2`，根本没有还原小程序的更新机制。\n\n因此可以得出结论：**体验版无法测试更新机制**。\n\n### 模拟更新\n\n另外，开发者工具的编译模式提供模拟更新：\n\n![](/images/update/mock-update.jpg)\n\n## 兼容处理\n\n由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。\n\n最简单的方式：每次升级接口时，均采用新接口。","source":"_posts/mini-program/update.md","raw":"---\ntitle: 自动更新机制\ntags: 小程序\ndesc: 小程序自动更新机制\n---\n\n## 前言\n\n小程序的更新机制与它的运行机制有关。\n\n为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。\n\n## 运行机制\n\n首先，先看下小程序的运行机制：\n\n![](/images/update/work-flow.png)\n\n与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。\n\n## 更新机制\n\n小程序的更新机制分为：\n\n- 未启动时更新\n- 启动时更新\n\n**未启动时更新**：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。\n\n**启动时更新**：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：\n\n```js\nconst updateManager = wx.getUpdateManager()\n\nupdateManager.onCheckForUpdate(function (res) {\n  // 请求完新版本信息的回调\n  console.log(res.hasUpdate)\n})\n\nupdateManager.onUpdateReady(function () {\n  wx.showModal({\n    title: '更新提示',\n    content: '新版本已经准备好，是否重启应用？',\n    success(res) {\n      if (res.confirm) {\n        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\n        updateManager.applyUpdate()\n      }\n    }\n  })\n})\n\nupdateManager.onUpdateFailed(function () {\n  // 新版本下载失败\n})\n```\n\n> 如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。\n\n根据微信提供的能力，小程序的更新流程大致如下：\n\n![](/images/update/update-logic.jpg)\n\n由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。\n\n下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。\n\n由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。\n\n## 测试\n\n更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。\n\n笔者尝试在体验版上做测试：先打开`v0.0.1`版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是`v0.0.2`，根本没有还原小程序的更新机制。\n\n因此可以得出结论：**体验版无法测试更新机制**。\n\n### 模拟更新\n\n另外，开发者工具的编译模式提供模拟更新：\n\n![](/images/update/mock-update.jpg)\n\n## 兼容处理\n\n由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。\n\n最简单的方式：每次升级接口时，均采用新接口。","slug":"mini-program/update","published":1,"date":"2020-05-23T06:40:56.000Z","updated":"2020-05-23T06:40:56.000Z","_id":"ckxvfmf9u0001brqqc6ui9l7c","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的更新机制与它的运行机制有关。</p>\n<p>为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。</p>\n<h2 id=\"运行机制\"><a href=\"#运行机制\" class=\"headerlink\" title=\"运行机制\"></a>运行机制</h2><p>首先，先看下小程序的运行机制：</p>\n<p><img src=\"/images/update/work-flow.png\"></p>\n<p>与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。</p>\n<h2 id=\"更新机制\"><a href=\"#更新机制\" class=\"headerlink\" title=\"更新机制\"></a>更新机制</h2><p>小程序的更新机制分为：</p>\n<ul>\n<li>未启动时更新</li>\n<li>启动时更新</li>\n</ul>\n<p><strong>未启动时更新</strong>：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。</p>\n<p><strong>启动时更新</strong>：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> updateManager = wx.getUpdateManager()</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onCheckForUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求完新版本信息的回调</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.hasUpdate)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateReady(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;更新提示&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">content</span>: <span class=\"string\">&#x27;新版本已经准备好，是否重启应用？&#x27;</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">success</span>(<span class=\"params\">res</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.confirm) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span></span><br><span class=\"line\">        updateManager.applyUpdate()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateFailed(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新版本下载失败</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。</p>\n</blockquote>\n<p>根据微信提供的能力，小程序的更新流程大致如下：</p>\n<p><img src=\"/images/update/update-logic.jpg\"></p>\n<p>由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。</p>\n<p>下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。</p>\n<p>由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。</p>\n<p>笔者尝试在体验版上做测试：先打开<code>v0.0.1</code>版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是<code>v0.0.2</code>，根本没有还原小程序的更新机制。</p>\n<p>因此可以得出结论：<strong>体验版无法测试更新机制</strong>。</p>\n<h3 id=\"模拟更新\"><a href=\"#模拟更新\" class=\"headerlink\" title=\"模拟更新\"></a>模拟更新</h3><p>另外，开发者工具的编译模式提供模拟更新：</p>\n<p><img src=\"/images/update/mock-update.jpg\"></p>\n<h2 id=\"兼容处理\"><a href=\"#兼容处理\" class=\"headerlink\" title=\"兼容处理\"></a>兼容处理</h2><p>由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。</p>\n<p>最简单的方式：每次升级接口时，均采用新接口。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的更新机制与它的运行机制有关。</p>\n<p>为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。</p>\n<h2 id=\"运行机制\"><a href=\"#运行机制\" class=\"headerlink\" title=\"运行机制\"></a>运行机制</h2><p>首先，先看下小程序的运行机制：</p>\n<p><img src=\"/images/update/work-flow.png\"></p>\n<p>与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。</p>\n<h2 id=\"更新机制\"><a href=\"#更新机制\" class=\"headerlink\" title=\"更新机制\"></a>更新机制</h2><p>小程序的更新机制分为：</p>\n<ul>\n<li>未启动时更新</li>\n<li>启动时更新</li>\n</ul>\n<p><strong>未启动时更新</strong>：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。</p>\n<p><strong>启动时更新</strong>：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> updateManager = wx.getUpdateManager()</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onCheckForUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求完新版本信息的回调</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.hasUpdate)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateReady(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;更新提示&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">content</span>: <span class=\"string\">&#x27;新版本已经准备好，是否重启应用？&#x27;</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">success</span>(<span class=\"params\">res</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.confirm) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span></span><br><span class=\"line\">        updateManager.applyUpdate()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateFailed(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新版本下载失败</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。</p>\n</blockquote>\n<p>根据微信提供的能力，小程序的更新流程大致如下：</p>\n<p><img src=\"/images/update/update-logic.jpg\"></p>\n<p>由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。</p>\n<p>下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。</p>\n<p>由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。</p>\n<p>笔者尝试在体验版上做测试：先打开<code>v0.0.1</code>版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是<code>v0.0.2</code>，根本没有还原小程序的更新机制。</p>\n<p>因此可以得出结论：<strong>体验版无法测试更新机制</strong>。</p>\n<h3 id=\"模拟更新\"><a href=\"#模拟更新\" class=\"headerlink\" title=\"模拟更新\"></a>模拟更新</h3><p>另外，开发者工具的编译模式提供模拟更新：</p>\n<p><img src=\"/images/update/mock-update.jpg\"></p>\n<h2 id=\"兼容处理\"><a href=\"#兼容处理\" class=\"headerlink\" title=\"兼容处理\"></a>兼容处理</h2><p>由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。</p>\n<p>最简单的方式：每次升级接口时，均采用新接口。</p>\n"},{"title":"什么是cookie","date":"2017-11-05T10:43:13.000Z","desc":"什么是cookie","_content":"\n起源，因为HTTP的无状态，无法知道两个请求是来自同个人。\n\n由NetScape工程师Lou Montulli与1994发表。正式确定于[RFC2109](http://tools.ietf.org/html/rfc2109)，最终演变成[RFC2965](http://tools.ietf.org/html/rfc2965)\n\n## Cookie为何物？\n\n简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。\n\n### 创建\n\n服务器通过`Set-Cookie`的HTTP头来设置：\n\n```\nSet-Cookie: <em>value</em>[; expires=<em>date</em>][; domain=<em>domain</em>][; path=<em>path</em>][; secure]\n```\n\n客户端将多个cookie通过`Cookie`的HTTP头来返回服务器：\n\n```\nCookie: value1; value2; name1=value1\n```\n\n> 多个value直接由一个分号和一个空格分隔开\n\n### value编码\n\n在普遍持有的观念中，value一定要是`URL-endcoed`编码的。\n\n其实这是个谬论，在文档中，明确指出只有`分号、逗号、空格`才需要编码。\n\n### expires\n\n设置过期时间。需要使用GMT格式的时间。\n\n\n```\nSet-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT\n```\n\n> 若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除\n\n> 校验的时间是以客户端的时间为准\n\n### domain\n\n指定什么域名请求时需要发送该cookie。\n\n> 采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)\n\n### path\n\n指定域名下的对应路径的请求才发送cookie。\n\n\n### secure\n\n有这个标志，cookie只会在HTTPS协议的请求发送该cookie。\n\n## 维护Cookie和周期\n\n修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。\n\n\n### 自动删除\n\n以下三个原因导致cookie被浏览器自动删除：\n\n- 会话结束自动删除\n- expires到期自动删除\n- 超过上线自动删除相对较旧的cookie\n\n## 其他限制\n\n- HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。\n\n\n## 参考：\n\n- [HTTP cookies explained](https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/)\n- [Cookies and security](https://www.nczonline.net/blog/2009/05/12/cookies-and-security/)\n- [Simple cookie framework](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework)","source":"_posts/what-is-cookie.md","raw":"---\ntitle: 什么是cookie\ndate: 2017-11-05 18:43:13\ntags: cookie\ndesc: 什么是cookie\n---\n\n起源，因为HTTP的无状态，无法知道两个请求是来自同个人。\n\n由NetScape工程师Lou Montulli与1994发表。正式确定于[RFC2109](http://tools.ietf.org/html/rfc2109)，最终演变成[RFC2965](http://tools.ietf.org/html/rfc2965)\n\n## Cookie为何物？\n\n简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。\n\n### 创建\n\n服务器通过`Set-Cookie`的HTTP头来设置：\n\n```\nSet-Cookie: <em>value</em>[; expires=<em>date</em>][; domain=<em>domain</em>][; path=<em>path</em>][; secure]\n```\n\n客户端将多个cookie通过`Cookie`的HTTP头来返回服务器：\n\n```\nCookie: value1; value2; name1=value1\n```\n\n> 多个value直接由一个分号和一个空格分隔开\n\n### value编码\n\n在普遍持有的观念中，value一定要是`URL-endcoed`编码的。\n\n其实这是个谬论，在文档中，明确指出只有`分号、逗号、空格`才需要编码。\n\n### expires\n\n设置过期时间。需要使用GMT格式的时间。\n\n\n```\nSet-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT\n```\n\n> 若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除\n\n> 校验的时间是以客户端的时间为准\n\n### domain\n\n指定什么域名请求时需要发送该cookie。\n\n> 采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)\n\n### path\n\n指定域名下的对应路径的请求才发送cookie。\n\n\n### secure\n\n有这个标志，cookie只会在HTTPS协议的请求发送该cookie。\n\n## 维护Cookie和周期\n\n修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。\n\n\n### 自动删除\n\n以下三个原因导致cookie被浏览器自动删除：\n\n- 会话结束自动删除\n- expires到期自动删除\n- 超过上线自动删除相对较旧的cookie\n\n## 其他限制\n\n- HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。\n\n\n## 参考：\n\n- [HTTP cookies explained](https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/)\n- [Cookies and security](https://www.nczonline.net/blog/2009/05/12/cookies-and-security/)\n- [Simple cookie framework](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework)","slug":"what-is-cookie","published":1,"updated":"2017-12-15T03:05:40.000Z","_id":"ckxvfmfb80004brqq4tlofoza","comments":1,"layout":"post","photos":[],"link":"","content":"<p>起源，因为HTTP的无状态，无法知道两个请求是来自同个人。</p>\n<p>由NetScape工程师Lou Montulli与1994发表。正式确定于<a href=\"http://tools.ietf.org/html/rfc2109\">RFC2109</a>，最终演变成<a href=\"http://tools.ietf.org/html/rfc2965\">RFC2965</a></p>\n<h2 id=\"Cookie为何物？\"><a href=\"#Cookie为何物？\" class=\"headerlink\" title=\"Cookie为何物？\"></a>Cookie为何物？</h2><p>简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>服务器通过<code>Set-Cookie</code>的HTTP头来设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: &lt;em&gt;value&lt;/em&gt;[; expires=&lt;em&gt;date&lt;/em&gt;][; domain=&lt;em&gt;domain&lt;/em&gt;][; path=&lt;em&gt;path&lt;/em&gt;][; secure]</span><br></pre></td></tr></table></figure>\n\n<p>客户端将多个cookie通过<code>Cookie</code>的HTTP头来返回服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie: value1; value2; name1=value1</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>多个value直接由一个分号和一个空格分隔开</p>\n</blockquote>\n<h3 id=\"value编码\"><a href=\"#value编码\" class=\"headerlink\" title=\"value编码\"></a>value编码</h3><p>在普遍持有的观念中，value一定要是<code>URL-endcoed</code>编码的。</p>\n<p>其实这是个谬论，在文档中，明确指出只有<code>分号、逗号、空格</code>才需要编码。</p>\n<h3 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h3><p>设置过期时间。需要使用GMT格式的时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除</p>\n</blockquote>\n<blockquote>\n<p>校验的时间是以客户端的时间为准</p>\n</blockquote>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>指定什么域名请求时需要发送该cookie。</p>\n<blockquote>\n<p>采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)</p>\n</blockquote>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>指定域名下的对应路径的请求才发送cookie。</p>\n<h3 id=\"secure\"><a href=\"#secure\" class=\"headerlink\" title=\"secure\"></a>secure</h3><p>有这个标志，cookie只会在HTTPS协议的请求发送该cookie。</p>\n<h2 id=\"维护Cookie和周期\"><a href=\"#维护Cookie和周期\" class=\"headerlink\" title=\"维护Cookie和周期\"></a>维护Cookie和周期</h2><p>修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。</p>\n<h3 id=\"自动删除\"><a href=\"#自动删除\" class=\"headerlink\" title=\"自动删除\"></a>自动删除</h3><p>以下三个原因导致cookie被浏览器自动删除：</p>\n<ul>\n<li>会话结束自动删除</li>\n<li>expires到期自动删除</li>\n<li>超过上线自动删除相对较旧的cookie</li>\n</ul>\n<h2 id=\"其他限制\"><a href=\"#其他限制\" class=\"headerlink\" title=\"其他限制\"></a>其他限制</h2><ul>\n<li>HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/\">HTTP cookies explained</a></li>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/12/cookies-and-security/\">Cookies and security</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework\">Simple cookie framework</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>起源，因为HTTP的无状态，无法知道两个请求是来自同个人。</p>\n<p>由NetScape工程师Lou Montulli与1994发表。正式确定于<a href=\"http://tools.ietf.org/html/rfc2109\">RFC2109</a>，最终演变成<a href=\"http://tools.ietf.org/html/rfc2965\">RFC2965</a></p>\n<h2 id=\"Cookie为何物？\"><a href=\"#Cookie为何物？\" class=\"headerlink\" title=\"Cookie为何物？\"></a>Cookie为何物？</h2><p>简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>服务器通过<code>Set-Cookie</code>的HTTP头来设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: &lt;em&gt;value&lt;/em&gt;[; expires=&lt;em&gt;date&lt;/em&gt;][; domain=&lt;em&gt;domain&lt;/em&gt;][; path=&lt;em&gt;path&lt;/em&gt;][; secure]</span><br></pre></td></tr></table></figure>\n\n<p>客户端将多个cookie通过<code>Cookie</code>的HTTP头来返回服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie: value1; value2; name1=value1</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>多个value直接由一个分号和一个空格分隔开</p>\n</blockquote>\n<h3 id=\"value编码\"><a href=\"#value编码\" class=\"headerlink\" title=\"value编码\"></a>value编码</h3><p>在普遍持有的观念中，value一定要是<code>URL-endcoed</code>编码的。</p>\n<p>其实这是个谬论，在文档中，明确指出只有<code>分号、逗号、空格</code>才需要编码。</p>\n<h3 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h3><p>设置过期时间。需要使用GMT格式的时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除</p>\n</blockquote>\n<blockquote>\n<p>校验的时间是以客户端的时间为准</p>\n</blockquote>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>指定什么域名请求时需要发送该cookie。</p>\n<blockquote>\n<p>采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)</p>\n</blockquote>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>指定域名下的对应路径的请求才发送cookie。</p>\n<h3 id=\"secure\"><a href=\"#secure\" class=\"headerlink\" title=\"secure\"></a>secure</h3><p>有这个标志，cookie只会在HTTPS协议的请求发送该cookie。</p>\n<h2 id=\"维护Cookie和周期\"><a href=\"#维护Cookie和周期\" class=\"headerlink\" title=\"维护Cookie和周期\"></a>维护Cookie和周期</h2><p>修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。</p>\n<h3 id=\"自动删除\"><a href=\"#自动删除\" class=\"headerlink\" title=\"自动删除\"></a>自动删除</h3><p>以下三个原因导致cookie被浏览器自动删除：</p>\n<ul>\n<li>会话结束自动删除</li>\n<li>expires到期自动删除</li>\n<li>超过上线自动删除相对较旧的cookie</li>\n</ul>\n<h2 id=\"其他限制\"><a href=\"#其他限制\" class=\"headerlink\" title=\"其他限制\"></a>其他限制</h2><ul>\n<li>HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/\">HTTP cookies explained</a></li>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/12/cookies-and-security/\">Cookies and security</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework\">Simple cookie framework</a></li>\n</ul>\n"},{"title":"我所理解的BFC","date":"2017-11-11T02:53:38.000Z","desc":"bfc, clear float","_content":"\n# BFC\n\nBFC (Block Formatting Context) **块级格式化上下文**，在W3C上是这么定义的：\n\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.  \nIn a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.  \nIn a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).  \nFor information about page breaks in paged media, please consult the section on allowed page breaks.\n\n## BFC效果\n\n先来说说BFC有什么效果，从效果看本质。\n\n逐个翻译W3c的定义如下：\n\n- `boxes`按顺序，从上到下，垂直排列\n\n> boxes are laid out one after the other, vertically, beginning at the top of a containing block\n\n- 相邻`boxes`的垂直距离由margin决定，但是在同一个BFC容器的话，`margin`会合并\n\n> The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.\n\n- 每个`boxes`的左边会和BFC容器的左边重叠，`float`元素也是如此\n\n> each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), \n\n- 可以解决因`float`元素导致的高度收缩问题（也就是常说的消除浮动）\n\n>  This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).\n\n## 如何触发BFC\n\n- `float`元素和 absolutely元素 (例如`position: absolute||fixed`) \n- `display`等于`inline-blocks`, `table-cells`, and `table-captions`的块级容器元素\n- `overflow`不等于`visible`的元素\n\n## BFC作用\n\n- 相邻margin合并的问题\n\n- 消除浮动\n\n## 参考：\n\n- [CSS之BFC详解](http://www.html-js.com/article/1866)\n- [W3C block-formatting](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)","source":"_posts/what-is-bfc.md","raw":"---\ntitle: 我所理解的BFC\ndate: 2017-11-11 10:53:38\ntags:\n- CSS\n- BFC\ndesc: bfc, clear float\n---\n\n# BFC\n\nBFC (Block Formatting Context) **块级格式化上下文**，在W3C上是这么定义的：\n\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.  \nIn a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.  \nIn a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).  \nFor information about page breaks in paged media, please consult the section on allowed page breaks.\n\n## BFC效果\n\n先来说说BFC有什么效果，从效果看本质。\n\n逐个翻译W3c的定义如下：\n\n- `boxes`按顺序，从上到下，垂直排列\n\n> boxes are laid out one after the other, vertically, beginning at the top of a containing block\n\n- 相邻`boxes`的垂直距离由margin决定，但是在同一个BFC容器的话，`margin`会合并\n\n> The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.\n\n- 每个`boxes`的左边会和BFC容器的左边重叠，`float`元素也是如此\n\n> each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), \n\n- 可以解决因`float`元素导致的高度收缩问题（也就是常说的消除浮动）\n\n>  This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).\n\n## 如何触发BFC\n\n- `float`元素和 absolutely元素 (例如`position: absolute||fixed`) \n- `display`等于`inline-blocks`, `table-cells`, and `table-captions`的块级容器元素\n- `overflow`不等于`visible`的元素\n\n## BFC作用\n\n- 相邻margin合并的问题\n\n- 消除浮动\n\n## 参考：\n\n- [CSS之BFC详解](http://www.html-js.com/article/1866)\n- [W3C block-formatting](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)","slug":"what-is-bfc","published":1,"updated":"2020-05-23T06:10:30.000Z","_id":"ckxvfmfb80005brqqgmjf2hb3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h1><p>BFC (Block Formatting Context) <strong>块级格式化上下文</strong>，在W3C上是这么定义的：</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.<br>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.<br>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).<br>For information about page breaks in paged media, please consult the section on allowed page breaks.</p>\n</blockquote>\n<h2 id=\"BFC效果\"><a href=\"#BFC效果\" class=\"headerlink\" title=\"BFC效果\"></a>BFC效果</h2><p>先来说说BFC有什么效果，从效果看本质。</p>\n<p>逐个翻译W3c的定义如下：</p>\n<ul>\n<li><code>boxes</code>按顺序，从上到下，垂直排列</li>\n</ul>\n<blockquote>\n<p>boxes are laid out one after the other, vertically, beginning at the top of a containing block</p>\n</blockquote>\n<ul>\n<li>相邻<code>boxes</code>的垂直距离由margin决定，但是在同一个BFC容器的话，<code>margin</code>会合并</li>\n</ul>\n<blockquote>\n<p>The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p>\n</blockquote>\n<ul>\n<li>每个<code>boxes</code>的左边会和BFC容器的左边重叠，<code>float</code>元素也是如此</li>\n</ul>\n<blockquote>\n<p>each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), </p>\n</blockquote>\n<ul>\n<li>可以解决因<code>float</code>元素导致的高度收缩问题（也就是常说的消除浮动）</li>\n</ul>\n<blockquote>\n<p> This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>\n</blockquote>\n<h2 id=\"如何触发BFC\"><a href=\"#如何触发BFC\" class=\"headerlink\" title=\"如何触发BFC\"></a>如何触发BFC</h2><ul>\n<li><code>float</code>元素和 absolutely元素 (例如<code>position: absolute||fixed</code>) </li>\n<li><code>display</code>等于<code>inline-blocks</code>, <code>table-cells</code>, and <code>table-captions</code>的块级容器元素</li>\n<li><code>overflow</code>不等于<code>visible</code>的元素</li>\n</ul>\n<h2 id=\"BFC作用\"><a href=\"#BFC作用\" class=\"headerlink\" title=\"BFC作用\"></a>BFC作用</h2><ul>\n<li><p>相邻margin合并的问题</p>\n</li>\n<li><p>消除浮动</p>\n</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"http://www.html-js.com/article/1866\">CSS之BFC详解</a></li>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\">W3C block-formatting</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h1 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h1><p>BFC (Block Formatting Context) <strong>块级格式化上下文</strong>，在W3C上是这么定义的：</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.<br>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.<br>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).<br>For information about page breaks in paged media, please consult the section on allowed page breaks.</p>\n</blockquote>\n<h2 id=\"BFC效果\"><a href=\"#BFC效果\" class=\"headerlink\" title=\"BFC效果\"></a>BFC效果</h2><p>先来说说BFC有什么效果，从效果看本质。</p>\n<p>逐个翻译W3c的定义如下：</p>\n<ul>\n<li><code>boxes</code>按顺序，从上到下，垂直排列</li>\n</ul>\n<blockquote>\n<p>boxes are laid out one after the other, vertically, beginning at the top of a containing block</p>\n</blockquote>\n<ul>\n<li>相邻<code>boxes</code>的垂直距离由margin决定，但是在同一个BFC容器的话，<code>margin</code>会合并</li>\n</ul>\n<blockquote>\n<p>The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p>\n</blockquote>\n<ul>\n<li>每个<code>boxes</code>的左边会和BFC容器的左边重叠，<code>float</code>元素也是如此</li>\n</ul>\n<blockquote>\n<p>each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), </p>\n</blockquote>\n<ul>\n<li>可以解决因<code>float</code>元素导致的高度收缩问题（也就是常说的消除浮动）</li>\n</ul>\n<blockquote>\n<p> This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>\n</blockquote>\n<h2 id=\"如何触发BFC\"><a href=\"#如何触发BFC\" class=\"headerlink\" title=\"如何触发BFC\"></a>如何触发BFC</h2><ul>\n<li><code>float</code>元素和 absolutely元素 (例如<code>position: absolute||fixed</code>) </li>\n<li><code>display</code>等于<code>inline-blocks</code>, <code>table-cells</code>, and <code>table-captions</code>的块级容器元素</li>\n<li><code>overflow</code>不等于<code>visible</code>的元素</li>\n</ul>\n<h2 id=\"BFC作用\"><a href=\"#BFC作用\" class=\"headerlink\" title=\"BFC作用\"></a>BFC作用</h2><ul>\n<li><p>相邻margin合并的问题</p>\n</li>\n<li><p>消除浮动</p>\n</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"http://www.html-js.com/article/1866\">CSS之BFC详解</a></li>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\">W3C block-formatting</a></li>\n</ul>\n"},{"title":"CSS空格和换行","date":"2015-10-14T06:25:19.000Z","desc":"CSS空格和换行,word-break,overflow-wrap,word-wrap,white-space","_content":"\n在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。\n\n<!--more-->\n\n### break-all\n\n指定怎么在单词内断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwork-break: normal | break-all | keep-all;\n```\n\n`normal`: 使用默认的换行\n\n`break-all`: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。\n\n`keep-all`: CJK文本不断行，non-CJK文本的行为则和`normal`保持一致。\n\n具体效果可以看这个[参考例子](https://jsfiddle.net/5psou6y5/)\n\n### overflow-wrap(别名：word-wrap)\n\n指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\noverflow-wrap: normal | break-word;\n```\n\n`normal`: 表示在正常的单词结束处换行。\n\n`break-word`: 如果一行内无法容下某个单词的话，那就断开这个单词。\n\n**补充**：\n\n如果不明白`break-all`和`overflow-wrap`的差别的话，查看[这个例子](https://jsfiddle.net/ar6nha8e/)就可以明白了。\n\n---\n\n### white-space\n用来描述要如何处理元素内的空格。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwhite-space: normal | pre | nowrap | pre-wrap | pre-line;\n```\n\n`normal`: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。\n\n`nowrap`: 和 `normal` 一样，连续的空白符会被合并。但文本内的换行无效。\n\n`pre`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素时才会换行。\n\n`pre-wrap`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时才会换行。\n\n`pre-line`: 连续的空白符会被合并。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时会换行。\n\n**各种white-space的值对应的行为如下**：\n\n||换行符|空白符和制表符|文字换行|\n|--|--|--|--|\n|normal|合并|合并|转行|\n|nowrap|合并|合并|不转行|\n|pre|保留|保留|不转行|\n|pre-wrap|保留|保留|转行|\n|pre-line|保留|合并|转行|\n\n效果请看这个[MDN的例子](https://jsfiddle.net/hzywLx6u/)","source":"_posts/white-space-and-wrap.md","raw":"---\ntitle: CSS空格和换行\ndate: 2015-10-14 14:25:19\ntags:\n- CSS\ndesc: CSS空格和换行,word-break,overflow-wrap,word-wrap,white-space\n---\n\n在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。\n\n<!--more-->\n\n### break-all\n\n指定怎么在单词内断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwork-break: normal | break-all | keep-all;\n```\n\n`normal`: 使用默认的换行\n\n`break-all`: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。\n\n`keep-all`: CJK文本不断行，non-CJK文本的行为则和`normal`保持一致。\n\n具体效果可以看这个[参考例子](https://jsfiddle.net/5psou6y5/)\n\n### overflow-wrap(别名：word-wrap)\n\n指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\noverflow-wrap: normal | break-word;\n```\n\n`normal`: 表示在正常的单词结束处换行。\n\n`break-word`: 如果一行内无法容下某个单词的话，那就断开这个单词。\n\n**补充**：\n\n如果不明白`break-all`和`overflow-wrap`的差别的话，查看[这个例子](https://jsfiddle.net/ar6nha8e/)就可以明白了。\n\n---\n\n### white-space\n用来描述要如何处理元素内的空格。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwhite-space: normal | pre | nowrap | pre-wrap | pre-line;\n```\n\n`normal`: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。\n\n`nowrap`: 和 `normal` 一样，连续的空白符会被合并。但文本内的换行无效。\n\n`pre`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素时才会换行。\n\n`pre-wrap`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时才会换行。\n\n`pre-line`: 连续的空白符会被合并。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时会换行。\n\n**各种white-space的值对应的行为如下**：\n\n||换行符|空白符和制表符|文字换行|\n|--|--|--|--|\n|normal|合并|合并|转行|\n|nowrap|合并|合并|不转行|\n|pre|保留|保留|不转行|\n|pre-wrap|保留|保留|转行|\n|pre-line|保留|合并|转行|\n\n效果请看这个[MDN的例子](https://jsfiddle.net/hzywLx6u/)","slug":"white-space-and-wrap","published":1,"updated":"2020-05-23T06:10:43.000Z","_id":"ckxvfmfba0007brqqaulmgg5k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"break-all\"><a href=\"#break-all\" class=\"headerlink\" title=\"break-all\"></a>break-all</h3><p>指定怎么在单词内断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">work-break: normal | break-all | keep-all;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 使用默认的换行</p>\n<p><code>break-all</code>: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。</p>\n<p><code>keep-all</code>: CJK文本不断行，non-CJK文本的行为则和<code>normal</code>保持一致。</p>\n<p>具体效果可以看这个<a href=\"https://jsfiddle.net/5psou6y5/\">参考例子</a></p>\n<h3 id=\"overflow-wrap-别名：word-wrap\"><a href=\"#overflow-wrap-别名：word-wrap\" class=\"headerlink\" title=\"overflow-wrap(别名：word-wrap)\"></a>overflow-wrap(别名：word-wrap)</h3><p>指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow-wrap: normal | break-word;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 表示在正常的单词结束处换行。</p>\n<p><code>break-word</code>: 如果一行内无法容下某个单词的话，那就断开这个单词。</p>\n<p><strong>补充</strong>：</p>\n<p>如果不明白<code>break-all</code>和<code>overflow-wrap</code>的差别的话，查看<a href=\"https://jsfiddle.net/ar6nha8e/\">这个例子</a>就可以明白了。</p>\n<hr>\n<h3 id=\"white-space\"><a href=\"#white-space\" class=\"headerlink\" title=\"white-space\"></a>white-space</h3><p>用来描述要如何处理元素内的空格。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">white-space: normal | pre | nowrap | pre-wrap | pre-line;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。</p>\n<p><code>nowrap</code>: 和 <code>normal</code> 一样，连续的空白符会被合并。但文本内的换行无效。</p>\n<p><code>pre</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素时才会换行。</p>\n<p><code>pre-wrap</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行。</p>\n<p><code>pre-line</code>: 连续的空白符会被合并。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时会换行。</p>\n<p><strong>各种white-space的值对应的行为如下</strong>：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>换行符</th>\n<th>空白符和制表符</th>\n<th>文字换行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>normal</td>\n<td>合并</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>nowrap</td>\n<td>合并</td>\n<td>合并</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre</td>\n<td>保留</td>\n<td>保留</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre-wrap</td>\n<td>保留</td>\n<td>保留</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>pre-line</td>\n<td>保留</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n</tbody></table>\n<p>效果请看这个<a href=\"https://jsfiddle.net/hzywLx6u/\">MDN的例子</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。</p>","more":"<h3 id=\"break-all\"><a href=\"#break-all\" class=\"headerlink\" title=\"break-all\"></a>break-all</h3><p>指定怎么在单词内断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">work-break: normal | break-all | keep-all;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 使用默认的换行</p>\n<p><code>break-all</code>: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。</p>\n<p><code>keep-all</code>: CJK文本不断行，non-CJK文本的行为则和<code>normal</code>保持一致。</p>\n<p>具体效果可以看这个<a href=\"https://jsfiddle.net/5psou6y5/\">参考例子</a></p>\n<h3 id=\"overflow-wrap-别名：word-wrap\"><a href=\"#overflow-wrap-别名：word-wrap\" class=\"headerlink\" title=\"overflow-wrap(别名：word-wrap)\"></a>overflow-wrap(别名：word-wrap)</h3><p>指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow-wrap: normal | break-word;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 表示在正常的单词结束处换行。</p>\n<p><code>break-word</code>: 如果一行内无法容下某个单词的话，那就断开这个单词。</p>\n<p><strong>补充</strong>：</p>\n<p>如果不明白<code>break-all</code>和<code>overflow-wrap</code>的差别的话，查看<a href=\"https://jsfiddle.net/ar6nha8e/\">这个例子</a>就可以明白了。</p>\n<hr>\n<h3 id=\"white-space\"><a href=\"#white-space\" class=\"headerlink\" title=\"white-space\"></a>white-space</h3><p>用来描述要如何处理元素内的空格。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">white-space: normal | pre | nowrap | pre-wrap | pre-line;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。</p>\n<p><code>nowrap</code>: 和 <code>normal</code> 一样，连续的空白符会被合并。但文本内的换行无效。</p>\n<p><code>pre</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素时才会换行。</p>\n<p><code>pre-wrap</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行。</p>\n<p><code>pre-line</code>: 连续的空白符会被合并。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时会换行。</p>\n<p><strong>各种white-space的值对应的行为如下</strong>：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>换行符</th>\n<th>空白符和制表符</th>\n<th>文字换行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>normal</td>\n<td>合并</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>nowrap</td>\n<td>合并</td>\n<td>合并</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre</td>\n<td>保留</td>\n<td>保留</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre-wrap</td>\n<td>保留</td>\n<td>保留</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>pre-line</td>\n<td>保留</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n</tbody></table>\n<p>效果请看这个<a href=\"https://jsfiddle.net/hzywLx6u/\">MDN的例子</a></p>"},{"title":"web安全相关-HTTP头部","date":"2016-05-09T13:02:49.000Z","desc":"web safe,web安全,网络安全,http,http安全头部","_content":"\nSecurity - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容`web`安全，不能更生动形象。最近项目涉及到一些`web`安全的东西，就来总结一下相关的HTTP安全头部。\n\n<!--more-->\n\n## [Content-Security-Policy](http://content-security-policy.com/)\n\n**作用**：防止的内容注入（减缓了`XSS`攻击，恶意`iframe`注入）\n\n**不足**：目前只支持现代浏览器，对浏览器有要求，要求如下：\n\nheader | Chrome | FireFox | Safari |  Internet Explorer\n---|---|---|---|---|\nContent-Security-Policy `CSP Level 2` | 40+ Full January 2015 | 31+ PartialJuly 2014 | - | -\nContent-Security-Policy `CSP 1.0` | 25+ | 23+ | 7+ | Edge 12 build 10240+\n\n**分析**：\n1. 由于HTML的`img`、`script`、`css`是可以跨域的，这就导致了XSS缺陷。CSP可以设置`default-src`、`script-src`、`img-src`等等来限制HTML资源的加载\n\n2. `script-src`可以设置两个特殊的值（`unsafe-inline`、`unsafe-eval`）。`unsafe-inline`代表不能执行内`script`，这就对`XSS`增添了一次防御，不过这样对开发人员有一定的规范。`unsafe-eval`则是代表不能执行`eval`方法(这是一个比较BUG级的函数，它会把传入的参数全部当做`JS`代码解释并且执行)\n3. `sandbox`沙盒则适用于同源策略的`webapp`，可以限制新标签页面打开等等。\n4. `report-uri`这个属性可以设置一个`URL`，然后会把`CSP`的失败信息`POST`到这个`URL`。我们则可以记录这个有用的信息用来安全性分析。\n\n\n## [Strict Transport Security](https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security)\n\n```\nStrict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]\n```\n**作用**：告诉浏览器接下来的一定时间内（自己设置）只能用`HTTPS`访问。这个只会让用`HTTPS`访问的用户继续使用`HTTPS`。而HTTP访问的则无效。\n\n**分析**：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入`HTTPS`。所以第一次访问的时候，都是以`HTTP`访问，这时负载服务器就应该返回一个`301`跳转给客户端，让客户端跳转到`HTTPS`的服务下。由于有了`HSTS`的头部，下次用户再次以`HTTP`访问的时候，浏览器会自己做`307`跳转到`HTTPS`请求。\n\n**实际开发遇到的问题**：\n\n由于公司使用阿里云的`SLB`负载均衡，无法实现`301`跳转，于是使用了`node`再开启一个服务，用于接受来自`SLB`80端口的请求，然后返回一个`301`状态码并在`Location`头部加上`HTTPS`的地址。真正的`node`服务只接受`SLB`443接口的请求。\n\n## [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/gg622941.aspx)\n```\nX-Content-Type-Options: nosniff\n```\n**作用**：互联网上的资源有各种类型，通常浏览器会根据响应头的`Content-Type`字段来分辨它们的类型。例如：`text/html`代表html文档，`image/png`是PNG图片，`text/css`是CSS样式文档。然而，有些资源的`Content-Type`是错的或者未定义。这时，某些浏览器会启用`MIME-sniffing`来猜测该资源的类型，解析内容并执行。\n\n例如，我们即使给一个`html`文档指定`Content-Type`为`text/plain`，在`IE8`中这个文档依然会被当做`html`来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为`JavaScript`。\n\n**实际开发遇到的问题**：\n\n在IE下图片验证码不能显示。  \n分析后得出，是因为图片验证码返回的时候没有返回`content-type`这个文件类型的头部。所以`IE`不能识别文件类型。  \n解决办法是修改图片验证码插件在返回图片是增加头部`content-type`：`image/jpg`\n\n## 参考：\n\n- [Node.js Security Checklist](https://blog.risingstack.com/node-js-security-checklist/)\n\n- [Express.js官方的安全性最佳实践指导](http://expressjs.com/en/advanced/best-practice-security.html)\n\n- [xss攻击入门](http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html)\n","source":"_posts/web-safe-http-header.md","raw":"---\ntitle: web安全相关-HTTP头部\ndate: 2016-05-9 21:02:49\ntags:\n- 网络安全\n- HTTP\ndesc: web safe,web安全,网络安全,http,http安全头部\n---\n\nSecurity - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容`web`安全，不能更生动形象。最近项目涉及到一些`web`安全的东西，就来总结一下相关的HTTP安全头部。\n\n<!--more-->\n\n## [Content-Security-Policy](http://content-security-policy.com/)\n\n**作用**：防止的内容注入（减缓了`XSS`攻击，恶意`iframe`注入）\n\n**不足**：目前只支持现代浏览器，对浏览器有要求，要求如下：\n\nheader | Chrome | FireFox | Safari |  Internet Explorer\n---|---|---|---|---|\nContent-Security-Policy `CSP Level 2` | 40+ Full January 2015 | 31+ PartialJuly 2014 | - | -\nContent-Security-Policy `CSP 1.0` | 25+ | 23+ | 7+ | Edge 12 build 10240+\n\n**分析**：\n1. 由于HTML的`img`、`script`、`css`是可以跨域的，这就导致了XSS缺陷。CSP可以设置`default-src`、`script-src`、`img-src`等等来限制HTML资源的加载\n\n2. `script-src`可以设置两个特殊的值（`unsafe-inline`、`unsafe-eval`）。`unsafe-inline`代表不能执行内`script`，这就对`XSS`增添了一次防御，不过这样对开发人员有一定的规范。`unsafe-eval`则是代表不能执行`eval`方法(这是一个比较BUG级的函数，它会把传入的参数全部当做`JS`代码解释并且执行)\n3. `sandbox`沙盒则适用于同源策略的`webapp`，可以限制新标签页面打开等等。\n4. `report-uri`这个属性可以设置一个`URL`，然后会把`CSP`的失败信息`POST`到这个`URL`。我们则可以记录这个有用的信息用来安全性分析。\n\n\n## [Strict Transport Security](https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security)\n\n```\nStrict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]\n```\n**作用**：告诉浏览器接下来的一定时间内（自己设置）只能用`HTTPS`访问。这个只会让用`HTTPS`访问的用户继续使用`HTTPS`。而HTTP访问的则无效。\n\n**分析**：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入`HTTPS`。所以第一次访问的时候，都是以`HTTP`访问，这时负载服务器就应该返回一个`301`跳转给客户端，让客户端跳转到`HTTPS`的服务下。由于有了`HSTS`的头部，下次用户再次以`HTTP`访问的时候，浏览器会自己做`307`跳转到`HTTPS`请求。\n\n**实际开发遇到的问题**：\n\n由于公司使用阿里云的`SLB`负载均衡，无法实现`301`跳转，于是使用了`node`再开启一个服务，用于接受来自`SLB`80端口的请求，然后返回一个`301`状态码并在`Location`头部加上`HTTPS`的地址。真正的`node`服务只接受`SLB`443接口的请求。\n\n## [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/gg622941.aspx)\n```\nX-Content-Type-Options: nosniff\n```\n**作用**：互联网上的资源有各种类型，通常浏览器会根据响应头的`Content-Type`字段来分辨它们的类型。例如：`text/html`代表html文档，`image/png`是PNG图片，`text/css`是CSS样式文档。然而，有些资源的`Content-Type`是错的或者未定义。这时，某些浏览器会启用`MIME-sniffing`来猜测该资源的类型，解析内容并执行。\n\n例如，我们即使给一个`html`文档指定`Content-Type`为`text/plain`，在`IE8`中这个文档依然会被当做`html`来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为`JavaScript`。\n\n**实际开发遇到的问题**：\n\n在IE下图片验证码不能显示。  \n分析后得出，是因为图片验证码返回的时候没有返回`content-type`这个文件类型的头部。所以`IE`不能识别文件类型。  \n解决办法是修改图片验证码插件在返回图片是增加头部`content-type`：`image/jpg`\n\n## 参考：\n\n- [Node.js Security Checklist](https://blog.risingstack.com/node-js-security-checklist/)\n\n- [Express.js官方的安全性最佳实践指导](http://expressjs.com/en/advanced/best-practice-security.html)\n\n- [xss攻击入门](http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html)\n","slug":"web-safe-http-header","published":1,"updated":"2020-05-23T06:12:16.000Z","_id":"ckxvfmfbb0008brqqfaskh4yo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Security - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容<code>web</code>安全，不能更生动形象。最近项目涉及到一些<code>web</code>安全的东西，就来总结一下相关的HTTP安全头部。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Content-Security-Policy\"><a href=\"#Content-Security-Policy\" class=\"headerlink\" title=\"Content-Security-Policy\"></a><a href=\"http://content-security-policy.com/\">Content-Security-Policy</a></h2><p><strong>作用</strong>：防止的内容注入（减缓了<code>XSS</code>攻击，恶意<code>iframe</code>注入）</p>\n<p><strong>不足</strong>：目前只支持现代浏览器，对浏览器有要求，要求如下：</p>\n<table>\n<thead>\n<tr>\n<th>header</th>\n<th>Chrome</th>\n<th>FireFox</th>\n<th>Safari</th>\n<th>Internet Explorer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content-Security-Policy <code>CSP Level 2</code></td>\n<td>40+ Full January 2015</td>\n<td>31+ PartialJuly 2014</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Content-Security-Policy <code>CSP 1.0</code></td>\n<td>25+</td>\n<td>23+</td>\n<td>7+</td>\n<td>Edge 12 build 10240+</td>\n</tr>\n</tbody></table>\n<p><strong>分析</strong>：</p>\n<ol>\n<li><p>由于HTML的<code>img</code>、<code>script</code>、<code>css</code>是可以跨域的，这就导致了XSS缺陷。CSP可以设置<code>default-src</code>、<code>script-src</code>、<code>img-src</code>等等来限制HTML资源的加载</p>\n</li>\n<li><p><code>script-src</code>可以设置两个特殊的值（<code>unsafe-inline</code>、<code>unsafe-eval</code>）。<code>unsafe-inline</code>代表不能执行内<code>script</code>，这就对<code>XSS</code>增添了一次防御，不过这样对开发人员有一定的规范。<code>unsafe-eval</code>则是代表不能执行<code>eval</code>方法(这是一个比较BUG级的函数，它会把传入的参数全部当做<code>JS</code>代码解释并且执行)</p>\n</li>\n<li><p><code>sandbox</code>沙盒则适用于同源策略的<code>webapp</code>，可以限制新标签页面打开等等。</p>\n</li>\n<li><p><code>report-uri</code>这个属性可以设置一个<code>URL</code>，然后会把<code>CSP</code>的失败信息<code>POST</code>到这个<code>URL</code>。我们则可以记录这个有用的信息用来安全性分析。</p>\n</li>\n</ol>\n<h2 id=\"Strict-Transport-Security\"><a href=\"#Strict-Transport-Security\" class=\"headerlink\" title=\"Strict Transport Security\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security\">Strict Transport Security</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：告诉浏览器接下来的一定时间内（自己设置）只能用<code>HTTPS</code>访问。这个只会让用<code>HTTPS</code>访问的用户继续使用<code>HTTPS</code>。而HTTP访问的则无效。</p>\n<p><strong>分析</strong>：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入<code>HTTPS</code>。所以第一次访问的时候，都是以<code>HTTP</code>访问，这时负载服务器就应该返回一个<code>301</code>跳转给客户端，让客户端跳转到<code>HTTPS</code>的服务下。由于有了<code>HSTS</code>的头部，下次用户再次以<code>HTTP</code>访问的时候，浏览器会自己做<code>307</code>跳转到<code>HTTPS</code>请求。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>由于公司使用阿里云的<code>SLB</code>负载均衡，无法实现<code>301</code>跳转，于是使用了<code>node</code>再开启一个服务，用于接受来自<code>SLB</code>80端口的请求，然后返回一个<code>301</code>状态码并在<code>Location</code>头部加上<code>HTTPS</code>的地址。真正的<code>node</code>服务只接受<code>SLB</code>443接口的请求。</p>\n<h2 id=\"X-Content-Type-Options\"><a href=\"#X-Content-Type-Options\" class=\"headerlink\" title=\"X-Content-Type-Options\"></a><a href=\"https://msdn.microsoft.com/en-us/library/gg622941.aspx\">X-Content-Type-Options</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：互联网上的资源有各种类型，通常浏览器会根据响应头的<code>Content-Type</code>字段来分辨它们的类型。例如：<code>text/html</code>代表html文档，<code>image/png</code>是PNG图片，<code>text/css</code>是CSS样式文档。然而，有些资源的<code>Content-Type</code>是错的或者未定义。这时，某些浏览器会启用<code>MIME-sniffing</code>来猜测该资源的类型，解析内容并执行。</p>\n<p>例如，我们即使给一个<code>html</code>文档指定<code>Content-Type</code>为<code>text/plain</code>，在<code>IE8</code>中这个文档依然会被当做<code>html</code>来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为<code>JavaScript</code>。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>在IE下图片验证码不能显示。<br>分析后得出，是因为图片验证码返回的时候没有返回<code>content-type</code>这个文件类型的头部。所以<code>IE</code>不能识别文件类型。<br>解决办法是修改图片验证码插件在返回图片是增加头部<code>content-type</code>：<code>image/jpg</code></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><p><a href=\"https://blog.risingstack.com/node-js-security-checklist/\">Node.js Security Checklist</a></p>\n</li>\n<li><p><a href=\"http://expressjs.com/en/advanced/best-practice-security.html\">Express.js官方的安全性最佳实践指导</a></p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html\">xss攻击入门</a></p>\n</li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>Security - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容<code>web</code>安全，不能更生动形象。最近项目涉及到一些<code>web</code>安全的东西，就来总结一下相关的HTTP安全头部。</p>","more":"<h2 id=\"Content-Security-Policy\"><a href=\"#Content-Security-Policy\" class=\"headerlink\" title=\"Content-Security-Policy\"></a><a href=\"http://content-security-policy.com/\">Content-Security-Policy</a></h2><p><strong>作用</strong>：防止的内容注入（减缓了<code>XSS</code>攻击，恶意<code>iframe</code>注入）</p>\n<p><strong>不足</strong>：目前只支持现代浏览器，对浏览器有要求，要求如下：</p>\n<table>\n<thead>\n<tr>\n<th>header</th>\n<th>Chrome</th>\n<th>FireFox</th>\n<th>Safari</th>\n<th>Internet Explorer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content-Security-Policy <code>CSP Level 2</code></td>\n<td>40+ Full January 2015</td>\n<td>31+ PartialJuly 2014</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Content-Security-Policy <code>CSP 1.0</code></td>\n<td>25+</td>\n<td>23+</td>\n<td>7+</td>\n<td>Edge 12 build 10240+</td>\n</tr>\n</tbody></table>\n<p><strong>分析</strong>：</p>\n<ol>\n<li><p>由于HTML的<code>img</code>、<code>script</code>、<code>css</code>是可以跨域的，这就导致了XSS缺陷。CSP可以设置<code>default-src</code>、<code>script-src</code>、<code>img-src</code>等等来限制HTML资源的加载</p>\n</li>\n<li><p><code>script-src</code>可以设置两个特殊的值（<code>unsafe-inline</code>、<code>unsafe-eval</code>）。<code>unsafe-inline</code>代表不能执行内<code>script</code>，这就对<code>XSS</code>增添了一次防御，不过这样对开发人员有一定的规范。<code>unsafe-eval</code>则是代表不能执行<code>eval</code>方法(这是一个比较BUG级的函数，它会把传入的参数全部当做<code>JS</code>代码解释并且执行)</p>\n</li>\n<li><p><code>sandbox</code>沙盒则适用于同源策略的<code>webapp</code>，可以限制新标签页面打开等等。</p>\n</li>\n<li><p><code>report-uri</code>这个属性可以设置一个<code>URL</code>，然后会把<code>CSP</code>的失败信息<code>POST</code>到这个<code>URL</code>。我们则可以记录这个有用的信息用来安全性分析。</p>\n</li>\n</ol>\n<h2 id=\"Strict-Transport-Security\"><a href=\"#Strict-Transport-Security\" class=\"headerlink\" title=\"Strict Transport Security\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security\">Strict Transport Security</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：告诉浏览器接下来的一定时间内（自己设置）只能用<code>HTTPS</code>访问。这个只会让用<code>HTTPS</code>访问的用户继续使用<code>HTTPS</code>。而HTTP访问的则无效。</p>\n<p><strong>分析</strong>：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入<code>HTTPS</code>。所以第一次访问的时候，都是以<code>HTTP</code>访问，这时负载服务器就应该返回一个<code>301</code>跳转给客户端，让客户端跳转到<code>HTTPS</code>的服务下。由于有了<code>HSTS</code>的头部，下次用户再次以<code>HTTP</code>访问的时候，浏览器会自己做<code>307</code>跳转到<code>HTTPS</code>请求。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>由于公司使用阿里云的<code>SLB</code>负载均衡，无法实现<code>301</code>跳转，于是使用了<code>node</code>再开启一个服务，用于接受来自<code>SLB</code>80端口的请求，然后返回一个<code>301</code>状态码并在<code>Location</code>头部加上<code>HTTPS</code>的地址。真正的<code>node</code>服务只接受<code>SLB</code>443接口的请求。</p>\n<h2 id=\"X-Content-Type-Options\"><a href=\"#X-Content-Type-Options\" class=\"headerlink\" title=\"X-Content-Type-Options\"></a><a href=\"https://msdn.microsoft.com/en-us/library/gg622941.aspx\">X-Content-Type-Options</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：互联网上的资源有各种类型，通常浏览器会根据响应头的<code>Content-Type</code>字段来分辨它们的类型。例如：<code>text/html</code>代表html文档，<code>image/png</code>是PNG图片，<code>text/css</code>是CSS样式文档。然而，有些资源的<code>Content-Type</code>是错的或者未定义。这时，某些浏览器会启用<code>MIME-sniffing</code>来猜测该资源的类型，解析内容并执行。</p>\n<p>例如，我们即使给一个<code>html</code>文档指定<code>Content-Type</code>为<code>text/plain</code>，在<code>IE8</code>中这个文档依然会被当做<code>html</code>来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为<code>JavaScript</code>。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>在IE下图片验证码不能显示。<br>分析后得出，是因为图片验证码返回的时候没有返回<code>content-type</code>这个文件类型的头部。所以<code>IE</code>不能识别文件类型。<br>解决办法是修改图片验证码插件在返回图片是增加头部<code>content-type</code>：<code>image/jpg</code></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><p><a href=\"https://blog.risingstack.com/node-js-security-checklist/\">Node.js Security Checklist</a></p>\n</li>\n<li><p><a href=\"http://expressjs.com/en/advanced/best-practice-security.html\">Express.js官方的安全性最佳实践指导</a></p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html\">xss攻击入门</a></p>\n</li>\n</ul>"},{"title":"小程序开发总结（session部分）","date":"2017-07-18T15:26:51.000Z","desc":null,"_content":"\n最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。\n\n<!-- more -->\n\n## 登录态维护\n\n每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。\n\n### 无cookie\n\n首先，第一个需要踩的坑就是无`cookie`的登录态要如何维护。\n\n微信官方提供了一个流程图，我们可以先看看：\n\n![微信官方登录时序图](https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712)\n\n简而言之：\n1. 在小程序上通过`wx.login()`获取`code`\n2. 将`code`传到自己的服务器，然后将小程序的`secret`和`appid`与微信服务器交换`openid`和`session_key`\n3. 将`session_key`加上随机数生成`sessionId`，然后`openid`和`session_key`存在`session`里\n4. 小程序将`sessionId`存起来，每次访问都带上这个`sessionId`\n\n### 小程序获取code\n\n在小程序的`app.js`文件里，`onLaunch`函数调用我们写好的`login`函数：\n\n```js\nwx.login({\n  success: function (loginResult) {\n    wx.getUserInfo({\n      withCredentials: true,\n      success: function (userResult) {\n        // doLogin 就是将这些数据发送到服务器\n        doLogin(null, {\n            code: loginResult.code,\n            encryptedData: userResult.encryptedData,\n            iv: userResult.iv\n        })\n      }\n    })\n  }\n})\n```\n\n服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是`openid`和`session_key`。\n\n### 解密用户信息\n\n通过小程序传过来的和`encryptedData`和`iv`，然后还有刚才获取的`session_key`，我们就能解密用户的信息，通过对比解密出来的`openid`和微信交换来的`openid`对比，即可知道用户信息的正确性。\n\n### sessionId生成：\n\n```js\nfunction generateSessionId() {\n  return crypto.randomBytes(32).toString('hex')\n}\n```\n\n按理说，我们生成了`sessionId`，然后将对应的用户信息存在`session`里就大功告成了。\n\n但是这样的话，很容易被伪造的暴力的伪造`sessionId`攻击。因此，需要再进一步，生成另外一个校验数据称为`sessionkey`简称`sKey`，这时就使用到刚获取到的`session_key`：\n\n```js\nfunction generateSkey(sessionKey) {\n  const sha1 = (message) => {\n      return crypto.createHash('sha1').update(message, 'utf8').digest('hex')\n  }\n\n  return sha1(appid + secret + sessionKey)\n}\n```\n\n此时我们的`session`的`key`就是一个前面随机生成的`sessionId`。`value`则为：\n\n```js\n{\n  userinfo,\n  session_key,\n  sKey\n}\n```\n\n然后每次`sessionId`传递过来的时候，我们获取对应的`session_key`，然后调用`generateSkey`生成`sKey`，然后和`session`里面的`sKey`对比即可。\n\n此时，`session`的生成大功告成了！\n\n### 两个登录态的问题\n\n首先，调用微信生成的code的`login()`函数是有时效的，大概5分钟。\n\n我们生成的`session`也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。\n\n#### 小程序登录态\n\n官方提供了`wx.checkSession()`方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的`login`函数\n\n#### session失效\n\n这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现`session`失效了。\n\n因此我们可以在`app.js`的`onShow()`里发送请求到服务器测试`session`是否过期。过期的话就重新调用`login`函数。\n","source":"_posts/wechat-miniapp-session.md","raw":"---\ntitle: 小程序开发总结（session部分）\ndate: 2017-07-18 23:26:51\ntags:\n- 小程序\n- Session\ndesc:\n---\n\n最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。\n\n<!-- more -->\n\n## 登录态维护\n\n每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。\n\n### 无cookie\n\n首先，第一个需要踩的坑就是无`cookie`的登录态要如何维护。\n\n微信官方提供了一个流程图，我们可以先看看：\n\n![微信官方登录时序图](https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712)\n\n简而言之：\n1. 在小程序上通过`wx.login()`获取`code`\n2. 将`code`传到自己的服务器，然后将小程序的`secret`和`appid`与微信服务器交换`openid`和`session_key`\n3. 将`session_key`加上随机数生成`sessionId`，然后`openid`和`session_key`存在`session`里\n4. 小程序将`sessionId`存起来，每次访问都带上这个`sessionId`\n\n### 小程序获取code\n\n在小程序的`app.js`文件里，`onLaunch`函数调用我们写好的`login`函数：\n\n```js\nwx.login({\n  success: function (loginResult) {\n    wx.getUserInfo({\n      withCredentials: true,\n      success: function (userResult) {\n        // doLogin 就是将这些数据发送到服务器\n        doLogin(null, {\n            code: loginResult.code,\n            encryptedData: userResult.encryptedData,\n            iv: userResult.iv\n        })\n      }\n    })\n  }\n})\n```\n\n服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是`openid`和`session_key`。\n\n### 解密用户信息\n\n通过小程序传过来的和`encryptedData`和`iv`，然后还有刚才获取的`session_key`，我们就能解密用户的信息，通过对比解密出来的`openid`和微信交换来的`openid`对比，即可知道用户信息的正确性。\n\n### sessionId生成：\n\n```js\nfunction generateSessionId() {\n  return crypto.randomBytes(32).toString('hex')\n}\n```\n\n按理说，我们生成了`sessionId`，然后将对应的用户信息存在`session`里就大功告成了。\n\n但是这样的话，很容易被伪造的暴力的伪造`sessionId`攻击。因此，需要再进一步，生成另外一个校验数据称为`sessionkey`简称`sKey`，这时就使用到刚获取到的`session_key`：\n\n```js\nfunction generateSkey(sessionKey) {\n  const sha1 = (message) => {\n      return crypto.createHash('sha1').update(message, 'utf8').digest('hex')\n  }\n\n  return sha1(appid + secret + sessionKey)\n}\n```\n\n此时我们的`session`的`key`就是一个前面随机生成的`sessionId`。`value`则为：\n\n```js\n{\n  userinfo,\n  session_key,\n  sKey\n}\n```\n\n然后每次`sessionId`传递过来的时候，我们获取对应的`session_key`，然后调用`generateSkey`生成`sKey`，然后和`session`里面的`sKey`对比即可。\n\n此时，`session`的生成大功告成了！\n\n### 两个登录态的问题\n\n首先，调用微信生成的code的`login()`函数是有时效的，大概5分钟。\n\n我们生成的`session`也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。\n\n#### 小程序登录态\n\n官方提供了`wx.checkSession()`方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的`login`函数\n\n#### session失效\n\n这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现`session`失效了。\n\n因此我们可以在`app.js`的`onShow()`里发送请求到服务器测试`session`是否过期。过期的话就重新调用`login`函数。\n","slug":"wechat-miniapp-session","published":1,"updated":"2020-05-23T06:10:21.000Z","_id":"ckxvfmfbc0009brqq351q2ux1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"登录态维护\"><a href=\"#登录态维护\" class=\"headerlink\" title=\"登录态维护\"></a>登录态维护</h2><p>每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。</p>\n<h3 id=\"无cookie\"><a href=\"#无cookie\" class=\"headerlink\" title=\"无cookie\"></a>无cookie</h3><p>首先，第一个需要踩的坑就是无<code>cookie</code>的登录态要如何维护。</p>\n<p>微信官方提供了一个流程图，我们可以先看看：</p>\n<p><img src=\"https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712\" alt=\"微信官方登录时序图\"></p>\n<p>简而言之：</p>\n<ol>\n<li>在小程序上通过<code>wx.login()</code>获取<code>code</code></li>\n<li>将<code>code</code>传到自己的服务器，然后将小程序的<code>secret</code>和<code>appid</code>与微信服务器交换<code>openid</code>和<code>session_key</code></li>\n<li>将<code>session_key</code>加上随机数生成<code>sessionId</code>，然后<code>openid</code>和<code>session_key</code>存在<code>session</code>里</li>\n<li>小程序将<code>sessionId</code>存起来，每次访问都带上这个<code>sessionId</code></li>\n</ol>\n<h3 id=\"小程序获取code\"><a href=\"#小程序获取code\" class=\"headerlink\" title=\"小程序获取code\"></a>小程序获取code</h3><p>在小程序的<code>app.js</code>文件里，<code>onLaunch</code>函数调用我们写好的<code>login</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.login(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">loginResult</span>) </span>&#123;</span><br><span class=\"line\">    wx.getUserInfo(&#123;</span><br><span class=\"line\">      <span class=\"attr\">withCredentials</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userResult</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// doLogin 就是将这些数据发送到服务器</span></span><br><span class=\"line\">        doLogin(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">            <span class=\"attr\">code</span>: loginResult.code,</span><br><span class=\"line\">            <span class=\"attr\">encryptedData</span>: userResult.encryptedData,</span><br><span class=\"line\">            <span class=\"attr\">iv</span>: userResult.iv</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是<code>openid</code>和<code>session_key</code>。</p>\n<h3 id=\"解密用户信息\"><a href=\"#解密用户信息\" class=\"headerlink\" title=\"解密用户信息\"></a>解密用户信息</h3><p>通过小程序传过来的和<code>encryptedData</code>和<code>iv</code>，然后还有刚才获取的<code>session_key</code>，我们就能解密用户的信息，通过对比解密出来的<code>openid</code>和微信交换来的<code>openid</code>对比，即可知道用户信息的正确性。</p>\n<h3 id=\"sessionId生成：\"><a href=\"#sessionId生成：\" class=\"headerlink\" title=\"sessionId生成：\"></a>sessionId生成：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSessionId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> crypto.randomBytes(<span class=\"number\">32</span>).toString(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按理说，我们生成了<code>sessionId</code>，然后将对应的用户信息存在<code>session</code>里就大功告成了。</p>\n<p>但是这样的话，很容易被伪造的暴力的伪造<code>sessionId</code>攻击。因此，需要再进一步，生成另外一个校验数据称为<code>sessionkey</code>简称<code>sKey</code>，这时就使用到刚获取到的<code>session_key</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSkey</span>(<span class=\"params\">sessionKey</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sha1 = <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> crypto.createHash(<span class=\"string\">&#x27;sha1&#x27;</span>).update(message, <span class=\"string\">&#x27;utf8&#x27;</span>).digest(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sha1(appid + secret + sessionKey)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们的<code>session</code>的<code>key</code>就是一个前面随机生成的<code>sessionId</code>。<code>value</code>则为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  userinfo,</span><br><span class=\"line\">  session_key,</span><br><span class=\"line\">  sKey</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后每次<code>sessionId</code>传递过来的时候，我们获取对应的<code>session_key</code>，然后调用<code>generateSkey</code>生成<code>sKey</code>，然后和<code>session</code>里面的<code>sKey</code>对比即可。</p>\n<p>此时，<code>session</code>的生成大功告成了！</p>\n<h3 id=\"两个登录态的问题\"><a href=\"#两个登录态的问题\" class=\"headerlink\" title=\"两个登录态的问题\"></a>两个登录态的问题</h3><p>首先，调用微信生成的code的<code>login()</code>函数是有时效的，大概5分钟。</p>\n<p>我们生成的<code>session</code>也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。</p>\n<h4 id=\"小程序登录态\"><a href=\"#小程序登录态\" class=\"headerlink\" title=\"小程序登录态\"></a>小程序登录态</h4><p>官方提供了<code>wx.checkSession()</code>方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的<code>login</code>函数</p>\n<h4 id=\"session失效\"><a href=\"#session失效\" class=\"headerlink\" title=\"session失效\"></a>session失效</h4><p>这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现<code>session</code>失效了。</p>\n<p>因此我们可以在<code>app.js</code>的<code>onShow()</code>里发送请求到服务器测试<code>session</code>是否过期。过期的话就重新调用<code>login</code>函数。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。</p>","more":"<h2 id=\"登录态维护\"><a href=\"#登录态维护\" class=\"headerlink\" title=\"登录态维护\"></a>登录态维护</h2><p>每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。</p>\n<h3 id=\"无cookie\"><a href=\"#无cookie\" class=\"headerlink\" title=\"无cookie\"></a>无cookie</h3><p>首先，第一个需要踩的坑就是无<code>cookie</code>的登录态要如何维护。</p>\n<p>微信官方提供了一个流程图，我们可以先看看：</p>\n<p><img src=\"https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712\" alt=\"微信官方登录时序图\"></p>\n<p>简而言之：</p>\n<ol>\n<li>在小程序上通过<code>wx.login()</code>获取<code>code</code></li>\n<li>将<code>code</code>传到自己的服务器，然后将小程序的<code>secret</code>和<code>appid</code>与微信服务器交换<code>openid</code>和<code>session_key</code></li>\n<li>将<code>session_key</code>加上随机数生成<code>sessionId</code>，然后<code>openid</code>和<code>session_key</code>存在<code>session</code>里</li>\n<li>小程序将<code>sessionId</code>存起来，每次访问都带上这个<code>sessionId</code></li>\n</ol>\n<h3 id=\"小程序获取code\"><a href=\"#小程序获取code\" class=\"headerlink\" title=\"小程序获取code\"></a>小程序获取code</h3><p>在小程序的<code>app.js</code>文件里，<code>onLaunch</code>函数调用我们写好的<code>login</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.login(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">loginResult</span>) </span>&#123;</span><br><span class=\"line\">    wx.getUserInfo(&#123;</span><br><span class=\"line\">      <span class=\"attr\">withCredentials</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userResult</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// doLogin 就是将这些数据发送到服务器</span></span><br><span class=\"line\">        doLogin(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">            <span class=\"attr\">code</span>: loginResult.code,</span><br><span class=\"line\">            <span class=\"attr\">encryptedData</span>: userResult.encryptedData,</span><br><span class=\"line\">            <span class=\"attr\">iv</span>: userResult.iv</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是<code>openid</code>和<code>session_key</code>。</p>\n<h3 id=\"解密用户信息\"><a href=\"#解密用户信息\" class=\"headerlink\" title=\"解密用户信息\"></a>解密用户信息</h3><p>通过小程序传过来的和<code>encryptedData</code>和<code>iv</code>，然后还有刚才获取的<code>session_key</code>，我们就能解密用户的信息，通过对比解密出来的<code>openid</code>和微信交换来的<code>openid</code>对比，即可知道用户信息的正确性。</p>\n<h3 id=\"sessionId生成：\"><a href=\"#sessionId生成：\" class=\"headerlink\" title=\"sessionId生成：\"></a>sessionId生成：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSessionId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> crypto.randomBytes(<span class=\"number\">32</span>).toString(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按理说，我们生成了<code>sessionId</code>，然后将对应的用户信息存在<code>session</code>里就大功告成了。</p>\n<p>但是这样的话，很容易被伪造的暴力的伪造<code>sessionId</code>攻击。因此，需要再进一步，生成另外一个校验数据称为<code>sessionkey</code>简称<code>sKey</code>，这时就使用到刚获取到的<code>session_key</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSkey</span>(<span class=\"params\">sessionKey</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sha1 = <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> crypto.createHash(<span class=\"string\">&#x27;sha1&#x27;</span>).update(message, <span class=\"string\">&#x27;utf8&#x27;</span>).digest(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sha1(appid + secret + sessionKey)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们的<code>session</code>的<code>key</code>就是一个前面随机生成的<code>sessionId</code>。<code>value</code>则为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  userinfo,</span><br><span class=\"line\">  session_key,</span><br><span class=\"line\">  sKey</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后每次<code>sessionId</code>传递过来的时候，我们获取对应的<code>session_key</code>，然后调用<code>generateSkey</code>生成<code>sKey</code>，然后和<code>session</code>里面的<code>sKey</code>对比即可。</p>\n<p>此时，<code>session</code>的生成大功告成了！</p>\n<h3 id=\"两个登录态的问题\"><a href=\"#两个登录态的问题\" class=\"headerlink\" title=\"两个登录态的问题\"></a>两个登录态的问题</h3><p>首先，调用微信生成的code的<code>login()</code>函数是有时效的，大概5分钟。</p>\n<p>我们生成的<code>session</code>也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。</p>\n<h4 id=\"小程序登录态\"><a href=\"#小程序登录态\" class=\"headerlink\" title=\"小程序登录态\"></a>小程序登录态</h4><p>官方提供了<code>wx.checkSession()</code>方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的<code>login</code>函数</p>\n<h4 id=\"session失效\"><a href=\"#session失效\" class=\"headerlink\" title=\"session失效\"></a>session失效</h4><p>这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现<code>session</code>失效了。</p>\n<p>因此我们可以在<code>app.js</code>的<code>onShow()</code>里发送请求到服务器测试<code>session</code>是否过期。过期的话就重新调用<code>login</code>函数。</p>"},{"title":"使用Web Storage API","date":"2017-08-07T15:20:31.000Z","desc":"localStorage的使用与分析","_content":"\n其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。\n\n<!-- more -->\n\n> 说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。\n\n### MDN\n\n要探究Web API，首先就想到[MDN](https://developer.mozilla.org/en-US/)。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！\n\n#### 中英文版本的差异\n\n中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。\n\n比如：\n\n- 我们可以像访问对象一样来访问Storage\n```js\nlocalStorage.colorSetting = '#a4509b';\nlocalStorage['colorSetting'] = '#a4509b';\nlocalStorage.setItem('colorSetting', '#a4509b');\n```\n但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下[《The pitfalls of using objects as maps in JavaScript》](http://2ality.com/2012/01/objects-as-maps.html)。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。\n\n- 可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：\n```js\nfunction storageAvailable() {\n    try {\n        const mod = '__storage__test__'\n        localStorage.setItem(mod, mod);\n        localStorage.removeItem(mod);\n        return true;\n    } catch(e) {\n        return false;\n    }\n}\n```\n附上一个[Storage可用性检测函数的简要历史](https://gist.github.com/paulirish/5558557)\n\n### 基本概念\n\nWeb Storage提供了两种机制让我们实现离线存储：\n- localStorage\n- sessionStorage\n\n其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。\n\n另外需要注意的是，两种机制都是在**每个独立域名**下**分开独立存储数据**的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)\n\n意思就是，在`a.com`下无法访问到`b.com`的storage数据，当然这是基于安全性的考虑。\n\n### 跨域\n\n跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用`Access-Control-Allow-origin`解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。\n\n由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的`postMessage`方法：\n\n首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考[annn.me](http://annn.me/cross-domain-local-storage/)的流程图如下：\n\n![](http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg)\n\ngithub上已有一个比较完备的类库可以参考：[cross-storage](https://github.com/zendesk/cross-storage)","source":"_posts/using-web-storage-api.md","raw":"---\ntitle: 使用Web Storage API\ndate: 2017-08-07 23:20:31\ntags:\n- JavaScript\n- Storage\ndesc: localStorage的使用与分析\n---\n\n其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。\n\n<!-- more -->\n\n> 说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。\n\n### MDN\n\n要探究Web API，首先就想到[MDN](https://developer.mozilla.org/en-US/)。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！\n\n#### 中英文版本的差异\n\n中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。\n\n比如：\n\n- 我们可以像访问对象一样来访问Storage\n```js\nlocalStorage.colorSetting = '#a4509b';\nlocalStorage['colorSetting'] = '#a4509b';\nlocalStorage.setItem('colorSetting', '#a4509b');\n```\n但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下[《The pitfalls of using objects as maps in JavaScript》](http://2ality.com/2012/01/objects-as-maps.html)。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。\n\n- 可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：\n```js\nfunction storageAvailable() {\n    try {\n        const mod = '__storage__test__'\n        localStorage.setItem(mod, mod);\n        localStorage.removeItem(mod);\n        return true;\n    } catch(e) {\n        return false;\n    }\n}\n```\n附上一个[Storage可用性检测函数的简要历史](https://gist.github.com/paulirish/5558557)\n\n### 基本概念\n\nWeb Storage提供了两种机制让我们实现离线存储：\n- localStorage\n- sessionStorage\n\n其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。\n\n另外需要注意的是，两种机制都是在**每个独立域名**下**分开独立存储数据**的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)\n\n意思就是，在`a.com`下无法访问到`b.com`的storage数据，当然这是基于安全性的考虑。\n\n### 跨域\n\n跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用`Access-Control-Allow-origin`解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。\n\n由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的`postMessage`方法：\n\n首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考[annn.me](http://annn.me/cross-domain-local-storage/)的流程图如下：\n\n![](http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg)\n\ngithub上已有一个比较完备的类库可以参考：[cross-storage](https://github.com/zendesk/cross-storage)","slug":"using-web-storage-api","published":1,"updated":"2020-05-23T06:09:57.000Z","_id":"ckxvfmfbe000cbrqq06fa8psr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。</p>\n</blockquote>\n<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p>要探究Web API，首先就想到<a href=\"https://developer.mozilla.org/en-US/\">MDN</a>。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！</p>\n<h4 id=\"中英文版本的差异\"><a href=\"#中英文版本的差异\" class=\"headerlink\" title=\"中英文版本的差异\"></a>中英文版本的差异</h4><p>中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。</p>\n<p>比如：</p>\n<ul>\n<li><p>我们可以像访问对象一样来访问Storage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">localStorage</span>.colorSetting = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>[<span class=\"string\">&#x27;colorSetting&#x27;</span>] = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>.setItem(<span class=\"string\">&#x27;colorSetting&#x27;</span>, <span class=\"string\">&#x27;#a4509b&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下<a href=\"http://2ality.com/2012/01/objects-as-maps.html\">《The pitfalls of using objects as maps in JavaScript》</a>。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。</p>\n</li>\n<li><p>可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">storageAvailable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> mod = <span class=\"string\">&#x27;__storage__test__&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.setItem(mod, mod);</span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.removeItem(mod);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附上一个<a href=\"https://gist.github.com/paulirish/5558557\">Storage可用性检测函数的简要历史</a></p>\n</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>Web Storage提供了两种机制让我们实现离线存储：</p>\n<ul>\n<li>localStorage</li>\n<li>sessionStorage</li>\n</ul>\n<p>其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。</p>\n<p>另外需要注意的是，两种机制都是在<strong>每个独立域名</strong>下<strong>分开独立存储数据</strong>的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)</p>\n<p>意思就是，在<code>a.com</code>下无法访问到<code>b.com</code>的storage数据，当然这是基于安全性的考虑。</p>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用<code>Access-Control-Allow-origin</code>解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。</p>\n<p>由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的<code>postMessage</code>方法：</p>\n<p>首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考<a href=\"http://annn.me/cross-domain-local-storage/\">annn.me</a>的流程图如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg\"></p>\n<p>github上已有一个比较完备的类库可以参考：<a href=\"https://github.com/zendesk/cross-storage\">cross-storage</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。</p>","more":"<blockquote>\n<p>说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。</p>\n</blockquote>\n<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p>要探究Web API，首先就想到<a href=\"https://developer.mozilla.org/en-US/\">MDN</a>。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！</p>\n<h4 id=\"中英文版本的差异\"><a href=\"#中英文版本的差异\" class=\"headerlink\" title=\"中英文版本的差异\"></a>中英文版本的差异</h4><p>中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。</p>\n<p>比如：</p>\n<ul>\n<li><p>我们可以像访问对象一样来访问Storage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">localStorage</span>.colorSetting = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>[<span class=\"string\">&#x27;colorSetting&#x27;</span>] = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>.setItem(<span class=\"string\">&#x27;colorSetting&#x27;</span>, <span class=\"string\">&#x27;#a4509b&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下<a href=\"http://2ality.com/2012/01/objects-as-maps.html\">《The pitfalls of using objects as maps in JavaScript》</a>。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。</p>\n</li>\n<li><p>可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">storageAvailable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> mod = <span class=\"string\">&#x27;__storage__test__&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.setItem(mod, mod);</span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.removeItem(mod);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附上一个<a href=\"https://gist.github.com/paulirish/5558557\">Storage可用性检测函数的简要历史</a></p>\n</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>Web Storage提供了两种机制让我们实现离线存储：</p>\n<ul>\n<li>localStorage</li>\n<li>sessionStorage</li>\n</ul>\n<p>其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。</p>\n<p>另外需要注意的是，两种机制都是在<strong>每个独立域名</strong>下<strong>分开独立存储数据</strong>的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)</p>\n<p>意思就是，在<code>a.com</code>下无法访问到<code>b.com</code>的storage数据，当然这是基于安全性的考虑。</p>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用<code>Access-Control-Allow-origin</code>解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。</p>\n<p>由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的<code>postMessage</code>方法：</p>\n<p>首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考<a href=\"http://annn.me/cross-domain-local-storage/\">annn.me</a>的流程图如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg\"></p>\n<p>github上已有一个比较完备的类库可以参考：<a href=\"https://github.com/zendesk/cross-storage\">cross-storage</a></p>"},{"title":"理解underscore.js系列——①分析外包装","date":"2017-09-04T12:26:40.000Z","desc":"理解underscore.js v1.8.3 源码解析","_content":"\n# 前言\n\n其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。\n\n另外提醒，此文对应的`underscore.js`版本是`v1.8.3`\n\n## 正文\n\n下面将以源码+解析的形式，叙述我对`underscore.js`的理解，能力有限，如有错误请指正。\n\n### 立即执行函数\n\n源码的最外面是一个立即执行函数(`IIFE`)：\n\n```js\n(function() {\n  // ...其他内容\n}());\n```\n\n之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。\n\n### 全局变量\n\n以前刚接触前端开发的时候，不懂`Node.js`，认为全局变量就是`window`，因此看到下面的代码会很困惑：\n\n```js\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n             typeof global == 'object' && global.global === global && global ||\n             this ||\n             {};\n```\n\n这是一个很geek的做法，运用了逻辑运算中的[`短路运算`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators)，在`||`操作的时候，如果前面为`true`的话，就不会计算后面的了。\n\n印象当中，以前的js库都是用`window`的，现在改用`self`，是因为要兼容[webWorker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)的缘故。因此（如注释所言）\n\n- 在浏览器或者`webWorker`的话，`root = self`\n- 在服务器环境的话，`root = global`\n- 在其他的虚拟机的话，则指向`this`即`root = this`\n- 其他环境就设置为空对象`{}`\n\n### 变量冲突\n\n我们假设一个情况，如果`_`这个变量被别人使用了。如果我们直接给`_`赋值，不就丢失了前面的对于`_`的定义。\n\n因此`undersocre.js`就先保存起来了：\n\n```js\nvar previousUnderscore = root._;\n```\n\n这样的话，就不会丢失了前面对`_`的定义，如果要使用的话，就可以使用`underscore.js`提供的`noConflict`方法：\n\n```js\n_.noConflict = function() {\n  root._ = previousUnderscore;\n  return this;\n};\n```\n\n### 缓存引用\n\n这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：\n\n```js\n// Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n```\n\n### 实现继承\n\n众所周知的是，js是使用原型链来实现继承的。\n\n其实这个实现方法就是ES5的`Object.create`的Polyfill，这么做是为了向后兼容：\n\n```js\n  var Ctor = function(){};\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null; // 恢复CTor的原型，以备后续使用\n    return result;\n  };\n```\n\n### 初始化\n\n```js\n// Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n```\n\n一开始我对这个部分有些困惑的，因为我简单地认为`_`就应该是一个空对象`{}`。\n\n其实，`underscore.js`是支持面向对象的方式使用的，也就是把`_`当作一个构造函数。即`new _(obj)`这样的用法。\n\n但是由于js没用真正的构造函数，因此还可以这样使用：`_(obj)`。为了避免这种情况，因此有了第二行代码：`if (!(this instanceof _)) return new _(obj);`。因为直接调用函数的话，`this`是指向全局的。\n\n### 兼容Node.js环境\n\n```js\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n```\n\n由于`Node.js`的存在，因此在`Node.js`环境就将`_`赋值给`exports`\n\n另外如注释所说，之所以要检测`nodeType`，是为了确保`exports`和`module`不是`HTML`元素\n\n## 结尾\n\n这篇文章就是我阅读`udersocre.js`的第一篇源码分析文章，也是这个系列的第一篇。\n\n写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。\n","source":"_posts/underscore-wrapper.md","raw":"---\ntitle: 理解underscore.js系列——①分析外包装\ndate: 2017-09-04 20:26:40\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\n---\n\n# 前言\n\n其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。\n\n另外提醒，此文对应的`underscore.js`版本是`v1.8.3`\n\n## 正文\n\n下面将以源码+解析的形式，叙述我对`underscore.js`的理解，能力有限，如有错误请指正。\n\n### 立即执行函数\n\n源码的最外面是一个立即执行函数(`IIFE`)：\n\n```js\n(function() {\n  // ...其他内容\n}());\n```\n\n之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。\n\n### 全局变量\n\n以前刚接触前端开发的时候，不懂`Node.js`，认为全局变量就是`window`，因此看到下面的代码会很困惑：\n\n```js\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n             typeof global == 'object' && global.global === global && global ||\n             this ||\n             {};\n```\n\n这是一个很geek的做法，运用了逻辑运算中的[`短路运算`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators)，在`||`操作的时候，如果前面为`true`的话，就不会计算后面的了。\n\n印象当中，以前的js库都是用`window`的，现在改用`self`，是因为要兼容[webWorker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)的缘故。因此（如注释所言）\n\n- 在浏览器或者`webWorker`的话，`root = self`\n- 在服务器环境的话，`root = global`\n- 在其他的虚拟机的话，则指向`this`即`root = this`\n- 其他环境就设置为空对象`{}`\n\n### 变量冲突\n\n我们假设一个情况，如果`_`这个变量被别人使用了。如果我们直接给`_`赋值，不就丢失了前面的对于`_`的定义。\n\n因此`undersocre.js`就先保存起来了：\n\n```js\nvar previousUnderscore = root._;\n```\n\n这样的话，就不会丢失了前面对`_`的定义，如果要使用的话，就可以使用`underscore.js`提供的`noConflict`方法：\n\n```js\n_.noConflict = function() {\n  root._ = previousUnderscore;\n  return this;\n};\n```\n\n### 缓存引用\n\n这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：\n\n```js\n// Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n```\n\n### 实现继承\n\n众所周知的是，js是使用原型链来实现继承的。\n\n其实这个实现方法就是ES5的`Object.create`的Polyfill，这么做是为了向后兼容：\n\n```js\n  var Ctor = function(){};\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null; // 恢复CTor的原型，以备后续使用\n    return result;\n  };\n```\n\n### 初始化\n\n```js\n// Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n```\n\n一开始我对这个部分有些困惑的，因为我简单地认为`_`就应该是一个空对象`{}`。\n\n其实，`underscore.js`是支持面向对象的方式使用的，也就是把`_`当作一个构造函数。即`new _(obj)`这样的用法。\n\n但是由于js没用真正的构造函数，因此还可以这样使用：`_(obj)`。为了避免这种情况，因此有了第二行代码：`if (!(this instanceof _)) return new _(obj);`。因为直接调用函数的话，`this`是指向全局的。\n\n### 兼容Node.js环境\n\n```js\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n```\n\n由于`Node.js`的存在，因此在`Node.js`环境就将`_`赋值给`exports`\n\n另外如注释所说，之所以要检测`nodeType`，是为了确保`exports`和`module`不是`HTML`元素\n\n## 结尾\n\n这篇文章就是我阅读`udersocre.js`的第一篇源码分析文章，也是这个系列的第一篇。\n\n写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。\n","slug":"underscore-wrapper","published":1,"updated":"2020-05-23T06:09:44.000Z","_id":"ckxvfmfbm000dbrqq4squfpbu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。</p>\n<p>另外提醒，此文对应的<code>underscore.js</code>版本是<code>v1.8.3</code></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>下面将以源码+解析的形式，叙述我对<code>underscore.js</code>的理解，能力有限，如有错误请指正。</p>\n<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h3><p>源码的最外面是一个立即执行函数(<code>IIFE</code>)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他内容</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>以前刚接触前端开发的时候，不懂<code>Node.js</code>，认为全局变量就是<code>window</code>，因此看到下面的代码会很困惑：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Establish the root object, `window` (`self`) in the browser, `global`</span></span><br><span class=\"line\"><span class=\"comment\">// on the server, or `this` in some virtual machines. We use `self`</span></span><br><span class=\"line\"><span class=\"comment\">// instead of `window` for `WebWorker` support.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = <span class=\"keyword\">typeof</span> self == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class=\"line\">           <span class=\"keyword\">typeof</span> <span class=\"built_in\">global</span> == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"built_in\">global</span>.global === <span class=\"built_in\">global</span> &amp;&amp; <span class=\"built_in\">global</span> ||</span><br><span class=\"line\">           <span class=\"built_in\">this</span> ||</span><br><span class=\"line\">           &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很geek的做法，运用了逻辑运算中的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators\"><code>短路运算</code></a>，在<code>||</code>操作的时候，如果前面为<code>true</code>的话，就不会计算后面的了。</p>\n<p>印象当中，以前的js库都是用<code>window</code>的，现在改用<code>self</code>，是因为要兼容<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker\">webWorker</a>的缘故。因此（如注释所言）</p>\n<ul>\n<li>在浏览器或者<code>webWorker</code>的话，<code>root = self</code></li>\n<li>在服务器环境的话，<code>root = global</code></li>\n<li>在其他的虚拟机的话，则指向<code>this</code>即<code>root = this</code></li>\n<li>其他环境就设置为空对象<code>&#123;&#125;</code></li>\n</ul>\n<h3 id=\"变量冲突\"><a href=\"#变量冲突\" class=\"headerlink\" title=\"变量冲突\"></a>变量冲突</h3><p>我们假设一个情况，如果<code>_</code>这个变量被别人使用了。如果我们直接给<code>_</code>赋值，不就丢失了前面的对于<code>_</code>的定义。</p>\n<p>因此<code>undersocre.js</code>就先保存起来了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> previousUnderscore = root._;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，就不会丢失了前面对<code>_</code>的定义，如果要使用的话，就可以使用<code>underscore.js</code>提供的<code>noConflict</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  root._ = previousUnderscore;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存引用\"><a href=\"#缓存引用\" class=\"headerlink\" title=\"缓存引用\"></a>缓存引用</h3><p>这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Save bytes in the minified (but not gzipped) version:</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ArrayProto = <span class=\"built_in\">Array</span>.prototype, ObjProto = <span class=\"built_in\">Object</span>.prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> SymbolProto = <span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> ? <span class=\"built_in\">Symbol</span>.prototype : <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create quick reference variables for speed access to core prototypes.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> push = ArrayProto.push,</span><br><span class=\"line\">      slice = ArrayProto.slice,</span><br><span class=\"line\">      toString = ObjProto.toString,</span><br><span class=\"line\">      hasOwnProperty = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All **ECMAScript 5** native function implementations that we hope to use</span></span><br><span class=\"line\">  <span class=\"comment\">// are declared here.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> nativeIsArray = <span class=\"built_in\">Array</span>.isArray,</span><br><span class=\"line\">      nativeKeys = <span class=\"built_in\">Object</span>.keys,</span><br><span class=\"line\">      nativeCreate = <span class=\"built_in\">Object</span>.create;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h3><p>众所周知的是，js是使用原型链来实现继承的。</p>\n<p>其实这个实现方法就是ES5的<code>Object.create</code>的Polyfill，这么做是为了向后兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Ctor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An internal function for creating a new object that inherits from another.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baseCreate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prototype</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_.isObject(prototype)) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nativeCreate) <span class=\"keyword\">return</span> nativeCreate(prototype);</span><br><span class=\"line\">  Ctor.prototype = prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> Ctor;</span><br><span class=\"line\">  Ctor.prototype = <span class=\"literal\">null</span>; <span class=\"comment\">// 恢复CTor的原型，以备后续使用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a safe reference to the Underscore object for use below.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> _) <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> _)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _(obj);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一开始我对这个部分有些困惑的，因为我简单地认为<code>_</code>就应该是一个空对象<code>&#123;&#125;</code>。</p>\n<p>其实，<code>underscore.js</code>是支持面向对象的方式使用的，也就是把<code>_</code>当作一个构造函数。即<code>new _(obj)</code>这样的用法。</p>\n<p>但是由于js没用真正的构造函数，因此还可以这样使用：<code>_(obj)</code>。为了避免这种情况，因此有了第二行代码：<code>if (!(this instanceof _)) return new _(obj);</code>。因为直接调用函数的话，<code>this</code>是指向全局的。</p>\n<h3 id=\"兼容Node-js环境\"><a href=\"#兼容Node-js环境\" class=\"headerlink\" title=\"兼容Node.js环境\"></a>兼容Node.js环境</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Export the Underscore object for **Node.js**, with</span></span><br><span class=\"line\"><span class=\"comment\">// backwards-compatibility for their old module API. If we&#x27;re in</span></span><br><span class=\"line\"><span class=\"comment\">// the browser, add `_` as a global object.</span></span><br><span class=\"line\"><span class=\"comment\">// (`nodeType` is checked to ensure that `module`</span></span><br><span class=\"line\"><span class=\"comment\">// and `exports` are not HTML elements.)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">exports</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">exports</span>.nodeType) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">module</span>.nodeType &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">exports</span> = <span class=\"built_in\">module</span>.exports = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>._ = _;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  root._ = _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>Node.js</code>的存在，因此在<code>Node.js</code>环境就将<code>_</code>赋值给<code>exports</code></p>\n<p>另外如注释所说，之所以要检测<code>nodeType</code>，是为了确保<code>exports</code>和<code>module</code>不是<code>HTML</code>元素</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这篇文章就是我阅读<code>udersocre.js</code>的第一篇源码分析文章，也是这个系列的第一篇。</p>\n<p>写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。</p>\n<p>另外提醒，此文对应的<code>underscore.js</code>版本是<code>v1.8.3</code></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>下面将以源码+解析的形式，叙述我对<code>underscore.js</code>的理解，能力有限，如有错误请指正。</p>\n<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h3><p>源码的最外面是一个立即执行函数(<code>IIFE</code>)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他内容</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>以前刚接触前端开发的时候，不懂<code>Node.js</code>，认为全局变量就是<code>window</code>，因此看到下面的代码会很困惑：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Establish the root object, `window` (`self`) in the browser, `global`</span></span><br><span class=\"line\"><span class=\"comment\">// on the server, or `this` in some virtual machines. We use `self`</span></span><br><span class=\"line\"><span class=\"comment\">// instead of `window` for `WebWorker` support.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = <span class=\"keyword\">typeof</span> self == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class=\"line\">           <span class=\"keyword\">typeof</span> <span class=\"built_in\">global</span> == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"built_in\">global</span>.global === <span class=\"built_in\">global</span> &amp;&amp; <span class=\"built_in\">global</span> ||</span><br><span class=\"line\">           <span class=\"built_in\">this</span> ||</span><br><span class=\"line\">           &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很geek的做法，运用了逻辑运算中的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators\"><code>短路运算</code></a>，在<code>||</code>操作的时候，如果前面为<code>true</code>的话，就不会计算后面的了。</p>\n<p>印象当中，以前的js库都是用<code>window</code>的，现在改用<code>self</code>，是因为要兼容<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker\">webWorker</a>的缘故。因此（如注释所言）</p>\n<ul>\n<li>在浏览器或者<code>webWorker</code>的话，<code>root = self</code></li>\n<li>在服务器环境的话，<code>root = global</code></li>\n<li>在其他的虚拟机的话，则指向<code>this</code>即<code>root = this</code></li>\n<li>其他环境就设置为空对象<code>&#123;&#125;</code></li>\n</ul>\n<h3 id=\"变量冲突\"><a href=\"#变量冲突\" class=\"headerlink\" title=\"变量冲突\"></a>变量冲突</h3><p>我们假设一个情况，如果<code>_</code>这个变量被别人使用了。如果我们直接给<code>_</code>赋值，不就丢失了前面的对于<code>_</code>的定义。</p>\n<p>因此<code>undersocre.js</code>就先保存起来了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> previousUnderscore = root._;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，就不会丢失了前面对<code>_</code>的定义，如果要使用的话，就可以使用<code>underscore.js</code>提供的<code>noConflict</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  root._ = previousUnderscore;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存引用\"><a href=\"#缓存引用\" class=\"headerlink\" title=\"缓存引用\"></a>缓存引用</h3><p>这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Save bytes in the minified (but not gzipped) version:</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ArrayProto = <span class=\"built_in\">Array</span>.prototype, ObjProto = <span class=\"built_in\">Object</span>.prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> SymbolProto = <span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> ? <span class=\"built_in\">Symbol</span>.prototype : <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create quick reference variables for speed access to core prototypes.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> push = ArrayProto.push,</span><br><span class=\"line\">      slice = ArrayProto.slice,</span><br><span class=\"line\">      toString = ObjProto.toString,</span><br><span class=\"line\">      hasOwnProperty = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All **ECMAScript 5** native function implementations that we hope to use</span></span><br><span class=\"line\">  <span class=\"comment\">// are declared here.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> nativeIsArray = <span class=\"built_in\">Array</span>.isArray,</span><br><span class=\"line\">      nativeKeys = <span class=\"built_in\">Object</span>.keys,</span><br><span class=\"line\">      nativeCreate = <span class=\"built_in\">Object</span>.create;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h3><p>众所周知的是，js是使用原型链来实现继承的。</p>\n<p>其实这个实现方法就是ES5的<code>Object.create</code>的Polyfill，这么做是为了向后兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Ctor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An internal function for creating a new object that inherits from another.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baseCreate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prototype</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_.isObject(prototype)) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nativeCreate) <span class=\"keyword\">return</span> nativeCreate(prototype);</span><br><span class=\"line\">  Ctor.prototype = prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> Ctor;</span><br><span class=\"line\">  Ctor.prototype = <span class=\"literal\">null</span>; <span class=\"comment\">// 恢复CTor的原型，以备后续使用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a safe reference to the Underscore object for use below.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> _) <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> _)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _(obj);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一开始我对这个部分有些困惑的，因为我简单地认为<code>_</code>就应该是一个空对象<code>&#123;&#125;</code>。</p>\n<p>其实，<code>underscore.js</code>是支持面向对象的方式使用的，也就是把<code>_</code>当作一个构造函数。即<code>new _(obj)</code>这样的用法。</p>\n<p>但是由于js没用真正的构造函数，因此还可以这样使用：<code>_(obj)</code>。为了避免这种情况，因此有了第二行代码：<code>if (!(this instanceof _)) return new _(obj);</code>。因为直接调用函数的话，<code>this</code>是指向全局的。</p>\n<h3 id=\"兼容Node-js环境\"><a href=\"#兼容Node-js环境\" class=\"headerlink\" title=\"兼容Node.js环境\"></a>兼容Node.js环境</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Export the Underscore object for **Node.js**, with</span></span><br><span class=\"line\"><span class=\"comment\">// backwards-compatibility for their old module API. If we&#x27;re in</span></span><br><span class=\"line\"><span class=\"comment\">// the browser, add `_` as a global object.</span></span><br><span class=\"line\"><span class=\"comment\">// (`nodeType` is checked to ensure that `module`</span></span><br><span class=\"line\"><span class=\"comment\">// and `exports` are not HTML elements.)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">exports</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">exports</span>.nodeType) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">module</span>.nodeType &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">exports</span> = <span class=\"built_in\">module</span>.exports = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>._ = _;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  root._ = _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>Node.js</code>的存在，因此在<code>Node.js</code>环境就将<code>_</code>赋值给<code>exports</code></p>\n<p>另外如注释所说，之所以要检测<code>nodeType</code>，是为了确保<code>exports</code>和<code>module</code>不是<code>HTML</code>元素</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这篇文章就是我阅读<code>udersocre.js</code>的第一篇源码分析文章，也是这个系列的第一篇。</p>\n<p>写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。</p>\n"},{"title":"理解underscore.js系列——②杂项","date":"2017-09-11T14:21:25.000Z","desc":"理解underscore.js v1.8.3 源码解析","_content":"\n这一篇文章，就写一些零散的（我所理解的）知识点，感觉`underscore.js`许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。\n\n<!-- more -->\n\n## typeof \n\n在`underscore.js`里，`typeof`后面都是跟着`==`而不是我们常用的`===`\n\n看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：\n\n> typeof typeof x，不管x是什么都是返回string的话，那么`==`就已经足够，并且与`===`相比还节省了一个字节。\n\n## void 0与undefined\n\n首先，`void`在C里是和常见的，但在js里就很少看到了。`void`在js里是一个操作符，它的作用在MDN里是这样描述的：\n\n> The `void` operator evaluates the given expression and then returns `undefined`.\n\n简而言之，`void`后面无论跟着什么表达式，都返回`undefined`。那使用`void 0`就是因为这样比较简洁。即\n\n```js\nvoid 0 === undefined\n```\n\n那么，为什么不直接用`undefined`而多此一举呢。\n\n那是因为\n\n- `undefined`有可能被重写(`undefined`不是保留字)\n\n```js\n// 在IE8及以下\nvar undefined = 10\nconsole.log(undefined) // 10\n\n// 主流浏览器\nfunction() {\n    var undefined = 10\n    console.log(undefined) // 10\n}\n```\n- `void 0`的长度为6个字符，而`undefined`则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。\n- 在iOS某版本下，`void 0`的速度比`undefind`快（这个是网上看到的，未验证）\n\n## val == null\n\n在`underscore.js`里，经常会看到`val == null`这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。\n\n在开发时，我要判断一个变量是否有传入，是这么做的：\n\n```js\nif (typeof val === 'undefined') {\n    // others\n}\n```\n\n这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：\n\n```js\nfunction someTest(val, otherVal) {\n    \n}\n\nsomeTest(null, 1)\n```\n\n此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：\n\n```js\nif (typeof val === 'undefined' || val === null) {\n    // others\n}\n```\n\n其实，此时完全可以用：`val == null`代替（**此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句**）。\n\n其中涉及的`==`（半等）知识，可以参考[Standard ECMA-262](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)","source":"_posts/underscore-mix.md","raw":"---\ntitle: 理解underscore.js系列——②杂项\ndate: 2017-09-11 22:21:25\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\n---\n\n这一篇文章，就写一些零散的（我所理解的）知识点，感觉`underscore.js`许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。\n\n<!-- more -->\n\n## typeof \n\n在`underscore.js`里，`typeof`后面都是跟着`==`而不是我们常用的`===`\n\n看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：\n\n> typeof typeof x，不管x是什么都是返回string的话，那么`==`就已经足够，并且与`===`相比还节省了一个字节。\n\n## void 0与undefined\n\n首先，`void`在C里是和常见的，但在js里就很少看到了。`void`在js里是一个操作符，它的作用在MDN里是这样描述的：\n\n> The `void` operator evaluates the given expression and then returns `undefined`.\n\n简而言之，`void`后面无论跟着什么表达式，都返回`undefined`。那使用`void 0`就是因为这样比较简洁。即\n\n```js\nvoid 0 === undefined\n```\n\n那么，为什么不直接用`undefined`而多此一举呢。\n\n那是因为\n\n- `undefined`有可能被重写(`undefined`不是保留字)\n\n```js\n// 在IE8及以下\nvar undefined = 10\nconsole.log(undefined) // 10\n\n// 主流浏览器\nfunction() {\n    var undefined = 10\n    console.log(undefined) // 10\n}\n```\n- `void 0`的长度为6个字符，而`undefined`则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。\n- 在iOS某版本下，`void 0`的速度比`undefind`快（这个是网上看到的，未验证）\n\n## val == null\n\n在`underscore.js`里，经常会看到`val == null`这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。\n\n在开发时，我要判断一个变量是否有传入，是这么做的：\n\n```js\nif (typeof val === 'undefined') {\n    // others\n}\n```\n\n这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：\n\n```js\nfunction someTest(val, otherVal) {\n    \n}\n\nsomeTest(null, 1)\n```\n\n此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：\n\n```js\nif (typeof val === 'undefined' || val === null) {\n    // others\n}\n```\n\n其实，此时完全可以用：`val == null`代替（**此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句**）。\n\n其中涉及的`==`（半等）知识，可以参考[Standard ECMA-262](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)","slug":"underscore-mix","published":1,"updated":"2020-05-23T06:09:39.000Z","_id":"ckxvfmfbv000fbrqq45hw9rv6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这一篇文章，就写一些零散的（我所理解的）知识点，感觉<code>underscore.js</code>许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><p>在<code>underscore.js</code>里，<code>typeof</code>后面都是跟着<code>==</code>而不是我们常用的<code>===</code></p>\n<p>看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：</p>\n<blockquote>\n<p>typeof typeof x，不管x是什么都是返回string的话，那么<code>==</code>就已经足够，并且与<code>===</code>相比还节省了一个字节。</p>\n</blockquote>\n<h2 id=\"void-0与undefined\"><a href=\"#void-0与undefined\" class=\"headerlink\" title=\"void 0与undefined\"></a>void 0与undefined</h2><p>首先，<code>void</code>在C里是和常见的，但在js里就很少看到了。<code>void</code>在js里是一个操作符，它的作用在MDN里是这样描述的：</p>\n<blockquote>\n<p>The <code>void</code> operator evaluates the given expression and then returns <code>undefined</code>.</p>\n</blockquote>\n<p>简而言之，<code>void</code>后面无论跟着什么表达式，都返回<code>undefined</code>。那使用<code>void 0</code>就是因为这样比较简洁。即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"number\">0</span> === <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，为什么不直接用<code>undefined</code>而多此一举呢。</p>\n<p>那是因为</p>\n<ul>\n<li><code>undefined</code>有可能被重写(<code>undefined</code>不是保留字)</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在IE8及以下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主流浏览器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>void 0</code>的长度为6个字符，而<code>undefined</code>则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。</li>\n<li>在iOS某版本下，<code>void 0</code>的速度比<code>undefind</code>快（这个是网上看到的，未验证）</li>\n</ul>\n<h2 id=\"val-null\"><a href=\"#val-null\" class=\"headerlink\" title=\"val == null\"></a>val == null</h2><p>在<code>underscore.js</code>里，经常会看到<code>val == null</code>这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。</p>\n<p>在开发时，我要判断一个变量是否有传入，是这么做的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someTest</span>(<span class=\"params\">val, otherVal</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">someTest(<span class=\"literal\">null</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span> || val === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，此时完全可以用：<code>val == null</code>代替（<strong>此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句</strong>）。</p>\n<p>其中涉及的<code>==</code>（半等）知识，可以参考<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\">Standard ECMA-262</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>这一篇文章，就写一些零散的（我所理解的）知识点，感觉<code>underscore.js</code>许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。</p>","more":"<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><p>在<code>underscore.js</code>里，<code>typeof</code>后面都是跟着<code>==</code>而不是我们常用的<code>===</code></p>\n<p>看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：</p>\n<blockquote>\n<p>typeof typeof x，不管x是什么都是返回string的话，那么<code>==</code>就已经足够，并且与<code>===</code>相比还节省了一个字节。</p>\n</blockquote>\n<h2 id=\"void-0与undefined\"><a href=\"#void-0与undefined\" class=\"headerlink\" title=\"void 0与undefined\"></a>void 0与undefined</h2><p>首先，<code>void</code>在C里是和常见的，但在js里就很少看到了。<code>void</code>在js里是一个操作符，它的作用在MDN里是这样描述的：</p>\n<blockquote>\n<p>The <code>void</code> operator evaluates the given expression and then returns <code>undefined</code>.</p>\n</blockquote>\n<p>简而言之，<code>void</code>后面无论跟着什么表达式，都返回<code>undefined</code>。那使用<code>void 0</code>就是因为这样比较简洁。即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"number\">0</span> === <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，为什么不直接用<code>undefined</code>而多此一举呢。</p>\n<p>那是因为</p>\n<ul>\n<li><code>undefined</code>有可能被重写(<code>undefined</code>不是保留字)</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在IE8及以下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主流浏览器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>void 0</code>的长度为6个字符，而<code>undefined</code>则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。</li>\n<li>在iOS某版本下，<code>void 0</code>的速度比<code>undefind</code>快（这个是网上看到的，未验证）</li>\n</ul>\n<h2 id=\"val-null\"><a href=\"#val-null\" class=\"headerlink\" title=\"val == null\"></a>val == null</h2><p>在<code>underscore.js</code>里，经常会看到<code>val == null</code>这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。</p>\n<p>在开发时，我要判断一个变量是否有传入，是这么做的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someTest</span>(<span class=\"params\">val, otherVal</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">someTest(<span class=\"literal\">null</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span> || val === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，此时完全可以用：<code>val == null</code>代替（<strong>此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句</strong>）。</p>\n<p>其中涉及的<code>==</code>（半等）知识，可以参考<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\">Standard ECMA-262</a></p>"},{"title":"理解underscore.js系列——④精选函数","date":"2017-09-23T10:43:11.000Z","desc":"理解underscore.js v1.8.3 源码解析","_content":"\n这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过`underscore`的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。\n\n\n### _.sample\n\n随意取出数组中的N个元素。\n\n按我的思路，就是使用`_.random`得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。\n\n`underscore`则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。\n\n```js\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n```\n\n### _.throttle\n\n节流函数，频繁触发的函数可用`throttle`来实现一段时间(周期取决于`wait`)内只执行一次。\n\n常见的场景是：页面滚动时`scroll`、页面大小改变时`resize`\n\n可以看到，这个`throttle`函数是比较健壮的。\n\n有`leading`、`trailing`可选，意思为开始和结束这个临界点是否触发。\n\n```js\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n```\n\n实现`options.leading`（即开始时是否执行）相关：\n - 设置`var previous = 0;`\n - 默认不设置`options.leading`即默认开始时执行，故此时`if (!previous && options.leading === false) previous = now;`不会执行。\n - 此时，`previous = 0`。因此，`remaining = wait - (now - previous);`肯定小于0，故开始时必会执行。\n \n\n实现`options.trailing`（即最后是否执行一次）相关：\n - 考虑一个情况，只触发一次时，那么最终要在`wait`时间之后是否执行呢？\n - 此时`underscore`就是使用一个定时器来实现。\n\n### _.debounce\n\n防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于`wait`)才执行一次。\n\n常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。\n\n```js\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArgs(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n```\n\n可以看到，该版本的`debounce`函数增加了`immediate`选项：就是刚开始的时候执行一次，n秒之后再执行一次。\n\n在看`underscore`官网上，介绍说这个在防止意外的双击`submit`按钮时很有用。\n\n这我有一点困惑，那不就提交了两次表单吗？\n\n后来我发现，`later`函数里，执行`func`有一个前置条件:`if (args)`，而在`immediate = true`的情况下，`later`是这么调用的：`setTimeout(later, wait)`，这时没有传入任何参数，故`args = undefind`即`func`不会执行。\n\n因此，`immediate = true`时，就只提交了一次表单，没任何问题。\n\n### _.compose\n\n组成函数，类似`jQuery`的链式调用：将前一个函数的执行结果传入后一个函数。\n\n```js\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n```\n\n这里我觉得`var i = start`似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。\n\n### _.after\n\n执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。\n\n```js\n// Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n```\n\n在`javaScript`开发中，经常遇到异步调用的问题。\n\n拿开发小程序为例，上传图片的功能官方只提供`单张上传API`，当我们要批量上次的时候，执行循环调用`单张上传API`。此时要全部上传完执行回调就可以使用这个方法了。\n\n现在想想，我之前的做法是`setTimeout(uploadSuccess, 100)`，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。\n\n","source":"_posts/underscore-featured-function.md","raw":"---\ntitle: 理解underscore.js系列——④精选函数\ndate: 2017-09-23 18:43:11\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\n---\n\n这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过`underscore`的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。\n\n\n### _.sample\n\n随意取出数组中的N个元素。\n\n按我的思路，就是使用`_.random`得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。\n\n`underscore`则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。\n\n```js\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n```\n\n### _.throttle\n\n节流函数，频繁触发的函数可用`throttle`来实现一段时间(周期取决于`wait`)内只执行一次。\n\n常见的场景是：页面滚动时`scroll`、页面大小改变时`resize`\n\n可以看到，这个`throttle`函数是比较健壮的。\n\n有`leading`、`trailing`可选，意思为开始和结束这个临界点是否触发。\n\n```js\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n```\n\n实现`options.leading`（即开始时是否执行）相关：\n - 设置`var previous = 0;`\n - 默认不设置`options.leading`即默认开始时执行，故此时`if (!previous && options.leading === false) previous = now;`不会执行。\n - 此时，`previous = 0`。因此，`remaining = wait - (now - previous);`肯定小于0，故开始时必会执行。\n \n\n实现`options.trailing`（即最后是否执行一次）相关：\n - 考虑一个情况，只触发一次时，那么最终要在`wait`时间之后是否执行呢？\n - 此时`underscore`就是使用一个定时器来实现。\n\n### _.debounce\n\n防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于`wait`)才执行一次。\n\n常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。\n\n```js\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArgs(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n```\n\n可以看到，该版本的`debounce`函数增加了`immediate`选项：就是刚开始的时候执行一次，n秒之后再执行一次。\n\n在看`underscore`官网上，介绍说这个在防止意外的双击`submit`按钮时很有用。\n\n这我有一点困惑，那不就提交了两次表单吗？\n\n后来我发现，`later`函数里，执行`func`有一个前置条件:`if (args)`，而在`immediate = true`的情况下，`later`是这么调用的：`setTimeout(later, wait)`，这时没有传入任何参数，故`args = undefind`即`func`不会执行。\n\n因此，`immediate = true`时，就只提交了一次表单，没任何问题。\n\n### _.compose\n\n组成函数，类似`jQuery`的链式调用：将前一个函数的执行结果传入后一个函数。\n\n```js\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n```\n\n这里我觉得`var i = start`似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。\n\n### _.after\n\n执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。\n\n```js\n// Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n```\n\n在`javaScript`开发中，经常遇到异步调用的问题。\n\n拿开发小程序为例，上传图片的功能官方只提供`单张上传API`，当我们要批量上次的时候，执行循环调用`单张上传API`。此时要全部上传完执行回调就可以使用这个方法了。\n\n现在想想，我之前的做法是`setTimeout(uploadSuccess, 100)`，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。\n\n","slug":"underscore-featured-function","published":1,"updated":"2020-05-23T06:09:34.000Z","_id":"ckxvfmfbz000gbrqq00054wui","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过<code>underscore</code>的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。</p>\n<h3 id=\"sample\"><a href=\"#sample\" class=\"headerlink\" title=\"_.sample\"></a>_.sample</h3><p>随意取出数组中的N个元素。</p>\n<p>按我的思路，就是使用<code>_.random</code>得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。</p>\n<p><code>underscore</code>则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sample **n** random values from a collection using the modern version of the</span></span><br><span class=\"line\"><span class=\"comment\">// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).</span></span><br><span class=\"line\"><span class=\"comment\">// If **n** is not specified, returns a single random element.</span></span><br><span class=\"line\"><span class=\"comment\">// The internal `guard` argument allows it to work with `map`.</span></span><br><span class=\"line\">_.sample = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, n, guard</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"literal\">null</span> || guard) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isArrayLike(obj)) obj = _.values(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[_.random(obj.length - <span class=\"number\">1</span>)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = getLength(sample);</span><br><span class=\"line\">  n = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">Math</span>.min(n, length), <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; n; index++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rand = _.random(index, last);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = sample[index];</span><br><span class=\"line\">    sample[index] = sample[rand];</span><br><span class=\"line\">    sample[rand] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sample.slice(<span class=\"number\">0</span>, n);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"_.throttle\"></a>_.throttle</h3><p>节流函数，频繁触发的函数可用<code>throttle</code>来实现一段时间(周期取决于<code>wait</code>)内只执行一次。</p>\n<p>常见的场景是：页面滚动时<code>scroll</code>、页面大小改变时<code>resize</code></p>\n<p>可以看到，这个<code>throttle</code>函数是比较健壮的。</p>\n<p>有<code>leading</code>、<code>trailing</code>可选，意思为开始和结束这个临界点是否触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class=\"line\"><span class=\"comment\">// during a given window of time. Normally, the throttled function will run</span></span><br><span class=\"line\"><span class=\"comment\">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class=\"line\"><span class=\"comment\">// but if you&#x27;d like to disable the execution on the leading edge, pass</span></span><br><span class=\"line\"><span class=\"comment\">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class=\"line\">_.throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, context, args, result;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.now();</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = _.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  throttled.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout = context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现<code>options.leading</code>（即开始时是否执行）相关：</p>\n<ul>\n<li>设置<code>var previous = 0;</code></li>\n<li>默认不设置<code>options.leading</code>即默认开始时执行，故此时<code>if (!previous &amp;&amp; options.leading === false) previous = now;</code>不会执行。</li>\n<li>此时，<code>previous = 0</code>。因此，<code>remaining = wait - (now - previous);</code>肯定小于0，故开始时必会执行。</li>\n</ul>\n<p>实现<code>options.trailing</code>（即最后是否执行一次）相关：</p>\n<ul>\n<li>考虑一个情况，只触发一次时，那么最终要在<code>wait</code>时间之后是否执行呢？</li>\n<li>此时<code>underscore</code>就是使用一个定时器来实现。</li>\n</ul>\n<h3 id=\"debounce\"><a href=\"#debounce\" class=\"headerlink\" title=\"_.debounce\"></a>_.debounce</h3><p>防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于<code>wait</code>)才执行一次。</p>\n<p>常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class=\"line\"><span class=\"comment\">// be triggered. The function will be called after it stops being called for</span></span><br><span class=\"line\"><span class=\"comment\">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class=\"line\"><span class=\"comment\">// leading edge, instead of the trailing.</span></span><br><span class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, args</span>) </span>&#123;</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args) result = func.apply(context, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounced = restArgs(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout) <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = !timeout;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) result = func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timeout = _.delay(later, wait, <span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  debounced.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounced;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，该版本的<code>debounce</code>函数增加了<code>immediate</code>选项：就是刚开始的时候执行一次，n秒之后再执行一次。</p>\n<p>在看<code>underscore</code>官网上，介绍说这个在防止意外的双击<code>submit</code>按钮时很有用。</p>\n<p>这我有一点困惑，那不就提交了两次表单吗？</p>\n<p>后来我发现，<code>later</code>函数里，执行<code>func</code>有一个前置条件:<code>if (args)</code>，而在<code>immediate = true</code>的情况下，<code>later</code>是这么调用的：<code>setTimeout(later, wait)</code>，这时没有传入任何参数，故<code>args = undefind</code>即<code>func</code>不会执行。</p>\n<p>因此，<code>immediate = true</code>时，就只提交了一次表单，没任何问题。</p>\n<h3 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"_.compose\"></a>_.compose</h3><p>组成函数，类似<code>jQuery</code>的链式调用：将前一个函数的执行结果传入后一个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that is the composition of a list of functions, each</span></span><br><span class=\"line\"><span class=\"comment\">// consuming the return value of the function that follows.</span></span><br><span class=\"line\">_.compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> start = args.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = start;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = args[start].apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) result = args[i].call(<span class=\"built_in\">this</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里我觉得<code>var i = start</code>似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。</p>\n<h3 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"_.after\"></a>_.after</h3><p>执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that will only be executed on and after the Nth call.</span></span><br><span class=\"line\">  _.after = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">times, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (--times &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>javaScript</code>开发中，经常遇到异步调用的问题。</p>\n<p>拿开发小程序为例，上传图片的功能官方只提供<code>单张上传API</code>，当我们要批量上次的时候，执行循环调用<code>单张上传API</code>。此时要全部上传完执行回调就可以使用这个方法了。</p>\n<p>现在想想，我之前的做法是<code>setTimeout(uploadSuccess, 100)</code>，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过<code>underscore</code>的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。</p>\n<h3 id=\"sample\"><a href=\"#sample\" class=\"headerlink\" title=\"_.sample\"></a>_.sample</h3><p>随意取出数组中的N个元素。</p>\n<p>按我的思路，就是使用<code>_.random</code>得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。</p>\n<p><code>underscore</code>则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sample **n** random values from a collection using the modern version of the</span></span><br><span class=\"line\"><span class=\"comment\">// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).</span></span><br><span class=\"line\"><span class=\"comment\">// If **n** is not specified, returns a single random element.</span></span><br><span class=\"line\"><span class=\"comment\">// The internal `guard` argument allows it to work with `map`.</span></span><br><span class=\"line\">_.sample = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, n, guard</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"literal\">null</span> || guard) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isArrayLike(obj)) obj = _.values(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[_.random(obj.length - <span class=\"number\">1</span>)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = getLength(sample);</span><br><span class=\"line\">  n = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">Math</span>.min(n, length), <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; n; index++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rand = _.random(index, last);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = sample[index];</span><br><span class=\"line\">    sample[index] = sample[rand];</span><br><span class=\"line\">    sample[rand] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sample.slice(<span class=\"number\">0</span>, n);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"_.throttle\"></a>_.throttle</h3><p>节流函数，频繁触发的函数可用<code>throttle</code>来实现一段时间(周期取决于<code>wait</code>)内只执行一次。</p>\n<p>常见的场景是：页面滚动时<code>scroll</code>、页面大小改变时<code>resize</code></p>\n<p>可以看到，这个<code>throttle</code>函数是比较健壮的。</p>\n<p>有<code>leading</code>、<code>trailing</code>可选，意思为开始和结束这个临界点是否触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class=\"line\"><span class=\"comment\">// during a given window of time. Normally, the throttled function will run</span></span><br><span class=\"line\"><span class=\"comment\">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class=\"line\"><span class=\"comment\">// but if you&#x27;d like to disable the execution on the leading edge, pass</span></span><br><span class=\"line\"><span class=\"comment\">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class=\"line\">_.throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, context, args, result;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.now();</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = _.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  throttled.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout = context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现<code>options.leading</code>（即开始时是否执行）相关：</p>\n<ul>\n<li>设置<code>var previous = 0;</code></li>\n<li>默认不设置<code>options.leading</code>即默认开始时执行，故此时<code>if (!previous &amp;&amp; options.leading === false) previous = now;</code>不会执行。</li>\n<li>此时，<code>previous = 0</code>。因此，<code>remaining = wait - (now - previous);</code>肯定小于0，故开始时必会执行。</li>\n</ul>\n<p>实现<code>options.trailing</code>（即最后是否执行一次）相关：</p>\n<ul>\n<li>考虑一个情况，只触发一次时，那么最终要在<code>wait</code>时间之后是否执行呢？</li>\n<li>此时<code>underscore</code>就是使用一个定时器来实现。</li>\n</ul>\n<h3 id=\"debounce\"><a href=\"#debounce\" class=\"headerlink\" title=\"_.debounce\"></a>_.debounce</h3><p>防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于<code>wait</code>)才执行一次。</p>\n<p>常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class=\"line\"><span class=\"comment\">// be triggered. The function will be called after it stops being called for</span></span><br><span class=\"line\"><span class=\"comment\">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class=\"line\"><span class=\"comment\">// leading edge, instead of the trailing.</span></span><br><span class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, args</span>) </span>&#123;</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args) result = func.apply(context, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounced = restArgs(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout) <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = !timeout;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) result = func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timeout = _.delay(later, wait, <span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  debounced.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounced;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，该版本的<code>debounce</code>函数增加了<code>immediate</code>选项：就是刚开始的时候执行一次，n秒之后再执行一次。</p>\n<p>在看<code>underscore</code>官网上，介绍说这个在防止意外的双击<code>submit</code>按钮时很有用。</p>\n<p>这我有一点困惑，那不就提交了两次表单吗？</p>\n<p>后来我发现，<code>later</code>函数里，执行<code>func</code>有一个前置条件:<code>if (args)</code>，而在<code>immediate = true</code>的情况下，<code>later</code>是这么调用的：<code>setTimeout(later, wait)</code>，这时没有传入任何参数，故<code>args = undefind</code>即<code>func</code>不会执行。</p>\n<p>因此，<code>immediate = true</code>时，就只提交了一次表单，没任何问题。</p>\n<h3 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"_.compose\"></a>_.compose</h3><p>组成函数，类似<code>jQuery</code>的链式调用：将前一个函数的执行结果传入后一个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that is the composition of a list of functions, each</span></span><br><span class=\"line\"><span class=\"comment\">// consuming the return value of the function that follows.</span></span><br><span class=\"line\">_.compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> start = args.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = start;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = args[start].apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) result = args[i].call(<span class=\"built_in\">this</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里我觉得<code>var i = start</code>似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。</p>\n<h3 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"_.after\"></a>_.after</h3><p>执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that will only be executed on and after the Nth call.</span></span><br><span class=\"line\">  _.after = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">times, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (--times &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>javaScript</code>开发中，经常遇到异步调用的问题。</p>\n<p>拿开发小程序为例，上传图片的功能官方只提供<code>单张上传API</code>，当我们要批量上次的时候，执行循环调用<code>单张上传API</code>。此时要全部上传完执行回调就可以使用这个方法了。</p>\n<p>现在想想，我之前的做法是<code>setTimeout(uploadSuccess, 100)</code>，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。</p>\n"},{"title":"理解underscore.js系列——③基础函数","date":"2017-09-18T06:52:42.000Z","desc":"理解underscore.js v1.8.3 源码解析","_content":"\n从`_.each`函数入手，理解`underscore.js`的基础函数，`_.each`的调用盏可以参考如下思维导图：\n\n![image](http://7xnh42.com1.z0.glb.clouddn.com/each.jpg)\n\n`underscore.js`的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，`_.each`也不例外。因此先来介绍内置的`cb`函数还有`optimizeCb`函数\n\n### cb\n\n`cb`顾名思义，就是回调函数(CallBack的简称)的意思。\n\n```js\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 1\n    if (value == null) return _.identity; // 2\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 3\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value); // 4\n    return _.property(value);\n  };\n```\n\n1. 对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的`_.iteratee`\n2. 如果没有传入`value`，就使用`_.identity = function(value) { return value; }`\n3. 如果传入了`function`，则使用`optimizeCb`格式化一下\n4. 如果传入了`object`，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致\n5. 否则就将传入的值当成一个属性，返回一个匹配该属性的函数\n\n\n### optimizeCb\n\n格式化传入的回调函数，以统一迭代函数，方便后续使用\n\n```js\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    // 如果没有执行上下文，就直接返回该函数\n    if (context === void 0) return func;\n    switch (argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-parameter case has been omitted only because no current consumers\n      // made use of it.\n      case null:\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n```\n\n### collectNonEnumProps\n\n在IE9以下版本，会有一个bug：如果重写了`原不可枚举的属性`，使用`for...in`是不会返回的。\n\n相关信息可参考：[W3Help SJ5003](http://www.w3help.org/zh-cn/causes/SJ5003)\n\n```js\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    // 获取对象的构造函数，以获取对象的原型\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    // 将构造函数属性放入keys\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      // 如果obj有这个属性\n      // obj[prop] !== proto[prop] 说明重写了该属性\n      // keys不包含该属性\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n```\n\n这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章[待续](/)\n\n### restArgs\n\n`rest`是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：`function(value, ...rest)`\n\n```js\n  // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n  // This accumulates the arguments passed into an array, after a given index.\n  var restArgs = function(func, startIndex) {\n    // func.length可获取函数定义的参数个数\n    // eg: function (a, b) {}  => 2\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      // 将定义的最后一个参数和超过定义的参数都放进rest数组\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      // 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      // 将超出的部分(指rest)放在args数组的最后一位\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n```\n\n这里涉及到两个知识点：\n\n- `function.length`指的是函数定义的参数个数\n- `function.call`和`function.apply`的区别：`call`需逐个传入参数，而`apply`则将参数放进一个数组传入","source":"_posts/underscore-base-function.md","raw":"---\ntitle: 理解underscore.js系列——③基础函数\ndate: 2017-09-18 14:52:42\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\n---\n\n从`_.each`函数入手，理解`underscore.js`的基础函数，`_.each`的调用盏可以参考如下思维导图：\n\n![image](http://7xnh42.com1.z0.glb.clouddn.com/each.jpg)\n\n`underscore.js`的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，`_.each`也不例外。因此先来介绍内置的`cb`函数还有`optimizeCb`函数\n\n### cb\n\n`cb`顾名思义，就是回调函数(CallBack的简称)的意思。\n\n```js\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 1\n    if (value == null) return _.identity; // 2\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 3\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value); // 4\n    return _.property(value);\n  };\n```\n\n1. 对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的`_.iteratee`\n2. 如果没有传入`value`，就使用`_.identity = function(value) { return value; }`\n3. 如果传入了`function`，则使用`optimizeCb`格式化一下\n4. 如果传入了`object`，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致\n5. 否则就将传入的值当成一个属性，返回一个匹配该属性的函数\n\n\n### optimizeCb\n\n格式化传入的回调函数，以统一迭代函数，方便后续使用\n\n```js\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    // 如果没有执行上下文，就直接返回该函数\n    if (context === void 0) return func;\n    switch (argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-parameter case has been omitted only because no current consumers\n      // made use of it.\n      case null:\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n```\n\n### collectNonEnumProps\n\n在IE9以下版本，会有一个bug：如果重写了`原不可枚举的属性`，使用`for...in`是不会返回的。\n\n相关信息可参考：[W3Help SJ5003](http://www.w3help.org/zh-cn/causes/SJ5003)\n\n```js\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    // 获取对象的构造函数，以获取对象的原型\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    // 将构造函数属性放入keys\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      // 如果obj有这个属性\n      // obj[prop] !== proto[prop] 说明重写了该属性\n      // keys不包含该属性\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n```\n\n这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章[待续](/)\n\n### restArgs\n\n`rest`是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：`function(value, ...rest)`\n\n```js\n  // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n  // This accumulates the arguments passed into an array, after a given index.\n  var restArgs = function(func, startIndex) {\n    // func.length可获取函数定义的参数个数\n    // eg: function (a, b) {}  => 2\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      // 将定义的最后一个参数和超过定义的参数都放进rest数组\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      // 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      // 将超出的部分(指rest)放在args数组的最后一位\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n```\n\n这里涉及到两个知识点：\n\n- `function.length`指的是函数定义的参数个数\n- `function.call`和`function.apply`的区别：`call`需逐个传入参数，而`apply`则将参数放进一个数组传入","slug":"underscore-base-function","published":1,"updated":"2020-05-23T06:09:22.000Z","_id":"ckxvfmfc6000ibrqqgrii3169","comments":1,"layout":"post","photos":[],"link":"","content":"<p>从<code>_.each</code>函数入手，理解<code>underscore.js</code>的基础函数，<code>_.each</code>的调用盏可以参考如下思维导图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/each.jpg\" alt=\"image\"></p>\n<p><code>underscore.js</code>的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，<code>_.each</code>也不例外。因此先来介绍内置的<code>cb</code>函数还有<code>optimizeCb</code>函数</p>\n<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p><code>cb</code>顾名思义，就是回调函数(CallBack的简称)的意思。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// An internal function to generate callbacks that can be applied to each</span></span><br><span class=\"line\"><span class=\"comment\">// element in a collection, returning the desired result — either `identity`,</span></span><br><span class=\"line\"><span class=\"comment\">// an arbitrary callback, a property matcher, or a property accessor.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.iteratee !== builtinIteratee) <span class=\"keyword\">return</span> _.iteratee(value, context); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> _.identity; <span class=\"comment\">// 2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(value)) <span class=\"keyword\">return</span> optimizeCb(value, context, argCount); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isObject(value) &amp;&amp; !_.isArray(value)) <span class=\"keyword\">return</span> _.matcher(value); <span class=\"comment\">// 4</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的<code>_.iteratee</code></li>\n<li>如果没有传入<code>value</code>，就使用<code>_.identity = function(value) &#123; return value; &#125;</code></li>\n<li>如果传入了<code>function</code>，则使用<code>optimizeCb</code>格式化一下</li>\n<li>如果传入了<code>object</code>，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致</li>\n<li>否则就将传入的值当成一个属性，返回一个匹配该属性的函数</li>\n</ol>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><p>格式化传入的回调函数，以统一迭代函数，方便后续使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Internal function that returns an efficient (for current engines) version</span></span><br><span class=\"line\"><span class=\"comment\">// of the passed-in callback, to be repeatedly applied in other Underscore</span></span><br><span class=\"line\"><span class=\"comment\">// functions.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> optimizeCb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有执行上下文，就直接返回该函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (context === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) <span class=\"keyword\">return</span> func;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (argCount) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class=\"line\">    <span class=\"comment\">// made use of it.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"literal\">null</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">accumulator, value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(context, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"collectNonEnumProps\"><a href=\"#collectNonEnumProps\" class=\"headerlink\" title=\"collectNonEnumProps\"></a>collectNonEnumProps</h3><p>在IE9以下版本，会有一个bug：如果重写了<code>原不可枚举的属性</code>，使用<code>for...in</code>是不会返回的。</p>\n<p>相关信息可参考：<a href=\"http://www.w3help.org/zh-cn/causes/SJ5003\">W3Help SJ5003</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Keys in IE &lt; 9 that won&#x27;t be iterated by `for key in ...` and thus missed.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hasEnumBug = !&#123;<span class=\"attr\">toString</span>: <span class=\"literal\">null</span>&#125;.propertyIsEnumerable(<span class=\"string\">&#x27;toString&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nonEnumerableProps = [<span class=\"string\">&#x27;valueOf&#x27;</span>, <span class=\"string\">&#x27;isPrototypeOf&#x27;</span>, <span class=\"string\">&#x27;toString&#x27;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;propertyIsEnumerable&#x27;</span>, <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>, <span class=\"string\">&#x27;toLocaleString&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> collectNonEnumProps = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, keys</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nonEnumIdx = nonEnumerableProps.length;</span><br><span class=\"line\">  <span class=\"comment\">// 获取对象的构造函数，以获取对象的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"title\">constructor</span> = <span class=\"title\">obj</span>.<span class=\"title\">constructor</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> proto = _.isFunction(<span class=\"title\">constructor</span>) &amp;&amp; <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span> || <span class=\"title\">ObjProto</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Constructor is a special case.</span></span><br><span class=\"line\">  <span class=\"comment\">// 将构造函数属性放入keys</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prop = <span class=\"string\">&#x27;constructor&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nonEnumIdx--) &#123;</span><br><span class=\"line\">    prop = nonEnumerableProps[nonEnumIdx];</span><br><span class=\"line\">    <span class=\"comment\">// 如果obj有这个属性</span></span><br><span class=\"line\">    <span class=\"comment\">// obj[prop] !== proto[prop] 说明重写了该属性</span></span><br><span class=\"line\">    <span class=\"comment\">// keys不包含该属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123;</span><br><span class=\"line\">      keys.push(prop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章<a href=\"/\">待续</a></p>\n<h3 id=\"restArgs\"><a href=\"#restArgs\" class=\"headerlink\" title=\"restArgs\"></a>restArgs</h3><p><code>rest</code>是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：<code>function(value, ...rest)</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to ES6&#x27;s rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)</span></span><br><span class=\"line\"><span class=\"comment\">// This accumulates the arguments passed into an array, after a given index.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restArgs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, startIndex</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// func.length可获取函数定义的参数个数</span></span><br><span class=\"line\">  <span class=\"comment\">// eg: function (a, b) &#123;&#125;  =&gt; 2</span></span><br><span class=\"line\">  startIndex = startIndex == <span class=\"literal\">null</span> ? func.length - <span class=\"number\">1</span> : +startIndex;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> length = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">arguments</span>.length - startIndex, <span class=\"number\">0</span>),</span><br><span class=\"line\">        rest = <span class=\"built_in\">Array</span>(length),</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将定义的最后一个参数和超过定义的参数都放进rest数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; index &lt; length; index++) &#123;</span><br><span class=\"line\">      rest[index] = <span class=\"built_in\">arguments</span>[index + startIndex];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (startIndex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>], rest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将超出的部分(指rest)放在args数组的最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>(startIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class=\"line\">      args[index] = <span class=\"built_in\">arguments</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    args[startIndex] = rest;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里涉及到两个知识点：</p>\n<ul>\n<li><code>function.length</code>指的是函数定义的参数个数</li>\n<li><code>function.call</code>和<code>function.apply</code>的区别：<code>call</code>需逐个传入参数，而<code>apply</code>则将参数放进一个数组传入</li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>从<code>_.each</code>函数入手，理解<code>underscore.js</code>的基础函数，<code>_.each</code>的调用盏可以参考如下思维导图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/each.jpg\" alt=\"image\"></p>\n<p><code>underscore.js</code>的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，<code>_.each</code>也不例外。因此先来介绍内置的<code>cb</code>函数还有<code>optimizeCb</code>函数</p>\n<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p><code>cb</code>顾名思义，就是回调函数(CallBack的简称)的意思。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// An internal function to generate callbacks that can be applied to each</span></span><br><span class=\"line\"><span class=\"comment\">// element in a collection, returning the desired result — either `identity`,</span></span><br><span class=\"line\"><span class=\"comment\">// an arbitrary callback, a property matcher, or a property accessor.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.iteratee !== builtinIteratee) <span class=\"keyword\">return</span> _.iteratee(value, context); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> _.identity; <span class=\"comment\">// 2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(value)) <span class=\"keyword\">return</span> optimizeCb(value, context, argCount); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isObject(value) &amp;&amp; !_.isArray(value)) <span class=\"keyword\">return</span> _.matcher(value); <span class=\"comment\">// 4</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的<code>_.iteratee</code></li>\n<li>如果没有传入<code>value</code>，就使用<code>_.identity = function(value) &#123; return value; &#125;</code></li>\n<li>如果传入了<code>function</code>，则使用<code>optimizeCb</code>格式化一下</li>\n<li>如果传入了<code>object</code>，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致</li>\n<li>否则就将传入的值当成一个属性，返回一个匹配该属性的函数</li>\n</ol>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><p>格式化传入的回调函数，以统一迭代函数，方便后续使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Internal function that returns an efficient (for current engines) version</span></span><br><span class=\"line\"><span class=\"comment\">// of the passed-in callback, to be repeatedly applied in other Underscore</span></span><br><span class=\"line\"><span class=\"comment\">// functions.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> optimizeCb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有执行上下文，就直接返回该函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (context === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) <span class=\"keyword\">return</span> func;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (argCount) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class=\"line\">    <span class=\"comment\">// made use of it.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"literal\">null</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">accumulator, value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(context, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"collectNonEnumProps\"><a href=\"#collectNonEnumProps\" class=\"headerlink\" title=\"collectNonEnumProps\"></a>collectNonEnumProps</h3><p>在IE9以下版本，会有一个bug：如果重写了<code>原不可枚举的属性</code>，使用<code>for...in</code>是不会返回的。</p>\n<p>相关信息可参考：<a href=\"http://www.w3help.org/zh-cn/causes/SJ5003\">W3Help SJ5003</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Keys in IE &lt; 9 that won&#x27;t be iterated by `for key in ...` and thus missed.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hasEnumBug = !&#123;<span class=\"attr\">toString</span>: <span class=\"literal\">null</span>&#125;.propertyIsEnumerable(<span class=\"string\">&#x27;toString&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nonEnumerableProps = [<span class=\"string\">&#x27;valueOf&#x27;</span>, <span class=\"string\">&#x27;isPrototypeOf&#x27;</span>, <span class=\"string\">&#x27;toString&#x27;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;propertyIsEnumerable&#x27;</span>, <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>, <span class=\"string\">&#x27;toLocaleString&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> collectNonEnumProps = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, keys</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nonEnumIdx = nonEnumerableProps.length;</span><br><span class=\"line\">  <span class=\"comment\">// 获取对象的构造函数，以获取对象的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"title\">constructor</span> = <span class=\"title\">obj</span>.<span class=\"title\">constructor</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> proto = _.isFunction(<span class=\"title\">constructor</span>) &amp;&amp; <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span> || <span class=\"title\">ObjProto</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Constructor is a special case.</span></span><br><span class=\"line\">  <span class=\"comment\">// 将构造函数属性放入keys</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prop = <span class=\"string\">&#x27;constructor&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nonEnumIdx--) &#123;</span><br><span class=\"line\">    prop = nonEnumerableProps[nonEnumIdx];</span><br><span class=\"line\">    <span class=\"comment\">// 如果obj有这个属性</span></span><br><span class=\"line\">    <span class=\"comment\">// obj[prop] !== proto[prop] 说明重写了该属性</span></span><br><span class=\"line\">    <span class=\"comment\">// keys不包含该属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123;</span><br><span class=\"line\">      keys.push(prop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章<a href=\"/\">待续</a></p>\n<h3 id=\"restArgs\"><a href=\"#restArgs\" class=\"headerlink\" title=\"restArgs\"></a>restArgs</h3><p><code>rest</code>是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：<code>function(value, ...rest)</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to ES6&#x27;s rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)</span></span><br><span class=\"line\"><span class=\"comment\">// This accumulates the arguments passed into an array, after a given index.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restArgs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, startIndex</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// func.length可获取函数定义的参数个数</span></span><br><span class=\"line\">  <span class=\"comment\">// eg: function (a, b) &#123;&#125;  =&gt; 2</span></span><br><span class=\"line\">  startIndex = startIndex == <span class=\"literal\">null</span> ? func.length - <span class=\"number\">1</span> : +startIndex;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> length = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">arguments</span>.length - startIndex, <span class=\"number\">0</span>),</span><br><span class=\"line\">        rest = <span class=\"built_in\">Array</span>(length),</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将定义的最后一个参数和超过定义的参数都放进rest数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; index &lt; length; index++) &#123;</span><br><span class=\"line\">      rest[index] = <span class=\"built_in\">arguments</span>[index + startIndex];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (startIndex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>], rest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将超出的部分(指rest)放在args数组的最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>(startIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class=\"line\">      args[index] = <span class=\"built_in\">arguments</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    args[startIndex] = rest;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里涉及到两个知识点：</p>\n<ul>\n<li><code>function.length</code>指的是函数定义的参数个数</li>\n<li><code>function.call</code>和<code>function.apply</code>的区别：<code>call</code>需逐个传入参数，而<code>apply</code>则将参数放进一个数组传入</li>\n</ul>\n"},{"title":"初用Vue.js的一些心得","date":"2017-05-19T12:40:03.000Z","desc":"summary of vuejs","_content":"\n其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。\n\n期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。\n\n## input\n\ntype类型的选择\n\n### 初始版本：\n\n```vue\n<template v-if=\"type === 'number'\">\n    <input type=\"number\" />\n</template>\n<template v-else-if=\"type === 'tel'\">\n    <input type=\"tel\" />\n</template>\n<template v-else>\n    <input type=\"text\" />\n</template>\n```\n\n原因：避免使用非法类型\n\n### 最终版本：\n\n```vue\n<input :type=\"type\"/>\n\n<script type=\"es6\">\nexport default {\n    props: {\n        type: {\n            type: 'string',\n            default: 'text',\n            validator(type){\n                return ['password', 'tel', 'number'].indexOf(type) > -1\n            }\n        }\n    }\n}\n</script>\n```\n\n### 同步校验与异步校验\n\n#### 同步校验：\n\ninput事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。\n\n#### 异步校验：\n\n因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。\n\n```js\n\nexport default {\n    props: {\n        verify: { // 验证规则 {rule: '规则', errMsg: '错误信息提示'}\n            type: Object,\n            'validator'(value) {\n              return value.rule \n                && (value.rule instanceof RegExp || typeof value.rule === 'string')\n            }\n        },\n        asyncVerify: String, // 异步验证规则（URL地址）\n    },\n    methods: {\n        async validate() {\n\n            const {verify, inValue, asyncVerify} = this\n\n            let isValid\n\n            // 存在验证规则\n            if (verify) {\n\n              const {rule, errMsg} = verify\n\n              // 正则的验证规则\n              if (rule instanceof RegExp) {\n                isValid = rule.test(inValue)\n              }\n\n              // 字符串型内置类型验证\n              else if (typeof rule === 'string') {\n                switch (rule) {\n                  case 'tel':\n                    isValid = /^1[34578]\\d{9}$/.test(inValue)\n                    break\n\n                  case 'password':\n                    isValid = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]{6,12}$/.test(inValue)\n                    break\n\n                  case 'telCaptcha':\n                    isValid = /^\\d{6}$/.test(inValue)\n                    break\n\n                  case 'imgCaptcha':\n                    isValid = /^\\S{4}$/.test(inValue)\n                    break\n\n                  default:\n                  // no default\n                }\n              }\n\n              if (!isValid) {\n                this.$emit('show-error', errMsg || '格式错误')\n                return\n              }\n            }\n            \n\n            // 存在异步校验\n            if (asyncVerify) {\n              \n            }\n            \n      }\n    }\n}\n```\n\n## 数据流动问题\n\n### 情况：\n\n一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError\n\n### 问题：\n\n父元素传递'first error'，子元素自产生'second error'，此时父再传'first error'，子元素就会忽略，因为父元素传递的数据还没改变还是'first error'。\n\n### 解决：\n\nA方法：子元素不自己产生childError，统一`$emit`发送给父元素，然后才传递给子元素\n\nB方法：父元素传递的数据，前缀加计数器以区别每次传递的数据\n\n## 错误信息往上传递\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" />\n\nshowError(error) {\n    // error = 谁的错误信息? 用户名 or 密码\n}\n\n```\n\n- A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可\n- B方法：使用curry化函数\n\n### A方法\n\n```js\n// bd-input\nthis.$emit('show-error', JSON.stringify([token, '出错了!']) )\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" token=\"username\"/>\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" token=\"password\"/>\n\nshowError(errObj) {\n    parsedErrObj = JSON.parse(errObj)\n\n    token = parsedErrObj[0] // 错误信息的宿主\n    error = parsedErrObj[1]\n}\n```\n\n### B方法\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"curryShowError('username')\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"curryShowError('password')\" type=\"password\" />\n\ncurryShowError(token) {\n    return function(error){\n\n    }\n}\n```\n\n\n","source":"_posts/summary-of-vuejs.md","raw":"---\ntitle: 初用Vue.js的一些心得\ndate: 2017-5-19 20:40:03\ntags: \n- vue.js\ndesc: summary of vuejs\n---\n\n其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。\n\n期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。\n\n## input\n\ntype类型的选择\n\n### 初始版本：\n\n```vue\n<template v-if=\"type === 'number'\">\n    <input type=\"number\" />\n</template>\n<template v-else-if=\"type === 'tel'\">\n    <input type=\"tel\" />\n</template>\n<template v-else>\n    <input type=\"text\" />\n</template>\n```\n\n原因：避免使用非法类型\n\n### 最终版本：\n\n```vue\n<input :type=\"type\"/>\n\n<script type=\"es6\">\nexport default {\n    props: {\n        type: {\n            type: 'string',\n            default: 'text',\n            validator(type){\n                return ['password', 'tel', 'number'].indexOf(type) > -1\n            }\n        }\n    }\n}\n</script>\n```\n\n### 同步校验与异步校验\n\n#### 同步校验：\n\ninput事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。\n\n#### 异步校验：\n\n因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。\n\n```js\n\nexport default {\n    props: {\n        verify: { // 验证规则 {rule: '规则', errMsg: '错误信息提示'}\n            type: Object,\n            'validator'(value) {\n              return value.rule \n                && (value.rule instanceof RegExp || typeof value.rule === 'string')\n            }\n        },\n        asyncVerify: String, // 异步验证规则（URL地址）\n    },\n    methods: {\n        async validate() {\n\n            const {verify, inValue, asyncVerify} = this\n\n            let isValid\n\n            // 存在验证规则\n            if (verify) {\n\n              const {rule, errMsg} = verify\n\n              // 正则的验证规则\n              if (rule instanceof RegExp) {\n                isValid = rule.test(inValue)\n              }\n\n              // 字符串型内置类型验证\n              else if (typeof rule === 'string') {\n                switch (rule) {\n                  case 'tel':\n                    isValid = /^1[34578]\\d{9}$/.test(inValue)\n                    break\n\n                  case 'password':\n                    isValid = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]{6,12}$/.test(inValue)\n                    break\n\n                  case 'telCaptcha':\n                    isValid = /^\\d{6}$/.test(inValue)\n                    break\n\n                  case 'imgCaptcha':\n                    isValid = /^\\S{4}$/.test(inValue)\n                    break\n\n                  default:\n                  // no default\n                }\n              }\n\n              if (!isValid) {\n                this.$emit('show-error', errMsg || '格式错误')\n                return\n              }\n            }\n            \n\n            // 存在异步校验\n            if (asyncVerify) {\n              \n            }\n            \n      }\n    }\n}\n```\n\n## 数据流动问题\n\n### 情况：\n\n一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError\n\n### 问题：\n\n父元素传递'first error'，子元素自产生'second error'，此时父再传'first error'，子元素就会忽略，因为父元素传递的数据还没改变还是'first error'。\n\n### 解决：\n\nA方法：子元素不自己产生childError，统一`$emit`发送给父元素，然后才传递给子元素\n\nB方法：父元素传递的数据，前缀加计数器以区别每次传递的数据\n\n## 错误信息往上传递\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" />\n\nshowError(error) {\n    // error = 谁的错误信息? 用户名 or 密码\n}\n\n```\n\n- A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可\n- B方法：使用curry化函数\n\n### A方法\n\n```js\n// bd-input\nthis.$emit('show-error', JSON.stringify([token, '出错了!']) )\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" token=\"username\"/>\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" token=\"password\"/>\n\nshowError(errObj) {\n    parsedErrObj = JSON.parse(errObj)\n\n    token = parsedErrObj[0] // 错误信息的宿主\n    error = parsedErrObj[1]\n}\n```\n\n### B方法\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"curryShowError('username')\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"curryShowError('password')\" type=\"password\" />\n\ncurryShowError(token) {\n    return function(error){\n\n    }\n}\n```\n\n\n","slug":"summary-of-vuejs","published":1,"updated":"2020-05-23T06:15:39.000Z","_id":"ckxvfmfc8000kbrqqddkn36p5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。</p>\n<p>期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。</p>\n<h2 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h2><p>type类型的选择</p>\n<h3 id=\"初始版本：\"><a href=\"#初始版本：\" class=\"headerlink\" title=\"初始版本：\"></a>初始版本：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-if=&quot;type === &#x27;number&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;number&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else-if=&quot;type === &#x27;tel&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;tel&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p>原因：避免使用非法类型</p>\n<h3 id=\"最终版本：\"><a href=\"#最终版本：\" class=\"headerlink\" title=\"最终版本：\"></a>最终版本：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input :type=&quot;type&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;es6&quot;&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        type: &#123;</span><br><span class=\"line\">            type: &#x27;string&#x27;,</span><br><span class=\"line\">            default: &#x27;text&#x27;,</span><br><span class=\"line\">            validator(type)&#123;</span><br><span class=\"line\">                return [&#x27;password&#x27;, &#x27;tel&#x27;, &#x27;number&#x27;].indexOf(type) &gt; -1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步校验与异步校验\"><a href=\"#同步校验与异步校验\" class=\"headerlink\" title=\"同步校验与异步校验\"></a>同步校验与异步校验</h3><h4 id=\"同步校验：\"><a href=\"#同步校验：\" class=\"headerlink\" title=\"同步校验：\"></a>同步校验：</h4><p>input事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。</p>\n<h4 id=\"异步校验：\"><a href=\"#异步校验：\" class=\"headerlink\" title=\"异步校验：\"></a>异步校验：</h4><p>因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">verify</span>: &#123; <span class=\"comment\">// 验证规则 &#123;rule: &#x27;规则&#x27;, errMsg: &#x27;错误信息提示&#x27;&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;validator&#x27;</span>(value) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> value.rule </span><br><span class=\"line\">                &amp;&amp; (value.rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span> || <span class=\"keyword\">typeof</span> value.rule === <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">asyncVerify</span>: <span class=\"built_in\">String</span>, <span class=\"comment\">// 异步验证规则（URL地址）</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">validate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123;verify, inValue, asyncVerify&#125; = <span class=\"built_in\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isValid</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在验证规则</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (verify) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">const</span> &#123;rule, errMsg&#125; = verify</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 正则的验证规则</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span>) &#123;</span><br><span class=\"line\">                isValid = rule.test(inValue)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 字符串型内置类型验证</span></span><br><span class=\"line\">              <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> rule === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (rule) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;tel&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^1[34578]\\d&#123;9&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;password&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]&#123;6,12&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;telCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\d&#123;6&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;imgCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\S&#123;4&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"attr\">default</span>:</span><br><span class=\"line\">                  <span class=\"comment\">// no default</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, errMsg || <span class=\"string\">&#x27;格式错误&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在异步校验</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (asyncVerify) &#123;</span><br><span class=\"line\">              </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据流动问题\"><a href=\"#数据流动问题\" class=\"headerlink\" title=\"数据流动问题\"></a>数据流动问题</h2><h3 id=\"情况：\"><a href=\"#情况：\" class=\"headerlink\" title=\"情况：\"></a>情况：</h3><p>一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError</p>\n<h3 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h3><p>父元素传递’first error’，子元素自产生’second error’，此时父再传’first error’，子元素就会忽略，因为父元素传递的数据还没改变还是’first error’。</p>\n<h3 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h3><p>A方法：子元素不自己产生childError，统一<code>$emit</code>发送给父元素，然后才传递给子元素</p>\n<p>B方法：父元素传递的数据，前缀加计数器以区别每次传递的数据</p>\n<h2 id=\"错误信息往上传递\"><a href=\"#错误信息往上传递\" class=\"headerlink\" title=\"错误信息往上传递\"></a>错误信息往上传递</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">error</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error = 谁的错误信息? 用户名 or 密码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可</li>\n<li>B方法：使用curry化函数</li>\n</ul>\n<h3 id=\"A方法\"><a href=\"#A方法\" class=\"headerlink\" title=\"A方法\"></a>A方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"built_in\">JSON</span>.stringify([token, <span class=\"string\">&#x27;出错了!&#x27;</span>]) )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> token=<span class=\"string\">&quot;username&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">token</span>=<span class=\"string\">&quot;password&quot;</span>/&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">errObj</span>)</span> &#123;</span><br><span class=\"line\">    parsedErrObj = <span class=\"built_in\">JSON</span>.parse(errObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    token = parsedErrObj[<span class=\"number\">0</span>] <span class=\"comment\">// 错误信息的宿主</span></span><br><span class=\"line\">    error = parsedErrObj[<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"B方法\"><a href=\"#B方法\" class=\"headerlink\" title=\"B方法\"></a>B方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;curryShowError(&#x27;username&#x27;)&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;curryShowError(&#x27;password&#x27;)&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">curryShowError</span>(<span class=\"params\">token</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。</p>\n<p>期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。</p>\n<h2 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h2><p>type类型的选择</p>\n<h3 id=\"初始版本：\"><a href=\"#初始版本：\" class=\"headerlink\" title=\"初始版本：\"></a>初始版本：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-if=&quot;type === &#x27;number&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;number&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else-if=&quot;type === &#x27;tel&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;tel&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p>原因：避免使用非法类型</p>\n<h3 id=\"最终版本：\"><a href=\"#最终版本：\" class=\"headerlink\" title=\"最终版本：\"></a>最终版本：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input :type=&quot;type&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;es6&quot;&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        type: &#123;</span><br><span class=\"line\">            type: &#x27;string&#x27;,</span><br><span class=\"line\">            default: &#x27;text&#x27;,</span><br><span class=\"line\">            validator(type)&#123;</span><br><span class=\"line\">                return [&#x27;password&#x27;, &#x27;tel&#x27;, &#x27;number&#x27;].indexOf(type) &gt; -1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步校验与异步校验\"><a href=\"#同步校验与异步校验\" class=\"headerlink\" title=\"同步校验与异步校验\"></a>同步校验与异步校验</h3><h4 id=\"同步校验：\"><a href=\"#同步校验：\" class=\"headerlink\" title=\"同步校验：\"></a>同步校验：</h4><p>input事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。</p>\n<h4 id=\"异步校验：\"><a href=\"#异步校验：\" class=\"headerlink\" title=\"异步校验：\"></a>异步校验：</h4><p>因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">verify</span>: &#123; <span class=\"comment\">// 验证规则 &#123;rule: &#x27;规则&#x27;, errMsg: &#x27;错误信息提示&#x27;&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;validator&#x27;</span>(value) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> value.rule </span><br><span class=\"line\">                &amp;&amp; (value.rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span> || <span class=\"keyword\">typeof</span> value.rule === <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">asyncVerify</span>: <span class=\"built_in\">String</span>, <span class=\"comment\">// 异步验证规则（URL地址）</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">validate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123;verify, inValue, asyncVerify&#125; = <span class=\"built_in\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isValid</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在验证规则</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (verify) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">const</span> &#123;rule, errMsg&#125; = verify</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 正则的验证规则</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span>) &#123;</span><br><span class=\"line\">                isValid = rule.test(inValue)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 字符串型内置类型验证</span></span><br><span class=\"line\">              <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> rule === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (rule) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;tel&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^1[34578]\\d&#123;9&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;password&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]&#123;6,12&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;telCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\d&#123;6&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;imgCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\S&#123;4&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"attr\">default</span>:</span><br><span class=\"line\">                  <span class=\"comment\">// no default</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, errMsg || <span class=\"string\">&#x27;格式错误&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在异步校验</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (asyncVerify) &#123;</span><br><span class=\"line\">              </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据流动问题\"><a href=\"#数据流动问题\" class=\"headerlink\" title=\"数据流动问题\"></a>数据流动问题</h2><h3 id=\"情况：\"><a href=\"#情况：\" class=\"headerlink\" title=\"情况：\"></a>情况：</h3><p>一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError</p>\n<h3 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h3><p>父元素传递’first error’，子元素自产生’second error’，此时父再传’first error’，子元素就会忽略，因为父元素传递的数据还没改变还是’first error’。</p>\n<h3 id=\"解决：\"><a href=\"#解决：\" class=\"headerlink\" title=\"解决：\"></a>解决：</h3><p>A方法：子元素不自己产生childError，统一<code>$emit</code>发送给父元素，然后才传递给子元素</p>\n<p>B方法：父元素传递的数据，前缀加计数器以区别每次传递的数据</p>\n<h2 id=\"错误信息往上传递\"><a href=\"#错误信息往上传递\" class=\"headerlink\" title=\"错误信息往上传递\"></a>错误信息往上传递</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">error</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error = 谁的错误信息? 用户名 or 密码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可</li>\n<li>B方法：使用curry化函数</li>\n</ul>\n<h3 id=\"A方法\"><a href=\"#A方法\" class=\"headerlink\" title=\"A方法\"></a>A方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"built_in\">JSON</span>.stringify([token, <span class=\"string\">&#x27;出错了!&#x27;</span>]) )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> token=<span class=\"string\">&quot;username&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">token</span>=<span class=\"string\">&quot;password&quot;</span>/&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">errObj</span>)</span> &#123;</span><br><span class=\"line\">    parsedErrObj = <span class=\"built_in\">JSON</span>.parse(errObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    token = parsedErrObj[<span class=\"number\">0</span>] <span class=\"comment\">// 错误信息的宿主</span></span><br><span class=\"line\">    error = parsedErrObj[<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"B方法\"><a href=\"#B方法\" class=\"headerlink\" title=\"B方法\"></a>B方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;curryShowError(&#x27;username&#x27;)&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;curryShowError(&#x27;password&#x27;)&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">curryShowError</span>(<span class=\"params\">token</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"前端进阶 - Promise原理&宏微任务","date":"2021-01-17T06:59:13.000Z","_content":"---\n\n读完这篇文章，你的收获有：\n1. Promise简史\n2. Promise的关键概念\n3. 可以手写符合标准的Promise\n4. 可以解答任意宏任务/微任务的题目\n\n# 0. 前言\n\n为什么写这篇文章？\n\nJavaScript是异步语言，因此Promise的重要性不言而喻。\n\n而我看了一些文章，觉得质量参差不齐。\n\n于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。\n\n由于能力有限，文中可能存在错误，望广大网友指正。\n\n# 1. Promise简史\n\nPromise并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。\n\n这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：[Promise/A+](https://promisesaplus.com)。\n\n在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。\n\n# 2. Promise的关键概念\n\n> “The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference\n\nPromise的基础认知，推荐看阮一峰的[《ES6 入门教程》](https://es6.ruanyifeng.com/#docs/promise)。\n\n本文的重点是讲解一些手写Promise需要关注的关键概念。\n\n## 2.1 Promise有三个状态：\n\n- pending\n- resolved\n- rejected\n\n只能从pending到resolved或rejected，之后状态就凝固了。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image)\n\n当状态流转成resolved时，需要选择一个值作为当前Promise的value：\n- `new Promise`时，则是通过`resolve(val)`\n- `promise.then`时，则是通过`return`（需要注意的是，没有显式`return`时是默认`return undefined`）\n\n这个值可以是任意的合法JavaScript值（包括`undefined`、`thenable对象`或者`promise`）\n\n> thenable对象是一个定义了then方法的对象或者函数\n\n状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。\n\n## 2.2 Promise.prototype.then\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n- [Promise/A+](https://promisesaplus.com/) 是Promise的标准规范，**其中指出Promise实例只需要实现then一个方法**\n- then接收两个参数，而两个参数都是可选的，意味着可以什么都不传\n- then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的\n- 每次调用then均返回一个全新的Promise实例，这样就可以链式调用\n- then会在当前宏任务下形成一个微任务（具体介绍看下面）\n\n### 2.2.1 promise的状态\n\nthen其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。\n\n它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：\n\n```js\nnew Promise((resolve, reject) => {\n\tresolve(1) // 将当前的状态流转成resolved\n})\n```\n\n而then返回的promise的状态判断需要分两步走：\n1. then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态\n2. 若满足条件1，则看当前回调函数能否正常处理\n\n说得有点绕口，看下面的实例代码即可理解：\n\n**理解条件1：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<rejected>: \"error1\"}\n\treject('error1')\n})\n\nlet p2 = p1.then(console.log) // Promise {<rejected>: \"error1\"}\n```\n\n由于`p1`的状态是`Rejected`的，而`p2`没有传入`onRejected`的回调函数，因此`p2`的状态完全复用`p1`的状态。\n\n**理解条件2：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<fulfilled>: 1}\n\tresolve(1)\n})\n\nlet p2 = p1.then(val => { // Promise {<rejected>: ReferenceError: x is not defined}\n\tconsole.log('p1 was resolved:', val)\n\treturn x; // Uncaught referenceError\n})\n\nlet p3 = p2.then(undefined, reason => 1) // Promise {<fulfilled>: 1}\n```\n\n`p1`的状态是`fulfilled`的，而`p2`有`onFulfilled`的回调函数，但是没有正确处理，抛异常了。因此`p2`的状态变成了`rejected`，其中的reason为则报错的原因。\n\n而此时`p3`刚好有`onRejected`的函数，也能正确处理，最后的返回值则是自己的value，因此`p3`的状态是`fulfilled`的。\n\n### 2.2.2 promise的返回值\n\n前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了`promise`，这里重点讲下。\n\n由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。\n\n同样看看例子：\n\n```js\nlet p1 = new Promise(resolve => {\n\tsetTimeout(resolve, 1000, 1)\n}) \n\nlet p2 = new Promise(() => p1)\n```\n\n`p1`是一个简单的定时器promise，在1000ms之后，状态会变成`<fulfilled: 1>`。\n\n而`p2`的返回值是`p1`，因此`p2`在1000ms之内也是`<pending>`，同样会在1000ms之后，变成`<fulfilled: 1>`\n\n## 2.3 Promise.prototype.catch\n\n虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。\n\n其实，catch可以理解成then的一种封装：\n\n```js\npromise.catch(function onRejected() {}) == promise.then(undefined, function onRejected() {})\n```\n\n## 2.4 微任务 microtask\n\n当前promise的状态变更之后，不是立即执行then方法的。此时引入了 **微任务(microtask)** 的概念。\n\n与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。\n\n也可以通过其他的方式生成宏任务：`setTimeout`、`setInterval`；而微任务则可以通过`promise.then`、`Object.observe(已废弃)`、`MutationObserver`生成。\n\n宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image)\n\n即一个宏任务下，是可以有多个微任务的。\n\n> 由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。\n\n### 2.4.1 解析任务\n\n分析代码的时候，可以这样分几步走：\n\n1. 理想情况下，如果没有任何`setTimeout`和`promise.then`的话，则全部在一个宏任务里执行\n2. 若出现`promise.then`，则在当前宏任务生成一个微任务，用于执行`promise.then`\n3. 若出现了`setTimeout`，则添加一个宏任务，重复条件1\n\n分析几个例子考验一下：\n\n**例子1：**\n```js\nsetTimeout(console.log, 0, 0)\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n**例子2：**\n```js\nconsole.log(8)\n\nsetTimeout(function() {\n    console.log(0)\n    Promise.resolve(4).then(console.log)\n}) // 省略参数，delay默认为0\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n\nsetTimeout(console.log, 0, 5)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n其实，还有`async/await`相关的题目，如果阅读足够多的话，我再完善吧。\n\n# 3. 手写Promise\n\n其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。\n\n我在[github](https://github.com/LeeJim/word)写了一份，代码逻辑都算挺清晰的，大家可以去看看。\n\n我建议大家在写之前，再仔细看一下`Promise/A+`的标准规范，可以结合我的代码一起看。\n\n清晰理解细节之后，再动手写一遍。\n\n如果觉得不错的话，记得给我点赞 + [star](https://github.com/LeeJim/word)。\n\n撒花，感谢阅读！","source":"_posts/promise.md","raw":"---\ntitle: 前端进阶 - Promise原理&宏微任务\ndate: 2021-01-17 14:59:13\ntags: promise 宏任务 微任务\n---\n---\n\n读完这篇文章，你的收获有：\n1. Promise简史\n2. Promise的关键概念\n3. 可以手写符合标准的Promise\n4. 可以解答任意宏任务/微任务的题目\n\n# 0. 前言\n\n为什么写这篇文章？\n\nJavaScript是异步语言，因此Promise的重要性不言而喻。\n\n而我看了一些文章，觉得质量参差不齐。\n\n于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。\n\n由于能力有限，文中可能存在错误，望广大网友指正。\n\n# 1. Promise简史\n\nPromise并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。\n\n这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：[Promise/A+](https://promisesaplus.com)。\n\n在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。\n\n# 2. Promise的关键概念\n\n> “The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference\n\nPromise的基础认知，推荐看阮一峰的[《ES6 入门教程》](https://es6.ruanyifeng.com/#docs/promise)。\n\n本文的重点是讲解一些手写Promise需要关注的关键概念。\n\n## 2.1 Promise有三个状态：\n\n- pending\n- resolved\n- rejected\n\n只能从pending到resolved或rejected，之后状态就凝固了。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image)\n\n当状态流转成resolved时，需要选择一个值作为当前Promise的value：\n- `new Promise`时，则是通过`resolve(val)`\n- `promise.then`时，则是通过`return`（需要注意的是，没有显式`return`时是默认`return undefined`）\n\n这个值可以是任意的合法JavaScript值（包括`undefined`、`thenable对象`或者`promise`）\n\n> thenable对象是一个定义了then方法的对象或者函数\n\n状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。\n\n## 2.2 Promise.prototype.then\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n- [Promise/A+](https://promisesaplus.com/) 是Promise的标准规范，**其中指出Promise实例只需要实现then一个方法**\n- then接收两个参数，而两个参数都是可选的，意味着可以什么都不传\n- then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的\n- 每次调用then均返回一个全新的Promise实例，这样就可以链式调用\n- then会在当前宏任务下形成一个微任务（具体介绍看下面）\n\n### 2.2.1 promise的状态\n\nthen其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。\n\n它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：\n\n```js\nnew Promise((resolve, reject) => {\n\tresolve(1) // 将当前的状态流转成resolved\n})\n```\n\n而then返回的promise的状态判断需要分两步走：\n1. then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态\n2. 若满足条件1，则看当前回调函数能否正常处理\n\n说得有点绕口，看下面的实例代码即可理解：\n\n**理解条件1：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<rejected>: \"error1\"}\n\treject('error1')\n})\n\nlet p2 = p1.then(console.log) // Promise {<rejected>: \"error1\"}\n```\n\n由于`p1`的状态是`Rejected`的，而`p2`没有传入`onRejected`的回调函数，因此`p2`的状态完全复用`p1`的状态。\n\n**理解条件2：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<fulfilled>: 1}\n\tresolve(1)\n})\n\nlet p2 = p1.then(val => { // Promise {<rejected>: ReferenceError: x is not defined}\n\tconsole.log('p1 was resolved:', val)\n\treturn x; // Uncaught referenceError\n})\n\nlet p3 = p2.then(undefined, reason => 1) // Promise {<fulfilled>: 1}\n```\n\n`p1`的状态是`fulfilled`的，而`p2`有`onFulfilled`的回调函数，但是没有正确处理，抛异常了。因此`p2`的状态变成了`rejected`，其中的reason为则报错的原因。\n\n而此时`p3`刚好有`onRejected`的函数，也能正确处理，最后的返回值则是自己的value，因此`p3`的状态是`fulfilled`的。\n\n### 2.2.2 promise的返回值\n\n前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了`promise`，这里重点讲下。\n\n由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。\n\n同样看看例子：\n\n```js\nlet p1 = new Promise(resolve => {\n\tsetTimeout(resolve, 1000, 1)\n}) \n\nlet p2 = new Promise(() => p1)\n```\n\n`p1`是一个简单的定时器promise，在1000ms之后，状态会变成`<fulfilled: 1>`。\n\n而`p2`的返回值是`p1`，因此`p2`在1000ms之内也是`<pending>`，同样会在1000ms之后，变成`<fulfilled: 1>`\n\n## 2.3 Promise.prototype.catch\n\n虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。\n\n其实，catch可以理解成then的一种封装：\n\n```js\npromise.catch(function onRejected() {}) == promise.then(undefined, function onRejected() {})\n```\n\n## 2.4 微任务 microtask\n\n当前promise的状态变更之后，不是立即执行then方法的。此时引入了 **微任务(microtask)** 的概念。\n\n与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。\n\n也可以通过其他的方式生成宏任务：`setTimeout`、`setInterval`；而微任务则可以通过`promise.then`、`Object.observe(已废弃)`、`MutationObserver`生成。\n\n宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image)\n\n即一个宏任务下，是可以有多个微任务的。\n\n> 由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。\n\n### 2.4.1 解析任务\n\n分析代码的时候，可以这样分几步走：\n\n1. 理想情况下，如果没有任何`setTimeout`和`promise.then`的话，则全部在一个宏任务里执行\n2. 若出现`promise.then`，则在当前宏任务生成一个微任务，用于执行`promise.then`\n3. 若出现了`setTimeout`，则添加一个宏任务，重复条件1\n\n分析几个例子考验一下：\n\n**例子1：**\n```js\nsetTimeout(console.log, 0, 0)\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n**例子2：**\n```js\nconsole.log(8)\n\nsetTimeout(function() {\n    console.log(0)\n    Promise.resolve(4).then(console.log)\n}) // 省略参数，delay默认为0\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n\nsetTimeout(console.log, 0, 5)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n其实，还有`async/await`相关的题目，如果阅读足够多的话，我再完善吧。\n\n# 3. 手写Promise\n\n其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。\n\n我在[github](https://github.com/LeeJim/word)写了一份，代码逻辑都算挺清晰的，大家可以去看看。\n\n我建议大家在写之前，再仔细看一下`Promise/A+`的标准规范，可以结合我的代码一起看。\n\n清晰理解细节之后，再动手写一遍。\n\n如果觉得不错的话，记得给我点赞 + [star](https://github.com/LeeJim/word)。\n\n撒花，感谢阅读！","slug":"promise","published":1,"updated":"2021-01-20T14:27:50.000Z","_id":"ckxvfmfca000nbrqqbu34c358","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p>读完这篇文章，你的收获有：</p>\n<ol>\n<li>Promise简史</li>\n<li>Promise的关键概念</li>\n<li>可以手写符合标准的Promise</li>\n<li>可以解答任意宏任务/微任务的题目</li>\n</ol>\n<h1 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0. 前言\"></a>0. 前言</h1><p>为什么写这篇文章？</p>\n<p>JavaScript是异步语言，因此Promise的重要性不言而喻。</p>\n<p>而我看了一些文章，觉得质量参差不齐。</p>\n<p>于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。</p>\n<p>由于能力有限，文中可能存在错误，望广大网友指正。</p>\n<h1 id=\"1-Promise简史\"><a href=\"#1-Promise简史\" class=\"headerlink\" title=\"1. Promise简史\"></a>1. Promise简史</h1><p>Promise并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。</p>\n<p>这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：<a href=\"https://promisesaplus.com/\">Promise/A+</a>。</p>\n<p>在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。</p>\n<h1 id=\"2-Promise的关键概念\"><a href=\"#2-Promise的关键概念\" class=\"headerlink\" title=\"2. Promise的关键概念\"></a>2. Promise的关键概念</h1><blockquote>\n<p>“The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference</p>\n</blockquote>\n<p>Promise的基础认知，推荐看阮一峰的<a href=\"https://es6.ruanyifeng.com/#docs/promise\">《ES6 入门教程》</a>。</p>\n<p>本文的重点是讲解一些手写Promise需要关注的关键概念。</p>\n<h2 id=\"2-1-Promise有三个状态：\"><a href=\"#2-1-Promise有三个状态：\" class=\"headerlink\" title=\"2.1 Promise有三个状态：\"></a>2.1 Promise有三个状态：</h2><ul>\n<li>pending</li>\n<li>resolved</li>\n<li>rejected</li>\n</ul>\n<p>只能从pending到resolved或rejected，之后状态就凝固了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>当状态流转成resolved时，需要选择一个值作为当前Promise的value：</p>\n<ul>\n<li><code>new Promise</code>时，则是通过<code>resolve(val)</code></li>\n<li><code>promise.then</code>时，则是通过<code>return</code>（需要注意的是，没有显式<code>return</code>时是默认<code>return undefined</code>）</li>\n</ul>\n<p>这个值可以是任意的合法JavaScript值（包括<code>undefined</code>、<code>thenable对象</code>或者<code>promise</code>）</p>\n<blockquote>\n<p>thenable对象是一个定义了then方法的对象或者函数</p>\n</blockquote>\n<p>状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。</p>\n<h2 id=\"2-2-Promise-prototype-then\"><a href=\"#2-2-Promise-prototype-then\" class=\"headerlink\" title=\"2.2 Promise.prototype.then\"></a>2.2 Promise.prototype.then</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://promisesaplus.com/\">Promise/A+</a> 是Promise的标准规范，<strong>其中指出Promise实例只需要实现then一个方法</strong></li>\n<li>then接收两个参数，而两个参数都是可选的，意味着可以什么都不传</li>\n<li>then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的</li>\n<li>每次调用then均返回一个全新的Promise实例，这样就可以链式调用</li>\n<li>then会在当前宏任务下形成一个微任务（具体介绍看下面）</li>\n</ul>\n<h3 id=\"2-2-1-promise的状态\"><a href=\"#2-2-1-promise的状态\" class=\"headerlink\" title=\"2.2.1 promise的状态\"></a>2.2.1 promise的状态</h3><p>then其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。</p>\n<p>它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>) <span class=\"comment\">// 将当前的状态流转成resolved</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>而then返回的promise的状态判断需要分两步走：</p>\n<ol>\n<li>then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态</li>\n<li>若满足条件1，则看当前回调函数能否正常处理</li>\n</ol>\n<p>说得有点绕口，看下面的实例代码即可理解：</p>\n<p><strong>理解条件1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br><span class=\"line\">\treject(<span class=\"string\">&#x27;error1&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>由于<code>p1</code>的状态是<code>Rejected</code>的，而<code>p2</code>没有传入<code>onRejected</code>的回调函数，因此<code>p2</code>的状态完全复用<code>p1</code>的状态。</p>\n<p><strong>理解条件2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: ReferenceError: x is not defined&#125;</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;p1 was resolved:&#x27;</span>, val)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x; <span class=\"comment\">// Uncaught referenceError</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = p2.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> <span class=\"number\">1</span>) <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>的状态是<code>fulfilled</code>的，而<code>p2</code>有<code>onFulfilled</code>的回调函数，但是没有正确处理，抛异常了。因此<code>p2</code>的状态变成了<code>rejected</code>，其中的reason为则报错的原因。</p>\n<p>而此时<code>p3</code>刚好有<code>onRejected</code>的函数，也能正确处理，最后的返回值则是自己的value，因此<code>p3</code>的状态是<code>fulfilled</code>的。</p>\n<h3 id=\"2-2-2-promise的返回值\"><a href=\"#2-2-2-promise的返回值\" class=\"headerlink\" title=\"2.2.2 promise的返回值\"></a>2.2.2 promise的返回值</h3><p>前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了<code>promise</code>，这里重点讲下。</p>\n<p>由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。</p>\n<p>同样看看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">1000</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">() =&gt;</span> p1)</span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>是一个简单的定时器promise，在1000ms之后，状态会变成<code>&lt;fulfilled: 1&gt;</code>。</p>\n<p>而<code>p2</code>的返回值是<code>p1</code>，因此<code>p2</code>在1000ms之内也是<code>&lt;pending&gt;</code>，同样会在1000ms之后，变成<code>&lt;fulfilled: 1&gt;</code></p>\n<h2 id=\"2-3-Promise-prototype-catch\"><a href=\"#2-3-Promise-prototype-catch\" class=\"headerlink\" title=\"2.3 Promise.prototype.catch\"></a>2.3 Promise.prototype.catch</h2><p>虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。</p>\n<p>其实，catch可以理解成then的一种封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;) == promise.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-微任务-microtask\"><a href=\"#2-4-微任务-microtask\" class=\"headerlink\" title=\"2.4 微任务 microtask\"></a>2.4 微任务 microtask</h2><p>当前promise的状态变更之后，不是立即执行then方法的。此时引入了 <strong>微任务(microtask)</strong> 的概念。</p>\n<p>与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。</p>\n<p>也可以通过其他的方式生成宏任务：<code>setTimeout</code>、<code>setInterval</code>；而微任务则可以通过<code>promise.then</code>、<code>Object.observe(已废弃)</code>、<code>MutationObserver</code>生成。</p>\n<p>宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>即一个宏任务下，是可以有多个微任务的。</p>\n<blockquote>\n<p>由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。</p>\n</blockquote>\n<h3 id=\"2-4-1-解析任务\"><a href=\"#2-4-1-解析任务\" class=\"headerlink\" title=\"2.4.1 解析任务\"></a>2.4.1 解析任务</h3><p>分析代码的时候，可以这样分几步走：</p>\n<ol>\n<li>理想情况下，如果没有任何<code>setTimeout</code>和<code>promise.then</code>的话，则全部在一个宏任务里执行</li>\n<li>若出现<code>promise.then</code>，则在当前宏任务生成一个微任务，用于执行<code>promise.then</code></li>\n<li>若出现了<code>setTimeout</code>，则添加一个宏任务，重复条件1</li>\n</ol>\n<p>分析几个例子考验一下：</p>\n<p><strong>例子1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n<p><strong>例子2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 省略参数，delay默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n<p>其实，还有<code>async/await</code>相关的题目，如果阅读足够多的话，我再完善吧。</p>\n<h1 id=\"3-手写Promise\"><a href=\"#3-手写Promise\" class=\"headerlink\" title=\"3. 手写Promise\"></a>3. 手写Promise</h1><p>其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。</p>\n<p>我在<a href=\"https://github.com/LeeJim/word\">github</a>写了一份，代码逻辑都算挺清晰的，大家可以去看看。</p>\n<p>我建议大家在写之前，再仔细看一下<code>Promise/A+</code>的标准规范，可以结合我的代码一起看。</p>\n<p>清晰理解细节之后，再动手写一遍。</p>\n<p>如果觉得不错的话，记得给我点赞 + <a href=\"https://github.com/LeeJim/word\">star</a>。</p>\n<p>撒花，感谢阅读！</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<hr>\n<p>读完这篇文章，你的收获有：</p>\n<ol>\n<li>Promise简史</li>\n<li>Promise的关键概念</li>\n<li>可以手写符合标准的Promise</li>\n<li>可以解答任意宏任务/微任务的题目</li>\n</ol>\n<h1 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0. 前言\"></a>0. 前言</h1><p>为什么写这篇文章？</p>\n<p>JavaScript是异步语言，因此Promise的重要性不言而喻。</p>\n<p>而我看了一些文章，觉得质量参差不齐。</p>\n<p>于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。</p>\n<p>由于能力有限，文中可能存在错误，望广大网友指正。</p>\n<h1 id=\"1-Promise简史\"><a href=\"#1-Promise简史\" class=\"headerlink\" title=\"1. Promise简史\"></a>1. Promise简史</h1><p>Promise并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。</p>\n<p>这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：<a href=\"https://promisesaplus.com/\">Promise/A+</a>。</p>\n<p>在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。</p>\n<h1 id=\"2-Promise的关键概念\"><a href=\"#2-Promise的关键概念\" class=\"headerlink\" title=\"2. Promise的关键概念\"></a>2. Promise的关键概念</h1><blockquote>\n<p>“The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference</p>\n</blockquote>\n<p>Promise的基础认知，推荐看阮一峰的<a href=\"https://es6.ruanyifeng.com/#docs/promise\">《ES6 入门教程》</a>。</p>\n<p>本文的重点是讲解一些手写Promise需要关注的关键概念。</p>\n<h2 id=\"2-1-Promise有三个状态：\"><a href=\"#2-1-Promise有三个状态：\" class=\"headerlink\" title=\"2.1 Promise有三个状态：\"></a>2.1 Promise有三个状态：</h2><ul>\n<li>pending</li>\n<li>resolved</li>\n<li>rejected</li>\n</ul>\n<p>只能从pending到resolved或rejected，之后状态就凝固了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>当状态流转成resolved时，需要选择一个值作为当前Promise的value：</p>\n<ul>\n<li><code>new Promise</code>时，则是通过<code>resolve(val)</code></li>\n<li><code>promise.then</code>时，则是通过<code>return</code>（需要注意的是，没有显式<code>return</code>时是默认<code>return undefined</code>）</li>\n</ul>\n<p>这个值可以是任意的合法JavaScript值（包括<code>undefined</code>、<code>thenable对象</code>或者<code>promise</code>）</p>\n<blockquote>\n<p>thenable对象是一个定义了then方法的对象或者函数</p>\n</blockquote>\n<p>状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。</p>\n<h2 id=\"2-2-Promise-prototype-then\"><a href=\"#2-2-Promise-prototype-then\" class=\"headerlink\" title=\"2.2 Promise.prototype.then\"></a>2.2 Promise.prototype.then</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://promisesaplus.com/\">Promise/A+</a> 是Promise的标准规范，<strong>其中指出Promise实例只需要实现then一个方法</strong></li>\n<li>then接收两个参数，而两个参数都是可选的，意味着可以什么都不传</li>\n<li>then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的</li>\n<li>每次调用then均返回一个全新的Promise实例，这样就可以链式调用</li>\n<li>then会在当前宏任务下形成一个微任务（具体介绍看下面）</li>\n</ul>\n<h3 id=\"2-2-1-promise的状态\"><a href=\"#2-2-1-promise的状态\" class=\"headerlink\" title=\"2.2.1 promise的状态\"></a>2.2.1 promise的状态</h3><p>then其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。</p>\n<p>它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>) <span class=\"comment\">// 将当前的状态流转成resolved</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>而then返回的promise的状态判断需要分两步走：</p>\n<ol>\n<li>then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态</li>\n<li>若满足条件1，则看当前回调函数能否正常处理</li>\n</ol>\n<p>说得有点绕口，看下面的实例代码即可理解：</p>\n<p><strong>理解条件1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br><span class=\"line\">\treject(<span class=\"string\">&#x27;error1&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>由于<code>p1</code>的状态是<code>Rejected</code>的，而<code>p2</code>没有传入<code>onRejected</code>的回调函数，因此<code>p2</code>的状态完全复用<code>p1</code>的状态。</p>\n<p><strong>理解条件2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: ReferenceError: x is not defined&#125;</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;p1 was resolved:&#x27;</span>, val)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x; <span class=\"comment\">// Uncaught referenceError</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = p2.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> <span class=\"number\">1</span>) <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>的状态是<code>fulfilled</code>的，而<code>p2</code>有<code>onFulfilled</code>的回调函数，但是没有正确处理，抛异常了。因此<code>p2</code>的状态变成了<code>rejected</code>，其中的reason为则报错的原因。</p>\n<p>而此时<code>p3</code>刚好有<code>onRejected</code>的函数，也能正确处理，最后的返回值则是自己的value，因此<code>p3</code>的状态是<code>fulfilled</code>的。</p>\n<h3 id=\"2-2-2-promise的返回值\"><a href=\"#2-2-2-promise的返回值\" class=\"headerlink\" title=\"2.2.2 promise的返回值\"></a>2.2.2 promise的返回值</h3><p>前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了<code>promise</code>，这里重点讲下。</p>\n<p>由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。</p>\n<p>同样看看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">1000</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">() =&gt;</span> p1)</span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>是一个简单的定时器promise，在1000ms之后，状态会变成<code>&lt;fulfilled: 1&gt;</code>。</p>\n<p>而<code>p2</code>的返回值是<code>p1</code>，因此<code>p2</code>在1000ms之内也是<code>&lt;pending&gt;</code>，同样会在1000ms之后，变成<code>&lt;fulfilled: 1&gt;</code></p>\n<h2 id=\"2-3-Promise-prototype-catch\"><a href=\"#2-3-Promise-prototype-catch\" class=\"headerlink\" title=\"2.3 Promise.prototype.catch\"></a>2.3 Promise.prototype.catch</h2><p>虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。</p>\n<p>其实，catch可以理解成then的一种封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;) == promise.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-微任务-microtask\"><a href=\"#2-4-微任务-microtask\" class=\"headerlink\" title=\"2.4 微任务 microtask\"></a>2.4 微任务 microtask</h2><p>当前promise的状态变更之后，不是立即执行then方法的。此时引入了 <strong>微任务(microtask)</strong> 的概念。</p>\n<p>与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。</p>\n<p>也可以通过其他的方式生成宏任务：<code>setTimeout</code>、<code>setInterval</code>；而微任务则可以通过<code>promise.then</code>、<code>Object.observe(已废弃)</code>、<code>MutationObserver</code>生成。</p>\n<p>宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>即一个宏任务下，是可以有多个微任务的。</p>\n<blockquote>\n<p>由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。</p>\n</blockquote>\n<h3 id=\"2-4-1-解析任务\"><a href=\"#2-4-1-解析任务\" class=\"headerlink\" title=\"2.4.1 解析任务\"></a>2.4.1 解析任务</h3><p>分析代码的时候，可以这样分几步走：</p>\n<ol>\n<li>理想情况下，如果没有任何<code>setTimeout</code>和<code>promise.then</code>的话，则全部在一个宏任务里执行</li>\n<li>若出现<code>promise.then</code>，则在当前宏任务生成一个微任务，用于执行<code>promise.then</code></li>\n<li>若出现了<code>setTimeout</code>，则添加一个宏任务，重复条件1</li>\n</ol>\n<p>分析几个例子考验一下：</p>\n<p><strong>例子1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n<p><strong>例子2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 省略参数，delay默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n<p>其实，还有<code>async/await</code>相关的题目，如果阅读足够多的话，我再完善吧。</p>\n<h1 id=\"3-手写Promise\"><a href=\"#3-手写Promise\" class=\"headerlink\" title=\"3. 手写Promise\"></a>3. 手写Promise</h1><p>其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。</p>\n<p>我在<a href=\"https://github.com/LeeJim/word\">github</a>写了一份，代码逻辑都算挺清晰的，大家可以去看看。</p>\n<p>我建议大家在写之前，再仔细看一下<code>Promise/A+</code>的标准规范，可以结合我的代码一起看。</p>\n<p>清晰理解细节之后，再动手写一遍。</p>\n<p>如果觉得不错的话，记得给我点赞 + <a href=\"https://github.com/LeeJim/word\">star</a>。</p>\n<p>撒花，感谢阅读！</p>\n"},{"title":"小程序实战汇总一","date":"2018-01-07T14:54:42.000Z","desc":"小程序 授权处理","_content":"\n随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。\n\n那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。\n\n# 授权处理\n\n在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。\n\n因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。\n\n## 解决方案\n\n在基础库**1.2**版本，新增了`wx.getSetting`接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。\n\n具体实现可参考一下代码：\n\n```js\nwx.getUserInfo({\n  success: function (res) {\n    // 成功获取用户信息，继续操作\n  },\n  fail: (res) => {\n    wx.showModal({\n      title: '用户未授权',\n      content: '如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？',\n      success: (action) => {\n        if (action.confirm) {\n          \n        }\n      }\n    })\n  }\n})\n\n// 检查状态\nwx.openSetting({\n  success: (res) => {\n    // 二次授权成功\n    if (res.authSetting[\"scope.userInfo\"]) {\n      // 成功获取用户信息\n    }\n  },\n  fail: function () {\n    fail()\n  }\n})\n```\n\n# 页面数据传递\n\n页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？\n\n## URL传递\n\n类似Web的链接跳转，使用类似query串的形式。\n\n```js\nwx.navigateTo('../user/user?name=leejim')\n```\n\n在目的页的`onload`函数，可以这么获取：\n\n```js\nonLoad(options) {\n  console.log(options.name) // leejim\n}\n```\n\n## 使用客户端缓存\n\n小程序提供了本地存储的方式：`wx.setStorage`和`wx.getStorage`。\n\n可以在页面跳转前，先用`wx.setStorage`缓存数据，然后在目的页使用`wx.getStorage`获取数据。\n\n## 使用全局变量\n\n在小程序里，有一个全局函数`getApp`用来获取全局变量`app`。\n\n比如这样：\n\n```js\nvar app = getApp()\napp.index = 1 // 设置变量\n```\n\n## 往栈内的页面传递数据\n\n使用全局函数`getCurrentPages`函数可以获取栈内的所有页面。\n\n然后就可以直接设置那个页面的数据：\n\n```js\nvar pages = getCurrentPages()\npages[pages.length -1].setData({ // 往前一个页面设置数据\n  data: 123\n})\n```\n\n# 修改Input组件的值\n\n因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。\n\n但是我们能通过data绑定的方式来实现：\n\n```html\n<input value='{{inputValue}}' />\n```\n\njs部分：\n\n```js\nthis.setData({\n  inputValue: ''\n})\n```","source":"_posts/practice-of-wxapp-1.md","raw":"---\ntitle: 小程序实战汇总一\ndate: 2018-01-07 22:54:42\ntags: 小程序\ndesc: 小程序 授权处理\n---\n\n随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。\n\n那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。\n\n# 授权处理\n\n在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。\n\n因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。\n\n## 解决方案\n\n在基础库**1.2**版本，新增了`wx.getSetting`接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。\n\n具体实现可参考一下代码：\n\n```js\nwx.getUserInfo({\n  success: function (res) {\n    // 成功获取用户信息，继续操作\n  },\n  fail: (res) => {\n    wx.showModal({\n      title: '用户未授权',\n      content: '如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？',\n      success: (action) => {\n        if (action.confirm) {\n          \n        }\n      }\n    })\n  }\n})\n\n// 检查状态\nwx.openSetting({\n  success: (res) => {\n    // 二次授权成功\n    if (res.authSetting[\"scope.userInfo\"]) {\n      // 成功获取用户信息\n    }\n  },\n  fail: function () {\n    fail()\n  }\n})\n```\n\n# 页面数据传递\n\n页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？\n\n## URL传递\n\n类似Web的链接跳转，使用类似query串的形式。\n\n```js\nwx.navigateTo('../user/user?name=leejim')\n```\n\n在目的页的`onload`函数，可以这么获取：\n\n```js\nonLoad(options) {\n  console.log(options.name) // leejim\n}\n```\n\n## 使用客户端缓存\n\n小程序提供了本地存储的方式：`wx.setStorage`和`wx.getStorage`。\n\n可以在页面跳转前，先用`wx.setStorage`缓存数据，然后在目的页使用`wx.getStorage`获取数据。\n\n## 使用全局变量\n\n在小程序里，有一个全局函数`getApp`用来获取全局变量`app`。\n\n比如这样：\n\n```js\nvar app = getApp()\napp.index = 1 // 设置变量\n```\n\n## 往栈内的页面传递数据\n\n使用全局函数`getCurrentPages`函数可以获取栈内的所有页面。\n\n然后就可以直接设置那个页面的数据：\n\n```js\nvar pages = getCurrentPages()\npages[pages.length -1].setData({ // 往前一个页面设置数据\n  data: 123\n})\n```\n\n# 修改Input组件的值\n\n因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。\n\n但是我们能通过data绑定的方式来实现：\n\n```html\n<input value='{{inputValue}}' />\n```\n\njs部分：\n\n```js\nthis.setData({\n  inputValue: ''\n})\n```","slug":"practice-of-wxapp-1","published":1,"updated":"2018-01-18T15:13:58.000Z","_id":"ckxvfmfcb000pbrqq0z3ucsyg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。</p>\n<p>那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。</p>\n<h1 id=\"授权处理\"><a href=\"#授权处理\" class=\"headerlink\" title=\"授权处理\"></a>授权处理</h1><p>在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。</p>\n<p>因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>在基础库<strong>1.2</strong>版本，新增了<code>wx.getSetting</code>接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。</p>\n<p>具体实现可参考一下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.getUserInfo(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成功获取用户信息，继续操作</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    wx.showModal(&#123;</span><br><span class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">&#x27;用户未授权&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">content</span>: <span class=\"string\">&#x27;如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action.confirm) &#123;</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查状态</span></span><br><span class=\"line\">wx.openSetting(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 二次授权成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.authSetting[<span class=\"string\">&quot;scope.userInfo&quot;</span>]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 成功获取用户信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    fail()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"页面数据传递\"><a href=\"#页面数据传递\" class=\"headerlink\" title=\"页面数据传递\"></a>页面数据传递</h1><p>页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？</p>\n<h2 id=\"URL传递\"><a href=\"#URL传递\" class=\"headerlink\" title=\"URL传递\"></a>URL传递</h2><p>类似Web的链接跳转，使用类似query串的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.navigateTo(<span class=\"string\">&#x27;../user/user?name=leejim&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在目的页的<code>onload</code>函数，可以这么获取：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\">options</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(options.name) <span class=\"comment\">// leejim</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用客户端缓存\"><a href=\"#使用客户端缓存\" class=\"headerlink\" title=\"使用客户端缓存\"></a>使用客户端缓存</h2><p>小程序提供了本地存储的方式：<code>wx.setStorage</code>和<code>wx.getStorage</code>。</p>\n<p>可以在页面跳转前，先用<code>wx.setStorage</code>缓存数据，然后在目的页使用<code>wx.getStorage</code>获取数据。</p>\n<h2 id=\"使用全局变量\"><a href=\"#使用全局变量\" class=\"headerlink\" title=\"使用全局变量\"></a>使用全局变量</h2><p>在小程序里，有一个全局函数<code>getApp</code>用来获取全局变量<code>app</code>。</p>\n<p>比如这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = getApp()</span><br><span class=\"line\">app.index = <span class=\"number\">1</span> <span class=\"comment\">// 设置变量</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"往栈内的页面传递数据\"><a href=\"#往栈内的页面传递数据\" class=\"headerlink\" title=\"往栈内的页面传递数据\"></a>往栈内的页面传递数据</h2><p>使用全局函数<code>getCurrentPages</code>函数可以获取栈内的所有页面。</p>\n<p>然后就可以直接设置那个页面的数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pages = getCurrentPages()</span><br><span class=\"line\">pages[pages.length -<span class=\"number\">1</span>].setData(&#123; <span class=\"comment\">// 往前一个页面设置数据</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"number\">123</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改Input组件的值\"><a href=\"#修改Input组件的值\" class=\"headerlink\" title=\"修改Input组件的值\"></a>修改Input组件的值</h1><p>因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。</p>\n<p>但是我们能通过data绑定的方式来实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;&#123;&#123;inputValue&#125;&#125;&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>js部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">  <span class=\"attr\">inputValue</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。</p>\n<p>那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。</p>\n<h1 id=\"授权处理\"><a href=\"#授权处理\" class=\"headerlink\" title=\"授权处理\"></a>授权处理</h1><p>在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。</p>\n<p>因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>在基础库<strong>1.2</strong>版本，新增了<code>wx.getSetting</code>接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。</p>\n<p>具体实现可参考一下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.getUserInfo(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成功获取用户信息，继续操作</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    wx.showModal(&#123;</span><br><span class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">&#x27;用户未授权&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">content</span>: <span class=\"string\">&#x27;如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action.confirm) &#123;</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查状态</span></span><br><span class=\"line\">wx.openSetting(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 二次授权成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.authSetting[<span class=\"string\">&quot;scope.userInfo&quot;</span>]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 成功获取用户信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    fail()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"页面数据传递\"><a href=\"#页面数据传递\" class=\"headerlink\" title=\"页面数据传递\"></a>页面数据传递</h1><p>页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？</p>\n<h2 id=\"URL传递\"><a href=\"#URL传递\" class=\"headerlink\" title=\"URL传递\"></a>URL传递</h2><p>类似Web的链接跳转，使用类似query串的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.navigateTo(<span class=\"string\">&#x27;../user/user?name=leejim&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在目的页的<code>onload</code>函数，可以这么获取：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\">options</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(options.name) <span class=\"comment\">// leejim</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用客户端缓存\"><a href=\"#使用客户端缓存\" class=\"headerlink\" title=\"使用客户端缓存\"></a>使用客户端缓存</h2><p>小程序提供了本地存储的方式：<code>wx.setStorage</code>和<code>wx.getStorage</code>。</p>\n<p>可以在页面跳转前，先用<code>wx.setStorage</code>缓存数据，然后在目的页使用<code>wx.getStorage</code>获取数据。</p>\n<h2 id=\"使用全局变量\"><a href=\"#使用全局变量\" class=\"headerlink\" title=\"使用全局变量\"></a>使用全局变量</h2><p>在小程序里，有一个全局函数<code>getApp</code>用来获取全局变量<code>app</code>。</p>\n<p>比如这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = getApp()</span><br><span class=\"line\">app.index = <span class=\"number\">1</span> <span class=\"comment\">// 设置变量</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"往栈内的页面传递数据\"><a href=\"#往栈内的页面传递数据\" class=\"headerlink\" title=\"往栈内的页面传递数据\"></a>往栈内的页面传递数据</h2><p>使用全局函数<code>getCurrentPages</code>函数可以获取栈内的所有页面。</p>\n<p>然后就可以直接设置那个页面的数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pages = getCurrentPages()</span><br><span class=\"line\">pages[pages.length -<span class=\"number\">1</span>].setData(&#123; <span class=\"comment\">// 往前一个页面设置数据</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"number\">123</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改Input组件的值\"><a href=\"#修改Input组件的值\" class=\"headerlink\" title=\"修改Input组件的值\"></a>修改Input组件的值</h1><p>因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。</p>\n<p>但是我们能通过data绑定的方式来实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;&#123;&#123;inputValue&#125;&#125;&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>js部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">  <span class=\"attr\">inputValue</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"关于事件绑定的一些知识","date":"2016-11-24T15:45:59.000Z","desc":null,"_content":"\n前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：\n\n<!-- more -->\n\n现在有一段HTML\n\n```html\n<ul id=\"list\">\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n```\n\n点击`li`的时候`alert`弹出`li`里面的文本内容，离开`ul`时`alert`提醒。\n\n注意，需要考虑性能和兼容性问题。\n\n### 分析点击事件\n\n首先，大家都知道的是，在`IE`下绑定事件是使用`attachEvent`的，而不是`addEventListener`，因此可以封装一个方法来绑定事件：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n```\n\n需要注意的是，使用`attachEvent`时，事件类型都是需要加个`on`前缀的。还有就是因为`attachEvent`是将事件绑定在冒泡阶段的，为了保持一致，所以使用`addEventListener`时，需指定第三个参数为false，否则就添加到事件捕获阶段了。\n\n其次，不能给每个`li`绑定事件，可以利用事件的冒泡机制，故需把事件绑定到`ul`上而不是`li`上。\n\n此时要拿到真正的`li`就要读取事件(event)的真实对象(target)了，这也是一个考察点：\n\n- 在IE上，事件(event)要需要通过`window.event`获取的。\n\n- 在IE上，事件对象(event target)的值是`event.srcElement`而不是`event.target`\n\n因此绑定点击事件的完整代码是这样的：\n\n```js\nvar list = document.getElementById('list')\n\naddEvent(list, 'click', function(event){\n  event = event || window.event;\n  var target = event.target || event.srcElement;\n  \n  alert(target.innerHTML)\n})\n```\n\n### 分析鼠标移开事件\n\n其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用`mouseout`事件就完了。然而这里隐藏了一个问题：就是当鼠标移入`ul`的子元素`li`时，也会触发`mouseout`事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。\n\n然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。\n\n在现代浏览器(`chrome`，`firefox`，`safari`等等)上，我们直接用`event.relatedTarget`就可以直接获取；而在IE上则比较繁琐，`mouseout`事件有一个叫`toElement`的元素（顾名思义就是鼠标移到了哪个元素），`mouseover`事件则有一个叫`fromElement`元素。\n\n因此，我们可以这么做：\n\n```js\n addEvent(list, 'mouseout', function(event){\n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n  if(!list.contains(t)) {\n    alert('!')\n  }\n})\n```\n\n### 取消冒泡\n\n其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。\n\n因为我们没有处理`list.contains(t)`的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：\n\n－ `IE`取消冒泡的方法是`event.cancelBubble = true`\n\n- 在符合`w3c`标准的浏览器上，则是使用`event.stopPropagation()`\n\n最终的代码是这样的：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n\nvar list = document.getElementById('list');\n\naddEvent(list, 'mouseout', function(event){\n  \n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n\n  if(list.contains(t)) {\n    event.cancelBubble = true;\n    event.stopPropagation();\n  }\n  else {\n    alert('你正在离开list!')\n  }\n})\n```\n","source":"_posts/some-summarize-about-event.md","raw":"---\ntitle: 关于事件绑定的一些知识\ndate: 2016-11-24 23:45:59\ntags:\n- JavaScript\n- 事件\ndesc:\n---\n\n前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：\n\n<!-- more -->\n\n现在有一段HTML\n\n```html\n<ul id=\"list\">\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n```\n\n点击`li`的时候`alert`弹出`li`里面的文本内容，离开`ul`时`alert`提醒。\n\n注意，需要考虑性能和兼容性问题。\n\n### 分析点击事件\n\n首先，大家都知道的是，在`IE`下绑定事件是使用`attachEvent`的，而不是`addEventListener`，因此可以封装一个方法来绑定事件：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n```\n\n需要注意的是，使用`attachEvent`时，事件类型都是需要加个`on`前缀的。还有就是因为`attachEvent`是将事件绑定在冒泡阶段的，为了保持一致，所以使用`addEventListener`时，需指定第三个参数为false，否则就添加到事件捕获阶段了。\n\n其次，不能给每个`li`绑定事件，可以利用事件的冒泡机制，故需把事件绑定到`ul`上而不是`li`上。\n\n此时要拿到真正的`li`就要读取事件(event)的真实对象(target)了，这也是一个考察点：\n\n- 在IE上，事件(event)要需要通过`window.event`获取的。\n\n- 在IE上，事件对象(event target)的值是`event.srcElement`而不是`event.target`\n\n因此绑定点击事件的完整代码是这样的：\n\n```js\nvar list = document.getElementById('list')\n\naddEvent(list, 'click', function(event){\n  event = event || window.event;\n  var target = event.target || event.srcElement;\n  \n  alert(target.innerHTML)\n})\n```\n\n### 分析鼠标移开事件\n\n其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用`mouseout`事件就完了。然而这里隐藏了一个问题：就是当鼠标移入`ul`的子元素`li`时，也会触发`mouseout`事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。\n\n然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。\n\n在现代浏览器(`chrome`，`firefox`，`safari`等等)上，我们直接用`event.relatedTarget`就可以直接获取；而在IE上则比较繁琐，`mouseout`事件有一个叫`toElement`的元素（顾名思义就是鼠标移到了哪个元素），`mouseover`事件则有一个叫`fromElement`元素。\n\n因此，我们可以这么做：\n\n```js\n addEvent(list, 'mouseout', function(event){\n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n  if(!list.contains(t)) {\n    alert('!')\n  }\n})\n```\n\n### 取消冒泡\n\n其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。\n\n因为我们没有处理`list.contains(t)`的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：\n\n－ `IE`取消冒泡的方法是`event.cancelBubble = true`\n\n- 在符合`w3c`标准的浏览器上，则是使用`event.stopPropagation()`\n\n最终的代码是这样的：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n\nvar list = document.getElementById('list');\n\naddEvent(list, 'mouseout', function(event){\n  \n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n\n  if(list.contains(t)) {\n    event.cancelBubble = true;\n    event.stopPropagation();\n  }\n  else {\n    alert('你正在离开list!')\n  }\n})\n```\n","slug":"some-summarize-about-event","published":1,"updated":"2020-05-23T06:08:56.000Z","_id":"ckxvfmfce000rbrqqd3ui3zpt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：</p>\n<span id=\"more\"></span>\n\n<p>现在有一段HTML</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>点击<code>li</code>的时候<code>alert</code>弹出<code>li</code>里面的文本内容，离开<code>ul</code>时<code>alert</code>提醒。</p>\n<p>注意，需要考虑性能和兼容性问题。</p>\n<h3 id=\"分析点击事件\"><a href=\"#分析点击事件\" class=\"headerlink\" title=\"分析点击事件\"></a>分析点击事件</h3><p>首先，大家都知道的是，在<code>IE</code>下绑定事件是使用<code>attachEvent</code>的，而不是<code>addEventListener</code>，因此可以封装一个方法来绑定事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用<code>attachEvent</code>时，事件类型都是需要加个<code>on</code>前缀的。还有就是因为<code>attachEvent</code>是将事件绑定在冒泡阶段的，为了保持一致，所以使用<code>addEventListener</code>时，需指定第三个参数为false，否则就添加到事件捕获阶段了。</p>\n<p>其次，不能给每个<code>li</code>绑定事件，可以利用事件的冒泡机制，故需把事件绑定到<code>ul</code>上而不是<code>li</code>上。</p>\n<p>此时要拿到真正的<code>li</code>就要读取事件(event)的真实对象(target)了，这也是一个考察点：</p>\n<ul>\n<li><p>在IE上，事件(event)要需要通过<code>window.event</code>获取的。</p>\n</li>\n<li><p>在IE上，事件对象(event target)的值是<code>event.srcElement</code>而不是<code>event.target</code></p>\n</li>\n</ul>\n<p>因此绑定点击事件的完整代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> target = event.target || event.srcElement;</span><br><span class=\"line\">  </span><br><span class=\"line\">  alert(target.innerHTML)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析鼠标移开事件\"><a href=\"#分析鼠标移开事件\" class=\"headerlink\" title=\"分析鼠标移开事件\"></a>分析鼠标移开事件</h3><p>其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用<code>mouseout</code>事件就完了。然而这里隐藏了一个问题：就是当鼠标移入<code>ul</code>的子元素<code>li</code>时，也会触发<code>mouseout</code>事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。</p>\n<p>然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。</p>\n<p>在现代浏览器(<code>chrome</code>，<code>firefox</code>，<code>safari</code>等等)上，我们直接用<code>event.relatedTarget</code>就可以直接获取；而在IE上则比较繁琐，<code>mouseout</code>事件有一个叫<code>toElement</code>的元素（顾名思义就是鼠标移到了哪个元素），<code>mouseover</code>事件则有一个叫<code>fromElement</code>元素。</p>\n<p>因此，我们可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!list.contains(t)) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"取消冒泡\"><a href=\"#取消冒泡\" class=\"headerlink\" title=\"取消冒泡\"></a>取消冒泡</h3><p>其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。</p>\n<p>因为我们没有处理<code>list.contains(t)</code>的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：</p>\n<p>－ <code>IE</code>取消冒泡的方法是<code>event.cancelBubble = true</code></p>\n<ul>\n<li>在符合<code>w3c</code>标准的浏览器上，则是使用<code>event.stopPropagation()</code></li>\n</ul>\n<p>最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(list.contains(t)) &#123;</span><br><span class=\"line\">    event.cancelBubble = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    event.stopPropagation();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;你正在离开list!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：</p>","more":"<p>现在有一段HTML</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>点击<code>li</code>的时候<code>alert</code>弹出<code>li</code>里面的文本内容，离开<code>ul</code>时<code>alert</code>提醒。</p>\n<p>注意，需要考虑性能和兼容性问题。</p>\n<h3 id=\"分析点击事件\"><a href=\"#分析点击事件\" class=\"headerlink\" title=\"分析点击事件\"></a>分析点击事件</h3><p>首先，大家都知道的是，在<code>IE</code>下绑定事件是使用<code>attachEvent</code>的，而不是<code>addEventListener</code>，因此可以封装一个方法来绑定事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用<code>attachEvent</code>时，事件类型都是需要加个<code>on</code>前缀的。还有就是因为<code>attachEvent</code>是将事件绑定在冒泡阶段的，为了保持一致，所以使用<code>addEventListener</code>时，需指定第三个参数为false，否则就添加到事件捕获阶段了。</p>\n<p>其次，不能给每个<code>li</code>绑定事件，可以利用事件的冒泡机制，故需把事件绑定到<code>ul</code>上而不是<code>li</code>上。</p>\n<p>此时要拿到真正的<code>li</code>就要读取事件(event)的真实对象(target)了，这也是一个考察点：</p>\n<ul>\n<li><p>在IE上，事件(event)要需要通过<code>window.event</code>获取的。</p>\n</li>\n<li><p>在IE上，事件对象(event target)的值是<code>event.srcElement</code>而不是<code>event.target</code></p>\n</li>\n</ul>\n<p>因此绑定点击事件的完整代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> target = event.target || event.srcElement;</span><br><span class=\"line\">  </span><br><span class=\"line\">  alert(target.innerHTML)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析鼠标移开事件\"><a href=\"#分析鼠标移开事件\" class=\"headerlink\" title=\"分析鼠标移开事件\"></a>分析鼠标移开事件</h3><p>其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用<code>mouseout</code>事件就完了。然而这里隐藏了一个问题：就是当鼠标移入<code>ul</code>的子元素<code>li</code>时，也会触发<code>mouseout</code>事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。</p>\n<p>然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。</p>\n<p>在现代浏览器(<code>chrome</code>，<code>firefox</code>，<code>safari</code>等等)上，我们直接用<code>event.relatedTarget</code>就可以直接获取；而在IE上则比较繁琐，<code>mouseout</code>事件有一个叫<code>toElement</code>的元素（顾名思义就是鼠标移到了哪个元素），<code>mouseover</code>事件则有一个叫<code>fromElement</code>元素。</p>\n<p>因此，我们可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!list.contains(t)) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"取消冒泡\"><a href=\"#取消冒泡\" class=\"headerlink\" title=\"取消冒泡\"></a>取消冒泡</h3><p>其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。</p>\n<p>因为我们没有处理<code>list.contains(t)</code>的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：</p>\n<p>－ <code>IE</code>取消冒泡的方法是<code>event.cancelBubble = true</code></p>\n<ul>\n<li>在符合<code>w3c</code>标准的浏览器上，则是使用<code>event.stopPropagation()</code></li>\n</ul>\n<p>最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(list.contains(t)) &#123;</span><br><span class=\"line\">    event.cancelBubble = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    event.stopPropagation();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;你正在离开list!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"多版本Node.js","date":"2016-11-03T09:06:19.000Z","desc":"Windows下安装多版本的Node.js","_content":"\n最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。\n\n然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。\n\n于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。\n\n所以我发现，拥有多版本的Node.js还是很有必要的。\n\n<!-- more -->\n\n## 开发环境\n\n#### linux / MacOs\n如果是在*nux的开发环境可以直接安装`nvm`即可\n\n#### Windows\n需要安装`nvm-window`。[github地址在此](https://github.com/coreybutler/nvm-windows)，[下载地址在此](https://github.com/coreybutler/nvm-windows/releases)\n\n在此我着重说一下`nvm-windows`需要注意的地方：\n\n- 安装`nvm-windows`之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）\n- 需要把NPM删掉(e.g. \"C:\\Users<user>\\AppData\\Roaming\\npm\")\n- 对应每个Node.js版本的全局安装方法都用重新安装，比如：\n\n```sh\nnvm use 4.0.0\nnpm install -g grunt\n\n\n#切换版本\nnvm use 7.0.0\nnpm install -g grunt\n```","source":"_posts/nvm-windows.md","raw":"---\ntitle: 多版本Node.js\ndate: 2016-11-03 17:06:19\ntags: Node.js\ndesc: Windows下安装多版本的Node.js\n---\n\n最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。\n\n然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。\n\n于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。\n\n所以我发现，拥有多版本的Node.js还是很有必要的。\n\n<!-- more -->\n\n## 开发环境\n\n#### linux / MacOs\n如果是在*nux的开发环境可以直接安装`nvm`即可\n\n#### Windows\n需要安装`nvm-window`。[github地址在此](https://github.com/coreybutler/nvm-windows)，[下载地址在此](https://github.com/coreybutler/nvm-windows/releases)\n\n在此我着重说一下`nvm-windows`需要注意的地方：\n\n- 安装`nvm-windows`之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）\n- 需要把NPM删掉(e.g. \"C:\\Users<user>\\AppData\\Roaming\\npm\")\n- 对应每个Node.js版本的全局安装方法都用重新安装，比如：\n\n```sh\nnvm use 4.0.0\nnpm install -g grunt\n\n\n#切换版本\nnvm use 7.0.0\nnpm install -g grunt\n```","slug":"nvm-windows","published":1,"updated":"2020-05-23T06:08:38.000Z","_id":"ckxvfmfcf000tbrqqh4j62d07","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。</p>\n<p>然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。</p>\n<p>于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。</p>\n<p>所以我发现，拥有多版本的Node.js还是很有必要的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><h4 id=\"linux-MacOs\"><a href=\"#linux-MacOs\" class=\"headerlink\" title=\"linux / MacOs\"></a>linux / MacOs</h4><p>如果是在*nux的开发环境可以直接安装<code>nvm</code>即可</p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>需要安装<code>nvm-window</code>。<a href=\"https://github.com/coreybutler/nvm-windows\">github地址在此</a>，<a href=\"https://github.com/coreybutler/nvm-windows/releases\">下载地址在此</a></p>\n<p>在此我着重说一下<code>nvm-windows</code>需要注意的地方：</p>\n<ul>\n<li>安装<code>nvm-windows</code>之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）</li>\n<li>需要把NPM删掉(e.g. “C:\\Users<user>\\AppData\\Roaming\\npm”)</li>\n<li>对应每个Node.js版本的全局安装方法都用重新安装，比如：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use 4.0.0</span><br><span class=\"line\">npm install -g grunt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#切换版本</span></span><br><span class=\"line\">nvm use 7.0.0</span><br><span class=\"line\">npm install -g grunt</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。</p>\n<p>然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。</p>\n<p>于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。</p>\n<p>所以我发现，拥有多版本的Node.js还是很有必要的。</p>","more":"<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><h4 id=\"linux-MacOs\"><a href=\"#linux-MacOs\" class=\"headerlink\" title=\"linux / MacOs\"></a>linux / MacOs</h4><p>如果是在*nux的开发环境可以直接安装<code>nvm</code>即可</p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>需要安装<code>nvm-window</code>。<a href=\"https://github.com/coreybutler/nvm-windows\">github地址在此</a>，<a href=\"https://github.com/coreybutler/nvm-windows/releases\">下载地址在此</a></p>\n<p>在此我着重说一下<code>nvm-windows</code>需要注意的地方：</p>\n<ul>\n<li>安装<code>nvm-windows</code>之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）</li>\n<li>需要把NPM删掉(e.g. “C:\\Users<user>\\AppData\\Roaming\\npm”)</li>\n<li>对应每个Node.js版本的全局安装方法都用重新安装，比如：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use 4.0.0</span><br><span class=\"line\">npm install -g grunt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#切换版本</span></span><br><span class=\"line\">nvm use 7.0.0</span><br><span class=\"line\">npm install -g grunt</span><br></pre></td></tr></table></figure>"},{"title":"mongodb使用记录","date":"2016-10-17T12:11:36.000Z","desc":null,"_content":"\n记录一下mongodb的使用记录，包含常用的启动、操作等命令。\n\n<!-- more -->\n\n\n## 初始化\n\n#### 文件目录\n\n```sh\n-data #数据\n+ log #日志\n  - mongod.log\n+ conf #配置文件\n  - mongod.conf\nbin #二进制目录\n```\n\n\n#### 启动的配置文件\n\n```sh\nport = 12345 #启动端口\ndbpath = data #数据路径\nlogpath = log/mongod.log #日志路径\nfork = true #表明启动的是后台进程 windows下无效\n```\n\n## 启动\n\n#### 启动数据库\n\n```sh\nmongod -f conf/mongod.conf\n```\n\n#### 连接数据库\n\n```sh\nmongo 127.0.0.1:12345/test\n```\n\n## 基本操作\n\n```sh\nshow dbs #显示所有数据库\nuse company #使用company数据库 不存在则自动创建\nshow collections #显示所有collection\nshow tables #效果同上\n```\n\n## CRUD\n\n#### 插入数据\n\n```sh\ndb.company_list.insert({name: 'one'}) # company_list为collection，不存在则自动创建，然后插入一个数据\n\nfor(i=0;i<10;i++) db.company_list.insert({name: i}) #使用js的语法插入10个数据\n```\n\n#### 查找数据\n\n```sh\ndb.company_list.find() #显示该collection的所有数据\n\ndb.company_list.find({name: 'one'}) #显示对应条件的数据\n\ndb.company_list.find().skip(2).limit(3).sort({name: 1}) #跳过前2个数据，按name排序获取3个数据\n```\n\n#### 数据更新\n\n```sh\ndb.company_list.update({x:1}, {x:1000}) #第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即{x:1,y:1} => {x:1000}）\n\ndb.company_list.update({x:1}, {$set: {x:1000}}) #只修改x字段\n\ndb.company_list.update({x:99, {y:99}, true}) #修改一个不存在的数据则插入这个数据\n\ndb.company_list.update({x:1}, {y:99}, false, true}) #批量修改多条数据\n```\n\n#### 删除数据\n\n\n```sh\ndb.company_list.remove({x:1}) #默认删除对应条件的所有数据\ndp.company_list.drop() #删除collection\n```\n\n## 索引相关\n\n```sh\ndb.company_list.getIndexes() #列出所有索引\ndb.company_list.ensureIndex({x:1}) #设置索引\n```\n\n#### 索引的类型\n\n- _id索引\n- 单键索引\n- 多键索引\n- 复合索引\n- 过期索引\n- 全文索引\n- 地理位置索引\n\n## 权限相关\n\n#### 创建用户\n\n\n```sh\ndb.createUser({\n    user: \"<name>\",\n    pwd: \"<cleartext password>\",\n    customData: {<any information},\n    roles: [{role: \"<role>\", db: \"<database>\"}]\n})\n```\n\n#### 用户类型：\n- read\n- readWrite\n- dbAdmin\n- dbOwner\n- userAdmin \n","source":"_posts/mongodb.md","raw":"---\ntitle: mongodb使用记录\ndate: 2016-10-17 20:11:36\ntags: MongoDB\ndesc:\n---\n\n记录一下mongodb的使用记录，包含常用的启动、操作等命令。\n\n<!-- more -->\n\n\n## 初始化\n\n#### 文件目录\n\n```sh\n-data #数据\n+ log #日志\n  - mongod.log\n+ conf #配置文件\n  - mongod.conf\nbin #二进制目录\n```\n\n\n#### 启动的配置文件\n\n```sh\nport = 12345 #启动端口\ndbpath = data #数据路径\nlogpath = log/mongod.log #日志路径\nfork = true #表明启动的是后台进程 windows下无效\n```\n\n## 启动\n\n#### 启动数据库\n\n```sh\nmongod -f conf/mongod.conf\n```\n\n#### 连接数据库\n\n```sh\nmongo 127.0.0.1:12345/test\n```\n\n## 基本操作\n\n```sh\nshow dbs #显示所有数据库\nuse company #使用company数据库 不存在则自动创建\nshow collections #显示所有collection\nshow tables #效果同上\n```\n\n## CRUD\n\n#### 插入数据\n\n```sh\ndb.company_list.insert({name: 'one'}) # company_list为collection，不存在则自动创建，然后插入一个数据\n\nfor(i=0;i<10;i++) db.company_list.insert({name: i}) #使用js的语法插入10个数据\n```\n\n#### 查找数据\n\n```sh\ndb.company_list.find() #显示该collection的所有数据\n\ndb.company_list.find({name: 'one'}) #显示对应条件的数据\n\ndb.company_list.find().skip(2).limit(3).sort({name: 1}) #跳过前2个数据，按name排序获取3个数据\n```\n\n#### 数据更新\n\n```sh\ndb.company_list.update({x:1}, {x:1000}) #第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即{x:1,y:1} => {x:1000}）\n\ndb.company_list.update({x:1}, {$set: {x:1000}}) #只修改x字段\n\ndb.company_list.update({x:99, {y:99}, true}) #修改一个不存在的数据则插入这个数据\n\ndb.company_list.update({x:1}, {y:99}, false, true}) #批量修改多条数据\n```\n\n#### 删除数据\n\n\n```sh\ndb.company_list.remove({x:1}) #默认删除对应条件的所有数据\ndp.company_list.drop() #删除collection\n```\n\n## 索引相关\n\n```sh\ndb.company_list.getIndexes() #列出所有索引\ndb.company_list.ensureIndex({x:1}) #设置索引\n```\n\n#### 索引的类型\n\n- _id索引\n- 单键索引\n- 多键索引\n- 复合索引\n- 过期索引\n- 全文索引\n- 地理位置索引\n\n## 权限相关\n\n#### 创建用户\n\n\n```sh\ndb.createUser({\n    user: \"<name>\",\n    pwd: \"<cleartext password>\",\n    customData: {<any information},\n    roles: [{role: \"<role>\", db: \"<database>\"}]\n})\n```\n\n#### 用户类型：\n- read\n- readWrite\n- dbAdmin\n- dbOwner\n- userAdmin \n","slug":"mongodb","published":1,"updated":"2020-05-23T06:08:33.000Z","_id":"ckxvfmfcg000ubrqqdgcc86lp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录一下mongodb的使用记录，包含常用的启动、操作等命令。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h4 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-data <span class=\"comment\">#数据</span></span><br><span class=\"line\">+ <span class=\"built_in\">log</span> <span class=\"comment\">#日志</span></span><br><span class=\"line\">  - mongod.log</span><br><span class=\"line\">+ conf <span class=\"comment\">#配置文件</span></span><br><span class=\"line\">  - mongod.conf</span><br><span class=\"line\">bin <span class=\"comment\">#二进制目录</span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"启动的配置文件\"><a href=\"#启动的配置文件\" class=\"headerlink\" title=\"启动的配置文件\"></a>启动的配置文件</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port = 12345 <span class=\"comment\">#启动端口</span></span><br><span class=\"line\">dbpath = data <span class=\"comment\">#数据路径</span></span><br><span class=\"line\">logpath = <span class=\"built_in\">log</span>/mongod.log <span class=\"comment\">#日志路径</span></span><br><span class=\"line\">fork = <span class=\"literal\">true</span> <span class=\"comment\">#表明启动的是后台进程 windows下无效</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><h4 id=\"启动数据库\"><a href=\"#启动数据库\" class=\"headerlink\" title=\"启动数据库\"></a>启动数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod -f conf/mongod.conf</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo 127.0.0.1:12345/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show dbs <span class=\"comment\">#显示所有数据库</span></span><br><span class=\"line\">use company <span class=\"comment\">#使用company数据库 不存在则自动创建</span></span><br><span class=\"line\">show collections <span class=\"comment\">#显示所有collection</span></span><br><span class=\"line\">show tables <span class=\"comment\">#效果同上</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h2><h4 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.insert(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\"># company_list为collection，不存在则自动创建，然后插入一个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=0;i&lt;10;i++) db.company_list.insert(&#123;name: i&#125;) <span class=\"comment\">#使用js的语法插入10个数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.find() <span class=\"comment\">#显示该collection的所有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\">#显示对应条件的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find().skip(2).<span class=\"built_in\">limit</span>(3).sort(&#123;name: 1&#125;) <span class=\"comment\">#跳过前2个数据，按name排序获取3个数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据更新\"><a href=\"#数据更新\" class=\"headerlink\" title=\"数据更新\"></a>数据更新</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;x:1000&#125;) <span class=\"comment\">#第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即&#123;x:1,y:1&#125; =&gt; &#123;x:1000&#125;）</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;<span class=\"variable\">$set</span>: &#123;x:1000&#125;&#125;) <span class=\"comment\">#只修改x字段</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:99, &#123;y:99&#125;, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#修改一个不存在的数据则插入这个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;y:99&#125;, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#批量修改多条数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.remove(&#123;x:1&#125;) <span class=\"comment\">#默认删除对应条件的所有数据</span></span><br><span class=\"line\">dp.company_list.drop() <span class=\"comment\">#删除collection</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引相关\"><a href=\"#索引相关\" class=\"headerlink\" title=\"索引相关\"></a>索引相关</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.getIndexes() <span class=\"comment\">#列出所有索引</span></span><br><span class=\"line\">db.company_list.ensureIndex(&#123;x:1&#125;) <span class=\"comment\">#设置索引</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h4><ul>\n<li>_id索引</li>\n<li>单键索引</li>\n<li>多键索引</li>\n<li>复合索引</li>\n<li>过期索引</li>\n<li>全文索引</li>\n<li>地理位置索引</li>\n</ul>\n<h2 id=\"权限相关\"><a href=\"#权限相关\" class=\"headerlink\" title=\"权限相关\"></a>权限相关</h2><h4 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(&#123;</span><br><span class=\"line\">    user: <span class=\"string\">&quot;&lt;name&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">pwd</span>: <span class=\"string\">&quot;&lt;cleartext password&gt;&quot;</span>,</span><br><span class=\"line\">    customData: &#123;&lt;any information&#125;,</span><br><span class=\"line\">    roles: [&#123;role: <span class=\"string\">&quot;&lt;role&gt;&quot;</span>, db: <span class=\"string\">&quot;&lt;database&gt;&quot;</span>&#125;]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用户类型：\"><a href=\"#用户类型：\" class=\"headerlink\" title=\"用户类型：\"></a>用户类型：</h4><ul>\n<li>read</li>\n<li>readWrite</li>\n<li>dbAdmin</li>\n<li>dbOwner</li>\n<li>userAdmin </li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>记录一下mongodb的使用记录，包含常用的启动、操作等命令。</p>","more":"<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h4 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-data <span class=\"comment\">#数据</span></span><br><span class=\"line\">+ <span class=\"built_in\">log</span> <span class=\"comment\">#日志</span></span><br><span class=\"line\">  - mongod.log</span><br><span class=\"line\">+ conf <span class=\"comment\">#配置文件</span></span><br><span class=\"line\">  - mongod.conf</span><br><span class=\"line\">bin <span class=\"comment\">#二进制目录</span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"启动的配置文件\"><a href=\"#启动的配置文件\" class=\"headerlink\" title=\"启动的配置文件\"></a>启动的配置文件</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port = 12345 <span class=\"comment\">#启动端口</span></span><br><span class=\"line\">dbpath = data <span class=\"comment\">#数据路径</span></span><br><span class=\"line\">logpath = <span class=\"built_in\">log</span>/mongod.log <span class=\"comment\">#日志路径</span></span><br><span class=\"line\">fork = <span class=\"literal\">true</span> <span class=\"comment\">#表明启动的是后台进程 windows下无效</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><h4 id=\"启动数据库\"><a href=\"#启动数据库\" class=\"headerlink\" title=\"启动数据库\"></a>启动数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod -f conf/mongod.conf</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo 127.0.0.1:12345/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show dbs <span class=\"comment\">#显示所有数据库</span></span><br><span class=\"line\">use company <span class=\"comment\">#使用company数据库 不存在则自动创建</span></span><br><span class=\"line\">show collections <span class=\"comment\">#显示所有collection</span></span><br><span class=\"line\">show tables <span class=\"comment\">#效果同上</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h2><h4 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.insert(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\"># company_list为collection，不存在则自动创建，然后插入一个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=0;i&lt;10;i++) db.company_list.insert(&#123;name: i&#125;) <span class=\"comment\">#使用js的语法插入10个数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.find() <span class=\"comment\">#显示该collection的所有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\">#显示对应条件的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find().skip(2).<span class=\"built_in\">limit</span>(3).sort(&#123;name: 1&#125;) <span class=\"comment\">#跳过前2个数据，按name排序获取3个数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据更新\"><a href=\"#数据更新\" class=\"headerlink\" title=\"数据更新\"></a>数据更新</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;x:1000&#125;) <span class=\"comment\">#第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即&#123;x:1,y:1&#125; =&gt; &#123;x:1000&#125;）</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;<span class=\"variable\">$set</span>: &#123;x:1000&#125;&#125;) <span class=\"comment\">#只修改x字段</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:99, &#123;y:99&#125;, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#修改一个不存在的数据则插入这个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;y:99&#125;, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#批量修改多条数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.remove(&#123;x:1&#125;) <span class=\"comment\">#默认删除对应条件的所有数据</span></span><br><span class=\"line\">dp.company_list.drop() <span class=\"comment\">#删除collection</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引相关\"><a href=\"#索引相关\" class=\"headerlink\" title=\"索引相关\"></a>索引相关</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.getIndexes() <span class=\"comment\">#列出所有索引</span></span><br><span class=\"line\">db.company_list.ensureIndex(&#123;x:1&#125;) <span class=\"comment\">#设置索引</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h4><ul>\n<li>_id索引</li>\n<li>单键索引</li>\n<li>多键索引</li>\n<li>复合索引</li>\n<li>过期索引</li>\n<li>全文索引</li>\n<li>地理位置索引</li>\n</ul>\n<h2 id=\"权限相关\"><a href=\"#权限相关\" class=\"headerlink\" title=\"权限相关\"></a>权限相关</h2><h4 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(&#123;</span><br><span class=\"line\">    user: <span class=\"string\">&quot;&lt;name&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">pwd</span>: <span class=\"string\">&quot;&lt;cleartext password&gt;&quot;</span>,</span><br><span class=\"line\">    customData: &#123;&lt;any information&#125;,</span><br><span class=\"line\">    roles: [&#123;role: <span class=\"string\">&quot;&lt;role&gt;&quot;</span>, db: <span class=\"string\">&quot;&lt;database&gt;&quot;</span>&#125;]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"用户类型：\"><a href=\"#用户类型：\" class=\"headerlink\" title=\"用户类型：\"></a>用户类型：</h4><ul>\n<li>read</li>\n<li>readWrite</li>\n<li>dbAdmin</li>\n<li>dbOwner</li>\n<li>userAdmin </li>\n</ul>"},{"title":"模块化 CommonJS VS ES6 Module","date":"2016-11-04T09:46:21.000Z","desc":null,"_content":"\n以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义\n\n<!-- more -->\n\n#### ES5方式输出模块\n\n- ES5方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:1\n```\n\n- ES5方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:1\n```\n\n#### ES6方式输出模块\n\n- ES6方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:2\n```\n\n- ES6方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:2\n```\n\n#### 总结\n\n上面的例子可以看出：\n\n- ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1\n- ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2\n\n因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用","source":"_posts/module-es6-vs-amd.md","raw":"---\ntitle: 模块化 CommonJS VS ES6 Module\ndate: 2016-11-4 17:46:21\ntags:\n- ES6\n- 模块化\ndesc:\n---\n\n以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义\n\n<!-- more -->\n\n#### ES5方式输出模块\n\n- ES5方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:1\n```\n\n- ES5方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:1\n```\n\n#### ES6方式输出模块\n\n- ES6方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:2\n```\n\n- ES6方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:2\n```\n\n#### 总结\n\n上面的例子可以看出：\n\n- ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1\n- ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2\n\n因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用","slug":"module-es6-vs-amd","published":1,"updated":"2020-05-23T06:08:26.000Z","_id":"ckxvfmfcj000xbrqq10lwerlk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义</p>\n<span id=\"more\"></span>\n\n<h4 id=\"ES5方式输出模块\"><a href=\"#ES5方式输出模块\" class=\"headerlink\" title=\"ES5方式输出模块\"></a>ES5方式输出模块</h4><ul>\n<li>ES5方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES5方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ES6方式输出模块\"><a href=\"#ES6方式输出模块\" class=\"headerlink\" title=\"ES6方式输出模块\"></a>ES6方式输出模块</h4><ul>\n<li>ES6方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>上面的例子可以看出：</p>\n<ul>\n<li>ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1</li>\n<li>ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2</li>\n</ul>\n<p>因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义</p>","more":"<h4 id=\"ES5方式输出模块\"><a href=\"#ES5方式输出模块\" class=\"headerlink\" title=\"ES5方式输出模块\"></a>ES5方式输出模块</h4><ul>\n<li>ES5方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES5方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ES6方式输出模块\"><a href=\"#ES6方式输出模块\" class=\"headerlink\" title=\"ES6方式输出模块\"></a>ES6方式输出模块</h4><ul>\n<li>ES6方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>上面的例子可以看出：</p>\n<ul>\n<li>ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1</li>\n<li>ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2</li>\n</ul>\n<p>因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用</p>"},{"title":"iOS 软键盘弹出","date":"2016-07-22T04:22:50.000Z","desc":"移动开发,软键盘弹出,iOS键盘弹出","_content":"\n移动`WEB`开发经常要遇到控制软键盘：**弹出键盘**和**收起键盘**。\n\n<!--more-->\n\n```javascript\n // 弹出键盘\n input.focus();\n\n// 收起键盘\n input.blur();\n```\n\n在`Android`上，弹出和收起都比较正常，在任何时候调用都行。\n在`iOS`则不一样，一定要有在用户有实际交互时**马上**(right now)调用`focus`或者`blur`才行。比如：\n\n```javascript\n   btn.addEventListener('click', function(){\n     input.focus(); //弹出键盘\n   }, false);\n```\n\n如果此时使用了`setTimeout`：\n\n```javascript\n   btn.addEventListener('click', function(){\n     setTimeout(function(){\n       input.focus(); //键盘是不会弹出的\n     }, 50);\n   }, false);\n```\n\n或者此时我调用`ajax`请求再`focus`也是不会弹出来的\n\n```js\n  $.ajax({\n    //...\n  })\n  .then(function(){\n    input.focus(); //键盘是不会弹出的\n  })\n```","source":"_posts/mobile-web-soft-keyboard.md","raw":"---\ntitle: iOS 软键盘弹出\ndate: 2016-07-22 12:22:50\ntags: 键盘\ndesc: 移动开发,软键盘弹出,iOS键盘弹出\n---\n\n移动`WEB`开发经常要遇到控制软键盘：**弹出键盘**和**收起键盘**。\n\n<!--more-->\n\n```javascript\n // 弹出键盘\n input.focus();\n\n// 收起键盘\n input.blur();\n```\n\n在`Android`上，弹出和收起都比较正常，在任何时候调用都行。\n在`iOS`则不一样，一定要有在用户有实际交互时**马上**(right now)调用`focus`或者`blur`才行。比如：\n\n```javascript\n   btn.addEventListener('click', function(){\n     input.focus(); //弹出键盘\n   }, false);\n```\n\n如果此时使用了`setTimeout`：\n\n```javascript\n   btn.addEventListener('click', function(){\n     setTimeout(function(){\n       input.focus(); //键盘是不会弹出的\n     }, 50);\n   }, false);\n```\n\n或者此时我调用`ajax`请求再`focus`也是不会弹出来的\n\n```js\n  $.ajax({\n    //...\n  })\n  .then(function(){\n    input.focus(); //键盘是不会弹出的\n  })\n```","slug":"mobile-web-soft-keyboard","published":1,"updated":"2020-05-23T06:13:23.000Z","_id":"ckxvfmfck000zbrqqg6j9457e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>移动<code>WEB</code>开发经常要遇到控制软键盘：<strong>弹出键盘</strong>和<strong>收起键盘</strong>。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 弹出键盘</span></span><br><span class=\"line\"> input.focus();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收起键盘</span></span><br><span class=\"line\"> input.blur();</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Android</code>上，弹出和收起都比较正常，在任何时候调用都行。<br>在<code>iOS</code>则不一样，一定要有在用户有实际交互时<strong>马上</strong>(right now)调用<code>focus</code>或者<code>blur</code>才行。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//弹出键盘</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果此时使用了<code>setTimeout</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>或者此时我调用<code>ajax</code>请求再<code>focus</code>也是不会弹出来的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>移动<code>WEB</code>开发经常要遇到控制软键盘：<strong>弹出键盘</strong>和<strong>收起键盘</strong>。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 弹出键盘</span></span><br><span class=\"line\"> input.focus();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收起键盘</span></span><br><span class=\"line\"> input.blur();</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Android</code>上，弹出和收起都比较正常，在任何时候调用都行。<br>在<code>iOS</code>则不一样，一定要有在用户有实际交互时<strong>马上</strong>(right now)调用<code>focus</code>或者<code>blur</code>才行。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//弹出键盘</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果此时使用了<code>setTimeout</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>或者此时我调用<code>ajax</code>请求再<code>focus</code>也是不会弹出来的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"正确使用JavaScript数组","date":"2017-02-20T16:08:29.000Z","desc":null,"_content":"\n\n首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。\n\n<!--more -->\n\n> “…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”\n－Luis Atencio\n\n## 循环\n\n我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。\n\n在JavaScript上至少有四五种循环的方式，其中最基础的就是`while`循环了。讲例子前，先设定一个函数和数组：\n\n```js\n// oodlify :: String -> String\nfunction oodlify(s) {\n    return s.replace(/[aeiou]/g, 'oodle');\n}\n\nconst input = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n那么，如果我们现在要使用`oodlify`函数操作一下数组里每个元素的话，如果我们使用`while`循环的话，是这样子的：\n\n```js\nlet i = 0;\nconst len = input.length;\nlet output = [];\n\nwhile (i < len) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n    i = i + 1;\n}\n```\n\n这里就有许多无谓的，但是又不得不做的工作。比如用`i`这个计数器来记住当前循环的位置，而且需要把`i`初始化成0，每次循环还要加一；比如要拿`i`和数组的长度`len`对比，这样才知道循环到什么时候停止。\n\n这时为了让清晰一点，我们可以使用JavaScript为我们提供的`for`循环：\n\n```js\nconst len = input.length;\nlet output = [];\n\nfor (let i = 0; i < len; i = i + 1) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n}\n```\n\n`for`循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。\n\n对比起`while`循环虽有一定改进，但是也会发生类似忘记给计数器`i`加一而导致死循环的情况。\n\n现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下`oodlify`函数而已。其实我们真的不想关什么计数器。\n\n因此，`ES2015`就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ `for...of`循环 ：\n\n```js\nlet output = [];\nfor (let item of input) {\n    let newItem = oodlify(item);\n    output.push(newItem);\n}\n```\n\n这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。\n\n如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。\n\n但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。\n\n## Mapping\n\n`for...of`循环的确比`for`循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如`output`数组，以及把每个操作过后的值push进去。\n\n其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：\n\n如果我们有两个数组需要使用`oodlify`函数操作的话呢？\n\n```js\nconst fellowship = [\n    'frodo',\n    'sam',\n    'gandalf',\n    'aragorn',\n    'boromir',\n    'legolas',\n    'gimli',\n];\n\nconst band = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n很明显，我们就要这样循环两个数组：\n\n```js\nlet bandoodle = [];\n\nfor (let item of band) {\n    let newItem = oodlify(item);\n    bandoodle.push(newItem);\n}\n\nlet floodleship = [];\n\nfor (let item of fellowship) {\n    let newItem = oodlify(item);\n    floodleship.push(newItem);\n}\n```\n\n这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nlet bandoodle = oodlifyArray(band);\nlet floodleship = oodlifyArray(fellowship);\n```\n\n这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？\n\n```js\nfunction izzlify(s) {\n    return s.replace(/[aeiou]+/g, 'izzle');\n}\n```\n\n这时，我们前面创建的`oodlifyArray`函数帮不了我们了。不过如果我们这时创建`izzlifyArray`函数的话，代码不就又有许多重复的部分了吗？\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nfunction izzlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = izzlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n```\n\n这两个函数是不是及其相似呢。\n\n如果此时我们将其抽象成一个模式的话呢：**我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组**。这个模式就称为`mapping`：\n\n```js\nfunction map(f, a) {\n    let output = [];\n    for (let item of a) {\n        output.push(f(item));\n    }\n    return output;\n}\n```\n\n其实我们并不需要自己手动写`mapping`函数，因为JavaScript提供了内置的`map`函数给我们使用，此时我们的代码是这样的：\n\n```js\nlet bandoodle     = band.map(oodlify);\nlet floodleship   = fellowship.map(oodlify);\nlet bandizzle     = band.map(izzlify);\nlet fellowshizzle = fellowship.map(izzlify);\n```\n\n## Reducing\n\n此时`map`是很方便了，但是并不能覆盖我们所有的循环需要。\n\n如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000},\n    {name: 'Spider-Man', strength: 25000},\n    {name: 'Hawk Eye', strength: 136},\n    {name: 'Thor', strength: 100000},\n    {name: 'Black Widow', strength: 136},\n    {name: 'Vision', strength: 5000},\n    {name: 'Scarlet Witch', strength: 60},\n    {name: 'Mystique', strength: 120},\n    {name: 'Namora', strength: 75000},\n];\n```\n\n如果我们要找到`strength`最大的那个的元素的话，使用`for...of`循环是这样的：\n\n```js\nlet strongest = {strength: 0};\nfor (hero of heroes) {\n    if (hero.strength > strongest.strength) {\n        strongest = hero;\n    }\n}\n```\n\n如果此时我们想累计一下所有的`strength`的话，循环里面就是这样的了：\n\n```js\nlet combinedStrength = 0;\nfor (hero of heroes) {\n    combinedStrength += hero.strength;\n}\n```\n\n这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：\n\n```js\nfunction greaterStrength(champion, contender) {\n    return (contender.strength > champion.strength) ? contender : champion;\n}\n\nfunction addStrength(tally, hero) {\n    return tally + hero.strength;\n}\n\n// 例子 1\nconst initialStrongest = {strength: 0};\nlet working = initialStrongest;\nfor (hero of heroes) {\n    working = greaterStrength(working, hero);\n}\nconst strongest = working;\n\n// 例子 2\nconst initialCombinedStrength = 0;\nworking = initialCombinedStrength;\nfor (hero of heroes) {\n    working = addStrength(working, hero);\n}\nconst combinedStrength = working;\n\n```\n\n此时我们可以抽象成这样一个函数：\n\n```js\nfunction reduce(f, initialVal, a) {\n    let working = initialVal;\n    for (item of a) {\n        working = f(working, item);\n    }\n    return working;\n}\n```\n\n其实这个方法JavaScript也提供了内置函数，就是`reduce`函数。这时代码是这样的：\n\n```js\nconst strongestHero = heroes.reduce(greaterStrength, {strength: 0});\nconst combinedStrength = heroes.reduce(addStrength, 0);\n```\n\n## Filtering\n\n前面的`map`函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；\n\n`reduce`则是将数组的全部值执行操作之后，最终输出一个值。\n\n如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000, sex: 'm'},\n    {name: 'Spider-Man', strength: 25000, sex: 'm'},\n    {name: 'Hawk Eye', strength: 136, sex: 'm'},\n    {name: 'Thor', strength: 100000, sex: 'm'},\n    {name: 'Black Widow', strength: 136, sex: 'f'},\n    {name: 'Vision', strength: 5000, sex: 'm'},\n    {name: 'Scarlet Witch', strength: 60, sex: 'f'},\n    {name: 'Mystique', strength: 120, sex: 'f'},\n    {name: 'Namora', strength: 75000, sex: 'f'},\n];\n```\n\n现在假设我们要做的两件事：\n\n1. 找到`sex = f`的元素\n2. 找到`strength > 500`的元素\n\n如果使用`for...of`循环的话，是这样的：\n\n```js\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (hero.sex === 'f') {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (hero.strength >= 500) {\n        superhumans.push(hero);\n    }\n}\n```\n\n由于有重复的地方，那么我们就把不同的地方抽取出来：\n\n```js\nfunction isFemaleHero(hero) {\n    return (hero.sex === 'f');\n}\n\nfunction isSuperhuman(hero) {\n    return (hero.strength >= 500);\n}\n\n\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (isFemaleHero(hero)) {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (isSuperhuman(hero)) {\n        superhumans.push(hero);\n    }\n}\n```\n\n此时就可以抽象成JavaScript内置的`filter`函数：\n\n```js\nfunction filter(predicate, arr) {\n\n    let working = [];\n\n    for (let item of arr) {\n\n        if (predicate(item)) {\n\n            working = working.concat(item);\n\n        }\n    }\n}\n\nconst femaleHeroes = filter(isFemaleHero, heroes);\nconst superhumans  = filter(isSuperhuman, heroes);\n```\n\n## Finding\n\n`filter`搞定了，那么如果我们只要找到一个元素呢。\n\n的确，我们同样可以使用`filter`函数完成这个目标，比如：\n\n```js\nfunction isBlackWidow(hero) {\n    return (hero.name === 'Black Widow');\n}\n\nconst blackWidow = heroes.filter(isBlackWidow)[0];\n```\n\n当然我们也同样会发现，这样的效率并不高。因为`filter`函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：\n\n```js\nfunction find(predicate, arr) {\n    for (let item of arr) {\n        if (predicate(item)) {\n            return item;\n        }\n    }\n}\n\nconst blackWidow = find(isBlackWidow, heroes);\n```\n\n正如大家所预期那样，JavaScript也同样提供了内置方法`find`给我们，因此我们最终的代码是这样的：\n\n```js\nconst blackWidow = heroes.find(isBlackWidow);\n```\n\n## 总结\n\n这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。\n\n现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：\n\n1. 摒弃了循环的控制结构，使代码更容易阅读。\n2. 通过使用适当的方法名称描述我们正在使用的方法。\n3. 减少了处理整个数组的问题，只需要关注我们的业务代码。\n\n在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。\n\n本文翻译自：[JavaScript Without Loops](http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email)\n\n","source":"_posts/javascript-without-loops.md","raw":"---\ntitle: 正确使用JavaScript数组\ndate: 2017-02-21 00:08:29\ntags:\n- JavaScript\n- Array\ndesc:\n---\n\n\n首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。\n\n<!--more -->\n\n> “…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”\n－Luis Atencio\n\n## 循环\n\n我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。\n\n在JavaScript上至少有四五种循环的方式，其中最基础的就是`while`循环了。讲例子前，先设定一个函数和数组：\n\n```js\n// oodlify :: String -> String\nfunction oodlify(s) {\n    return s.replace(/[aeiou]/g, 'oodle');\n}\n\nconst input = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n那么，如果我们现在要使用`oodlify`函数操作一下数组里每个元素的话，如果我们使用`while`循环的话，是这样子的：\n\n```js\nlet i = 0;\nconst len = input.length;\nlet output = [];\n\nwhile (i < len) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n    i = i + 1;\n}\n```\n\n这里就有许多无谓的，但是又不得不做的工作。比如用`i`这个计数器来记住当前循环的位置，而且需要把`i`初始化成0，每次循环还要加一；比如要拿`i`和数组的长度`len`对比，这样才知道循环到什么时候停止。\n\n这时为了让清晰一点，我们可以使用JavaScript为我们提供的`for`循环：\n\n```js\nconst len = input.length;\nlet output = [];\n\nfor (let i = 0; i < len; i = i + 1) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n}\n```\n\n`for`循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。\n\n对比起`while`循环虽有一定改进，但是也会发生类似忘记给计数器`i`加一而导致死循环的情况。\n\n现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下`oodlify`函数而已。其实我们真的不想关什么计数器。\n\n因此，`ES2015`就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ `for...of`循环 ：\n\n```js\nlet output = [];\nfor (let item of input) {\n    let newItem = oodlify(item);\n    output.push(newItem);\n}\n```\n\n这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。\n\n如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。\n\n但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。\n\n## Mapping\n\n`for...of`循环的确比`for`循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如`output`数组，以及把每个操作过后的值push进去。\n\n其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：\n\n如果我们有两个数组需要使用`oodlify`函数操作的话呢？\n\n```js\nconst fellowship = [\n    'frodo',\n    'sam',\n    'gandalf',\n    'aragorn',\n    'boromir',\n    'legolas',\n    'gimli',\n];\n\nconst band = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n很明显，我们就要这样循环两个数组：\n\n```js\nlet bandoodle = [];\n\nfor (let item of band) {\n    let newItem = oodlify(item);\n    bandoodle.push(newItem);\n}\n\nlet floodleship = [];\n\nfor (let item of fellowship) {\n    let newItem = oodlify(item);\n    floodleship.push(newItem);\n}\n```\n\n这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nlet bandoodle = oodlifyArray(band);\nlet floodleship = oodlifyArray(fellowship);\n```\n\n这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？\n\n```js\nfunction izzlify(s) {\n    return s.replace(/[aeiou]+/g, 'izzle');\n}\n```\n\n这时，我们前面创建的`oodlifyArray`函数帮不了我们了。不过如果我们这时创建`izzlifyArray`函数的话，代码不就又有许多重复的部分了吗？\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nfunction izzlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = izzlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n```\n\n这两个函数是不是及其相似呢。\n\n如果此时我们将其抽象成一个模式的话呢：**我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组**。这个模式就称为`mapping`：\n\n```js\nfunction map(f, a) {\n    let output = [];\n    for (let item of a) {\n        output.push(f(item));\n    }\n    return output;\n}\n```\n\n其实我们并不需要自己手动写`mapping`函数，因为JavaScript提供了内置的`map`函数给我们使用，此时我们的代码是这样的：\n\n```js\nlet bandoodle     = band.map(oodlify);\nlet floodleship   = fellowship.map(oodlify);\nlet bandizzle     = band.map(izzlify);\nlet fellowshizzle = fellowship.map(izzlify);\n```\n\n## Reducing\n\n此时`map`是很方便了，但是并不能覆盖我们所有的循环需要。\n\n如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000},\n    {name: 'Spider-Man', strength: 25000},\n    {name: 'Hawk Eye', strength: 136},\n    {name: 'Thor', strength: 100000},\n    {name: 'Black Widow', strength: 136},\n    {name: 'Vision', strength: 5000},\n    {name: 'Scarlet Witch', strength: 60},\n    {name: 'Mystique', strength: 120},\n    {name: 'Namora', strength: 75000},\n];\n```\n\n如果我们要找到`strength`最大的那个的元素的话，使用`for...of`循环是这样的：\n\n```js\nlet strongest = {strength: 0};\nfor (hero of heroes) {\n    if (hero.strength > strongest.strength) {\n        strongest = hero;\n    }\n}\n```\n\n如果此时我们想累计一下所有的`strength`的话，循环里面就是这样的了：\n\n```js\nlet combinedStrength = 0;\nfor (hero of heroes) {\n    combinedStrength += hero.strength;\n}\n```\n\n这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：\n\n```js\nfunction greaterStrength(champion, contender) {\n    return (contender.strength > champion.strength) ? contender : champion;\n}\n\nfunction addStrength(tally, hero) {\n    return tally + hero.strength;\n}\n\n// 例子 1\nconst initialStrongest = {strength: 0};\nlet working = initialStrongest;\nfor (hero of heroes) {\n    working = greaterStrength(working, hero);\n}\nconst strongest = working;\n\n// 例子 2\nconst initialCombinedStrength = 0;\nworking = initialCombinedStrength;\nfor (hero of heroes) {\n    working = addStrength(working, hero);\n}\nconst combinedStrength = working;\n\n```\n\n此时我们可以抽象成这样一个函数：\n\n```js\nfunction reduce(f, initialVal, a) {\n    let working = initialVal;\n    for (item of a) {\n        working = f(working, item);\n    }\n    return working;\n}\n```\n\n其实这个方法JavaScript也提供了内置函数，就是`reduce`函数。这时代码是这样的：\n\n```js\nconst strongestHero = heroes.reduce(greaterStrength, {strength: 0});\nconst combinedStrength = heroes.reduce(addStrength, 0);\n```\n\n## Filtering\n\n前面的`map`函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；\n\n`reduce`则是将数组的全部值执行操作之后，最终输出一个值。\n\n如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000, sex: 'm'},\n    {name: 'Spider-Man', strength: 25000, sex: 'm'},\n    {name: 'Hawk Eye', strength: 136, sex: 'm'},\n    {name: 'Thor', strength: 100000, sex: 'm'},\n    {name: 'Black Widow', strength: 136, sex: 'f'},\n    {name: 'Vision', strength: 5000, sex: 'm'},\n    {name: 'Scarlet Witch', strength: 60, sex: 'f'},\n    {name: 'Mystique', strength: 120, sex: 'f'},\n    {name: 'Namora', strength: 75000, sex: 'f'},\n];\n```\n\n现在假设我们要做的两件事：\n\n1. 找到`sex = f`的元素\n2. 找到`strength > 500`的元素\n\n如果使用`for...of`循环的话，是这样的：\n\n```js\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (hero.sex === 'f') {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (hero.strength >= 500) {\n        superhumans.push(hero);\n    }\n}\n```\n\n由于有重复的地方，那么我们就把不同的地方抽取出来：\n\n```js\nfunction isFemaleHero(hero) {\n    return (hero.sex === 'f');\n}\n\nfunction isSuperhuman(hero) {\n    return (hero.strength >= 500);\n}\n\n\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (isFemaleHero(hero)) {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (isSuperhuman(hero)) {\n        superhumans.push(hero);\n    }\n}\n```\n\n此时就可以抽象成JavaScript内置的`filter`函数：\n\n```js\nfunction filter(predicate, arr) {\n\n    let working = [];\n\n    for (let item of arr) {\n\n        if (predicate(item)) {\n\n            working = working.concat(item);\n\n        }\n    }\n}\n\nconst femaleHeroes = filter(isFemaleHero, heroes);\nconst superhumans  = filter(isSuperhuman, heroes);\n```\n\n## Finding\n\n`filter`搞定了，那么如果我们只要找到一个元素呢。\n\n的确，我们同样可以使用`filter`函数完成这个目标，比如：\n\n```js\nfunction isBlackWidow(hero) {\n    return (hero.name === 'Black Widow');\n}\n\nconst blackWidow = heroes.filter(isBlackWidow)[0];\n```\n\n当然我们也同样会发现，这样的效率并不高。因为`filter`函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：\n\n```js\nfunction find(predicate, arr) {\n    for (let item of arr) {\n        if (predicate(item)) {\n            return item;\n        }\n    }\n}\n\nconst blackWidow = find(isBlackWidow, heroes);\n```\n\n正如大家所预期那样，JavaScript也同样提供了内置方法`find`给我们，因此我们最终的代码是这样的：\n\n```js\nconst blackWidow = heroes.find(isBlackWidow);\n```\n\n## 总结\n\n这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。\n\n现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：\n\n1. 摒弃了循环的控制结构，使代码更容易阅读。\n2. 通过使用适当的方法名称描述我们正在使用的方法。\n3. 减少了处理整个数组的问题，只需要关注我们的业务代码。\n\n在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。\n\n本文翻译自：[JavaScript Without Loops](http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email)\n\n","slug":"javascript-without-loops","published":1,"updated":"2020-05-23T06:07:18.000Z","_id":"ckxvfmfcn0011brqqfgwtbnl0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>“…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”<br>－Luis Atencio</p>\n</blockquote>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。</p>\n<p>在JavaScript上至少有四五种循环的方式，其中最基础的就是<code>while</code>循环了。讲例子前，先设定一个函数和数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// oodlify :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]/g</span>, <span class=\"string\">&#x27;oodle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>那么，如果我们现在要使用<code>oodlify</code>函数操作一下数组里每个元素的话，如果我们使用<code>while</code>循环的话，是这样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; len) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">    i = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就有许多无谓的，但是又不得不做的工作。比如用<code>i</code>这个计数器来记住当前循环的位置，而且需要把<code>i</code>初始化成0，每次循环还要加一；比如要拿<code>i</code>和数组的长度<code>len</code>对比，这样才知道循环到什么时候停止。</p>\n<p>这时为了让清晰一点，我们可以使用JavaScript为我们提供的<code>for</code>循环：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>for</code>循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。</p>\n<p>对比起<code>while</code>循环虽有一定改进，但是也会发生类似忘记给计数器<code>i</code>加一而导致死循环的情况。</p>\n<p>现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下<code>oodlify</code>函数而已。其实我们真的不想关什么计数器。</p>\n<p>因此，<code>ES2015</code>就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ <code>for...of</code>循环 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。</p>\n<p>如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。</p>\n<p>但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。</p>\n<h2 id=\"Mapping\"><a href=\"#Mapping\" class=\"headerlink\" title=\"Mapping\"></a>Mapping</h2><p><code>for...of</code>循环的确比<code>for</code>循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如<code>output</code>数组，以及把每个操作过后的值push进去。</p>\n<p>其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：</p>\n<p>如果我们有两个数组需要使用<code>oodlify</code>函数操作的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fellowship = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;frodo&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;sam&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gandalf&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;aragorn&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;boromir&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;legolas&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gimli&#x27;</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> band = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>很明显，我们就要这样循环两个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> band) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    bandoodle.push(newItem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> fellowship) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    floodleship.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = oodlifyArray(band);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = oodlifyArray(fellowship);</span><br></pre></td></tr></table></figure>\n\n<p>这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]+/g</span>, <span class=\"string\">&#x27;izzle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时，我们前面创建的<code>oodlifyArray</code>函数帮不了我们了。不过如果我们这时创建<code>izzlifyArray</code>函数的话，代码不就又有许多重复的部分了吗？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = izzlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个函数是不是及其相似呢。</p>\n<p>如果此时我们将其抽象成一个模式的话呢：<strong>我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组</strong>。这个模式就称为<code>mapping</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">f, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        output.push(f(item));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我们并不需要自己手动写<code>mapping</code>函数，因为JavaScript提供了内置的<code>map</code>函数给我们使用，此时我们的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle     = band.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship   = fellowship.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> bandizzle     = band.map(izzlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> fellowshizzle = fellowship.map(izzlify);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reducing\"><a href=\"#Reducing\" class=\"headerlink\" title=\"Reducing\"></a>Reducing</h2><p>此时<code>map</code>是很方便了，但是并不能覆盖我们所有的循环需要。</p>\n<p>如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要找到<code>strength</code>最大的那个的元素的话，使用<code>for...of</code>循环是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt; strongest.strength) &#123;</span><br><span class=\"line\">        strongest = hero;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果此时我们想累计一下所有的<code>strength</code>的话，循环里面就是这样的了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> combinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    combinedStrength += hero.strength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greaterStrength</span>(<span class=\"params\">champion, contender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (contender.strength &gt; champion.strength) ? contender : champion;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addStrength</span>(<span class=\"params\">tally, hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tally + hero.strength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialStrongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> working = initialStrongest;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = greaterStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strongest = working;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialCombinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\">working = initialCombinedStrength;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = addStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = working;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此时我们可以抽象成这样一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">f, initialVal, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = initialVal;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        working = f(working, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> working;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这个方法JavaScript也提供了内置函数，就是<code>reduce</code>函数。这时代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> strongestHero = heroes.reduce(greaterStrength, &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = heroes.reduce(addStrength, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Filtering\"><a href=\"#Filtering\" class=\"headerlink\" title=\"Filtering\"></a>Filtering</h2><p>前面的<code>map</code>函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；</p>\n<p><code>reduce</code>则是将数组的全部值执行操作之后，最终输出一个值。</p>\n<p>如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>现在假设我们要做的两件事：</p>\n<ol>\n<li>找到<code>sex = f</code>的元素</li>\n<li>找到<code>strength &gt; 500</code>的元素</li>\n</ol>\n<p>如果使用<code>for...of</code>循环的话，是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt;= <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于有重复的地方，那么我们就把不同的地方抽取出来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFemaleHero</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSuperhuman</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.strength &gt;= <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFemaleHero(hero)) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSuperhuman(hero)) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以抽象成JavaScript内置的<code>filter</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            working = working.concat(item);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> femaleHeroes = filter(isFemaleHero, heroes);</span><br><span class=\"line\"><span class=\"keyword\">const</span> superhumans  = filter(isSuperhuman, heroes);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Finding\"><a href=\"#Finding\" class=\"headerlink\" title=\"Finding\"></a>Finding</h2><p><code>filter</code>搞定了，那么如果我们只要找到一个元素呢。</p>\n<p>的确，我们同样可以使用<code>filter</code>函数完成这个目标，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBlackWidow</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.name === <span class=\"string\">&#x27;Black Widow&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.filter(isBlackWidow)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n<p>当然我们也同样会发现，这样的效率并不高。因为<code>filter</code>函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = find(isBlackWidow, heroes);</span><br></pre></td></tr></table></figure>\n\n<p>正如大家所预期那样，JavaScript也同样提供了内置方法<code>find</code>给我们，因此我们最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.find(isBlackWidow);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。</p>\n<p>现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：</p>\n<ol>\n<li>摒弃了循环的控制结构，使代码更容易阅读。</li>\n<li>通过使用适当的方法名称描述我们正在使用的方法。</li>\n<li>减少了处理整个数组的问题，只需要关注我们的业务代码。</li>\n</ol>\n<p>在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。</p>\n<p>本文翻译自：<a href=\"http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email\">JavaScript Without Loops</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。</p>","more":"<blockquote>\n<p>“…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”<br>－Luis Atencio</p>\n</blockquote>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。</p>\n<p>在JavaScript上至少有四五种循环的方式，其中最基础的就是<code>while</code>循环了。讲例子前，先设定一个函数和数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// oodlify :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]/g</span>, <span class=\"string\">&#x27;oodle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>那么，如果我们现在要使用<code>oodlify</code>函数操作一下数组里每个元素的话，如果我们使用<code>while</code>循环的话，是这样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; len) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">    i = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就有许多无谓的，但是又不得不做的工作。比如用<code>i</code>这个计数器来记住当前循环的位置，而且需要把<code>i</code>初始化成0，每次循环还要加一；比如要拿<code>i</code>和数组的长度<code>len</code>对比，这样才知道循环到什么时候停止。</p>\n<p>这时为了让清晰一点，我们可以使用JavaScript为我们提供的<code>for</code>循环：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>for</code>循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。</p>\n<p>对比起<code>while</code>循环虽有一定改进，但是也会发生类似忘记给计数器<code>i</code>加一而导致死循环的情况。</p>\n<p>现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下<code>oodlify</code>函数而已。其实我们真的不想关什么计数器。</p>\n<p>因此，<code>ES2015</code>就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ <code>for...of</code>循环 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。</p>\n<p>如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。</p>\n<p>但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。</p>\n<h2 id=\"Mapping\"><a href=\"#Mapping\" class=\"headerlink\" title=\"Mapping\"></a>Mapping</h2><p><code>for...of</code>循环的确比<code>for</code>循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如<code>output</code>数组，以及把每个操作过后的值push进去。</p>\n<p>其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：</p>\n<p>如果我们有两个数组需要使用<code>oodlify</code>函数操作的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fellowship = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;frodo&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;sam&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gandalf&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;aragorn&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;boromir&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;legolas&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gimli&#x27;</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> band = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>很明显，我们就要这样循环两个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> band) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    bandoodle.push(newItem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> fellowship) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    floodleship.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = oodlifyArray(band);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = oodlifyArray(fellowship);</span><br></pre></td></tr></table></figure>\n\n<p>这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]+/g</span>, <span class=\"string\">&#x27;izzle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时，我们前面创建的<code>oodlifyArray</code>函数帮不了我们了。不过如果我们这时创建<code>izzlifyArray</code>函数的话，代码不就又有许多重复的部分了吗？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = izzlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个函数是不是及其相似呢。</p>\n<p>如果此时我们将其抽象成一个模式的话呢：<strong>我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组</strong>。这个模式就称为<code>mapping</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">f, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        output.push(f(item));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我们并不需要自己手动写<code>mapping</code>函数，因为JavaScript提供了内置的<code>map</code>函数给我们使用，此时我们的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle     = band.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship   = fellowship.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> bandizzle     = band.map(izzlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> fellowshizzle = fellowship.map(izzlify);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reducing\"><a href=\"#Reducing\" class=\"headerlink\" title=\"Reducing\"></a>Reducing</h2><p>此时<code>map</code>是很方便了，但是并不能覆盖我们所有的循环需要。</p>\n<p>如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要找到<code>strength</code>最大的那个的元素的话，使用<code>for...of</code>循环是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt; strongest.strength) &#123;</span><br><span class=\"line\">        strongest = hero;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果此时我们想累计一下所有的<code>strength</code>的话，循环里面就是这样的了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> combinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    combinedStrength += hero.strength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greaterStrength</span>(<span class=\"params\">champion, contender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (contender.strength &gt; champion.strength) ? contender : champion;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addStrength</span>(<span class=\"params\">tally, hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tally + hero.strength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialStrongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> working = initialStrongest;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = greaterStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strongest = working;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialCombinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\">working = initialCombinedStrength;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = addStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = working;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此时我们可以抽象成这样一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">f, initialVal, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = initialVal;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        working = f(working, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> working;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这个方法JavaScript也提供了内置函数，就是<code>reduce</code>函数。这时代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> strongestHero = heroes.reduce(greaterStrength, &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = heroes.reduce(addStrength, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Filtering\"><a href=\"#Filtering\" class=\"headerlink\" title=\"Filtering\"></a>Filtering</h2><p>前面的<code>map</code>函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；</p>\n<p><code>reduce</code>则是将数组的全部值执行操作之后，最终输出一个值。</p>\n<p>如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>现在假设我们要做的两件事：</p>\n<ol>\n<li>找到<code>sex = f</code>的元素</li>\n<li>找到<code>strength &gt; 500</code>的元素</li>\n</ol>\n<p>如果使用<code>for...of</code>循环的话，是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt;= <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于有重复的地方，那么我们就把不同的地方抽取出来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFemaleHero</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSuperhuman</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.strength &gt;= <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFemaleHero(hero)) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSuperhuman(hero)) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以抽象成JavaScript内置的<code>filter</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            working = working.concat(item);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> femaleHeroes = filter(isFemaleHero, heroes);</span><br><span class=\"line\"><span class=\"keyword\">const</span> superhumans  = filter(isSuperhuman, heroes);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Finding\"><a href=\"#Finding\" class=\"headerlink\" title=\"Finding\"></a>Finding</h2><p><code>filter</code>搞定了，那么如果我们只要找到一个元素呢。</p>\n<p>的确，我们同样可以使用<code>filter</code>函数完成这个目标，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBlackWidow</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.name === <span class=\"string\">&#x27;Black Widow&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.filter(isBlackWidow)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n<p>当然我们也同样会发现，这样的效率并不高。因为<code>filter</code>函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = find(isBlackWidow, heroes);</span><br></pre></td></tr></table></figure>\n\n<p>正如大家所预期那样，JavaScript也同样提供了内置方法<code>find</code>给我们，因此我们最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.find(isBlackWidow);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。</p>\n<p>现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：</p>\n<ol>\n<li>摒弃了循环的控制结构，使代码更容易阅读。</li>\n<li>通过使用适当的方法名称描述我们正在使用的方法。</li>\n<li>减少了处理整个数组的问题，只需要关注我们的业务代码。</li>\n</ol>\n<p>在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。</p>\n<p>本文翻译自：<a href=\"http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email\">JavaScript Without Loops</a></p>"},{"title":"总结JavaScript的检测方式","date":"2016-11-15T12:32:12.000Z","desc":["JavaScript","detect"],"_content":"\n在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。\n\n<!-- more -->\n\n我们都知道，JavaScript是有5种原始类型的：\n- number\n- string\n- boolean\n- undefined\n- null\n\n## 检测原始类型\n检测原始类型的最佳选择是使用`typeof`\n\n```js\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof undefined // undefined\n```\n\n`typeof`有一个好处就是：未声明的变量也不会报错\n```js\ntypeof someVariable //此时someVariable是未定义，返回undefined\n```\n\n## 检测复合类型\n复合类型内置有（不只以下几种，只是举例说明）：\n- Object\n- Array\n- Date\n- Error\n\n当我们使用`typeof`检测的时候，就会看到都是返回object\n\n```js\ntypeof {} //object\ntypeof [] //object\ntypeof new Date() //object\ntypeof new Error() //object\n```\n\n此时的最佳选择是使用`instanceof`\n\n```js\nvar today = new Date()\n\ntoday instanceof Date // true\n```\n\n到这里好像全部的检测类型都搞定了。\n\n但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。\n\n### 检测函数\n当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：\n\n```js\n// 在frame A定义的函数test\nfunction test(){}\n\n// 在frame B检测\ntest instanceof Function //false\n\n// 而使用typeof则可以正确返回\ntypeof test // function\n```\n\n故检测函数的时候，最佳选择是使用`typeof`\n\n### 检测数组\n数组的问题和函数是一样的，因为不同的构造函数。而此时`typeof`也不灵了，因为只返回object。\n\nDouglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：\n\n```js\nfunction isArray(value){\n  return typeof value.sort === 'function';\n}\n```\n\n其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。\n\n最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：\n\n```js\nfunction isArray(value){\n  return Object.prototype.toString.call(value) === '[object Array]' ;\n}\n```\n\n这个方法能完美地辨别是否为数组。\n\n在ECMAScript 5则可以使用Array的内置方法：\n\n```js\nArray.isArray([]) // true\n```\n\n## 检测属性\n我发现，在检测一个对象的属性是否存在的时候，常常是这样的：\n\n```js\nif(object.someProps){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != null){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != undefined){\n  //一些逻辑\n}\n```\n其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用`in`运算符：\n\n```js\nif(someProps in object){\n  //一些逻辑\n}\n```\n\n以上检测数据类型的所有方式。\n\n参考：\n《Maintainable JavaScript》\n\n\n","source":"_posts/JavaScript-detect.md","raw":"---\ntitle: 总结JavaScript的检测方式\ndate: 2016-11-15 20:32:12\ntags:\ndesc:\n- JavaScript\n- detect\n---\n\n在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。\n\n<!-- more -->\n\n我们都知道，JavaScript是有5种原始类型的：\n- number\n- string\n- boolean\n- undefined\n- null\n\n## 检测原始类型\n检测原始类型的最佳选择是使用`typeof`\n\n```js\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof undefined // undefined\n```\n\n`typeof`有一个好处就是：未声明的变量也不会报错\n```js\ntypeof someVariable //此时someVariable是未定义，返回undefined\n```\n\n## 检测复合类型\n复合类型内置有（不只以下几种，只是举例说明）：\n- Object\n- Array\n- Date\n- Error\n\n当我们使用`typeof`检测的时候，就会看到都是返回object\n\n```js\ntypeof {} //object\ntypeof [] //object\ntypeof new Date() //object\ntypeof new Error() //object\n```\n\n此时的最佳选择是使用`instanceof`\n\n```js\nvar today = new Date()\n\ntoday instanceof Date // true\n```\n\n到这里好像全部的检测类型都搞定了。\n\n但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。\n\n### 检测函数\n当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：\n\n```js\n// 在frame A定义的函数test\nfunction test(){}\n\n// 在frame B检测\ntest instanceof Function //false\n\n// 而使用typeof则可以正确返回\ntypeof test // function\n```\n\n故检测函数的时候，最佳选择是使用`typeof`\n\n### 检测数组\n数组的问题和函数是一样的，因为不同的构造函数。而此时`typeof`也不灵了，因为只返回object。\n\nDouglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：\n\n```js\nfunction isArray(value){\n  return typeof value.sort === 'function';\n}\n```\n\n其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。\n\n最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：\n\n```js\nfunction isArray(value){\n  return Object.prototype.toString.call(value) === '[object Array]' ;\n}\n```\n\n这个方法能完美地辨别是否为数组。\n\n在ECMAScript 5则可以使用Array的内置方法：\n\n```js\nArray.isArray([]) // true\n```\n\n## 检测属性\n我发现，在检测一个对象的属性是否存在的时候，常常是这样的：\n\n```js\nif(object.someProps){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != null){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != undefined){\n  //一些逻辑\n}\n```\n其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用`in`运算符：\n\n```js\nif(someProps in object){\n  //一些逻辑\n}\n```\n\n以上检测数据类型的所有方式。\n\n参考：\n《Maintainable JavaScript》\n\n\n","slug":"JavaScript-detect","published":1,"updated":"2020-05-23T06:07:03.000Z","_id":"ckxvfmfco0013brqqec1jd8zv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。</p>\n<span id=\"more\"></span>\n\n<p>我们都知道，JavaScript是有5种原始类型的：</p>\n<ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>null</li>\n</ul>\n<h2 id=\"检测原始类型\"><a href=\"#检测原始类型\" class=\"headerlink\" title=\"检测原始类型\"></a>检测原始类型</h2><p>检测原始类型的最佳选择是使用<code>typeof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p><code>typeof</code>有一个好处就是：未声明的变量也不会报错</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> someVariable <span class=\"comment\">//此时someVariable是未定义，返回undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测复合类型\"><a href=\"#检测复合类型\" class=\"headerlink\" title=\"检测复合类型\"></a>检测复合类型</h2><p>复合类型内置有（不只以下几种，只是举例说明）：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>Error</li>\n</ul>\n<p>当我们使用<code>typeof</code>检测的时候，就会看到都是返回object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>() <span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>\n\n<p>此时的最佳选择是使用<code>instanceof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">today <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里好像全部的检测类型都搞定了。</p>\n<p>但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。</p>\n<h3 id=\"检测函数\"><a href=\"#检测函数\" class=\"headerlink\" title=\"检测函数\"></a>检测函数</h3><p>当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在frame A定义的函数test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在frame B检测</span></span><br><span class=\"line\">test <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而使用typeof则可以正确返回</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<p>故检测函数的时候，最佳选择是使用<code>typeof</code></p>\n<h3 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h3><p>数组的问题和函数是一样的，因为不同的构造函数。而此时<code>typeof</code>也不灵了，因为只返回object。</p>\n<p>Douglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value.sort === <span class=\"string\">&#x27;function&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。</p>\n<p>最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) === <span class=\"string\">&#x27;[object Array]&#x27;</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法能完美地辨别是否为数组。</p>\n<p>在ECMAScript 5则可以使用Array的内置方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.isArray([]) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测属性\"><a href=\"#检测属性\" class=\"headerlink\" title=\"检测属性\"></a>检测属性</h2><p>我发现，在检测一个对象的属性是否存在的时候，常常是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用<code>in</code>运算符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(someProps <span class=\"keyword\">in</span> object)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上检测数据类型的所有方式。</p>\n<p>参考：<br>《Maintainable JavaScript》</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。</p>","more":"<p>我们都知道，JavaScript是有5种原始类型的：</p>\n<ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>null</li>\n</ul>\n<h2 id=\"检测原始类型\"><a href=\"#检测原始类型\" class=\"headerlink\" title=\"检测原始类型\"></a>检测原始类型</h2><p>检测原始类型的最佳选择是使用<code>typeof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p><code>typeof</code>有一个好处就是：未声明的变量也不会报错</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> someVariable <span class=\"comment\">//此时someVariable是未定义，返回undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测复合类型\"><a href=\"#检测复合类型\" class=\"headerlink\" title=\"检测复合类型\"></a>检测复合类型</h2><p>复合类型内置有（不只以下几种，只是举例说明）：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>Error</li>\n</ul>\n<p>当我们使用<code>typeof</code>检测的时候，就会看到都是返回object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>() <span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>\n\n<p>此时的最佳选择是使用<code>instanceof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">today <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里好像全部的检测类型都搞定了。</p>\n<p>但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。</p>\n<h3 id=\"检测函数\"><a href=\"#检测函数\" class=\"headerlink\" title=\"检测函数\"></a>检测函数</h3><p>当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在frame A定义的函数test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在frame B检测</span></span><br><span class=\"line\">test <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而使用typeof则可以正确返回</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<p>故检测函数的时候，最佳选择是使用<code>typeof</code></p>\n<h3 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h3><p>数组的问题和函数是一样的，因为不同的构造函数。而此时<code>typeof</code>也不灵了，因为只返回object。</p>\n<p>Douglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value.sort === <span class=\"string\">&#x27;function&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。</p>\n<p>最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) === <span class=\"string\">&#x27;[object Array]&#x27;</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法能完美地辨别是否为数组。</p>\n<p>在ECMAScript 5则可以使用Array的内置方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.isArray([]) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测属性\"><a href=\"#检测属性\" class=\"headerlink\" title=\"检测属性\"></a>检测属性</h2><p>我发现，在检测一个对象的属性是否存在的时候，常常是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用<code>in</code>运算符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(someProps <span class=\"keyword\">in</span> object)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上检测数据类型的所有方式。</p>\n<p>参考：<br>《Maintainable JavaScript》</p>"},{"title":"我所理解的JavaScript闭包","date":"2017-03-05T06:47:08.000Z","desc":"js闭包","_content":"\n闭包是JavaScript的一种特性，而不是函数。\n\n闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。\n\n<!--more-->\n\n## 使用场景\n\n#### 定义私有变量的时候\n\n```js\nfunction Application() {\n    var password = '123456';\n    \n    this.getPassword = function(){\n        return password;\n    }\n}\n\nvar app = new Application();\napp.getPassword();\n```\n\n`password`此时就是个私有变量，只能通过`getPassword`获取。\n\n\n## 变量作用域\n\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n\n变量的作用域无非就是两种：全局和局部（函数）。\n\nJavascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：\n\n```js\nvar color = 'blue';\n\nfunction changeColor(){\n\n    var anotherColor = 'red';\n    \n    function swapColors() {\n        var tempColor = anotherColor;\n        anotherColor = color;\n        color = tempColor;\n        \n        //这里可访问color，anotherColor和tempColor\n    }\n    \n    // 这里可访问color，anotherColor，但不能访问tempColor\n    swapColors();\n}\n\n// 这里只能访问color\nchangeColor();\n```\n\n本文主要参考：\n\n- [Private Members in JavaScript](http://www.crockford.com/javascript/private.html)\n- [学习Javascript闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)","source":"_posts/javascript-closure.md","raw":"---\ntitle: 我所理解的JavaScript闭包\ndate: 2017-03-05 14:47:08\ntags: \n- JavaScript\n- 闭包\ndesc: js闭包\n---\n\n闭包是JavaScript的一种特性，而不是函数。\n\n闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。\n\n<!--more-->\n\n## 使用场景\n\n#### 定义私有变量的时候\n\n```js\nfunction Application() {\n    var password = '123456';\n    \n    this.getPassword = function(){\n        return password;\n    }\n}\n\nvar app = new Application();\napp.getPassword();\n```\n\n`password`此时就是个私有变量，只能通过`getPassword`获取。\n\n\n## 变量作用域\n\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n\n变量的作用域无非就是两种：全局和局部（函数）。\n\nJavascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：\n\n```js\nvar color = 'blue';\n\nfunction changeColor(){\n\n    var anotherColor = 'red';\n    \n    function swapColors() {\n        var tempColor = anotherColor;\n        anotherColor = color;\n        color = tempColor;\n        \n        //这里可访问color，anotherColor和tempColor\n    }\n    \n    // 这里可访问color，anotherColor，但不能访问tempColor\n    swapColors();\n}\n\n// 这里只能访问color\nchangeColor();\n```\n\n本文主要参考：\n\n- [Private Members in JavaScript](http://www.crockford.com/javascript/private.html)\n- [学习Javascript闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)","slug":"javascript-closure","published":1,"updated":"2020-05-23T06:06:53.000Z","_id":"ckxvfmfcs0016brqq1fig8rui","comments":1,"layout":"post","photos":[],"link":"","content":"<p>闭包是JavaScript的一种特性，而不是函数。</p>\n<p>闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><h4 id=\"定义私有变量的时候\"><a href=\"#定义私有变量的时候\" class=\"headerlink\" title=\"定义私有变量的时候\"></a>定义私有变量的时候</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Application</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> password = <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.getPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Application();</span><br><span class=\"line\">app.getPassword();</span><br></pre></td></tr></table></figure>\n\n<p><code>password</code>此时就是个私有变量，只能通过<code>getPassword</code>获取。</p>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>\n<p>变量的作用域无非就是两种：全局和局部（函数）。</p>\n<p>Javascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">&#x27;blue&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> anotherColor = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColors</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tempColor = anotherColor;</span><br><span class=\"line\">        anotherColor = color;</span><br><span class=\"line\">        color = tempColor;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//这里可访问color，anotherColor和tempColor</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这里可访问color，anotherColor，但不能访问tempColor</span></span><br><span class=\"line\">    swapColors();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里只能访问color</span></span><br><span class=\"line\">changeColor();</span><br></pre></td></tr></table></figure>\n\n<p>本文主要参考：</p>\n<ul>\n<li><a href=\"http://www.crockford.com/javascript/private.html\">Private Members in JavaScript</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\">学习Javascript闭包（Closure）</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>闭包是JavaScript的一种特性，而不是函数。</p>\n<p>闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。</p>","more":"<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><h4 id=\"定义私有变量的时候\"><a href=\"#定义私有变量的时候\" class=\"headerlink\" title=\"定义私有变量的时候\"></a>定义私有变量的时候</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Application</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> password = <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.getPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Application();</span><br><span class=\"line\">app.getPassword();</span><br></pre></td></tr></table></figure>\n\n<p><code>password</code>此时就是个私有变量，只能通过<code>getPassword</code>获取。</p>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>\n<p>变量的作用域无非就是两种：全局和局部（函数）。</p>\n<p>Javascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">&#x27;blue&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> anotherColor = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColors</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tempColor = anotherColor;</span><br><span class=\"line\">        anotherColor = color;</span><br><span class=\"line\">        color = tempColor;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//这里可访问color，anotherColor和tempColor</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这里可访问color，anotherColor，但不能访问tempColor</span></span><br><span class=\"line\">    swapColors();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里只能访问color</span></span><br><span class=\"line\">changeColor();</span><br></pre></td></tr></table></figure>\n\n<p>本文主要参考：</p>\n<ul>\n<li><a href=\"http://www.crockford.com/javascript/private.html\">Private Members in JavaScript</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\">学习Javascript闭包（Closure）</a></li>\n</ul>"},{"title":"web与APP的交互","date":"2016-09-26T10:08:19.000Z","desc":"web与APP的交互,web,iOS,Andriod,addJavascriptInterface,WebViewJavascriptBridge,初始化分支","_content":"\n在移动`web`开发过程中，一定会遇到`web`端与`APP`端交互的情况。下面就来分析下，`web`端到底是如何与`APP`端实现交互的。\n\n在`APP`端，`iOS`和`Andriod`的实现方式各不一样。\n\n大家都知道，我们的`javascript`大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的`javascript`提供了`window`,`navigator`等宿主对象。\n\n<!--more-->\n\n### Andriod\n\n在`Android`上，实现的方式就和上面这种方式类似，就是在`webview`上注册一个全局变量，然后我们再`js`直接调用即可。下面即表示在全局环境下定义了一个对象`androidEnv `:\n\n```java\nwebview.addJavascriptInterface(object, \"androidEnv\");\n```\n\n#### web调用Andriod\n\n`Andriod`在`webview`这个类里面定义的方法，我们在`js`都可以直接调用，这样就实现了`web`到`Andriod`的单向交互了，例如：\n\n```js\nAndriodEnv.sayHi(); //注意：sayHi是Andriod定义的方法\n```\n\n#### Andriod调用web\n\n然后，如果我们要实现`Andriod`到`web`的单向交互呢，道理也一样。即是`js`定义一个全局的函数，然后`Andriod`就可以直接调用了：\n\n```js\nfunction globalFunc(){\n  return 'hello Andriod';\n}\n```\n\n### iOS\n\n相反在`iOS`上，则没这么方便了，需要用到一个叫`WebViewJavascriptBridge`的桥接中间件。\n\n在`js`上我们需要判断这个`bridge`是否已经注册，如果有就直接拿来使用；否则就监听一下`brideg`的变化，然后再使用。因此我们先封装好一个方法：\n\n```js\nfunction connectWebViewJavascriptBridge(callback) {\n    if (window.WebViewJavascriptBridge) {\n      callback(WebViewJavascriptBridge);\n    }\n    else {\n      document.addEventListener('WebViewJavascriptBridgeReady', function() {\n        callback(WebViewJavascriptBridge);\n      }, false);\n    };\n  }\n```\n\n之后我们用一个`callback`来处理这个`bridge`：\n\n```js\nconnectWebViewJavascriptBridge(function(bridge) {\n\n    bridge.init(function(data, responseCallback) {});\n    \n});\n```\n\n到这个时候，基础工作就做完了，接下来就是`web`与`iOS`之间的交互了。\n\n#### web调用iOS\n\n```js\nbridge.callHandler('ObjC Echo', {'key':'value'}, function responseCallback(responseData) {\n    console.log(\"JS received response:\", responseData)\n})\n```\n\n其中，`ObjC Echo`是`iOS`上的对应方法（其实并不是函数，只是一个token），`{'key':'value'}`则是`web`传到`iOS`的参数，`responseData`则是`iOS`回传的数据。\n\n这里还有另外一种方法，就是我们可以直接利用`bridge`的`send`方法，直接将所有东西都`send`过去给`iOS`即可，例如：\n\n```js\nvar param = {\n  \"functionName\" : \"share\",\n  \"params\":{\n    \"title\" : opt.title,\n    \"desc\" : opt.desc\n  }\n};\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param);\n});\n\n```\n\n`send`可以接受两个参数，第二个参数就是回调函数了：\n\n```js\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param, function(data){\n    callback(data);\n  });\n\n});\n```\n\n\n#### iOS调用web\n\n```js\nbridge.registerHandler('JS Echo', function(data, responseCallback) {\n    console.log(\"JS Echo called with:\", data)\n    responseCallback(data)\n})\n```\n\n这里的`JS Echo`则是`JS`上注册的一个方法名，当`iOS`执行玩这个方法，我们就可以马上监听到并接受到一些数据`data`，之后我们还可以执行`responseCallback`回调`iOS`告诉它我们的处理情况。\n\n### 说说js代码\n\n知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。\n\n```js\njAPP = {\n  getUserName: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  },\n\n  getUserId: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  }\n}\n```\n\n**我认为的缺点**：\n\n- 重复判断设备信息，因为设备信息可以理解成`常量`，一经获取就不会更改，所以我们可以用`初始化分支`来优化。\n\n- 重复判断是否在APP内。同样可以采用`初始化分支`来优化，也就是说不在`APP`内的话，调用的方法都不需要初始化了。\n\n- `console.log`没有意义，只有在测试环境下能有，上生产应该去除。\n\n### 优化\n\n```js\nvar ua = navigator.userAgent().toLowerCase();\nvar inIOS = !!( ua.indexOf('iphone') > -1 || ua.indexOf('ipad') > -1 );\nvar inAndriod = !!( ua.indexOf('andriod') > -1 );\nvar inAPP = !!( ua.indexOf('your APP token') > -1 );\nvar jAPP = {};\n\nif(inAPP) {\n  \n  if(inIOS) {\n    jAPP.getUserId = function(){\n      //..\n    };\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n\n  else if(inAndriod) {\n\n    jAPP.getUserId = function(){\n      //..\n    };\n\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n}\n```\n\n`初始化分支`的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。**好处**在于不用重复判断分支。\n\n如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。\n\n### 参考：\n\n> [JS与WebView交互存在的一些问题](http://www.jianshu.com/p/93cea79a2443)\n\n> [WebViewJavascriptBridge](https://github.com/marcuswestin/WebViewJavascriptBridge)","source":"_posts/interact-with-app.md","raw":"---\ntitle: web与APP的交互\ndate: 2016-09-26 18:08:19\ntags: \ndesc: web与APP的交互,web,iOS,Andriod,addJavascriptInterface,WebViewJavascriptBridge,初始化分支\n---\n\n在移动`web`开发过程中，一定会遇到`web`端与`APP`端交互的情况。下面就来分析下，`web`端到底是如何与`APP`端实现交互的。\n\n在`APP`端，`iOS`和`Andriod`的实现方式各不一样。\n\n大家都知道，我们的`javascript`大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的`javascript`提供了`window`,`navigator`等宿主对象。\n\n<!--more-->\n\n### Andriod\n\n在`Android`上，实现的方式就和上面这种方式类似，就是在`webview`上注册一个全局变量，然后我们再`js`直接调用即可。下面即表示在全局环境下定义了一个对象`androidEnv `:\n\n```java\nwebview.addJavascriptInterface(object, \"androidEnv\");\n```\n\n#### web调用Andriod\n\n`Andriod`在`webview`这个类里面定义的方法，我们在`js`都可以直接调用，这样就实现了`web`到`Andriod`的单向交互了，例如：\n\n```js\nAndriodEnv.sayHi(); //注意：sayHi是Andriod定义的方法\n```\n\n#### Andriod调用web\n\n然后，如果我们要实现`Andriod`到`web`的单向交互呢，道理也一样。即是`js`定义一个全局的函数，然后`Andriod`就可以直接调用了：\n\n```js\nfunction globalFunc(){\n  return 'hello Andriod';\n}\n```\n\n### iOS\n\n相反在`iOS`上，则没这么方便了，需要用到一个叫`WebViewJavascriptBridge`的桥接中间件。\n\n在`js`上我们需要判断这个`bridge`是否已经注册，如果有就直接拿来使用；否则就监听一下`brideg`的变化，然后再使用。因此我们先封装好一个方法：\n\n```js\nfunction connectWebViewJavascriptBridge(callback) {\n    if (window.WebViewJavascriptBridge) {\n      callback(WebViewJavascriptBridge);\n    }\n    else {\n      document.addEventListener('WebViewJavascriptBridgeReady', function() {\n        callback(WebViewJavascriptBridge);\n      }, false);\n    };\n  }\n```\n\n之后我们用一个`callback`来处理这个`bridge`：\n\n```js\nconnectWebViewJavascriptBridge(function(bridge) {\n\n    bridge.init(function(data, responseCallback) {});\n    \n});\n```\n\n到这个时候，基础工作就做完了，接下来就是`web`与`iOS`之间的交互了。\n\n#### web调用iOS\n\n```js\nbridge.callHandler('ObjC Echo', {'key':'value'}, function responseCallback(responseData) {\n    console.log(\"JS received response:\", responseData)\n})\n```\n\n其中，`ObjC Echo`是`iOS`上的对应方法（其实并不是函数，只是一个token），`{'key':'value'}`则是`web`传到`iOS`的参数，`responseData`则是`iOS`回传的数据。\n\n这里还有另外一种方法，就是我们可以直接利用`bridge`的`send`方法，直接将所有东西都`send`过去给`iOS`即可，例如：\n\n```js\nvar param = {\n  \"functionName\" : \"share\",\n  \"params\":{\n    \"title\" : opt.title,\n    \"desc\" : opt.desc\n  }\n};\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param);\n});\n\n```\n\n`send`可以接受两个参数，第二个参数就是回调函数了：\n\n```js\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param, function(data){\n    callback(data);\n  });\n\n});\n```\n\n\n#### iOS调用web\n\n```js\nbridge.registerHandler('JS Echo', function(data, responseCallback) {\n    console.log(\"JS Echo called with:\", data)\n    responseCallback(data)\n})\n```\n\n这里的`JS Echo`则是`JS`上注册的一个方法名，当`iOS`执行玩这个方法，我们就可以马上监听到并接受到一些数据`data`，之后我们还可以执行`responseCallback`回调`iOS`告诉它我们的处理情况。\n\n### 说说js代码\n\n知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。\n\n```js\njAPP = {\n  getUserName: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  },\n\n  getUserId: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  }\n}\n```\n\n**我认为的缺点**：\n\n- 重复判断设备信息，因为设备信息可以理解成`常量`，一经获取就不会更改，所以我们可以用`初始化分支`来优化。\n\n- 重复判断是否在APP内。同样可以采用`初始化分支`来优化，也就是说不在`APP`内的话，调用的方法都不需要初始化了。\n\n- `console.log`没有意义，只有在测试环境下能有，上生产应该去除。\n\n### 优化\n\n```js\nvar ua = navigator.userAgent().toLowerCase();\nvar inIOS = !!( ua.indexOf('iphone') > -1 || ua.indexOf('ipad') > -1 );\nvar inAndriod = !!( ua.indexOf('andriod') > -1 );\nvar inAPP = !!( ua.indexOf('your APP token') > -1 );\nvar jAPP = {};\n\nif(inAPP) {\n  \n  if(inIOS) {\n    jAPP.getUserId = function(){\n      //..\n    };\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n\n  else if(inAndriod) {\n\n    jAPP.getUserId = function(){\n      //..\n    };\n\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n}\n```\n\n`初始化分支`的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。**好处**在于不用重复判断分支。\n\n如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。\n\n### 参考：\n\n> [JS与WebView交互存在的一些问题](http://www.jianshu.com/p/93cea79a2443)\n\n> [WebViewJavascriptBridge](https://github.com/marcuswestin/WebViewJavascriptBridge)","slug":"interact-with-app","published":1,"updated":"2020-05-23T06:13:51.000Z","_id":"ckxvfmfct0017brqq83n24pwy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在移动<code>web</code>开发过程中，一定会遇到<code>web</code>端与<code>APP</code>端交互的情况。下面就来分析下，<code>web</code>端到底是如何与<code>APP</code>端实现交互的。</p>\n<p>在<code>APP</code>端，<code>iOS</code>和<code>Andriod</code>的实现方式各不一样。</p>\n<p>大家都知道，我们的<code>javascript</code>大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的<code>javascript</code>提供了<code>window</code>,<code>navigator</code>等宿主对象。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Andriod\"><a href=\"#Andriod\" class=\"headerlink\" title=\"Andriod\"></a>Andriod</h3><p>在<code>Android</code>上，实现的方式就和上面这种方式类似，就是在<code>webview</code>上注册一个全局变量，然后我们再<code>js</code>直接调用即可。下面即表示在全局环境下定义了一个对象<code>androidEnv </code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webview.addJavascriptInterface(object, <span class=\"string\">&quot;androidEnv&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"web调用Andriod\"><a href=\"#web调用Andriod\" class=\"headerlink\" title=\"web调用Andriod\"></a>web调用Andriod</h4><p><code>Andriod</code>在<code>webview</code>这个类里面定义的方法，我们在<code>js</code>都可以直接调用，这样就实现了<code>web</code>到<code>Andriod</code>的单向交互了，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AndriodEnv.sayHi(); <span class=\"comment\">//注意：sayHi是Andriod定义的方法</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Andriod调用web\"><a href=\"#Andriod调用web\" class=\"headerlink\" title=\"Andriod调用web\"></a>Andriod调用web</h4><p>然后，如果我们要实现<code>Andriod</code>到<code>web</code>的单向交互呢，道理也一样。即是<code>js</code>定义一个全局的函数，然后<code>Andriod</code>就可以直接调用了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">globalFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello Andriod&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p>相反在<code>iOS</code>上，则没这么方便了，需要用到一个叫<code>WebViewJavascriptBridge</code>的桥接中间件。</p>\n<p>在<code>js</code>上我们需要判断这个<code>bridge</code>是否已经注册，如果有就直接拿来使用；否则就监听一下<code>brideg</code>的变化，然后再使用。因此我们先封装好一个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connectWebViewJavascriptBridge</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class=\"line\">      callback(WebViewJavascriptBridge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">&#x27;WebViewJavascriptBridgeReady&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(WebViewJavascriptBridge);</span><br><span class=\"line\">      &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后我们用一个<code>callback</code>来处理这个<code>bridge</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    bridge.init(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>到这个时候，基础工作就做完了，接下来就是<code>web</code>与<code>iOS</code>之间的交互了。</p>\n<h4 id=\"web调用iOS\"><a href=\"#web调用iOS\" class=\"headerlink\" title=\"web调用iOS\"></a>web调用iOS</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.callHandler(<span class=\"string\">&#x27;ObjC Echo&#x27;</span>, &#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">responseCallback</span>(<span class=\"params\">responseData</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS received response:&quot;</span>, responseData)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>ObjC Echo</code>是<code>iOS</code>上的对应方法（其实并不是函数，只是一个token），<code>&#123;&#39;key&#39;:&#39;value&#39;&#125;</code>则是<code>web</code>传到<code>iOS</code>的参数，<code>responseData</code>则是<code>iOS</code>回传的数据。</p>\n<p>这里还有另外一种方法，就是我们可以直接利用<code>bridge</code>的<code>send</code>方法，直接将所有东西都<code>send</code>过去给<code>iOS</code>即可，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> param = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;functionName&quot;</span> : <span class=\"string\">&quot;share&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;params&quot;</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;title&quot;</span> : opt.title,</span><br><span class=\"line\">    <span class=\"string\">&quot;desc&quot;</span> : opt.desc</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>send</code>可以接受两个参数，第二个参数就是回调函数了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    callback(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"iOS调用web\"><a href=\"#iOS调用web\" class=\"headerlink\" title=\"iOS调用web\"></a>iOS调用web</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.registerHandler(<span class=\"string\">&#x27;JS Echo&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS Echo called with:&quot;</span>, data)</span><br><span class=\"line\">    responseCallback(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>JS Echo</code>则是<code>JS</code>上注册的一个方法名，当<code>iOS</code>执行玩这个方法，我们就可以马上监听到并接受到一些数据<code>data</code>，之后我们还可以执行<code>responseCallback</code>回调<code>iOS</code>告诉它我们的处理情况。</p>\n<h3 id=\"说说js代码\"><a href=\"#说说js代码\" class=\"headerlink\" title=\"说说js代码\"></a>说说js代码</h3><p>知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jAPP = &#123;</span><br><span class=\"line\">  <span class=\"attr\">getUserName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">getUserId</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我认为的缺点</strong>：</p>\n<ul>\n<li><p>重复判断设备信息，因为设备信息可以理解成<code>常量</code>，一经获取就不会更改，所以我们可以用<code>初始化分支</code>来优化。</p>\n</li>\n<li><p>重复判断是否在APP内。同样可以采用<code>初始化分支</code>来优化，也就是说不在<code>APP</code>内的话，调用的方法都不需要初始化了。</p>\n</li>\n<li><p><code>console.log</code>没有意义，只有在测试环境下能有，上生产应该去除。</p>\n</li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ua = navigator.userAgent().toLowerCase();</span><br><span class=\"line\"><span class=\"keyword\">var</span> inIOS = !!( ua.indexOf(<span class=\"string\">&#x27;iphone&#x27;</span>) &gt; -<span class=\"number\">1</span> || ua.indexOf(<span class=\"string\">&#x27;ipad&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAndriod = !!( ua.indexOf(<span class=\"string\">&#x27;andriod&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAPP = !!( ua.indexOf(<span class=\"string\">&#x27;your APP token&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> jAPP = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(inIOS) &#123;</span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(inAndriod) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>初始化分支</code>的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。<strong>好处</strong>在于不用重复判断分支。</p>\n<p>如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。</p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><blockquote>\n<p><a href=\"http://www.jianshu.com/p/93cea79a2443\">JS与WebView交互存在的一些问题</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/marcuswestin/WebViewJavascriptBridge\">WebViewJavascriptBridge</a></p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在移动<code>web</code>开发过程中，一定会遇到<code>web</code>端与<code>APP</code>端交互的情况。下面就来分析下，<code>web</code>端到底是如何与<code>APP</code>端实现交互的。</p>\n<p>在<code>APP</code>端，<code>iOS</code>和<code>Andriod</code>的实现方式各不一样。</p>\n<p>大家都知道，我们的<code>javascript</code>大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的<code>javascript</code>提供了<code>window</code>,<code>navigator</code>等宿主对象。</p>","more":"<h3 id=\"Andriod\"><a href=\"#Andriod\" class=\"headerlink\" title=\"Andriod\"></a>Andriod</h3><p>在<code>Android</code>上，实现的方式就和上面这种方式类似，就是在<code>webview</code>上注册一个全局变量，然后我们再<code>js</code>直接调用即可。下面即表示在全局环境下定义了一个对象<code>androidEnv </code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webview.addJavascriptInterface(object, <span class=\"string\">&quot;androidEnv&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"web调用Andriod\"><a href=\"#web调用Andriod\" class=\"headerlink\" title=\"web调用Andriod\"></a>web调用Andriod</h4><p><code>Andriod</code>在<code>webview</code>这个类里面定义的方法，我们在<code>js</code>都可以直接调用，这样就实现了<code>web</code>到<code>Andriod</code>的单向交互了，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AndriodEnv.sayHi(); <span class=\"comment\">//注意：sayHi是Andriod定义的方法</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Andriod调用web\"><a href=\"#Andriod调用web\" class=\"headerlink\" title=\"Andriod调用web\"></a>Andriod调用web</h4><p>然后，如果我们要实现<code>Andriod</code>到<code>web</code>的单向交互呢，道理也一样。即是<code>js</code>定义一个全局的函数，然后<code>Andriod</code>就可以直接调用了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">globalFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello Andriod&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p>相反在<code>iOS</code>上，则没这么方便了，需要用到一个叫<code>WebViewJavascriptBridge</code>的桥接中间件。</p>\n<p>在<code>js</code>上我们需要判断这个<code>bridge</code>是否已经注册，如果有就直接拿来使用；否则就监听一下<code>brideg</code>的变化，然后再使用。因此我们先封装好一个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connectWebViewJavascriptBridge</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class=\"line\">      callback(WebViewJavascriptBridge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">&#x27;WebViewJavascriptBridgeReady&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(WebViewJavascriptBridge);</span><br><span class=\"line\">      &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后我们用一个<code>callback</code>来处理这个<code>bridge</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    bridge.init(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>到这个时候，基础工作就做完了，接下来就是<code>web</code>与<code>iOS</code>之间的交互了。</p>\n<h4 id=\"web调用iOS\"><a href=\"#web调用iOS\" class=\"headerlink\" title=\"web调用iOS\"></a>web调用iOS</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.callHandler(<span class=\"string\">&#x27;ObjC Echo&#x27;</span>, &#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">responseCallback</span>(<span class=\"params\">responseData</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS received response:&quot;</span>, responseData)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>ObjC Echo</code>是<code>iOS</code>上的对应方法（其实并不是函数，只是一个token），<code>&#123;&#39;key&#39;:&#39;value&#39;&#125;</code>则是<code>web</code>传到<code>iOS</code>的参数，<code>responseData</code>则是<code>iOS</code>回传的数据。</p>\n<p>这里还有另外一种方法，就是我们可以直接利用<code>bridge</code>的<code>send</code>方法，直接将所有东西都<code>send</code>过去给<code>iOS</code>即可，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> param = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;functionName&quot;</span> : <span class=\"string\">&quot;share&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;params&quot;</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;title&quot;</span> : opt.title,</span><br><span class=\"line\">    <span class=\"string\">&quot;desc&quot;</span> : opt.desc</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>send</code>可以接受两个参数，第二个参数就是回调函数了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    callback(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"iOS调用web\"><a href=\"#iOS调用web\" class=\"headerlink\" title=\"iOS调用web\"></a>iOS调用web</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.registerHandler(<span class=\"string\">&#x27;JS Echo&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS Echo called with:&quot;</span>, data)</span><br><span class=\"line\">    responseCallback(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>JS Echo</code>则是<code>JS</code>上注册的一个方法名，当<code>iOS</code>执行玩这个方法，我们就可以马上监听到并接受到一些数据<code>data</code>，之后我们还可以执行<code>responseCallback</code>回调<code>iOS</code>告诉它我们的处理情况。</p>\n<h3 id=\"说说js代码\"><a href=\"#说说js代码\" class=\"headerlink\" title=\"说说js代码\"></a>说说js代码</h3><p>知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jAPP = &#123;</span><br><span class=\"line\">  <span class=\"attr\">getUserName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">getUserId</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我认为的缺点</strong>：</p>\n<ul>\n<li><p>重复判断设备信息，因为设备信息可以理解成<code>常量</code>，一经获取就不会更改，所以我们可以用<code>初始化分支</code>来优化。</p>\n</li>\n<li><p>重复判断是否在APP内。同样可以采用<code>初始化分支</code>来优化，也就是说不在<code>APP</code>内的话，调用的方法都不需要初始化了。</p>\n</li>\n<li><p><code>console.log</code>没有意义，只有在测试环境下能有，上生产应该去除。</p>\n</li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ua = navigator.userAgent().toLowerCase();</span><br><span class=\"line\"><span class=\"keyword\">var</span> inIOS = !!( ua.indexOf(<span class=\"string\">&#x27;iphone&#x27;</span>) &gt; -<span class=\"number\">1</span> || ua.indexOf(<span class=\"string\">&#x27;ipad&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAndriod = !!( ua.indexOf(<span class=\"string\">&#x27;andriod&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAPP = !!( ua.indexOf(<span class=\"string\">&#x27;your APP token&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> jAPP = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(inIOS) &#123;</span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(inAndriod) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>初始化分支</code>的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。<strong>好处</strong>在于不用重复判断分支。</p>\n<p>如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。</p>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><blockquote>\n<p><a href=\"http://www.jianshu.com/p/93cea79a2443\">JS与WebView交互存在的一些问题</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/marcuswestin/WebViewJavascriptBridge\">WebViewJavascriptBridge</a></p>\n</blockquote>"},{"title":"使用HTML发送邮件","date":"2016-09-12T04:25:25.000Z","desc":"HTML发邮件,使用mailto协议","_content":"\n最近项目上的需求是在`HTML`上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。\n\n<!--more-->\n\n## 使用方法\n\n- 直接用`a`标签，然后`href`属性设置协议为`mailto`即可。然后后面可以跟一些参数\n\n```html\n  <a href=\"mailto:xxx@qq.com?subject=这是标题&cc=这是抄送&body=这是正文内容\">发送邮件</a>\n```\n\n- 其实和上面的方法差不多，不过是换了提交的方式，就是使用`form`表单，然后在`form`的`action`属性设置协议`mailto`即可。\n\n```html\n  <form action=\"mailto:xxx@qq.com\" method=\"get\">\n    <input type=\"text\" name=\"cc\" value=\"这是抄送\">\n    <input type=\"text\" name=\"subject\" value=\"这是标题\">\n    <textarea name=\"body\" cols=\"30\" rows=\"10\">这是内容</textarea>\n    <button type=\"submit\">发送邮件</button>\n  </form>\n```\n\n- 如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：\n\n```html\n  <a href=\"mailto:xxx@qq.com,yyy@qq.com\">发送邮件</a>\n```\n\n## 存在的问题\n\n很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。\n\n由于需求的问题，需要自由输入邮件的内容，所有就没使用`a`标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：\n\n1. 在`textarea`的内容格式提交到邮件系统就乱了（换行什么的丢失了）\n\n2. 在`ios`上出现的问题：点击发送的时候，`safari`浏览器提示“这是一张不安全的表单”。\n\n**分析**：\n\n出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用`encodeURIComponent`编码一下`textarea`的内容即可。\n\n出现问题2：则是因为在生产上，我们是使用`https`协议的，如果表单提交到`mailto`这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉`form`表单的提交，自己使用`location.href`跳转（与此同时编码一下`textarea`的内容，则完美解决以上两个问题），这时就类似`a`标签的方式了。（其实这个时候倒不如使用`a`标签提交）\n\n## 无法解决的问题\n\n- 在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）\n\n\n\n\n## 参考\n\n- [HTML的电子邮件链接标签mailto用法详解](http://www.5icool.org/a/201003/308.html)","source":"_posts/html-send-email.md","raw":"---\ntitle: 使用HTML发送邮件\ndate: 2016-09-12 12:25:25\ntags:\n- HTML\ndesc: HTML发邮件,使用mailto协议\n---\n\n最近项目上的需求是在`HTML`上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。\n\n<!--more-->\n\n## 使用方法\n\n- 直接用`a`标签，然后`href`属性设置协议为`mailto`即可。然后后面可以跟一些参数\n\n```html\n  <a href=\"mailto:xxx@qq.com?subject=这是标题&cc=这是抄送&body=这是正文内容\">发送邮件</a>\n```\n\n- 其实和上面的方法差不多，不过是换了提交的方式，就是使用`form`表单，然后在`form`的`action`属性设置协议`mailto`即可。\n\n```html\n  <form action=\"mailto:xxx@qq.com\" method=\"get\">\n    <input type=\"text\" name=\"cc\" value=\"这是抄送\">\n    <input type=\"text\" name=\"subject\" value=\"这是标题\">\n    <textarea name=\"body\" cols=\"30\" rows=\"10\">这是内容</textarea>\n    <button type=\"submit\">发送邮件</button>\n  </form>\n```\n\n- 如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：\n\n```html\n  <a href=\"mailto:xxx@qq.com,yyy@qq.com\">发送邮件</a>\n```\n\n## 存在的问题\n\n很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。\n\n由于需求的问题，需要自由输入邮件的内容，所有就没使用`a`标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：\n\n1. 在`textarea`的内容格式提交到邮件系统就乱了（换行什么的丢失了）\n\n2. 在`ios`上出现的问题：点击发送的时候，`safari`浏览器提示“这是一张不安全的表单”。\n\n**分析**：\n\n出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用`encodeURIComponent`编码一下`textarea`的内容即可。\n\n出现问题2：则是因为在生产上，我们是使用`https`协议的，如果表单提交到`mailto`这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉`form`表单的提交，自己使用`location.href`跳转（与此同时编码一下`textarea`的内容，则完美解决以上两个问题），这时就类似`a`标签的方式了。（其实这个时候倒不如使用`a`标签提交）\n\n## 无法解决的问题\n\n- 在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）\n\n\n\n\n## 参考\n\n- [HTML的电子邮件链接标签mailto用法详解](http://www.5icool.org/a/201003/308.html)","slug":"html-send-email","published":1,"updated":"2020-05-23T06:16:13.000Z","_id":"ckxvfmfcu0019brqq7iygg312","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近项目上的需求是在<code>HTML</code>上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><ul>\n<li>直接用<code>a</code>标签，然后<code>href</code>属性设置协议为<code>mailto</code>即可。然后后面可以跟一些参数</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com?subject=这是标题&amp;cc=这是抄送&amp;body=这是正文内容&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其实和上面的方法差不多，不过是换了提交的方式，就是使用<code>form</code>表单，然后在<code>form</code>的<code>action</code>属性设置协议<code>mailto</code>即可。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;mailto:xxx@qq.com&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;get&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cc&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是抄送&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;subject&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是标题&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;body&quot;</span> <span class=\"attr\">cols</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">rows</span>=<span class=\"string\">&quot;10&quot;</span>&gt;</span>这是内容<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com,yyy@qq.com&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><p>很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。</p>\n<p>由于需求的问题，需要自由输入邮件的内容，所有就没使用<code>a</code>标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：</p>\n<ol>\n<li><p>在<code>textarea</code>的内容格式提交到邮件系统就乱了（换行什么的丢失了）</p>\n</li>\n<li><p>在<code>ios</code>上出现的问题：点击发送的时候，<code>safari</code>浏览器提示“这是一张不安全的表单”。</p>\n</li>\n</ol>\n<p><strong>分析</strong>：</p>\n<p>出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用<code>encodeURIComponent</code>编码一下<code>textarea</code>的内容即可。</p>\n<p>出现问题2：则是因为在生产上，我们是使用<code>https</code>协议的，如果表单提交到<code>mailto</code>这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉<code>form</code>表单的提交，自己使用<code>location.href</code>跳转（与此同时编码一下<code>textarea</code>的内容，则完美解决以上两个问题），这时就类似<code>a</code>标签的方式了。（其实这个时候倒不如使用<code>a</code>标签提交）</p>\n<h2 id=\"无法解决的问题\"><a href=\"#无法解决的问题\" class=\"headerlink\" title=\"无法解决的问题\"></a>无法解决的问题</h2><ul>\n<li>在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.5icool.org/a/201003/308.html\">HTML的电子邮件链接标签mailto用法详解</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>最近项目上的需求是在<code>HTML</code>上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。</p>","more":"<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><ul>\n<li>直接用<code>a</code>标签，然后<code>href</code>属性设置协议为<code>mailto</code>即可。然后后面可以跟一些参数</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com?subject=这是标题&amp;cc=这是抄送&amp;body=这是正文内容&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其实和上面的方法差不多，不过是换了提交的方式，就是使用<code>form</code>表单，然后在<code>form</code>的<code>action</code>属性设置协议<code>mailto</code>即可。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;mailto:xxx@qq.com&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;get&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cc&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是抄送&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;subject&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是标题&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;body&quot;</span> <span class=\"attr\">cols</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">rows</span>=<span class=\"string\">&quot;10&quot;</span>&gt;</span>这是内容<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com,yyy@qq.com&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><p>很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。</p>\n<p>由于需求的问题，需要自由输入邮件的内容，所有就没使用<code>a</code>标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：</p>\n<ol>\n<li><p>在<code>textarea</code>的内容格式提交到邮件系统就乱了（换行什么的丢失了）</p>\n</li>\n<li><p>在<code>ios</code>上出现的问题：点击发送的时候，<code>safari</code>浏览器提示“这是一张不安全的表单”。</p>\n</li>\n</ol>\n<p><strong>分析</strong>：</p>\n<p>出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用<code>encodeURIComponent</code>编码一下<code>textarea</code>的内容即可。</p>\n<p>出现问题2：则是因为在生产上，我们是使用<code>https</code>协议的，如果表单提交到<code>mailto</code>这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉<code>form</code>表单的提交，自己使用<code>location.href</code>跳转（与此同时编码一下<code>textarea</code>的内容，则完美解决以上两个问题），这时就类似<code>a</code>标签的方式了。（其实这个时候倒不如使用<code>a</code>标签提交）</p>\n<h2 id=\"无法解决的问题\"><a href=\"#无法解决的问题\" class=\"headerlink\" title=\"无法解决的问题\"></a>无法解决的问题</h2><ul>\n<li>在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.5icool.org/a/201003/308.html\">HTML的电子邮件链接标签mailto用法详解</a></li>\n</ul>"},{"title":"如果使用Node.js的Buffers","date":"2017-10-06T09:14:44.000Z","desc":null,"from":"https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers/","_content":"\n# 为什么要有Buffers？\n\n在纯`JavaScript`开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让`JavaScript`需要处理纯二进制数据了。\n\n其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。\n\n所以，记住了，别使用二进制字符串(binary strings)，用**buffers**代替它！\n\n# 什么是Buffers？\n\n在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。\n\n每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。\n\n> 另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)\n\n# 在哪里可以看到buffers\n\n一般情况，buffer经常可以在读取二进制数据流的时候看到，比如`fs.createReadStream`\n\n## 用法：\n\n### 创建buffer\n\n有许多方法可以生成新的buffers：\n\n```js\nvar buffer = new Buffer(8);\n```\n\n> 这个buffer是未初始化的，且包含8个字节(bytes)。\n\n```\nvar buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);\n```\n\n这个buffer用一个数组的内容来初始化。记住了，**数组里的数字表示的是字节(bytes)**\n\n```\nvar buffer = new Buffer(\"I'm a string!\", \"utf-8\")\n```\n\n通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：\n\n- \"ascii\"：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。\n- \"ucs2\"：一种双字节，小端存储的编码。可以编码一个unicode的子集。\n- \"base64\"：Base64字符串编码。\n- \"binary\"：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。\n\n### 写入buffer\n\n#### 创建一个buffer：\n\n```js\n> var buffer = new Buffer(16);\n```\n\n开始写入字符串：\n\n```\n> buffer.write(\"Hello\", \"utf-8\")\n5\n```\n\n`buffer.write`的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。\n\n`buffer.write`返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：\n\n```js\n> buffer.write(\" world!\", 5, \"utf-8\")\n7\n```\n\n当`buffer.write`有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。\n\n### 读取buffer\n\n#### toString：\n\n这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：\n\n```js\n> buffer.toString('utf-8')\n'Hello world!\\u0000�k\\t'\n```\n\n再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：\n\n```js\n> buffer.toString(\"utf-8\", 0, 12)\n'Hello world!'\n```\n\n#### 独立字节：\n\n你可以看到用类似数组的语法来设置独立位(individual bits)\n\n```js\n> buffer[12] = buffer[11];\n33\n> buffer[13] = \"1\".charCodeAt();\n49\n> buffer[14] = buffer[13];\n49\n> buffer[15] = 33\n33\n> buffer.toString(\"utf-8\")\n'Hello world!!11!'\n```\n\n在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。\n\n## 更多有趣用法\n\n### Buffer.isBuffer(object)\n\n这个方法是检测一个对象是否是buffer，类似于`Array.isArray`\n\n### Buffer.byteLength(string, encoding)\n\n通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：\n\n```js\n> var snowman = \"☃\";\n> snowman.length\n1\n> Buffer.byteLength(snowman)\n3\n```\n\n这个unicode的雪人只有两个字符，却占了3个字节。\n\n### buffer.length\n\n这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：\n\n```js\n> var buffer = new Buffer(16)\n> buffer.write(snowman)\n3\n> buffer.length\n16\n```\n\n在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。\n\n### buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n`buffer.copy`允许拷贝一个buffer的内容到另一个buffer。\n\n第一个参数表示**目标buffer**，就是要写入内容的buffer。\n\n另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：\n\n```js\n> var frosty = new Buffer(24)\n> var snowman = new Buffer(\"☃\", \"utf-8\")\n> frosty.write(\"Happy birthday! \", \"utf-8\")\n16\n> snowman.copy(frosty, 16)\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ☃'\n```\n\n在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。\n\n其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。\n\n### buffer.slice(start, end=buffer.length)\n\n这个方法的API可以说和`Array.prototype.slice`是一样的。\n\n不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：\n\n```js\n> var puddle = frosty.slice(16, 19)\n> puddle.toString()\n'☃'\n> puddle.write(\"___\")\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ___'\n```\n\n完。\n\n\n\n","source":"_posts/how-to-use-buffers.md","raw":"---\ntitle: 如果使用Node.js的Buffers\ndate: 2017-10-06 17:14:44\ntags: \n- Node.js\n- Buffers\ndesc: \nfrom: https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers/\n---\n\n# 为什么要有Buffers？\n\n在纯`JavaScript`开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让`JavaScript`需要处理纯二进制数据了。\n\n其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。\n\n所以，记住了，别使用二进制字符串(binary strings)，用**buffers**代替它！\n\n# 什么是Buffers？\n\n在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。\n\n每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。\n\n> 另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)\n\n# 在哪里可以看到buffers\n\n一般情况，buffer经常可以在读取二进制数据流的时候看到，比如`fs.createReadStream`\n\n## 用法：\n\n### 创建buffer\n\n有许多方法可以生成新的buffers：\n\n```js\nvar buffer = new Buffer(8);\n```\n\n> 这个buffer是未初始化的，且包含8个字节(bytes)。\n\n```\nvar buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);\n```\n\n这个buffer用一个数组的内容来初始化。记住了，**数组里的数字表示的是字节(bytes)**\n\n```\nvar buffer = new Buffer(\"I'm a string!\", \"utf-8\")\n```\n\n通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：\n\n- \"ascii\"：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。\n- \"ucs2\"：一种双字节，小端存储的编码。可以编码一个unicode的子集。\n- \"base64\"：Base64字符串编码。\n- \"binary\"：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。\n\n### 写入buffer\n\n#### 创建一个buffer：\n\n```js\n> var buffer = new Buffer(16);\n```\n\n开始写入字符串：\n\n```\n> buffer.write(\"Hello\", \"utf-8\")\n5\n```\n\n`buffer.write`的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。\n\n`buffer.write`返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：\n\n```js\n> buffer.write(\" world!\", 5, \"utf-8\")\n7\n```\n\n当`buffer.write`有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。\n\n### 读取buffer\n\n#### toString：\n\n这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：\n\n```js\n> buffer.toString('utf-8')\n'Hello world!\\u0000�k\\t'\n```\n\n再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：\n\n```js\n> buffer.toString(\"utf-8\", 0, 12)\n'Hello world!'\n```\n\n#### 独立字节：\n\n你可以看到用类似数组的语法来设置独立位(individual bits)\n\n```js\n> buffer[12] = buffer[11];\n33\n> buffer[13] = \"1\".charCodeAt();\n49\n> buffer[14] = buffer[13];\n49\n> buffer[15] = 33\n33\n> buffer.toString(\"utf-8\")\n'Hello world!!11!'\n```\n\n在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。\n\n## 更多有趣用法\n\n### Buffer.isBuffer(object)\n\n这个方法是检测一个对象是否是buffer，类似于`Array.isArray`\n\n### Buffer.byteLength(string, encoding)\n\n通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：\n\n```js\n> var snowman = \"☃\";\n> snowman.length\n1\n> Buffer.byteLength(snowman)\n3\n```\n\n这个unicode的雪人只有两个字符，却占了3个字节。\n\n### buffer.length\n\n这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：\n\n```js\n> var buffer = new Buffer(16)\n> buffer.write(snowman)\n3\n> buffer.length\n16\n```\n\n在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。\n\n### buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n`buffer.copy`允许拷贝一个buffer的内容到另一个buffer。\n\n第一个参数表示**目标buffer**，就是要写入内容的buffer。\n\n另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：\n\n```js\n> var frosty = new Buffer(24)\n> var snowman = new Buffer(\"☃\", \"utf-8\")\n> frosty.write(\"Happy birthday! \", \"utf-8\")\n16\n> snowman.copy(frosty, 16)\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ☃'\n```\n\n在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。\n\n其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。\n\n### buffer.slice(start, end=buffer.length)\n\n这个方法的API可以说和`Array.prototype.slice`是一样的。\n\n不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：\n\n```js\n> var puddle = frosty.slice(16, 19)\n> puddle.toString()\n'☃'\n> puddle.write(\"___\")\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ___'\n```\n\n完。\n\n\n\n","slug":"how-to-use-buffers","published":1,"updated":"2020-05-23T06:05:36.000Z","_id":"ckxvfmfd0001bbrqqbo8mbgqt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"为什么要有Buffers？\"><a href=\"#为什么要有Buffers？\" class=\"headerlink\" title=\"为什么要有Buffers？\"></a>为什么要有Buffers？</h1><p>在纯<code>JavaScript</code>开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让<code>JavaScript</code>需要处理纯二进制数据了。</p>\n<p>其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。</p>\n<p>所以，记住了，别使用二进制字符串(binary strings)，用<strong>buffers</strong>代替它！</p>\n<h1 id=\"什么是Buffers？\"><a href=\"#什么是Buffers？\" class=\"headerlink\" title=\"什么是Buffers？\"></a>什么是Buffers？</h1><p>在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。</p>\n<p>每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。</p>\n<blockquote>\n<p>另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)</p>\n</blockquote>\n<h1 id=\"在哪里可以看到buffers\"><a href=\"#在哪里可以看到buffers\" class=\"headerlink\" title=\"在哪里可以看到buffers\"></a>在哪里可以看到buffers</h1><p>一般情况，buffer经常可以在读取二进制数据流的时候看到，比如<code>fs.createReadStream</code></p>\n<h2 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h2><h3 id=\"创建buffer\"><a href=\"#创建buffer\" class=\"headerlink\" title=\"创建buffer\"></a>创建buffer</h3><p>有许多方法可以生成新的buffers：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个buffer是未初始化的，且包含8个字节(bytes)。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);</span><br></pre></td></tr></table></figure>\n\n<p>这个buffer用一个数组的内容来初始化。记住了，<strong>数组里的数字表示的是字节(bytes)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer(&quot;I&#x27;m a string!&quot;, &quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：</p>\n<ul>\n<li>“ascii”：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。</li>\n<li>“ucs2”：一种双字节，小端存储的编码。可以编码一个unicode的子集。</li>\n<li>“base64”：Base64字符串编码。</li>\n<li>“binary”：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。</li>\n</ul>\n<h3 id=\"写入buffer\"><a href=\"#写入buffer\" class=\"headerlink\" title=\"写入buffer\"></a>写入buffer</h3><h4 id=\"创建一个buffer：\"><a href=\"#创建一个buffer：\" class=\"headerlink\" title=\"创建一个buffer：\"></a>创建一个buffer：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>开始写入字符串：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(&quot;Hello&quot;, &quot;utf-8&quot;)</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><code>buffer.write</code>的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。</p>\n<p><code>buffer.write</code>返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(<span class=\"string\">&quot; world!&quot;</span>, <span class=\"number\">5</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>buffer.write</code>有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。</p>\n<h3 id=\"读取buffer\"><a href=\"#读取buffer\" class=\"headerlink\" title=\"读取buffer\"></a>读取buffer</h3><h4 id=\"toString：\"><a href=\"#toString：\" class=\"headerlink\" title=\"toString：\"></a>toString：</h4><p>这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!\\u0000�k\\t&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"独立字节：\"><a href=\"#独立字节：\" class=\"headerlink\" title=\"独立字节：\"></a>独立字节：</h4><p>你可以看到用类似数组的语法来设置独立位(individual bits)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer[<span class=\"number\">12</span>] = buffer[<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">13</span>] = <span class=\"string\">&quot;1&quot;</span>.charCodeAt();</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">14</span>] = buffer[<span class=\"number\">13</span>];</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">15</span>] = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!!11!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。</p>\n<h2 id=\"更多有趣用法\"><a href=\"#更多有趣用法\" class=\"headerlink\" title=\"更多有趣用法\"></a>更多有趣用法</h2><h3 id=\"Buffer-isBuffer-object\"><a href=\"#Buffer-isBuffer-object\" class=\"headerlink\" title=\"Buffer.isBuffer(object)\"></a>Buffer.isBuffer(object)</h3><p>这个方法是检测一个对象是否是buffer，类似于<code>Array.isArray</code></p>\n<h3 id=\"Buffer-byteLength-string-encoding\"><a href=\"#Buffer-byteLength-string-encoding\" class=\"headerlink\" title=\"Buffer.byteLength(string, encoding)\"></a>Buffer.byteLength(string, encoding)</h3><p>通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"string\">&quot;☃&quot;</span>;</span><br><span class=\"line\">&gt; snowman.length</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">&gt; Buffer.byteLength(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>这个unicode的雪人只有两个字符，却占了3个字节。</p>\n<h3 id=\"buffer-length\"><a href=\"#buffer-length\" class=\"headerlink\" title=\"buffer.length\"></a>buffer.length</h3><p>这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>)</span><br><span class=\"line\">&gt; buffer.write(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; buffer.length</span><br><span class=\"line\"><span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。</p>\n<h3 id=\"buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\"><a href=\"#buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\" class=\"headerlink\" title=\"buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\"></a>buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</h3><p><code>buffer.copy</code>允许拷贝一个buffer的内容到另一个buffer。</p>\n<p>第一个参数表示<strong>目标buffer</strong>，就是要写入内容的buffer。</p>\n<p>另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> frosty = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">24</span>)</span><br><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">&quot;☃&quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\">&gt; frosty.write(<span class=\"string\">&quot;Happy birthday! &quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">16</span></span><br><span class=\"line\">&gt; snowman.copy(frosty, <span class=\"number\">16</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ☃&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。</p>\n<p>其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。</p>\n<h3 id=\"buffer-slice-start-end-buffer-length\"><a href=\"#buffer-slice-start-end-buffer-length\" class=\"headerlink\" title=\"buffer.slice(start, end=buffer.length)\"></a>buffer.slice(start, end=buffer.length)</h3><p>这个方法的API可以说和<code>Array.prototype.slice</code>是一样的。</p>\n<p>不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> puddle = frosty.slice(<span class=\"number\">16</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\">&gt; puddle.toString()</span><br><span class=\"line\"><span class=\"string\">&#x27;☃&#x27;</span></span><br><span class=\"line\">&gt; puddle.write(<span class=\"string\">&quot;___&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ___&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>完。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h1 id=\"为什么要有Buffers？\"><a href=\"#为什么要有Buffers？\" class=\"headerlink\" title=\"为什么要有Buffers？\"></a>为什么要有Buffers？</h1><p>在纯<code>JavaScript</code>开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让<code>JavaScript</code>需要处理纯二进制数据了。</p>\n<p>其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。</p>\n<p>所以，记住了，别使用二进制字符串(binary strings)，用<strong>buffers</strong>代替它！</p>\n<h1 id=\"什么是Buffers？\"><a href=\"#什么是Buffers？\" class=\"headerlink\" title=\"什么是Buffers？\"></a>什么是Buffers？</h1><p>在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。</p>\n<p>每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。</p>\n<blockquote>\n<p>另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)</p>\n</blockquote>\n<h1 id=\"在哪里可以看到buffers\"><a href=\"#在哪里可以看到buffers\" class=\"headerlink\" title=\"在哪里可以看到buffers\"></a>在哪里可以看到buffers</h1><p>一般情况，buffer经常可以在读取二进制数据流的时候看到，比如<code>fs.createReadStream</code></p>\n<h2 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h2><h3 id=\"创建buffer\"><a href=\"#创建buffer\" class=\"headerlink\" title=\"创建buffer\"></a>创建buffer</h3><p>有许多方法可以生成新的buffers：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个buffer是未初始化的，且包含8个字节(bytes)。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);</span><br></pre></td></tr></table></figure>\n\n<p>这个buffer用一个数组的内容来初始化。记住了，<strong>数组里的数字表示的是字节(bytes)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer(&quot;I&#x27;m a string!&quot;, &quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：</p>\n<ul>\n<li>“ascii”：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。</li>\n<li>“ucs2”：一种双字节，小端存储的编码。可以编码一个unicode的子集。</li>\n<li>“base64”：Base64字符串编码。</li>\n<li>“binary”：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。</li>\n</ul>\n<h3 id=\"写入buffer\"><a href=\"#写入buffer\" class=\"headerlink\" title=\"写入buffer\"></a>写入buffer</h3><h4 id=\"创建一个buffer：\"><a href=\"#创建一个buffer：\" class=\"headerlink\" title=\"创建一个buffer：\"></a>创建一个buffer：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>开始写入字符串：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(&quot;Hello&quot;, &quot;utf-8&quot;)</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><code>buffer.write</code>的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。</p>\n<p><code>buffer.write</code>返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(<span class=\"string\">&quot; world!&quot;</span>, <span class=\"number\">5</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>buffer.write</code>有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。</p>\n<h3 id=\"读取buffer\"><a href=\"#读取buffer\" class=\"headerlink\" title=\"读取buffer\"></a>读取buffer</h3><h4 id=\"toString：\"><a href=\"#toString：\" class=\"headerlink\" title=\"toString：\"></a>toString：</h4><p>这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!\\u0000�k\\t&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"独立字节：\"><a href=\"#独立字节：\" class=\"headerlink\" title=\"独立字节：\"></a>独立字节：</h4><p>你可以看到用类似数组的语法来设置独立位(individual bits)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer[<span class=\"number\">12</span>] = buffer[<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">13</span>] = <span class=\"string\">&quot;1&quot;</span>.charCodeAt();</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">14</span>] = buffer[<span class=\"number\">13</span>];</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">15</span>] = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!!11!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。</p>\n<h2 id=\"更多有趣用法\"><a href=\"#更多有趣用法\" class=\"headerlink\" title=\"更多有趣用法\"></a>更多有趣用法</h2><h3 id=\"Buffer-isBuffer-object\"><a href=\"#Buffer-isBuffer-object\" class=\"headerlink\" title=\"Buffer.isBuffer(object)\"></a>Buffer.isBuffer(object)</h3><p>这个方法是检测一个对象是否是buffer，类似于<code>Array.isArray</code></p>\n<h3 id=\"Buffer-byteLength-string-encoding\"><a href=\"#Buffer-byteLength-string-encoding\" class=\"headerlink\" title=\"Buffer.byteLength(string, encoding)\"></a>Buffer.byteLength(string, encoding)</h3><p>通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"string\">&quot;☃&quot;</span>;</span><br><span class=\"line\">&gt; snowman.length</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">&gt; Buffer.byteLength(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>这个unicode的雪人只有两个字符，却占了3个字节。</p>\n<h3 id=\"buffer-length\"><a href=\"#buffer-length\" class=\"headerlink\" title=\"buffer.length\"></a>buffer.length</h3><p>这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>)</span><br><span class=\"line\">&gt; buffer.write(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; buffer.length</span><br><span class=\"line\"><span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。</p>\n<h3 id=\"buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\"><a href=\"#buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\" class=\"headerlink\" title=\"buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\"></a>buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</h3><p><code>buffer.copy</code>允许拷贝一个buffer的内容到另一个buffer。</p>\n<p>第一个参数表示<strong>目标buffer</strong>，就是要写入内容的buffer。</p>\n<p>另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> frosty = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">24</span>)</span><br><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">&quot;☃&quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\">&gt; frosty.write(<span class=\"string\">&quot;Happy birthday! &quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">16</span></span><br><span class=\"line\">&gt; snowman.copy(frosty, <span class=\"number\">16</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ☃&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。</p>\n<p>其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。</p>\n<h3 id=\"buffer-slice-start-end-buffer-length\"><a href=\"#buffer-slice-start-end-buffer-length\" class=\"headerlink\" title=\"buffer.slice(start, end=buffer.length)\"></a>buffer.slice(start, end=buffer.length)</h3><p>这个方法的API可以说和<code>Array.prototype.slice</code>是一样的。</p>\n<p>不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> puddle = frosty.slice(<span class=\"number\">16</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\">&gt; puddle.toString()</span><br><span class=\"line\"><span class=\"string\">&#x27;☃&#x27;</span></span><br><span class=\"line\">&gt; puddle.write(<span class=\"string\">&quot;___&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ___&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>完。</p>\n"},{"title":"操作浏览器历史 HTML5 History API","date":"2016-07-05T13:16:18.000Z","desc":"html5,history api,历史API,操作历史记录","_content":"\n在`DOM`中，`window`对象中有一个`history`的对象可以用来访问浏览器的历史记录，在`HTML5`中，更可以通过它来操作历史记录\n\n<!--more-->\n\n### 以前的API\n\n历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）\n\n```js\n  history.forward(); //前进\n  history.back(); //后退\n```\n\n移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）\n\n```js\n  history.go(-1) //相当于history.back();\n  history.go(1) //相当于history.forward();\n```\n\n其中，`history`有一个`length`的属性，就是历史记录的长度\n\n```js\n  var historyLength = history.length;\n```\n\n## 更强大的HTML5 Histroy API\n\n- `history.pushState()`\n- `history.replaceState()`\n两个方法配合`window.onpopstate`事件使用更佳。\n\n其中，`pushState()`方法接受三个参数\n- 状态对象（state obejct）即一个可序列化的`javascript`对象，与新历史记录相关联。可以使用`history.state`读取当前历史记录相关的数据对象。\n- 标题（title）目前暂时会忽略这个参数，以后可能会用上。\n- 地址（URL）新的历史记录的地址。\n\n举个例子，假设我们现在打开的是index.html\n\n```js\n  var stateObj = { country: 'China' };\n  setTimeout(function(){\n    history.pushState(stateObj, 'china', 'china.html');\n  }, 1000);\n```\n\n页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的`history.state`就是`stateObj`的拷贝，此时我们就可以利用这个数据来进行相关的操作了。\n如果此时我们点击后退，则URL变成index.html，此时`history.state=null`\n\n说到这里，你应该会有点困惑，好像这个`API`并没什么卵用，直接用`hash`配合`window.onhashchange`就可以做到啦，类似如下\n\n```js\n  location.href = 'www.someURL.com#/china.html?country=china';\n```\n\n上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应`伪URL`的相关的数据。\n\n不过对比而言，`pushState`也有它的优势：\n\n- 使用`hash`的方式时，如果当前`hash`的值不变（即url='www.someURL.com#foo'时，设置location.href = 'www.someURL.com#foo'），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同 url 时则会创建新的历史记录。\n- 绑定相关数据时，`history.state`可以说是可以绑定任意数据，而基于`hash`的方式则要把所有数据转换成相关的字符串\n\n`replaceState()`使用方法和`pushState()`基本一致。不同的是，`replaceState()`方法会修改当前历史记录而不是创建新的历史记录\n\n相关DEMO，敬请期待。。。","source":"_posts/h5-history-api.md","raw":"---\ntitle: 操作浏览器历史 HTML5 History API\ndate: 2016-07-05 21:16:18\ntags: History API\ndesc: html5,history api,历史API,操作历史记录\n---\n\n在`DOM`中，`window`对象中有一个`history`的对象可以用来访问浏览器的历史记录，在`HTML5`中，更可以通过它来操作历史记录\n\n<!--more-->\n\n### 以前的API\n\n历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）\n\n```js\n  history.forward(); //前进\n  history.back(); //后退\n```\n\n移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）\n\n```js\n  history.go(-1) //相当于history.back();\n  history.go(1) //相当于history.forward();\n```\n\n其中，`history`有一个`length`的属性，就是历史记录的长度\n\n```js\n  var historyLength = history.length;\n```\n\n## 更强大的HTML5 Histroy API\n\n- `history.pushState()`\n- `history.replaceState()`\n两个方法配合`window.onpopstate`事件使用更佳。\n\n其中，`pushState()`方法接受三个参数\n- 状态对象（state obejct）即一个可序列化的`javascript`对象，与新历史记录相关联。可以使用`history.state`读取当前历史记录相关的数据对象。\n- 标题（title）目前暂时会忽略这个参数，以后可能会用上。\n- 地址（URL）新的历史记录的地址。\n\n举个例子，假设我们现在打开的是index.html\n\n```js\n  var stateObj = { country: 'China' };\n  setTimeout(function(){\n    history.pushState(stateObj, 'china', 'china.html');\n  }, 1000);\n```\n\n页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的`history.state`就是`stateObj`的拷贝，此时我们就可以利用这个数据来进行相关的操作了。\n如果此时我们点击后退，则URL变成index.html，此时`history.state=null`\n\n说到这里，你应该会有点困惑，好像这个`API`并没什么卵用，直接用`hash`配合`window.onhashchange`就可以做到啦，类似如下\n\n```js\n  location.href = 'www.someURL.com#/china.html?country=china';\n```\n\n上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应`伪URL`的相关的数据。\n\n不过对比而言，`pushState`也有它的优势：\n\n- 使用`hash`的方式时，如果当前`hash`的值不变（即url='www.someURL.com#foo'时，设置location.href = 'www.someURL.com#foo'），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同 url 时则会创建新的历史记录。\n- 绑定相关数据时，`history.state`可以说是可以绑定任意数据，而基于`hash`的方式则要把所有数据转换成相关的字符串\n\n`replaceState()`使用方法和`pushState()`基本一致。不同的是，`replaceState()`方法会修改当前历史记录而不是创建新的历史记录\n\n相关DEMO，敬请期待。。。","slug":"h5-history-api","published":1,"updated":"2020-05-23T06:01:14.000Z","_id":"ckxvfmfd3001ebrqqb3f43pj5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在<code>DOM</code>中，<code>window</code>对象中有一个<code>history</code>的对象可以用来访问浏览器的历史记录，在<code>HTML5</code>中，更可以通过它来操作历史记录</p>\n<span id=\"more\"></span>\n\n<h3 id=\"以前的API\"><a href=\"#以前的API\" class=\"headerlink\" title=\"以前的API\"></a>以前的API</h3><p>历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.forward(); <span class=\"comment\">//前进</span></span><br><span class=\"line\">history.back(); <span class=\"comment\">//后退</span></span><br></pre></td></tr></table></figure>\n\n<p>移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.back();</span></span><br><span class=\"line\">history.go(<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.forward();</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>history</code>有一个<code>length</code>的属性，就是历史记录的长度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> historyLength = history.length;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更强大的HTML5-Histroy-API\"><a href=\"#更强大的HTML5-Histroy-API\" class=\"headerlink\" title=\"更强大的HTML5 Histroy API\"></a>更强大的HTML5 Histroy API</h2><ul>\n<li><code>history.pushState()</code></li>\n<li><code>history.replaceState()</code><br>两个方法配合<code>window.onpopstate</code>事件使用更佳。</li>\n</ul>\n<p>其中，<code>pushState()</code>方法接受三个参数</p>\n<ul>\n<li>状态对象（state obejct）即一个可序列化的<code>javascript</code>对象，与新历史记录相关联。可以使用<code>history.state</code>读取当前历史记录相关的数据对象。</li>\n<li>标题（title）目前暂时会忽略这个参数，以后可能会用上。</li>\n<li>地址（URL）新的历史记录的地址。</li>\n</ul>\n<p>举个例子，假设我们现在打开的是index.html</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stateObj = &#123; <span class=\"attr\">country</span>: <span class=\"string\">&#x27;China&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  history.pushState(stateObj, <span class=\"string\">&#x27;china&#x27;</span>, <span class=\"string\">&#x27;china.html&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的<code>history.state</code>就是<code>stateObj</code>的拷贝，此时我们就可以利用这个数据来进行相关的操作了。<br>如果此时我们点击后退，则URL变成index.html，此时<code>history.state=null</code></p>\n<p>说到这里，你应该会有点困惑，好像这个<code>API</code>并没什么卵用，直接用<code>hash</code>配合<code>window.onhashchange</code>就可以做到啦，类似如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location.href = <span class=\"string\">&#x27;www.someURL.com#/china.html?country=china&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应<code>伪URL</code>的相关的数据。</p>\n<p>不过对比而言，<code>pushState</code>也有它的优势：</p>\n<ul>\n<li>使用<code>hash</code>的方式时，如果当前<code>hash</code>的值不变（即url=’<a href=\"http://www.someurl.com/#foo&#39;%E6%97%B6%EF%BC%8C%E8%AE%BE%E7%BD%AElocation.href\">www.someURL.com#foo&#39;时，设置location.href</a> = ‘<a href=\"http://www.someurl.com/#foo&#39;%EF%BC%89%EF%BC%8C%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%EF%BC%8C%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%60onhashchange%60%E4%BA%8B%E4%BB%B6%E7%9A%84%EF%BC%8C%E8%80%8C%60history.pushState%60%E6%8F%92%E5%85%A5%E7%9B%B8%E5%90%8C\">www.someURL.com#foo&#39;），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同</a> url 时则会创建新的历史记录。</li>\n<li>绑定相关数据时，<code>history.state</code>可以说是可以绑定任意数据，而基于<code>hash</code>的方式则要把所有数据转换成相关的字符串</li>\n</ul>\n<p><code>replaceState()</code>使用方法和<code>pushState()</code>基本一致。不同的是，<code>replaceState()</code>方法会修改当前历史记录而不是创建新的历史记录</p>\n<p>相关DEMO，敬请期待。。。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在<code>DOM</code>中，<code>window</code>对象中有一个<code>history</code>的对象可以用来访问浏览器的历史记录，在<code>HTML5</code>中，更可以通过它来操作历史记录</p>","more":"<h3 id=\"以前的API\"><a href=\"#以前的API\" class=\"headerlink\" title=\"以前的API\"></a>以前的API</h3><p>历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.forward(); <span class=\"comment\">//前进</span></span><br><span class=\"line\">history.back(); <span class=\"comment\">//后退</span></span><br></pre></td></tr></table></figure>\n\n<p>移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.back();</span></span><br><span class=\"line\">history.go(<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.forward();</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>history</code>有一个<code>length</code>的属性，就是历史记录的长度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> historyLength = history.length;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更强大的HTML5-Histroy-API\"><a href=\"#更强大的HTML5-Histroy-API\" class=\"headerlink\" title=\"更强大的HTML5 Histroy API\"></a>更强大的HTML5 Histroy API</h2><ul>\n<li><code>history.pushState()</code></li>\n<li><code>history.replaceState()</code><br>两个方法配合<code>window.onpopstate</code>事件使用更佳。</li>\n</ul>\n<p>其中，<code>pushState()</code>方法接受三个参数</p>\n<ul>\n<li>状态对象（state obejct）即一个可序列化的<code>javascript</code>对象，与新历史记录相关联。可以使用<code>history.state</code>读取当前历史记录相关的数据对象。</li>\n<li>标题（title）目前暂时会忽略这个参数，以后可能会用上。</li>\n<li>地址（URL）新的历史记录的地址。</li>\n</ul>\n<p>举个例子，假设我们现在打开的是index.html</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stateObj = &#123; <span class=\"attr\">country</span>: <span class=\"string\">&#x27;China&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  history.pushState(stateObj, <span class=\"string\">&#x27;china&#x27;</span>, <span class=\"string\">&#x27;china.html&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的<code>history.state</code>就是<code>stateObj</code>的拷贝，此时我们就可以利用这个数据来进行相关的操作了。<br>如果此时我们点击后退，则URL变成index.html，此时<code>history.state=null</code></p>\n<p>说到这里，你应该会有点困惑，好像这个<code>API</code>并没什么卵用，直接用<code>hash</code>配合<code>window.onhashchange</code>就可以做到啦，类似如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location.href = <span class=\"string\">&#x27;www.someURL.com#/china.html?country=china&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应<code>伪URL</code>的相关的数据。</p>\n<p>不过对比而言，<code>pushState</code>也有它的优势：</p>\n<ul>\n<li>使用<code>hash</code>的方式时，如果当前<code>hash</code>的值不变（即url=’<a href=\"http://www.someurl.com/#foo&#39;%E6%97%B6%EF%BC%8C%E8%AE%BE%E7%BD%AElocation.href\">www.someURL.com#foo&#39;时，设置location.href</a> = ‘<a href=\"http://www.someurl.com/#foo&#39;%EF%BC%89%EF%BC%8C%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%EF%BC%8C%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%60onhashchange%60%E4%BA%8B%E4%BB%B6%E7%9A%84%EF%BC%8C%E8%80%8C%60history.pushState%60%E6%8F%92%E5%85%A5%E7%9B%B8%E5%90%8C\">www.someURL.com#foo&#39;），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同</a> url 时则会创建新的历史记录。</li>\n<li>绑定相关数据时，<code>history.state</code>可以说是可以绑定任意数据，而基于<code>hash</code>的方式则要把所有数据转换成相关的字符串</li>\n</ul>\n<p><code>replaceState()</code>使用方法和<code>pushState()</code>基本一致。不同的是，<code>replaceState()</code>方法会修改当前历史记录而不是创建新的历史记录</p>\n<p>相关DEMO，敬请期待。。。</p>"},{"title":"开始拥抱gulp","date":"2016-09-23T04:17:53.000Z","desc":"getting-started-with-gulp,gulp,grunt,gulpfile,gruntfile","from":"https://markgoodyear.com/2014/01/getting-started-with-gulp/","_content":"\n前端工作流中常用的构建工具除了`grunt`，还有一个`gulp`(当然现在还有`webpack`)。`gulp`是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于`nodejs`流的构建工具，而且执行很快。\n\n<!--more-->\n\n既然有了`grunt`，为啥还要来学习`gulp`呢？这是一个好问题，用过`grunt`的都知道，每次写`Gruntfile.js`的时候，都要先写一大片的配置文件，而`gulp`和`grunt`最大的差别在于，`gulp`是执行代码覆盖配置的。这样的好处在于，`gulpfile.js`很容易写，而且阅读起来清晰明了，并且容易维护。\n\n`gulp`使用`node.js`的流(stream)，这让`gulp`构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看[这篇文章](https://github.com/substack/stream-handbook)（写得很好）\n\n`gulp`允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像`grunt`那样，为每一个`grunt`都写一些配置信息和输入输出路径。让我们看下使用`grunt`和`gulp`写的`Sass`编译：\n\n\n**Grunt**:\n\n```js\nsass: {\n  dist: {\n    options: {\n      style: 'expanded'\n    },\n    files: {\n      'dist/assets/css/main.css': 'src/styles/main.scss',\n    }\n  }\n},\n\nautoprefixer: {\n  dist: {\n    options: {\n      browsers: [\n        'last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'\n      ]\n    },\n    src: 'dist/assets/css/main.css',\n    dest: 'dist/assets/css/main.css'\n  }\n},\n\ngrunt.registerTask('styles', ['sass', 'autoprefixer']);\n```\n\n`Grunt`需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到`Sass`插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给`Autoprefixer`输入，然后我们再将文件输出保存起来。\n\n**gulp**:\n\n```js\ngulp.task('sass', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n});\n```\n\n使用`gulp`的时候，我们只需要输入一个文件，然后经过`Sass`插件修改，然后经过`Autoprefixer`插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。\n\n### 安装Gulp\n\n在我们钻研配置任务信息之前，我们需要安装`gulp`：\n\n```\n$ npm install gulp -g\n```\n\n以上命令会在全局环境上安装`gulp`，让我们可以使用`gulp`命令行。然后，我们需要在项目文件夹内安装本地的`gulp`，`cd`到你的项目路径，然后运行一下命令(执行命令前需确保项目下有`package.json`这个文件)\n\n```\n$ npm install gulp --save-dev\n```\n\n以上命令会在项目内安装本地的gulp并保存到`package.json`里的`devDependencies`\n\n### 安装gulp插件\n\n我们需要安装一些插件来完成以下的任务：\n\n- 编译sass ([gulp-ruby-sass](https://github.com/sindresorhus/gulp-ruby-sass))\n\n- 自动添加厂商前缀 ([gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer))\n\n- 压缩CSS ([gulp-cssnano](https://github.com/jonathanepollack/gulp-cssnano))\n\n- js检测 ([gulp-jshint](https://github.com/wearefractal/gulp-jshint))\n\n- 合并文件 ([gulp-concat](https://github.com/wearefractal/gulp-concat))\n\n- 压缩JS ([gulp-uglify](https://github.com/terinjokes/gulp-uglify))\n\n- 压缩图片 ([gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin))\n\n- 动态加载 ([gulp-livereload](https://github.com/vohof/gulp-livereload))\n\n- 缓存图片然后只压缩改变后的图片 ([gulp-cache](https://github.com/jgable/gulp-cache/))\n\n- 提示信息 ([gulp-notify](https://github.com/mikaelbr/gulp-notify))\n\n- 清除文件 ([del](https://www.npmjs.org/package/del))\n\n通过以下命令来安装这些插件：\n\n```\nnpm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n```\n\n这将会安装全部需要的插件并将它们保存到`package.json`的`devDependencies`里面。你可以[在这里](http://gulpjs.com/plugins/)找到gulp的全部插件。\n\n### 加载插件\n\n之后，我们要创建一个文件夹`gulpfile.js`并加载这些插件：\n\n```js\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n```\n\n这个时候，看起来是不是好像需要写的东西比`grunt`还多？其实，`gulp`插件和`grunt`插件有略微的不同——`gulp`插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，`grunt`的`imagemin`使用缓存来避免压缩已经压缩过的图片；而`gulp`则需要`cache`插件来协助完成这样的任务，当然`cache`插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？\n\n我们同样可以像`grunt`那样[自动加载所有已安装的插件](https://github.com/jackfranklin/gulp-load-tasks)，不过为了这篇文章，我们就将坚持纯手工工艺！\n\n### 创建任务\n\n#### Compile Sass, Autoprefix and minify\n\n首先，我们先配置`Sass`编译，然后使用`Autoprefixer`添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给`cssnao`压缩成一个`.min`版本，最后再输出到另一个目的地，最后的最后调用`notify`提示我们任务完成了：\n\n```js\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n```\n\n继续往下讲之前，有一点东西需要解释一下：\n\n```js\ngulp.task('styles', function() {...});\n```\n\n这里的`gulp.task`API是用来创建任务的。我们在命令行工具中可以使用`$ gulp styles`运行上面的任务。\n\n```js\nreturn sass('src/styles/main.scss', { style: 'expanded' })\n```\n\n这里是一个新的`gulp-rubu-sass`API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用`gulp.src`API来代替（在文章的下部分你将会看到）这同样可以使用`glob pattern`，比如：`/**/*.scss`来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)\n\n```js\n.pipe(autoprefixer('last 2 version'))\n```\n\n我们通过`.pipe()`来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。\n\n```js\n.pipe(gulp.dest('dist/assets/css'));\n```\n\n这里的`gulp.dest`API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出`expanded version`(正常大小版本)，另一个输出`minifed version`(压缩版本)\n\n我建议去看下`gulp`的[API文档](https://github.com/gulpjs/gulp/blob/master/docs/API.md)来更好地理解这些方法，它并不像听起来那么吓人！\n\n#### JSHint, concat, and minify JavaScript\n\n希望你现在对如何创建一个`gulp`任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：\n\n```js\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n```\n\n这里我们就是用`gulp.src`API来指定我们的输入文件。有一件事情需要注意的是，我们需要为`JSHint`指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在[JSHint官网](http://www.jshint.com/docs/reporters/)找到更多的信息。\n\n#### Compress Images\n\n接下来，我们设置图片压缩。\n\n```js\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n    .pipe(gulp.dest('dist/assets/img'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n```\n\n这里我们将拿到一些图片，然后导到`imagemin`插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的`gulp-cache`插件。为了实现这个，我们需要改变这一行：\n\n```js\n.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n```\n\n改成：\n\n```js\n.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true })))\n```\n\n现在就只用新的图片和改变过的图片会被压缩了，nice吧？\n\n#### Clean up!\n\n在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：\n\n```js\ngulp.task('clean', function() {\n    return del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img']);\n});\n```\n\n这里我们不需要使用`gulp`的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）\n\n#### The default task\n\n我们定义的default任务可以直接使用`$ gulp`运行，比如：\n\n```js\ngulp.task('default', ['clean'], function() {\n    gulp.start('styles', 'scripts', 'images');\n});\n```\n\n需要注意到的是，我们添加了一个数组到`gulp.task`上，在这里我们可以定义任务依赖。在这里例子里，`clean`任务将会在`gulp.start`之前先运行。`gulp`里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保`clean`任务完成之后才开始其他的任务。\n\n**注意**：\n\n建议是的不要在依赖任务中使用`gulp.start`，不过在这个脚本里为了确保`clean`完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）\n\n#### watch\n\n监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用`gulp.watch`API来开始监听文件。\n\n```js\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n});\n```\n我们可以通过`gulp.watch`API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行`$ gulp watch`，然后修改一下对应监听目录下的文件，就将会执行对应的任务。\n\n\n#### LiveReload\n\n`gulp`同样可以在文件修改的时候刷新页面，我们需要修改我们的`watch`任务来配置`LiveReload`服务：\n\n```js\ngulp.task('watch', function() {\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n为了让实现这个梦想，你需要安装和启用`LiveReload`的浏览器插件。或者你也可以[手动的添加这些东西](http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-)\n\n### 合并所有代码\n\n现在你拥有了一个完整的`gulpfile`了， 它来自于[这里](https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js)\n\n```js\n/*!\n * gulp\n * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n */\n\n// Load plugins\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n\n// Styles\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n\n// Scripts\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n\n// Images\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n    .pipe(gulp.dest('dist/images'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n\n// Clean\ngulp.task('clean', function() {\n  return del(['dist/styles', 'dist/scripts', 'dist/images']);\n});\n\n// Default task\ngulp.task('default', ['clean'], function() {\n  gulp.start('styles', 'scripts', 'images');\n});\n\n// Watch\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n我也使用`grunt`写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。[拿好了，不送了](https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js)\n\n本文翻译自：[Getting started with gulp](https://markgoodyear.com/2014/01/getting-started-with-gulp/)","source":"_posts/getting-started-with-gulp.md","raw":"---\ntitle: 开始拥抱gulp\ndate: 2016-09-23 12:17:53\ntags: gulp\ndesc: getting-started-with-gulp,gulp,grunt,gulpfile,gruntfile\nfrom: https://markgoodyear.com/2014/01/getting-started-with-gulp/\n---\n\n前端工作流中常用的构建工具除了`grunt`，还有一个`gulp`(当然现在还有`webpack`)。`gulp`是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于`nodejs`流的构建工具，而且执行很快。\n\n<!--more-->\n\n既然有了`grunt`，为啥还要来学习`gulp`呢？这是一个好问题，用过`grunt`的都知道，每次写`Gruntfile.js`的时候，都要先写一大片的配置文件，而`gulp`和`grunt`最大的差别在于，`gulp`是执行代码覆盖配置的。这样的好处在于，`gulpfile.js`很容易写，而且阅读起来清晰明了，并且容易维护。\n\n`gulp`使用`node.js`的流(stream)，这让`gulp`构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看[这篇文章](https://github.com/substack/stream-handbook)（写得很好）\n\n`gulp`允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像`grunt`那样，为每一个`grunt`都写一些配置信息和输入输出路径。让我们看下使用`grunt`和`gulp`写的`Sass`编译：\n\n\n**Grunt**:\n\n```js\nsass: {\n  dist: {\n    options: {\n      style: 'expanded'\n    },\n    files: {\n      'dist/assets/css/main.css': 'src/styles/main.scss',\n    }\n  }\n},\n\nautoprefixer: {\n  dist: {\n    options: {\n      browsers: [\n        'last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'\n      ]\n    },\n    src: 'dist/assets/css/main.css',\n    dest: 'dist/assets/css/main.css'\n  }\n},\n\ngrunt.registerTask('styles', ['sass', 'autoprefixer']);\n```\n\n`Grunt`需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到`Sass`插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给`Autoprefixer`输入，然后我们再将文件输出保存起来。\n\n**gulp**:\n\n```js\ngulp.task('sass', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n});\n```\n\n使用`gulp`的时候，我们只需要输入一个文件，然后经过`Sass`插件修改，然后经过`Autoprefixer`插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。\n\n### 安装Gulp\n\n在我们钻研配置任务信息之前，我们需要安装`gulp`：\n\n```\n$ npm install gulp -g\n```\n\n以上命令会在全局环境上安装`gulp`，让我们可以使用`gulp`命令行。然后，我们需要在项目文件夹内安装本地的`gulp`，`cd`到你的项目路径，然后运行一下命令(执行命令前需确保项目下有`package.json`这个文件)\n\n```\n$ npm install gulp --save-dev\n```\n\n以上命令会在项目内安装本地的gulp并保存到`package.json`里的`devDependencies`\n\n### 安装gulp插件\n\n我们需要安装一些插件来完成以下的任务：\n\n- 编译sass ([gulp-ruby-sass](https://github.com/sindresorhus/gulp-ruby-sass))\n\n- 自动添加厂商前缀 ([gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer))\n\n- 压缩CSS ([gulp-cssnano](https://github.com/jonathanepollack/gulp-cssnano))\n\n- js检测 ([gulp-jshint](https://github.com/wearefractal/gulp-jshint))\n\n- 合并文件 ([gulp-concat](https://github.com/wearefractal/gulp-concat))\n\n- 压缩JS ([gulp-uglify](https://github.com/terinjokes/gulp-uglify))\n\n- 压缩图片 ([gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin))\n\n- 动态加载 ([gulp-livereload](https://github.com/vohof/gulp-livereload))\n\n- 缓存图片然后只压缩改变后的图片 ([gulp-cache](https://github.com/jgable/gulp-cache/))\n\n- 提示信息 ([gulp-notify](https://github.com/mikaelbr/gulp-notify))\n\n- 清除文件 ([del](https://www.npmjs.org/package/del))\n\n通过以下命令来安装这些插件：\n\n```\nnpm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n```\n\n这将会安装全部需要的插件并将它们保存到`package.json`的`devDependencies`里面。你可以[在这里](http://gulpjs.com/plugins/)找到gulp的全部插件。\n\n### 加载插件\n\n之后，我们要创建一个文件夹`gulpfile.js`并加载这些插件：\n\n```js\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n```\n\n这个时候，看起来是不是好像需要写的东西比`grunt`还多？其实，`gulp`插件和`grunt`插件有略微的不同——`gulp`插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，`grunt`的`imagemin`使用缓存来避免压缩已经压缩过的图片；而`gulp`则需要`cache`插件来协助完成这样的任务，当然`cache`插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？\n\n我们同样可以像`grunt`那样[自动加载所有已安装的插件](https://github.com/jackfranklin/gulp-load-tasks)，不过为了这篇文章，我们就将坚持纯手工工艺！\n\n### 创建任务\n\n#### Compile Sass, Autoprefix and minify\n\n首先，我们先配置`Sass`编译，然后使用`Autoprefixer`添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给`cssnao`压缩成一个`.min`版本，最后再输出到另一个目的地，最后的最后调用`notify`提示我们任务完成了：\n\n```js\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n```\n\n继续往下讲之前，有一点东西需要解释一下：\n\n```js\ngulp.task('styles', function() {...});\n```\n\n这里的`gulp.task`API是用来创建任务的。我们在命令行工具中可以使用`$ gulp styles`运行上面的任务。\n\n```js\nreturn sass('src/styles/main.scss', { style: 'expanded' })\n```\n\n这里是一个新的`gulp-rubu-sass`API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用`gulp.src`API来代替（在文章的下部分你将会看到）这同样可以使用`glob pattern`，比如：`/**/*.scss`来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)\n\n```js\n.pipe(autoprefixer('last 2 version'))\n```\n\n我们通过`.pipe()`来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。\n\n```js\n.pipe(gulp.dest('dist/assets/css'));\n```\n\n这里的`gulp.dest`API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出`expanded version`(正常大小版本)，另一个输出`minifed version`(压缩版本)\n\n我建议去看下`gulp`的[API文档](https://github.com/gulpjs/gulp/blob/master/docs/API.md)来更好地理解这些方法，它并不像听起来那么吓人！\n\n#### JSHint, concat, and minify JavaScript\n\n希望你现在对如何创建一个`gulp`任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：\n\n```js\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n```\n\n这里我们就是用`gulp.src`API来指定我们的输入文件。有一件事情需要注意的是，我们需要为`JSHint`指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在[JSHint官网](http://www.jshint.com/docs/reporters/)找到更多的信息。\n\n#### Compress Images\n\n接下来，我们设置图片压缩。\n\n```js\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n    .pipe(gulp.dest('dist/assets/img'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n```\n\n这里我们将拿到一些图片，然后导到`imagemin`插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的`gulp-cache`插件。为了实现这个，我们需要改变这一行：\n\n```js\n.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n```\n\n改成：\n\n```js\n.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true })))\n```\n\n现在就只用新的图片和改变过的图片会被压缩了，nice吧？\n\n#### Clean up!\n\n在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：\n\n```js\ngulp.task('clean', function() {\n    return del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img']);\n});\n```\n\n这里我们不需要使用`gulp`的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）\n\n#### The default task\n\n我们定义的default任务可以直接使用`$ gulp`运行，比如：\n\n```js\ngulp.task('default', ['clean'], function() {\n    gulp.start('styles', 'scripts', 'images');\n});\n```\n\n需要注意到的是，我们添加了一个数组到`gulp.task`上，在这里我们可以定义任务依赖。在这里例子里，`clean`任务将会在`gulp.start`之前先运行。`gulp`里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保`clean`任务完成之后才开始其他的任务。\n\n**注意**：\n\n建议是的不要在依赖任务中使用`gulp.start`，不过在这个脚本里为了确保`clean`完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）\n\n#### watch\n\n监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用`gulp.watch`API来开始监听文件。\n\n```js\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n});\n```\n我们可以通过`gulp.watch`API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行`$ gulp watch`，然后修改一下对应监听目录下的文件，就将会执行对应的任务。\n\n\n#### LiveReload\n\n`gulp`同样可以在文件修改的时候刷新页面，我们需要修改我们的`watch`任务来配置`LiveReload`服务：\n\n```js\ngulp.task('watch', function() {\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n为了让实现这个梦想，你需要安装和启用`LiveReload`的浏览器插件。或者你也可以[手动的添加这些东西](http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-)\n\n### 合并所有代码\n\n现在你拥有了一个完整的`gulpfile`了， 它来自于[这里](https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js)\n\n```js\n/*!\n * gulp\n * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n */\n\n// Load plugins\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n\n// Styles\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n\n// Scripts\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n\n// Images\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n    .pipe(gulp.dest('dist/images'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n\n// Clean\ngulp.task('clean', function() {\n  return del(['dist/styles', 'dist/scripts', 'dist/images']);\n});\n\n// Default task\ngulp.task('default', ['clean'], function() {\n  gulp.start('styles', 'scripts', 'images');\n});\n\n// Watch\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n我也使用`grunt`写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。[拿好了，不送了](https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js)\n\n本文翻译自：[Getting started with gulp](https://markgoodyear.com/2014/01/getting-started-with-gulp/)","slug":"getting-started-with-gulp","published":1,"updated":"2017-11-09T16:15:25.000Z","_id":"ckxvfmfd4001fbrqq9i5r6i6p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前端工作流中常用的构建工具除了<code>grunt</code>，还有一个<code>gulp</code>(当然现在还有<code>webpack</code>)。<code>gulp</code>是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于<code>nodejs</code>流的构建工具，而且执行很快。</p>\n<span id=\"more\"></span>\n\n<p>既然有了<code>grunt</code>，为啥还要来学习<code>gulp</code>呢？这是一个好问题，用过<code>grunt</code>的都知道，每次写<code>Gruntfile.js</code>的时候，都要先写一大片的配置文件，而<code>gulp</code>和<code>grunt</code>最大的差别在于，<code>gulp</code>是执行代码覆盖配置的。这样的好处在于，<code>gulpfile.js</code>很容易写，而且阅读起来清晰明了，并且容易维护。</p>\n<p><code>gulp</code>使用<code>node.js</code>的流(stream)，这让<code>gulp</code>构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看<a href=\"https://github.com/substack/stream-handbook\">这篇文章</a>（写得很好）</p>\n<p><code>gulp</code>允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像<code>grunt</code>那样，为每一个<code>grunt</code>都写一些配置信息和输入输出路径。让我们看下使用<code>grunt</code>和<code>gulp</code>写的<code>Sass</code>编译：</p>\n<p><strong>Grunt</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">files</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>: <span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">autoprefixer</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">browsers</span>: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">src</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dest</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">grunt.registerTask(<span class=\"string\">&#x27;styles&#x27;</span>, [<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"string\">&#x27;autoprefixer&#x27;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p><code>Grunt</code>需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到<code>Sass</code>插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给<code>Autoprefixer</code>输入，然后我们再将文件输出保存起来。</p>\n<p><strong>gulp</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>gulp</code>的时候，我们只需要输入一个文件，然后经过<code>Sass</code>插件修改，然后经过<code>Autoprefixer</code>插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。</p>\n<h3 id=\"安装Gulp\"><a href=\"#安装Gulp\" class=\"headerlink\" title=\"安装Gulp\"></a>安装Gulp</h3><p>在我们钻研配置任务信息之前，我们需要安装<code>gulp</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp -g</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在全局环境上安装<code>gulp</code>，让我们可以使用<code>gulp</code>命令行。然后，我们需要在项目文件夹内安装本地的<code>gulp</code>，<code>cd</code>到你的项目路径，然后运行一下命令(执行命令前需确保项目下有<code>package.json</code>这个文件)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在项目内安装本地的gulp并保存到<code>package.json</code>里的<code>devDependencies</code></p>\n<h3 id=\"安装gulp插件\"><a href=\"#安装gulp插件\" class=\"headerlink\" title=\"安装gulp插件\"></a>安装gulp插件</h3><p>我们需要安装一些插件来完成以下的任务：</p>\n<ul>\n<li><p>编译sass (<a href=\"https://github.com/sindresorhus/gulp-ruby-sass\">gulp-ruby-sass</a>)</p>\n</li>\n<li><p>自动添加厂商前缀 (<a href=\"https://github.com/Metrime/gulp-autoprefixer\">gulp-autoprefixer</a>)</p>\n</li>\n<li><p>压缩CSS (<a href=\"https://github.com/jonathanepollack/gulp-cssnano\">gulp-cssnano</a>)</p>\n</li>\n<li><p>js检测 (<a href=\"https://github.com/wearefractal/gulp-jshint\">gulp-jshint</a>)</p>\n</li>\n<li><p>合并文件 (<a href=\"https://github.com/wearefractal/gulp-concat\">gulp-concat</a>)</p>\n</li>\n<li><p>压缩JS (<a href=\"https://github.com/terinjokes/gulp-uglify\">gulp-uglify</a>)</p>\n</li>\n<li><p>压缩图片 (<a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a>)</p>\n</li>\n<li><p>动态加载 (<a href=\"https://github.com/vohof/gulp-livereload\">gulp-livereload</a>)</p>\n</li>\n<li><p>缓存图片然后只压缩改变后的图片 (<a href=\"https://github.com/jgable/gulp-cache/\">gulp-cache</a>)</p>\n</li>\n<li><p>提示信息 (<a href=\"https://github.com/mikaelbr/gulp-notify\">gulp-notify</a>)</p>\n</li>\n<li><p>清除文件 (<a href=\"https://www.npmjs.org/package/del\">del</a>)</p>\n</li>\n</ul>\n<p>通过以下命令来安装这些插件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>这将会安装全部需要的插件并将它们保存到<code>package.json</code>的<code>devDependencies</code>里面。你可以<a href=\"http://gulpjs.com/plugins/\">在这里</a>找到gulp的全部插件。</p>\n<h3 id=\"加载插件\"><a href=\"#加载插件\" class=\"headerlink\" title=\"加载插件\"></a>加载插件</h3><p>之后，我们要创建一个文件夹<code>gulpfile.js</code>并加载这些插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，看起来是不是好像需要写的东西比<code>grunt</code>还多？其实，<code>gulp</code>插件和<code>grunt</code>插件有略微的不同——<code>gulp</code>插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，<code>grunt</code>的<code>imagemin</code>使用缓存来避免压缩已经压缩过的图片；而<code>gulp</code>则需要<code>cache</code>插件来协助完成这样的任务，当然<code>cache</code>插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？</p>\n<p>我们同样可以像<code>grunt</code>那样<a href=\"https://github.com/jackfranklin/gulp-load-tasks\">自动加载所有已安装的插件</a>，不过为了这篇文章，我们就将坚持纯手工工艺！</p>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><h4 id=\"Compile-Sass-Autoprefix-and-minify\"><a href=\"#Compile-Sass-Autoprefix-and-minify\" class=\"headerlink\" title=\"Compile Sass, Autoprefix and minify\"></a>Compile Sass, Autoprefix and minify</h4><p>首先，我们先配置<code>Sass</code>编译，然后使用<code>Autoprefixer</code>添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给<code>cssnao</code>压缩成一个<code>.min</code>版本，最后再输出到另一个目的地，最后的最后调用<code>notify</code>提示我们任务完成了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>继续往下讲之前，有一点东西需要解释一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.task</code>API是用来创建任务的。我们在命令行工具中可以使用<code>$ gulp styles</code>运行上面的任务。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里是一个新的<code>gulp-rubu-sass</code>API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用<code>gulp.src</code>API来代替（在文章的下部分你将会看到）这同样可以使用<code>glob pattern</code>，比如：<code>/**/*.scss</code>来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>.pipe()</code>来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.dest</code>API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出<code>expanded version</code>(正常大小版本)，另一个输出<code>minifed version</code>(压缩版本)</p>\n<p>我建议去看下<code>gulp</code>的<a href=\"https://github.com/gulpjs/gulp/blob/master/docs/API.md\">API文档</a>来更好地理解这些方法，它并不像听起来那么吓人！</p>\n<h4 id=\"JSHint-concat-and-minify-JavaScript\"><a href=\"#JSHint-concat-and-minify-JavaScript\" class=\"headerlink\" title=\"JSHint, concat, and minify JavaScript\"></a>JSHint, concat, and minify JavaScript</h4><p>希望你现在对如何创建一个<code>gulp</code>任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们就是用<code>gulp.src</code>API来指定我们的输入文件。有一件事情需要注意的是，我们需要为<code>JSHint</code>指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在<a href=\"http://www.jshint.com/docs/reporters/\">JSHint官网</a>找到更多的信息。</p>\n<h4 id=\"Compress-Images\"><a href=\"#Compress-Images\" class=\"headerlink\" title=\"Compress Images\"></a>Compress Images</h4><p>接下来，我们设置图片压缩。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/img&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们将拿到一些图片，然后导到<code>imagemin</code>插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的<code>gulp-cache</code>插件。为了实现这个，我们需要改变这一行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br></pre></td></tr></table></figure>\n\n<p>改成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">5</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br></pre></td></tr></table></figure>\n\n<p>现在就只用新的图片和改变过的图片会被压缩了，nice吧？</p>\n<h4 id=\"Clean-up\"><a href=\"#Clean-up\" class=\"headerlink\" title=\"Clean up!\"></a>Clean up!</h4><p>在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/assets/css&#x27;</span>, <span class=\"string\">&#x27;dist/assets/js&#x27;</span>, <span class=\"string\">&#x27;dist/assets/img&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们不需要使用<code>gulp</code>的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）</p>\n<h4 id=\"The-default-task\"><a href=\"#The-default-task\" class=\"headerlink\" title=\"The default task\"></a>The default task</h4><p>我们定义的default任务可以直接使用<code>$ gulp</code>运行，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>需要注意到的是，我们添加了一个数组到<code>gulp.task</code>上，在这里我们可以定义任务依赖。在这里例子里，<code>clean</code>任务将会在<code>gulp.start</code>之前先运行。<code>gulp</code>里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保<code>clean</code>任务完成之后才开始其他的任务。</p>\n<p><strong>注意</strong>：</p>\n<p>建议是的不要在依赖任务中使用<code>gulp.start</code>，不过在这个脚本里为了确保<code>clean</code>完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）</p>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h4><p>监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用<code>gulp.watch</code>API来开始监听文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以通过<code>gulp.watch</code>API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行<code>$ gulp watch</code>，然后修改一下对应监听目录下的文件，就将会执行对应的任务。</p>\n<h4 id=\"LiveReload\"><a href=\"#LiveReload\" class=\"headerlink\" title=\"LiveReload\"></a>LiveReload</h4><p><code>gulp</code>同样可以在文件修改的时候刷新页面，我们需要修改我们的<code>watch</code>任务来配置<code>LiveReload</code>服务：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>为了让实现这个梦想，你需要安装和启用<code>LiveReload</code>的浏览器插件。或者你也可以<a href=\"http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-\">手动的添加这些东西</a></p>\n<h3 id=\"合并所有代码\"><a href=\"#合并所有代码\" class=\"headerlink\" title=\"合并所有代码\"></a>合并所有代码</h3><p>现在你拥有了一个完整的<code>gulpfile</code>了， 它来自于<a href=\"https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js\">这里</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\"> * gulp</span></span><br><span class=\"line\"><span class=\"comment\"> * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Load plugins</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Styles</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Scripts</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Images</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/images&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Clean</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/styles&#x27;</span>, <span class=\"string\">&#x27;dist/scripts&#x27;</span>, <span class=\"string\">&#x27;dist/images&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Default task</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Watch</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我也使用<code>grunt</code>写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。<a href=\"https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js\">拿好了，不送了</a></p>\n<p>本文翻译自：<a href=\"https://markgoodyear.com/2014/01/getting-started-with-gulp/\">Getting started with gulp</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>前端工作流中常用的构建工具除了<code>grunt</code>，还有一个<code>gulp</code>(当然现在还有<code>webpack</code>)。<code>gulp</code>是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于<code>nodejs</code>流的构建工具，而且执行很快。</p>","more":"<p>既然有了<code>grunt</code>，为啥还要来学习<code>gulp</code>呢？这是一个好问题，用过<code>grunt</code>的都知道，每次写<code>Gruntfile.js</code>的时候，都要先写一大片的配置文件，而<code>gulp</code>和<code>grunt</code>最大的差别在于，<code>gulp</code>是执行代码覆盖配置的。这样的好处在于，<code>gulpfile.js</code>很容易写，而且阅读起来清晰明了，并且容易维护。</p>\n<p><code>gulp</code>使用<code>node.js</code>的流(stream)，这让<code>gulp</code>构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看<a href=\"https://github.com/substack/stream-handbook\">这篇文章</a>（写得很好）</p>\n<p><code>gulp</code>允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像<code>grunt</code>那样，为每一个<code>grunt</code>都写一些配置信息和输入输出路径。让我们看下使用<code>grunt</code>和<code>gulp</code>写的<code>Sass</code>编译：</p>\n<p><strong>Grunt</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">files</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>: <span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">autoprefixer</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">browsers</span>: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">src</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dest</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">grunt.registerTask(<span class=\"string\">&#x27;styles&#x27;</span>, [<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"string\">&#x27;autoprefixer&#x27;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p><code>Grunt</code>需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到<code>Sass</code>插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给<code>Autoprefixer</code>输入，然后我们再将文件输出保存起来。</p>\n<p><strong>gulp</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>gulp</code>的时候，我们只需要输入一个文件，然后经过<code>Sass</code>插件修改，然后经过<code>Autoprefixer</code>插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。</p>\n<h3 id=\"安装Gulp\"><a href=\"#安装Gulp\" class=\"headerlink\" title=\"安装Gulp\"></a>安装Gulp</h3><p>在我们钻研配置任务信息之前，我们需要安装<code>gulp</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp -g</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在全局环境上安装<code>gulp</code>，让我们可以使用<code>gulp</code>命令行。然后，我们需要在项目文件夹内安装本地的<code>gulp</code>，<code>cd</code>到你的项目路径，然后运行一下命令(执行命令前需确保项目下有<code>package.json</code>这个文件)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在项目内安装本地的gulp并保存到<code>package.json</code>里的<code>devDependencies</code></p>\n<h3 id=\"安装gulp插件\"><a href=\"#安装gulp插件\" class=\"headerlink\" title=\"安装gulp插件\"></a>安装gulp插件</h3><p>我们需要安装一些插件来完成以下的任务：</p>\n<ul>\n<li><p>编译sass (<a href=\"https://github.com/sindresorhus/gulp-ruby-sass\">gulp-ruby-sass</a>)</p>\n</li>\n<li><p>自动添加厂商前缀 (<a href=\"https://github.com/Metrime/gulp-autoprefixer\">gulp-autoprefixer</a>)</p>\n</li>\n<li><p>压缩CSS (<a href=\"https://github.com/jonathanepollack/gulp-cssnano\">gulp-cssnano</a>)</p>\n</li>\n<li><p>js检测 (<a href=\"https://github.com/wearefractal/gulp-jshint\">gulp-jshint</a>)</p>\n</li>\n<li><p>合并文件 (<a href=\"https://github.com/wearefractal/gulp-concat\">gulp-concat</a>)</p>\n</li>\n<li><p>压缩JS (<a href=\"https://github.com/terinjokes/gulp-uglify\">gulp-uglify</a>)</p>\n</li>\n<li><p>压缩图片 (<a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a>)</p>\n</li>\n<li><p>动态加载 (<a href=\"https://github.com/vohof/gulp-livereload\">gulp-livereload</a>)</p>\n</li>\n<li><p>缓存图片然后只压缩改变后的图片 (<a href=\"https://github.com/jgable/gulp-cache/\">gulp-cache</a>)</p>\n</li>\n<li><p>提示信息 (<a href=\"https://github.com/mikaelbr/gulp-notify\">gulp-notify</a>)</p>\n</li>\n<li><p>清除文件 (<a href=\"https://www.npmjs.org/package/del\">del</a>)</p>\n</li>\n</ul>\n<p>通过以下命令来安装这些插件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>这将会安装全部需要的插件并将它们保存到<code>package.json</code>的<code>devDependencies</code>里面。你可以<a href=\"http://gulpjs.com/plugins/\">在这里</a>找到gulp的全部插件。</p>\n<h3 id=\"加载插件\"><a href=\"#加载插件\" class=\"headerlink\" title=\"加载插件\"></a>加载插件</h3><p>之后，我们要创建一个文件夹<code>gulpfile.js</code>并加载这些插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，看起来是不是好像需要写的东西比<code>grunt</code>还多？其实，<code>gulp</code>插件和<code>grunt</code>插件有略微的不同——<code>gulp</code>插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，<code>grunt</code>的<code>imagemin</code>使用缓存来避免压缩已经压缩过的图片；而<code>gulp</code>则需要<code>cache</code>插件来协助完成这样的任务，当然<code>cache</code>插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？</p>\n<p>我们同样可以像<code>grunt</code>那样<a href=\"https://github.com/jackfranklin/gulp-load-tasks\">自动加载所有已安装的插件</a>，不过为了这篇文章，我们就将坚持纯手工工艺！</p>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><h4 id=\"Compile-Sass-Autoprefix-and-minify\"><a href=\"#Compile-Sass-Autoprefix-and-minify\" class=\"headerlink\" title=\"Compile Sass, Autoprefix and minify\"></a>Compile Sass, Autoprefix and minify</h4><p>首先，我们先配置<code>Sass</code>编译，然后使用<code>Autoprefixer</code>添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给<code>cssnao</code>压缩成一个<code>.min</code>版本，最后再输出到另一个目的地，最后的最后调用<code>notify</code>提示我们任务完成了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>继续往下讲之前，有一点东西需要解释一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.task</code>API是用来创建任务的。我们在命令行工具中可以使用<code>$ gulp styles</code>运行上面的任务。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里是一个新的<code>gulp-rubu-sass</code>API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用<code>gulp.src</code>API来代替（在文章的下部分你将会看到）这同样可以使用<code>glob pattern</code>，比如：<code>/**/*.scss</code>来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>.pipe()</code>来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.dest</code>API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出<code>expanded version</code>(正常大小版本)，另一个输出<code>minifed version</code>(压缩版本)</p>\n<p>我建议去看下<code>gulp</code>的<a href=\"https://github.com/gulpjs/gulp/blob/master/docs/API.md\">API文档</a>来更好地理解这些方法，它并不像听起来那么吓人！</p>\n<h4 id=\"JSHint-concat-and-minify-JavaScript\"><a href=\"#JSHint-concat-and-minify-JavaScript\" class=\"headerlink\" title=\"JSHint, concat, and minify JavaScript\"></a>JSHint, concat, and minify JavaScript</h4><p>希望你现在对如何创建一个<code>gulp</code>任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们就是用<code>gulp.src</code>API来指定我们的输入文件。有一件事情需要注意的是，我们需要为<code>JSHint</code>指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在<a href=\"http://www.jshint.com/docs/reporters/\">JSHint官网</a>找到更多的信息。</p>\n<h4 id=\"Compress-Images\"><a href=\"#Compress-Images\" class=\"headerlink\" title=\"Compress Images\"></a>Compress Images</h4><p>接下来，我们设置图片压缩。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/img&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们将拿到一些图片，然后导到<code>imagemin</code>插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的<code>gulp-cache</code>插件。为了实现这个，我们需要改变这一行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br></pre></td></tr></table></figure>\n\n<p>改成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">5</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br></pre></td></tr></table></figure>\n\n<p>现在就只用新的图片和改变过的图片会被压缩了，nice吧？</p>\n<h4 id=\"Clean-up\"><a href=\"#Clean-up\" class=\"headerlink\" title=\"Clean up!\"></a>Clean up!</h4><p>在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/assets/css&#x27;</span>, <span class=\"string\">&#x27;dist/assets/js&#x27;</span>, <span class=\"string\">&#x27;dist/assets/img&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们不需要使用<code>gulp</code>的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）</p>\n<h4 id=\"The-default-task\"><a href=\"#The-default-task\" class=\"headerlink\" title=\"The default task\"></a>The default task</h4><p>我们定义的default任务可以直接使用<code>$ gulp</code>运行，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>需要注意到的是，我们添加了一个数组到<code>gulp.task</code>上，在这里我们可以定义任务依赖。在这里例子里，<code>clean</code>任务将会在<code>gulp.start</code>之前先运行。<code>gulp</code>里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保<code>clean</code>任务完成之后才开始其他的任务。</p>\n<p><strong>注意</strong>：</p>\n<p>建议是的不要在依赖任务中使用<code>gulp.start</code>，不过在这个脚本里为了确保<code>clean</code>完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）</p>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h4><p>监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用<code>gulp.watch</code>API来开始监听文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以通过<code>gulp.watch</code>API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行<code>$ gulp watch</code>，然后修改一下对应监听目录下的文件，就将会执行对应的任务。</p>\n<h4 id=\"LiveReload\"><a href=\"#LiveReload\" class=\"headerlink\" title=\"LiveReload\"></a>LiveReload</h4><p><code>gulp</code>同样可以在文件修改的时候刷新页面，我们需要修改我们的<code>watch</code>任务来配置<code>LiveReload</code>服务：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>为了让实现这个梦想，你需要安装和启用<code>LiveReload</code>的浏览器插件。或者你也可以<a href=\"http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-\">手动的添加这些东西</a></p>\n<h3 id=\"合并所有代码\"><a href=\"#合并所有代码\" class=\"headerlink\" title=\"合并所有代码\"></a>合并所有代码</h3><p>现在你拥有了一个完整的<code>gulpfile</code>了， 它来自于<a href=\"https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js\">这里</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\"> * gulp</span></span><br><span class=\"line\"><span class=\"comment\"> * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Load plugins</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Styles</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Scripts</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Images</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/images&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Clean</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/styles&#x27;</span>, <span class=\"string\">&#x27;dist/scripts&#x27;</span>, <span class=\"string\">&#x27;dist/images&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Default task</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Watch</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我也使用<code>grunt</code>写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。<a href=\"https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js\">拿好了，不送了</a></p>\n<p>本文翻译自：<a href=\"https://markgoodyear.com/2014/01/getting-started-with-gulp/\">Getting started with gulp</a></p>"},{"title":"前端路由","date":"2015-09-21T04:44:09.000Z","desc":"router","_content":"\n路由一直都是后端控制的，然而，其实我们前端也可以使用`hash`实现我们前端自己的路由。\n下面的代码就是参考他人代码实现的：\n\n<!--more-->\n\n```js\nvar router = {\n  routes: {},\n  currentUrl: '',\n  lastPanel: ''\n};\n\nrouter.init = function(){\n  window.addEventListener('load', this.update.bind(this), false);\n  window.addEventListener('hashchange', this.update.bind(this), false);\n};\n\nrouter.add = function(path, callback){\n  this.routes[path] = callback;\n};\n\nrouter.update = function(){\n  this.currentUrl = location.hash.slice(1) || '/';\n  this.routes[this.currentUrl]();\n}\n\nif(this === window && typeof window.document !== 'undefined') {\n  window.router = router;\n}\nelse if(typeof define === 'function') {\n  define('router', [], function(){\n    return router;\n  })\n}\n```","source":"_posts/front-end-router.md","raw":"---\ntitle: 前端路由\ndate: 2015-09-21 12:44:09\ntags: 路由\ndesc: router\n---\n\n路由一直都是后端控制的，然而，其实我们前端也可以使用`hash`实现我们前端自己的路由。\n下面的代码就是参考他人代码实现的：\n\n<!--more-->\n\n```js\nvar router = {\n  routes: {},\n  currentUrl: '',\n  lastPanel: ''\n};\n\nrouter.init = function(){\n  window.addEventListener('load', this.update.bind(this), false);\n  window.addEventListener('hashchange', this.update.bind(this), false);\n};\n\nrouter.add = function(path, callback){\n  this.routes[path] = callback;\n};\n\nrouter.update = function(){\n  this.currentUrl = location.hash.slice(1) || '/';\n  this.routes[this.currentUrl]();\n}\n\nif(this === window && typeof window.document !== 'undefined') {\n  window.router = router;\n}\nelse if(typeof define === 'function') {\n  define('router', [], function(){\n    return router;\n  })\n}\n```","slug":"front-end-router","published":1,"updated":"2020-05-23T06:14:33.000Z","_id":"ckxvfmfd5001gbrqq6t7q7ca3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>路由一直都是后端控制的，然而，其实我们前端也可以使用<code>hash</code>实现我们前端自己的路由。<br>下面的代码就是参考他人代码实现的：</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = &#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">currentUrl</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastPanel</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, callback</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[path] = callback;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.update = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[<span class=\"built_in\">this</span>.currentUrl]();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.document !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.router = router;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> define === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">  define(<span class=\"string\">&#x27;router&#x27;</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> router;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>路由一直都是后端控制的，然而，其实我们前端也可以使用<code>hash</code>实现我们前端自己的路由。<br>下面的代码就是参考他人代码实现的：</p>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = &#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">currentUrl</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastPanel</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, callback</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[path] = callback;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.update = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[<span class=\"built_in\">this</span>.currentUrl]();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.document !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.router = router;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> define === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">  define(<span class=\"string\">&#x27;router&#x27;</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> router;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ES6 Promise","date":"2016-08-05T11:00:49.000Z","desc":["ES6","Promise"],"_content":"\n由于`js`的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。`ES6`(也叫`ES2015`)为了解决这个问题提出了`Promse`对象。\n\n<!--more-->\n\n### 出现Promise的原因\n\n当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。\n\n```javascript\n$.ajax({\n  //...\n})\n.then(function (data) {\n  // 要在第一个请求成功后才可以执行下一步\n  $.ajax({  \n    //...\n  })\n  .then(function (data) {\n    // ...\n  });\n});\n```\n\n**缺点**：\n\n1. 回调地狱，多个操作的时候就要无限嵌套回调函数了\n2. 如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了\n\n### 什么是Promise？\n\n一个`Promise`对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了`Promise`对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。\n\n#### resolve和reject\n\n```javascript\nfunction helloWorld (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello World!\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nhelloWorld(true).then(function (message) {\n    alert(message);\n}, function (error) {\n    alert(error);\n});\n```\n`resolve` 方法可以使`Promise`对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 `Hello World!` 字符串。\n`reject` 方法则是将`Promise`对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。\n\n### promise三种状态\n\n上面提到了 `resolve` 和 `reject` 可以改变`Promise`对象的状态，那么它究竟有哪些状态呢？\n`Promise`对象有三种对象\n1 `Fulfilled` 可以理解为成功的状态\n2 `Rejected` 可以理解为失败的状态\n3 `Pending` 可以理解为`Promise`对象实例创建时候的初始状态\n\n#### then和catch\n\nhelloWorld 的例子当中利用了 `then(onFulfilld, onRejected)` 方法来执行一个任务打印 \"Hello World!\"，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。\n\n```javascript\nfunction printHello (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nfunction printWorld () {\n    alert(\"World\");\n}\nfunction printExclamation () {\n    alert(\"!\");\n}\nprintHello(true)\n    .then(function(message){\n        alert(message);\n    })\n    .then(printWorld)\n    .then(printExclamation);\n```\n\n`catch` 方法是 `then(onFulfilled, onRejected)` 方法当中 `onRejected` 函数的一个简单的写法，也就是说可以写成`then(fn).catch(fn)`，相当于 `then(fn).then(null, fn)`。使用 `catch` 的写法比一般的写法更加清晰明确。\n\n#### Promise.all 和 Promise.race\n\n`Promise.all` 可以接收一个元素为 `Promise` 对象的数组作为参数，当这个数组里面所有的 `Promise` 对象都变为 `resolve` 时，该方法才会返回。\n\n```javascript\nvar p1 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"Hello\");\n    }, 3000);\n});\nvar p2 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"World\");\n    }, 1000);\n});\nPromise.all([p1, p2]).then(function (result) {\n    console.log(result); // [\"Hello\", \"World\"]\n});\n```\n\n`Promise.race` 在`promise`数组中任何一个`promise`对象变成`resolve`或者`reject`，马上执行函数\n\n```javascript\n// `delay`毫秒后执行resolve\nfunction timerPromisefy(delay) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay);\n    });\n}\n\n// 任何一个promise变为resolve或reject 的话程序就停止运行\nPromise.race([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64),\n    timerPromisefy(128)\n]).then(function (value) {\n    console.log(value);    // => 1\n});\n```\n\n**特殊地方**：\n\n```javascript\nvar promise = new Promise(function (resolve){\n    console.log(\"inner promise\"); // 1\n    resolve(42);\n});\npromise.then(function(value){\n    console.log(value); // 3\n});\nconsole.log(\"outer promise\"); // 2\n```\n\n输出结果是：`inner promise -> outer promise -> 42`\n","source":"_posts/es6-promise.md","raw":"---\ntitle: ES6 Promise\ndate: 2016-08-05 19:00:49\ntags:\ndesc: \n- ES6\n- Promise\n---\n\n由于`js`的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。`ES6`(也叫`ES2015`)为了解决这个问题提出了`Promse`对象。\n\n<!--more-->\n\n### 出现Promise的原因\n\n当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。\n\n```javascript\n$.ajax({\n  //...\n})\n.then(function (data) {\n  // 要在第一个请求成功后才可以执行下一步\n  $.ajax({  \n    //...\n  })\n  .then(function (data) {\n    // ...\n  });\n});\n```\n\n**缺点**：\n\n1. 回调地狱，多个操作的时候就要无限嵌套回调函数了\n2. 如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了\n\n### 什么是Promise？\n\n一个`Promise`对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了`Promise`对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。\n\n#### resolve和reject\n\n```javascript\nfunction helloWorld (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello World!\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nhelloWorld(true).then(function (message) {\n    alert(message);\n}, function (error) {\n    alert(error);\n});\n```\n`resolve` 方法可以使`Promise`对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 `Hello World!` 字符串。\n`reject` 方法则是将`Promise`对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。\n\n### promise三种状态\n\n上面提到了 `resolve` 和 `reject` 可以改变`Promise`对象的状态，那么它究竟有哪些状态呢？\n`Promise`对象有三种对象\n1 `Fulfilled` 可以理解为成功的状态\n2 `Rejected` 可以理解为失败的状态\n3 `Pending` 可以理解为`Promise`对象实例创建时候的初始状态\n\n#### then和catch\n\nhelloWorld 的例子当中利用了 `then(onFulfilld, onRejected)` 方法来执行一个任务打印 \"Hello World!\"，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。\n\n```javascript\nfunction printHello (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nfunction printWorld () {\n    alert(\"World\");\n}\nfunction printExclamation () {\n    alert(\"!\");\n}\nprintHello(true)\n    .then(function(message){\n        alert(message);\n    })\n    .then(printWorld)\n    .then(printExclamation);\n```\n\n`catch` 方法是 `then(onFulfilled, onRejected)` 方法当中 `onRejected` 函数的一个简单的写法，也就是说可以写成`then(fn).catch(fn)`，相当于 `then(fn).then(null, fn)`。使用 `catch` 的写法比一般的写法更加清晰明确。\n\n#### Promise.all 和 Promise.race\n\n`Promise.all` 可以接收一个元素为 `Promise` 对象的数组作为参数，当这个数组里面所有的 `Promise` 对象都变为 `resolve` 时，该方法才会返回。\n\n```javascript\nvar p1 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"Hello\");\n    }, 3000);\n});\nvar p2 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"World\");\n    }, 1000);\n});\nPromise.all([p1, p2]).then(function (result) {\n    console.log(result); // [\"Hello\", \"World\"]\n});\n```\n\n`Promise.race` 在`promise`数组中任何一个`promise`对象变成`resolve`或者`reject`，马上执行函数\n\n```javascript\n// `delay`毫秒后执行resolve\nfunction timerPromisefy(delay) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay);\n    });\n}\n\n// 任何一个promise变为resolve或reject 的话程序就停止运行\nPromise.race([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64),\n    timerPromisefy(128)\n]).then(function (value) {\n    console.log(value);    // => 1\n});\n```\n\n**特殊地方**：\n\n```javascript\nvar promise = new Promise(function (resolve){\n    console.log(\"inner promise\"); // 1\n    resolve(42);\n});\npromise.then(function(value){\n    console.log(value); // 3\n});\nconsole.log(\"outer promise\"); // 2\n```\n\n输出结果是：`inner promise -> outer promise -> 42`\n","slug":"es6-promise","published":1,"updated":"2020-05-23T06:05:51.000Z","_id":"ckxvfmfdd001jbrqqhyl7h2px","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于<code>js</code>的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。<code>ES6</code>(也叫<code>ES2015</code>)为了解决这个问题提出了<code>Promse</code>对象。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"出现Promise的原因\"><a href=\"#出现Promise的原因\" class=\"headerlink\" title=\"出现Promise的原因\"></a>出现Promise的原因</h3><p>当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 要在第一个请求成功后才可以执行下一步</span></span><br><span class=\"line\">  $.ajax(&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>回调地狱，多个操作的时候就要无限嵌套回调函数了</li>\n<li>如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了</li>\n</ol>\n<h3 id=\"什么是Promise？\"><a href=\"#什么是Promise？\" class=\"headerlink\" title=\"什么是Promise？\"></a>什么是Promise？</h3><p>一个<code>Promise</code>对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了<code>Promise</code>对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。</p>\n<h4 id=\"resolve和reject\"><a href=\"#resolve和reject\" class=\"headerlink\" title=\"resolve和reject\"></a>resolve和reject</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">helloWorld</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">helloWorld(<span class=\"literal\">true</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    alert(message);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>resolve</code> 方法可以使<code>Promise</code>对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 <code>Hello World!</code> 字符串。<br><code>reject</code> 方法则是将<code>Promise</code>对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。</p>\n<h3 id=\"promise三种状态\"><a href=\"#promise三种状态\" class=\"headerlink\" title=\"promise三种状态\"></a>promise三种状态</h3><p>上面提到了 <code>resolve</code> 和 <code>reject</code> 可以改变<code>Promise</code>对象的状态，那么它究竟有哪些状态呢？<br><code>Promise</code>对象有三种对象<br>1 <code>Fulfilled</code> 可以理解为成功的状态<br>2 <code>Rejected</code> 可以理解为失败的状态<br>3 <code>Pending</code> 可以理解为<code>Promise</code>对象实例创建时候的初始状态</p>\n<h4 id=\"then和catch\"><a href=\"#then和catch\" class=\"headerlink\" title=\"then和catch\"></a>then和catch</h4><p>helloWorld 的例子当中利用了 <code>then(onFulfilld, onRejected)</code> 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printHello</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printWorld</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printExclamation</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printHello(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>)</span>&#123;</span><br><span class=\"line\">        alert(message);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(printWorld)</span><br><span class=\"line\">    .then(printExclamation);</span><br></pre></td></tr></table></figure>\n\n<p><code>catch</code> 方法是 <code>then(onFulfilled, onRejected)</code> 方法当中 <code>onRejected</code> 函数的一个简单的写法，也就是说可以写成<code>then(fn).catch(fn)</code>，相当于 <code>then(fn).then(null, fn)</code>。使用 <code>catch</code> 的写法比一般的写法更加清晰明确。</p>\n<h4 id=\"Promise-all-和-Promise-race\"><a href=\"#Promise-all-和-Promise-race\" class=\"headerlink\" title=\"Promise.all 和 Promise.race\"></a>Promise.all 和 Promise.race</h4><p><code>Promise.all</code> 可以接收一个元素为 <code>Promise</code> 对象的数组作为参数，当这个数组里面所有的 <code>Promise</code> 对象都变为 <code>resolve</code> 时，该方法才会返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>Promise.race</code> 在<code>promise</code>数组中任何一个<code>promise</code>对象变成<code>resolve</code>或者<code>reject</code>，马上执行函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `delay`毫秒后执行resolve</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timerPromisefy</span>(<span class=\"params\">delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            resolve(delay);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 任何一个promise变为resolve或reject 的话程序就停止运行</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">1</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">32</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">64</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">128</span>)</span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);    <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>特殊地方</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;inner promise&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">    resolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;outer promise&quot;</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果是：<code>inner promise -&gt; outer promise -&gt; 42</code></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>由于<code>js</code>的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。<code>ES6</code>(也叫<code>ES2015</code>)为了解决这个问题提出了<code>Promse</code>对象。</p>","more":"<h3 id=\"出现Promise的原因\"><a href=\"#出现Promise的原因\" class=\"headerlink\" title=\"出现Promise的原因\"></a>出现Promise的原因</h3><p>当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 要在第一个请求成功后才可以执行下一步</span></span><br><span class=\"line\">  $.ajax(&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>回调地狱，多个操作的时候就要无限嵌套回调函数了</li>\n<li>如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了</li>\n</ol>\n<h3 id=\"什么是Promise？\"><a href=\"#什么是Promise？\" class=\"headerlink\" title=\"什么是Promise？\"></a>什么是Promise？</h3><p>一个<code>Promise</code>对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了<code>Promise</code>对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。</p>\n<h4 id=\"resolve和reject\"><a href=\"#resolve和reject\" class=\"headerlink\" title=\"resolve和reject\"></a>resolve和reject</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">helloWorld</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">helloWorld(<span class=\"literal\">true</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    alert(message);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>resolve</code> 方法可以使<code>Promise</code>对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 <code>Hello World!</code> 字符串。<br><code>reject</code> 方法则是将<code>Promise</code>对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。</p>\n<h3 id=\"promise三种状态\"><a href=\"#promise三种状态\" class=\"headerlink\" title=\"promise三种状态\"></a>promise三种状态</h3><p>上面提到了 <code>resolve</code> 和 <code>reject</code> 可以改变<code>Promise</code>对象的状态，那么它究竟有哪些状态呢？<br><code>Promise</code>对象有三种对象<br>1 <code>Fulfilled</code> 可以理解为成功的状态<br>2 <code>Rejected</code> 可以理解为失败的状态<br>3 <code>Pending</code> 可以理解为<code>Promise</code>对象实例创建时候的初始状态</p>\n<h4 id=\"then和catch\"><a href=\"#then和catch\" class=\"headerlink\" title=\"then和catch\"></a>then和catch</h4><p>helloWorld 的例子当中利用了 <code>then(onFulfilld, onRejected)</code> 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printHello</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printWorld</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printExclamation</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printHello(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>)</span>&#123;</span><br><span class=\"line\">        alert(message);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(printWorld)</span><br><span class=\"line\">    .then(printExclamation);</span><br></pre></td></tr></table></figure>\n\n<p><code>catch</code> 方法是 <code>then(onFulfilled, onRejected)</code> 方法当中 <code>onRejected</code> 函数的一个简单的写法，也就是说可以写成<code>then(fn).catch(fn)</code>，相当于 <code>then(fn).then(null, fn)</code>。使用 <code>catch</code> 的写法比一般的写法更加清晰明确。</p>\n<h4 id=\"Promise-all-和-Promise-race\"><a href=\"#Promise-all-和-Promise-race\" class=\"headerlink\" title=\"Promise.all 和 Promise.race\"></a>Promise.all 和 Promise.race</h4><p><code>Promise.all</code> 可以接收一个元素为 <code>Promise</code> 对象的数组作为参数，当这个数组里面所有的 <code>Promise</code> 对象都变为 <code>resolve</code> 时，该方法才会返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>Promise.race</code> 在<code>promise</code>数组中任何一个<code>promise</code>对象变成<code>resolve</code>或者<code>reject</code>，马上执行函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `delay`毫秒后执行resolve</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timerPromisefy</span>(<span class=\"params\">delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            resolve(delay);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 任何一个promise变为resolve或reject 的话程序就停止运行</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">1</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">32</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">64</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">128</span>)</span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);    <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>特殊地方</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;inner promise&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">    resolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;outer promise&quot;</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果是：<code>inner promise -&gt; outer promise -&gt; 42</code></p>"},{"title":"探索CSS盒模型","date":"2017-08-15T16:17:32.000Z","desc":"css model，css盒模型，margin，padding，widht，height","_content":"\n从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。\n\n现在开发基本遇到的基本样式(`CSS`)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。\n\n<!-- more -->\n\n# 块级元素\n\n毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png)\n\n## 水平格式化\n\n水平方向的大小也是有些复杂，主要一个原因是`width`影响的是内容(`content`)区域的宽度，而不是整个可见的元素框。\n\n大多数开发者以为，`widht`指的就是可见元素框的宽度，其实不是这样的(不过`CSS3`的`box-sizing`可以修改盒模型，这里暂不讨论)。\n\n\n> **可见元素框的宽 = `margin-left` + `border-left` + `padding-left` + `width` + `padding-right` + `border-right` + `margin-right`**\n\n知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。\n\n> 以上7个属性中，只有`margin-left`、`margin-right`和`width`这三个属性可以设置为auto，其他必须设置特定的值或0\n\n### 使用auto\n\n首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的`width`。\n\n#### 设置一个auto\n\n假定父元素`width: 400px`\n\n```css\np {\n    magrin-left: auto; /* 等于200px */\n    margin-right: 100px;\n    width: 100px;\n}\n```\n\n此时`margin-left`就是弥补剩余的宽度即400-100-100=200\n\n#### 不设置auto\n\n如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的`width`:\n\n```css\np {\n  magrin-left: 100px;\n  margin-right: 100px; /* 等于200px */\n  width: 100px;  \n}\n```\n\n其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(`overconstrained`)，因此此时的`margin-right`会被强制设置成`auto`，即`margin-right=200px`而不是我们想当然的那样等于`100px`。\n\n(ps:在英语这种从左向右读的语言是强制设置`marin-right`，而在从右向左的语言则是强制设置`margin-left`为`auto`了)\n\n#### 设置两个auto\n\n首先先考虑常用的，设置两个`margin`为`auto`，此时就可以实现水平居中的效果。\n\n如果设置其中一个`margin`和`width`为`auto`的话，`margin`的值则会减为0，而`widht`会水平延伸直至充满父元素。\n\n#### 设置三个auto\n\n即`margin-left`、`margin-right`和`widht`都为`auto`。此时和上面那个例子比较类似，就是`margin`都减为0，`width`则填满父元素。\n\n### 负的margin值\n\n前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：\n\n```css\n.parent {\n    widht: 400px;\n    border: 2px solid black;\n}\n\n.child {\n    margin-left: 10px;\n    width: auto;\n    margin-right: -50px;\n}\n```\n\n这个时候child这个子元素的`widht`是多少呢？\n\n根据前面提到的算法可以得到：**10px + 0 + 0 + width + -50px = 400px**，此时可以得到`width=440px`\n\n另外需要注意的是：`padding`、`border`和`width`都不能设置为负值。\n\n## 垂直格式化\n\n垂直方向和水平的大部分都比较类似，比如：\n\n> 可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom\n\n如果此时子元素的`height`大于父元素的`height`时，具体效果就要取决于`overflow`属性的值了，这里暂不讨论。\n\n有一点不一样的是：`margin-top`和`margin-bottom`设置为`auto`的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。\n\n### 设置margin-top、margin-bottom\n\n经常会有这么一个情况：子元素设置了`margin-top`或者`margin-bottom`，但是父元素不会撑开这部分的`margin`高度，这部分出现在父元素以外:\n\n```html\n<div class=\"parent\" style=\"background-color: silver\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n此时效果是这样的：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg)\n\n因为块级元素只有块级子元素的话，其高度是子元素的`border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom`的总和。\n\n但是如果该块级元素有padding或者border的话，则其高度等于子元素的`margin-top` + `border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom` + `margin-bottom`总和。比如：\n\n```html\n<div class=\"parent\" style=\"background-color: silver; border: 1px solid black\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n#### 合并margin-top和margin-bottom\n\n众所周知的是，如果有上下两个元素，上元素的`margin-bottom`和下元素的`margin-top`是会合并的，大小等于这两个的最大值。\n\n这时又有一个例外，就是如果元素含有`padding`或者`border`的话，则不会合并。","source":"_posts/css-box-model.md","raw":"---\ntitle: 探索CSS盒模型\ndate: 2017-08-16 00:17:32\ntags: \n- CSS\n- 盒模型\ndesc: css model，css盒模型，margin，padding，widht，height\n---\n\n从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。\n\n现在开发基本遇到的基本样式(`CSS`)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。\n\n<!-- more -->\n\n# 块级元素\n\n毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png)\n\n## 水平格式化\n\n水平方向的大小也是有些复杂，主要一个原因是`width`影响的是内容(`content`)区域的宽度，而不是整个可见的元素框。\n\n大多数开发者以为，`widht`指的就是可见元素框的宽度，其实不是这样的(不过`CSS3`的`box-sizing`可以修改盒模型，这里暂不讨论)。\n\n\n> **可见元素框的宽 = `margin-left` + `border-left` + `padding-left` + `width` + `padding-right` + `border-right` + `margin-right`**\n\n知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。\n\n> 以上7个属性中，只有`margin-left`、`margin-right`和`width`这三个属性可以设置为auto，其他必须设置特定的值或0\n\n### 使用auto\n\n首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的`width`。\n\n#### 设置一个auto\n\n假定父元素`width: 400px`\n\n```css\np {\n    magrin-left: auto; /* 等于200px */\n    margin-right: 100px;\n    width: 100px;\n}\n```\n\n此时`margin-left`就是弥补剩余的宽度即400-100-100=200\n\n#### 不设置auto\n\n如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的`width`:\n\n```css\np {\n  magrin-left: 100px;\n  margin-right: 100px; /* 等于200px */\n  width: 100px;  \n}\n```\n\n其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(`overconstrained`)，因此此时的`margin-right`会被强制设置成`auto`，即`margin-right=200px`而不是我们想当然的那样等于`100px`。\n\n(ps:在英语这种从左向右读的语言是强制设置`marin-right`，而在从右向左的语言则是强制设置`margin-left`为`auto`了)\n\n#### 设置两个auto\n\n首先先考虑常用的，设置两个`margin`为`auto`，此时就可以实现水平居中的效果。\n\n如果设置其中一个`margin`和`width`为`auto`的话，`margin`的值则会减为0，而`widht`会水平延伸直至充满父元素。\n\n#### 设置三个auto\n\n即`margin-left`、`margin-right`和`widht`都为`auto`。此时和上面那个例子比较类似，就是`margin`都减为0，`width`则填满父元素。\n\n### 负的margin值\n\n前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：\n\n```css\n.parent {\n    widht: 400px;\n    border: 2px solid black;\n}\n\n.child {\n    margin-left: 10px;\n    width: auto;\n    margin-right: -50px;\n}\n```\n\n这个时候child这个子元素的`widht`是多少呢？\n\n根据前面提到的算法可以得到：**10px + 0 + 0 + width + -50px = 400px**，此时可以得到`width=440px`\n\n另外需要注意的是：`padding`、`border`和`width`都不能设置为负值。\n\n## 垂直格式化\n\n垂直方向和水平的大部分都比较类似，比如：\n\n> 可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom\n\n如果此时子元素的`height`大于父元素的`height`时，具体效果就要取决于`overflow`属性的值了，这里暂不讨论。\n\n有一点不一样的是：`margin-top`和`margin-bottom`设置为`auto`的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。\n\n### 设置margin-top、margin-bottom\n\n经常会有这么一个情况：子元素设置了`margin-top`或者`margin-bottom`，但是父元素不会撑开这部分的`margin`高度，这部分出现在父元素以外:\n\n```html\n<div class=\"parent\" style=\"background-color: silver\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n此时效果是这样的：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg)\n\n因为块级元素只有块级子元素的话，其高度是子元素的`border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom`的总和。\n\n但是如果该块级元素有padding或者border的话，则其高度等于子元素的`margin-top` + `border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom` + `margin-bottom`总和。比如：\n\n```html\n<div class=\"parent\" style=\"background-color: silver; border: 1px solid black\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n#### 合并margin-top和margin-bottom\n\n众所周知的是，如果有上下两个元素，上元素的`margin-bottom`和下元素的`margin-top`是会合并的，大小等于这两个的最大值。\n\n这时又有一个例外，就是如果元素含有`padding`或者`border`的话，则不会合并。","slug":"css-box-model","published":1,"updated":"2020-05-23T06:05:56.000Z","_id":"ckxvfmfde001lbrqqg2qv6ym0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。</p>\n<p>现在开发基本遇到的基本样式(<code>CSS</code>)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h1><p>毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png\"></p>\n<h2 id=\"水平格式化\"><a href=\"#水平格式化\" class=\"headerlink\" title=\"水平格式化\"></a>水平格式化</h2><p>水平方向的大小也是有些复杂，主要一个原因是<code>width</code>影响的是内容(<code>content</code>)区域的宽度，而不是整个可见的元素框。</p>\n<p>大多数开发者以为，<code>widht</code>指的就是可见元素框的宽度，其实不是这样的(不过<code>CSS3</code>的<code>box-sizing</code>可以修改盒模型，这里暂不讨论)。</p>\n<blockquote>\n<p><strong>可见元素框的宽 = <code>margin-left</code> + <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code> + <code>margin-right</code></strong></p>\n</blockquote>\n<p>知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。</p>\n<blockquote>\n<p>以上7个属性中，只有<code>margin-left</code>、<code>margin-right</code>和<code>width</code>这三个属性可以设置为auto，其他必须设置特定的值或0</p>\n</blockquote>\n<h3 id=\"使用auto\"><a href=\"#使用auto\" class=\"headerlink\" title=\"使用auto\"></a>使用auto</h3><p>首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的<code>width</code>。</p>\n<h4 id=\"设置一个auto\"><a href=\"#设置一个auto\" class=\"headerlink\" title=\"设置一个auto\"></a>设置一个auto</h4><p>假定父元素<code>width: 400px</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    magrin-<span class=\"attribute\">left</span>: auto; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时<code>margin-left</code>就是弥补剩余的宽度即400-100-100=200</p>\n<h4 id=\"不设置auto\"><a href=\"#不设置auto\" class=\"headerlink\" title=\"不设置auto\"></a>不设置auto</h4><p>如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的<code>width</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  magrin-<span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(<code>overconstrained</code>)，因此此时的<code>margin-right</code>会被强制设置成<code>auto</code>，即<code>margin-right=200px</code>而不是我们想当然的那样等于<code>100px</code>。</p>\n<p>(ps:在英语这种从左向右读的语言是强制设置<code>marin-right</code>，而在从右向左的语言则是强制设置<code>margin-left</code>为<code>auto</code>了)</p>\n<h4 id=\"设置两个auto\"><a href=\"#设置两个auto\" class=\"headerlink\" title=\"设置两个auto\"></a>设置两个auto</h4><p>首先先考虑常用的，设置两个<code>margin</code>为<code>auto</code>，此时就可以实现水平居中的效果。</p>\n<p>如果设置其中一个<code>margin</code>和<code>width</code>为<code>auto</code>的话，<code>margin</code>的值则会减为0，而<code>widht</code>会水平延伸直至充满父元素。</p>\n<h4 id=\"设置三个auto\"><a href=\"#设置三个auto\" class=\"headerlink\" title=\"设置三个auto\"></a>设置三个auto</h4><p>即<code>margin-left</code>、<code>margin-right</code>和<code>widht</code>都为<code>auto</code>。此时和上面那个例子比较类似，就是<code>margin</code>都减为0，<code>width</code>则填满父元素。</p>\n<h3 id=\"负的margin值\"><a href=\"#负的margin值\" class=\"headerlink\" title=\"负的margin值\"></a>负的margin值</h3><p>前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">    widht: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候child这个子元素的<code>widht</code>是多少呢？</p>\n<p>根据前面提到的算法可以得到：<strong>10px + 0 + 0 + width + -50px = 400px</strong>，此时可以得到<code>width=440px</code></p>\n<p>另外需要注意的是：<code>padding</code>、<code>border</code>和<code>width</code>都不能设置为负值。</p>\n<h2 id=\"垂直格式化\"><a href=\"#垂直格式化\" class=\"headerlink\" title=\"垂直格式化\"></a>垂直格式化</h2><p>垂直方向和水平的大部分都比较类似，比如：</p>\n<blockquote>\n<p>可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom</p>\n</blockquote>\n<p>如果此时子元素的<code>height</code>大于父元素的<code>height</code>时，具体效果就要取决于<code>overflow</code>属性的值了，这里暂不讨论。</p>\n<p>有一点不一样的是：<code>margin-top</code>和<code>margin-bottom</code>设置为<code>auto</code>的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。</p>\n<h3 id=\"设置margin-top、margin-bottom\"><a href=\"#设置margin-top、margin-bottom\" class=\"headerlink\" title=\"设置margin-top、margin-bottom\"></a>设置margin-top、margin-bottom</h3><p>经常会有这么一个情况：子元素设置了<code>margin-top</code>或者<code>margin-bottom</code>，但是父元素不会撑开这部分的<code>margin</code>高度，这部分出现在父元素以外:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时效果是这样的：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg\"></p>\n<p>因为块级元素只有块级子元素的话，其高度是子元素的<code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code>的总和。</p>\n<p>但是如果该块级元素有padding或者border的话，则其高度等于子元素的<code>margin-top</code> + <code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code> + <code>margin-bottom</code>总和。比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver; border: 1px solid black&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并margin-top和margin-bottom\"><a href=\"#合并margin-top和margin-bottom\" class=\"headerlink\" title=\"合并margin-top和margin-bottom\"></a>合并margin-top和margin-bottom</h4><p>众所周知的是，如果有上下两个元素，上元素的<code>margin-bottom</code>和下元素的<code>margin-top</code>是会合并的，大小等于这两个的最大值。</p>\n<p>这时又有一个例外，就是如果元素含有<code>padding</code>或者<code>border</code>的话，则不会合并。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。</p>\n<p>现在开发基本遇到的基本样式(<code>CSS</code>)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。</p>","more":"<h1 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h1><p>毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png\"></p>\n<h2 id=\"水平格式化\"><a href=\"#水平格式化\" class=\"headerlink\" title=\"水平格式化\"></a>水平格式化</h2><p>水平方向的大小也是有些复杂，主要一个原因是<code>width</code>影响的是内容(<code>content</code>)区域的宽度，而不是整个可见的元素框。</p>\n<p>大多数开发者以为，<code>widht</code>指的就是可见元素框的宽度，其实不是这样的(不过<code>CSS3</code>的<code>box-sizing</code>可以修改盒模型，这里暂不讨论)。</p>\n<blockquote>\n<p><strong>可见元素框的宽 = <code>margin-left</code> + <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code> + <code>margin-right</code></strong></p>\n</blockquote>\n<p>知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。</p>\n<blockquote>\n<p>以上7个属性中，只有<code>margin-left</code>、<code>margin-right</code>和<code>width</code>这三个属性可以设置为auto，其他必须设置特定的值或0</p>\n</blockquote>\n<h3 id=\"使用auto\"><a href=\"#使用auto\" class=\"headerlink\" title=\"使用auto\"></a>使用auto</h3><p>首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的<code>width</code>。</p>\n<h4 id=\"设置一个auto\"><a href=\"#设置一个auto\" class=\"headerlink\" title=\"设置一个auto\"></a>设置一个auto</h4><p>假定父元素<code>width: 400px</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    magrin-<span class=\"attribute\">left</span>: auto; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时<code>margin-left</code>就是弥补剩余的宽度即400-100-100=200</p>\n<h4 id=\"不设置auto\"><a href=\"#不设置auto\" class=\"headerlink\" title=\"不设置auto\"></a>不设置auto</h4><p>如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的<code>width</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  magrin-<span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(<code>overconstrained</code>)，因此此时的<code>margin-right</code>会被强制设置成<code>auto</code>，即<code>margin-right=200px</code>而不是我们想当然的那样等于<code>100px</code>。</p>\n<p>(ps:在英语这种从左向右读的语言是强制设置<code>marin-right</code>，而在从右向左的语言则是强制设置<code>margin-left</code>为<code>auto</code>了)</p>\n<h4 id=\"设置两个auto\"><a href=\"#设置两个auto\" class=\"headerlink\" title=\"设置两个auto\"></a>设置两个auto</h4><p>首先先考虑常用的，设置两个<code>margin</code>为<code>auto</code>，此时就可以实现水平居中的效果。</p>\n<p>如果设置其中一个<code>margin</code>和<code>width</code>为<code>auto</code>的话，<code>margin</code>的值则会减为0，而<code>widht</code>会水平延伸直至充满父元素。</p>\n<h4 id=\"设置三个auto\"><a href=\"#设置三个auto\" class=\"headerlink\" title=\"设置三个auto\"></a>设置三个auto</h4><p>即<code>margin-left</code>、<code>margin-right</code>和<code>widht</code>都为<code>auto</code>。此时和上面那个例子比较类似，就是<code>margin</code>都减为0，<code>width</code>则填满父元素。</p>\n<h3 id=\"负的margin值\"><a href=\"#负的margin值\" class=\"headerlink\" title=\"负的margin值\"></a>负的margin值</h3><p>前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">    widht: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候child这个子元素的<code>widht</code>是多少呢？</p>\n<p>根据前面提到的算法可以得到：<strong>10px + 0 + 0 + width + -50px = 400px</strong>，此时可以得到<code>width=440px</code></p>\n<p>另外需要注意的是：<code>padding</code>、<code>border</code>和<code>width</code>都不能设置为负值。</p>\n<h2 id=\"垂直格式化\"><a href=\"#垂直格式化\" class=\"headerlink\" title=\"垂直格式化\"></a>垂直格式化</h2><p>垂直方向和水平的大部分都比较类似，比如：</p>\n<blockquote>\n<p>可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom</p>\n</blockquote>\n<p>如果此时子元素的<code>height</code>大于父元素的<code>height</code>时，具体效果就要取决于<code>overflow</code>属性的值了，这里暂不讨论。</p>\n<p>有一点不一样的是：<code>margin-top</code>和<code>margin-bottom</code>设置为<code>auto</code>的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。</p>\n<h3 id=\"设置margin-top、margin-bottom\"><a href=\"#设置margin-top、margin-bottom\" class=\"headerlink\" title=\"设置margin-top、margin-bottom\"></a>设置margin-top、margin-bottom</h3><p>经常会有这么一个情况：子元素设置了<code>margin-top</code>或者<code>margin-bottom</code>，但是父元素不会撑开这部分的<code>margin</code>高度，这部分出现在父元素以外:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时效果是这样的：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg\"></p>\n<p>因为块级元素只有块级子元素的话，其高度是子元素的<code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code>的总和。</p>\n<p>但是如果该块级元素有padding或者border的话，则其高度等于子元素的<code>margin-top</code> + <code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code> + <code>margin-bottom</code>总和。比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver; border: 1px solid black&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并margin-top和margin-bottom\"><a href=\"#合并margin-top和margin-bottom\" class=\"headerlink\" title=\"合并margin-top和margin-bottom\"></a>合并margin-top和margin-bottom</h4><p>众所周知的是，如果有上下两个元素，上元素的<code>margin-bottom</code>和下元素的<code>margin-top</code>是会合并的，大小等于这两个的最大值。</p>\n<p>这时又有一个例外，就是如果元素含有<code>padding</code>或者<code>border</code>的话，则不会合并。</p>"},{"title":"CSS background","date":"2015-10-17T08:05:26.000Z","desc":"CSS,background,background-size,background-clip,background-origin,background-position,background-attachment","_content":"\nWEB开发常用到`background`但是没有去深究，仔细看了之后，发现`background`里面的知识点还是挺多不懂的。\n\n<!--more-->\n\n### background-size\n\n设置背景图大小[`初始值auto auto`-`非继承`-`适用所有元素`]\n\n```\nbackgrount-size: (<length> | <percentage> | auto){1,2} | contain | cover\n```\n- `length`：直接指定背景图大小\n- `percentage`：指定背景图片相对背景区的百分比\n- `auto`：以背景图片的比例缩放背景图片\n- `contain`：缩放背景图片以完全装入背景区，可能背景区部分空白。\n- `cover`：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。\n\n补充：\n- `<length>`/`<percentage>`/`auto` 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成`auto`\n- 逗号分隔的多个值：设置多重背景\n- `contain`/`cover` 会保留图片的原来比例\n\n### background-origin\n\n规定了指定背景图片`background-image`属性的原点位置的背景相对区域[`初始值padding-box`-`非继承`-`适用所有元素`]\n\n\n```\nbackgrount-origin: border-box | padding-box | content-box\n```\n\n- `border-box`: 背景图将显示在`border`上，设置`border-style:dashed`即可以看到效果\n- `padding-box`: 背景图将显示到`padding`上。\n- `content-box`: 背景图只显示在内容区域\n\n如果还不明白，可以看[这个例子](https://jsfiddle.net/vk3v9sez/)\n\n补充：\n\n- 当使用 `background-attachment` 为`fixed`时，该属性将被忽略不起作用。\n\n### background-clip\n\n效果同上面的`background-origin`，差别在于指定的是背景色不是图片\n\n[例子才此](https://jsfiddle.net/vk3v9sez/1/)，可以和上面对比一下\n\n### background-attachment\n\n如果指定了 `background-image` ，那么 `background-attachment` 决定背景是在视口中固定的还是随包含它的区块滚动的[`初始值scroll`-`非继承`-`适用所有元素`]\n\n\n```\nbackground-attachment: scroll | fixed | local\n```\n\n- `scroll`： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。\n- `fixed`：表示背景相对于视口固定\n- `local`：表示背景相对于元素的内容固定。\n\n解释：\n- `fixed`和其他两个的差别在于：`fixed`是相对于视窗（可以理解成屏幕）固定的。\n- `scroll`和`local`的差别在于：`scroll`在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而`local`则是跟着滚动的。可以看下[根据MDN改编的例子](https://jsfiddle.net/bcLs7uxk/)\n\n### background-position\n\n指定背景图片的初始位置[`初始值0% 0%`-`非继承`-`适用所有元素`]\n\n```\nbackground-position: (top, bottom, left, right){1,2} | <percentage> | <length>\n\n```\n\n- `top`: 等于垂直方向的0%\n- `bottom`：等于垂直方向的100%\n- `left`：等于水平方向的0%\n- `right`：等于水平方向的100%","source":"_posts/css-background.md","raw":"---\ntitle: CSS background\ndate: 2015-10-17 16:05:26\ntags: \n- CSS\ndesc: CSS,background,background-size,background-clip,background-origin,background-position,background-attachment\n---\n\nWEB开发常用到`background`但是没有去深究，仔细看了之后，发现`background`里面的知识点还是挺多不懂的。\n\n<!--more-->\n\n### background-size\n\n设置背景图大小[`初始值auto auto`-`非继承`-`适用所有元素`]\n\n```\nbackgrount-size: (<length> | <percentage> | auto){1,2} | contain | cover\n```\n- `length`：直接指定背景图大小\n- `percentage`：指定背景图片相对背景区的百分比\n- `auto`：以背景图片的比例缩放背景图片\n- `contain`：缩放背景图片以完全装入背景区，可能背景区部分空白。\n- `cover`：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。\n\n补充：\n- `<length>`/`<percentage>`/`auto` 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成`auto`\n- 逗号分隔的多个值：设置多重背景\n- `contain`/`cover` 会保留图片的原来比例\n\n### background-origin\n\n规定了指定背景图片`background-image`属性的原点位置的背景相对区域[`初始值padding-box`-`非继承`-`适用所有元素`]\n\n\n```\nbackgrount-origin: border-box | padding-box | content-box\n```\n\n- `border-box`: 背景图将显示在`border`上，设置`border-style:dashed`即可以看到效果\n- `padding-box`: 背景图将显示到`padding`上。\n- `content-box`: 背景图只显示在内容区域\n\n如果还不明白，可以看[这个例子](https://jsfiddle.net/vk3v9sez/)\n\n补充：\n\n- 当使用 `background-attachment` 为`fixed`时，该属性将被忽略不起作用。\n\n### background-clip\n\n效果同上面的`background-origin`，差别在于指定的是背景色不是图片\n\n[例子才此](https://jsfiddle.net/vk3v9sez/1/)，可以和上面对比一下\n\n### background-attachment\n\n如果指定了 `background-image` ，那么 `background-attachment` 决定背景是在视口中固定的还是随包含它的区块滚动的[`初始值scroll`-`非继承`-`适用所有元素`]\n\n\n```\nbackground-attachment: scroll | fixed | local\n```\n\n- `scroll`： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。\n- `fixed`：表示背景相对于视口固定\n- `local`：表示背景相对于元素的内容固定。\n\n解释：\n- `fixed`和其他两个的差别在于：`fixed`是相对于视窗（可以理解成屏幕）固定的。\n- `scroll`和`local`的差别在于：`scroll`在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而`local`则是跟着滚动的。可以看下[根据MDN改编的例子](https://jsfiddle.net/bcLs7uxk/)\n\n### background-position\n\n指定背景图片的初始位置[`初始值0% 0%`-`非继承`-`适用所有元素`]\n\n```\nbackground-position: (top, bottom, left, right){1,2} | <percentage> | <length>\n\n```\n\n- `top`: 等于垂直方向的0%\n- `bottom`：等于垂直方向的100%\n- `left`：等于水平方向的0%\n- `right`：等于水平方向的100%","slug":"css-background","published":1,"updated":"2020-05-23T06:12:38.000Z","_id":"ckxvfmfdj001nbrqq96cpbrnr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WEB开发常用到<code>background</code>但是没有去深究，仔细看了之后，发现<code>background</code>里面的知识点还是挺多不懂的。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h3><p>设置背景图大小[<code>初始值auto auto</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-size: (&lt;length&gt; | &lt;percentage&gt; | auto)&#123;1,2&#125; | contain | cover</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>length</code>：直接指定背景图大小</li>\n<li><code>percentage</code>：指定背景图片相对背景区的百分比</li>\n<li><code>auto</code>：以背景图片的比例缩放背景图片</li>\n<li><code>contain</code>：缩放背景图片以完全装入背景区，可能背景区部分空白。</li>\n<li><code>cover</code>：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。</li>\n</ul>\n<p>补充：</p>\n<ul>\n<li><code>&lt;length&gt;</code>/<code>&lt;percentage&gt;</code>/<code>auto</code> 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成<code>auto</code></li>\n<li>逗号分隔的多个值：设置多重背景</li>\n<li><code>contain</code>/<code>cover</code> 会保留图片的原来比例</li>\n</ul>\n<h3 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h3><p>规定了指定背景图片<code>background-image</code>属性的原点位置的背景相对区域[<code>初始值padding-box</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-origin: border-box | padding-box | content-box</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>border-box</code>: 背景图将显示在<code>border</code>上，设置<code>border-style:dashed</code>即可以看到效果</li>\n<li><code>padding-box</code>: 背景图将显示到<code>padding</code>上。</li>\n<li><code>content-box</code>: 背景图只显示在内容区域</li>\n</ul>\n<p>如果还不明白，可以看<a href=\"https://jsfiddle.net/vk3v9sez/\">这个例子</a></p>\n<p>补充：</p>\n<ul>\n<li>当使用 <code>background-attachment</code> 为<code>fixed</code>时，该属性将被忽略不起作用。</li>\n</ul>\n<h3 id=\"background-clip\"><a href=\"#background-clip\" class=\"headerlink\" title=\"background-clip\"></a>background-clip</h3><p>效果同上面的<code>background-origin</code>，差别在于指定的是背景色不是图片</p>\n<p><a href=\"https://jsfiddle.net/vk3v9sez/1/\">例子才此</a>，可以和上面对比一下</p>\n<h3 id=\"background-attachment\"><a href=\"#background-attachment\" class=\"headerlink\" title=\"background-attachment\"></a>background-attachment</h3><p>如果指定了 <code>background-image</code> ，那么 <code>background-attachment</code> 决定背景是在视口中固定的还是随包含它的区块滚动的[<code>初始值scroll</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-attachment: scroll | fixed | local</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>scroll</code>： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。</li>\n<li><code>fixed</code>：表示背景相对于视口固定</li>\n<li><code>local</code>：表示背景相对于元素的内容固定。</li>\n</ul>\n<p>解释：</p>\n<ul>\n<li><code>fixed</code>和其他两个的差别在于：<code>fixed</code>是相对于视窗（可以理解成屏幕）固定的。</li>\n<li><code>scroll</code>和<code>local</code>的差别在于：<code>scroll</code>在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而<code>local</code>则是跟着滚动的。可以看下<a href=\"https://jsfiddle.net/bcLs7uxk/\">根据MDN改编的例子</a></li>\n</ul>\n<h3 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h3><p>指定背景图片的初始位置[<code>初始值0% 0%</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-position: (top, bottom, left, right)&#123;1,2&#125; | &lt;percentage&gt; | &lt;length&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>top</code>: 等于垂直方向的0%</li>\n<li><code>bottom</code>：等于垂直方向的100%</li>\n<li><code>left</code>：等于水平方向的0%</li>\n<li><code>right</code>：等于水平方向的100%</li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>WEB开发常用到<code>background</code>但是没有去深究，仔细看了之后，发现<code>background</code>里面的知识点还是挺多不懂的。</p>","more":"<h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h3><p>设置背景图大小[<code>初始值auto auto</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-size: (&lt;length&gt; | &lt;percentage&gt; | auto)&#123;1,2&#125; | contain | cover</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>length</code>：直接指定背景图大小</li>\n<li><code>percentage</code>：指定背景图片相对背景区的百分比</li>\n<li><code>auto</code>：以背景图片的比例缩放背景图片</li>\n<li><code>contain</code>：缩放背景图片以完全装入背景区，可能背景区部分空白。</li>\n<li><code>cover</code>：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。</li>\n</ul>\n<p>补充：</p>\n<ul>\n<li><code>&lt;length&gt;</code>/<code>&lt;percentage&gt;</code>/<code>auto</code> 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成<code>auto</code></li>\n<li>逗号分隔的多个值：设置多重背景</li>\n<li><code>contain</code>/<code>cover</code> 会保留图片的原来比例</li>\n</ul>\n<h3 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h3><p>规定了指定背景图片<code>background-image</code>属性的原点位置的背景相对区域[<code>初始值padding-box</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-origin: border-box | padding-box | content-box</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>border-box</code>: 背景图将显示在<code>border</code>上，设置<code>border-style:dashed</code>即可以看到效果</li>\n<li><code>padding-box</code>: 背景图将显示到<code>padding</code>上。</li>\n<li><code>content-box</code>: 背景图只显示在内容区域</li>\n</ul>\n<p>如果还不明白，可以看<a href=\"https://jsfiddle.net/vk3v9sez/\">这个例子</a></p>\n<p>补充：</p>\n<ul>\n<li>当使用 <code>background-attachment</code> 为<code>fixed</code>时，该属性将被忽略不起作用。</li>\n</ul>\n<h3 id=\"background-clip\"><a href=\"#background-clip\" class=\"headerlink\" title=\"background-clip\"></a>background-clip</h3><p>效果同上面的<code>background-origin</code>，差别在于指定的是背景色不是图片</p>\n<p><a href=\"https://jsfiddle.net/vk3v9sez/1/\">例子才此</a>，可以和上面对比一下</p>\n<h3 id=\"background-attachment\"><a href=\"#background-attachment\" class=\"headerlink\" title=\"background-attachment\"></a>background-attachment</h3><p>如果指定了 <code>background-image</code> ，那么 <code>background-attachment</code> 决定背景是在视口中固定的还是随包含它的区块滚动的[<code>初始值scroll</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-attachment: scroll | fixed | local</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>scroll</code>： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。</li>\n<li><code>fixed</code>：表示背景相对于视口固定</li>\n<li><code>local</code>：表示背景相对于元素的内容固定。</li>\n</ul>\n<p>解释：</p>\n<ul>\n<li><code>fixed</code>和其他两个的差别在于：<code>fixed</code>是相对于视窗（可以理解成屏幕）固定的。</li>\n<li><code>scroll</code>和<code>local</code>的差别在于：<code>scroll</code>在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而<code>local</code>则是跟着滚动的。可以看下<a href=\"https://jsfiddle.net/bcLs7uxk/\">根据MDN改编的例子</a></li>\n</ul>\n<h3 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h3><p>指定背景图片的初始位置[<code>初始值0% 0%</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-position: (top, bottom, left, right)&#123;1,2&#125; | &lt;percentage&gt; | &lt;length&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>top</code>: 等于垂直方向的0%</li>\n<li><code>bottom</code>：等于垂直方向的100%</li>\n<li><code>left</code>：等于水平方向的0%</li>\n<li><code>right</code>：等于水平方向的100%</li>\n</ul>"},{"title":"从零开始，部署一个Web应用（三）Vue.js & Redis","date":"2017-10-27T10:37:14.000Z","desc":"for beginner, how to build an web application","_content":"\n这篇文章，就总结一些`Vue.js`和`Redis`遇到的问题。\n\n# Vue.js\n\n## 非index页面刷新报404\n\n由于采用了`Vue-router`前端路由。因此在非index页面刷新会出现404的问题。\n\n原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。\n\n以下是nginx的解决方案：\n\n```\nserver {\n    listen 80;\n    server_name favweb.cn;\n    access_log  off;\n\n    root /home/vuejs/dist;\n\n    location / {\n      try_files $uri $uri/ /index.html;\n    }\n}\n```\n\n## 页面统计问题\n\n由于Google Analytics的不可用，采用的是百度统计。\n\n发现统计数据都是只有主页，因此又是因为SPA的问题。\n\n解决方案是在前端路由切换的时候，手动调用PV追踪代码：\n\n```js\n_hmt.push(['_trackPageview', pageURL]);\n```\n\nVuejs的配置为：\n\n```js\nimport Router from 'vue-router'\n\nconst router = new Router(config)\n\nrouter.afterEach((to, from, next) => {\n  try {\n    window._hmt.push(['_trackPageview', to.path])\n  } catch (e) { }\n})\n```\n\n# Redis\n\n## 安装：\n\n```\nwget http://download.redis.io/releases/redis-4.0.2.tar.gz\ntar xzf redis-4.0.2.tar.gz\ncd redis-4.0.2\nmake\n```\n\n## 常用配置\n\n以`MacOS`的`homebrew`安装方式为例。其中`redis.conf`文件在`/usr/local/etc/`。\n\n### 后台运行\n\n```\n# 原来\ndaemonize no\n\n# 改成\ndaemonize yes\n```\n\n### 增加密码\n\n找到`requirepass`，去掉前面的注释符号`#`，后面改成自己的密码\n\n```\n#原来\n#requirepass yourPassword\n\n#改成\nrequirepass yourPassword\n```\n\n### 远程访问\n\n找到`bind`，将`127.0.0.1`改成`0.0.0.0`即可。\n\n因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。\n\n因此要开启这个之前，一定要先设置好密码。\n\n\n","source":"_posts/about-deploly-favweb-3.md","raw":"---\ntitle: 从零开始，部署一个Web应用（三）Vue.js & Redis\ndate: 2017-10-27 18:37:14\ntags: vue.js\ndesc: for beginner, how to build an web application\n---\n\n这篇文章，就总结一些`Vue.js`和`Redis`遇到的问题。\n\n# Vue.js\n\n## 非index页面刷新报404\n\n由于采用了`Vue-router`前端路由。因此在非index页面刷新会出现404的问题。\n\n原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。\n\n以下是nginx的解决方案：\n\n```\nserver {\n    listen 80;\n    server_name favweb.cn;\n    access_log  off;\n\n    root /home/vuejs/dist;\n\n    location / {\n      try_files $uri $uri/ /index.html;\n    }\n}\n```\n\n## 页面统计问题\n\n由于Google Analytics的不可用，采用的是百度统计。\n\n发现统计数据都是只有主页，因此又是因为SPA的问题。\n\n解决方案是在前端路由切换的时候，手动调用PV追踪代码：\n\n```js\n_hmt.push(['_trackPageview', pageURL]);\n```\n\nVuejs的配置为：\n\n```js\nimport Router from 'vue-router'\n\nconst router = new Router(config)\n\nrouter.afterEach((to, from, next) => {\n  try {\n    window._hmt.push(['_trackPageview', to.path])\n  } catch (e) { }\n})\n```\n\n# Redis\n\n## 安装：\n\n```\nwget http://download.redis.io/releases/redis-4.0.2.tar.gz\ntar xzf redis-4.0.2.tar.gz\ncd redis-4.0.2\nmake\n```\n\n## 常用配置\n\n以`MacOS`的`homebrew`安装方式为例。其中`redis.conf`文件在`/usr/local/etc/`。\n\n### 后台运行\n\n```\n# 原来\ndaemonize no\n\n# 改成\ndaemonize yes\n```\n\n### 增加密码\n\n找到`requirepass`，去掉前面的注释符号`#`，后面改成自己的密码\n\n```\n#原来\n#requirepass yourPassword\n\n#改成\nrequirepass yourPassword\n```\n\n### 远程访问\n\n找到`bind`，将`127.0.0.1`改成`0.0.0.0`即可。\n\n因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。\n\n因此要开启这个之前，一定要先设置好密码。\n\n\n","slug":"about-deploly-favweb-3","published":1,"updated":"2020-05-23T06:00:02.000Z","_id":"ckxvfmfdl001obrqq049pap06","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇文章，就总结一些<code>Vue.js</code>和<code>Redis</code>遇到的问题。</p>\n<h1 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h1><h2 id=\"非index页面刷新报404\"><a href=\"#非index页面刷新报404\" class=\"headerlink\" title=\"非index页面刷新报404\"></a>非index页面刷新报404</h2><p>由于采用了<code>Vue-router</code>前端路由。因此在非index页面刷新会出现404的问题。</p>\n<p>原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。</p>\n<p>以下是nginx的解决方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name favweb.cn;</span><br><span class=\"line\">    access_log  off;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /home/vuejs/dist;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">      try_files $uri $uri/ /index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"页面统计问题\"><a href=\"#页面统计问题\" class=\"headerlink\" title=\"页面统计问题\"></a>页面统计问题</h2><p>由于Google Analytics的不可用，采用的是百度统计。</p>\n<p>发现统计数据都是只有主页，因此又是因为SPA的问题。</p>\n<p>解决方案是在前端路由切换的时候，手动调用PV追踪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, pageURL]);</span><br></pre></td></tr></table></figure>\n\n<p>Vuejs的配置为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-router&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router(config)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>._hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, to.path])</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span><br><span class=\"line\">tar xzf redis-4.0.2.tar.gz</span><br><span class=\"line\">cd redis-4.0.2</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用配置\"><a href=\"#常用配置\" class=\"headerlink\" title=\"常用配置\"></a>常用配置</h2><p>以<code>MacOS</code>的<code>homebrew</code>安装方式为例。其中<code>redis.conf</code>文件在<code>/usr/local/etc/</code>。</p>\n<h3 id=\"后台运行\"><a href=\"#后台运行\" class=\"headerlink\" title=\"后台运行\"></a>后台运行</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 原来</span><br><span class=\"line\">daemonize no</span><br><span class=\"line\"></span><br><span class=\"line\"># 改成</span><br><span class=\"line\">daemonize yes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加密码\"><a href=\"#增加密码\" class=\"headerlink\" title=\"增加密码\"></a>增加密码</h3><p>找到<code>requirepass</code>，去掉前面的注释符号<code>#</code>，后面改成自己的密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#原来</span><br><span class=\"line\">#requirepass yourPassword</span><br><span class=\"line\"></span><br><span class=\"line\">#改成</span><br><span class=\"line\">requirepass yourPassword</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h3><p>找到<code>bind</code>，将<code>127.0.0.1</code>改成<code>0.0.0.0</code>即可。</p>\n<p>因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。</p>\n<p>因此要开启这个之前，一定要先设置好密码。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>这篇文章，就总结一些<code>Vue.js</code>和<code>Redis</code>遇到的问题。</p>\n<h1 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h1><h2 id=\"非index页面刷新报404\"><a href=\"#非index页面刷新报404\" class=\"headerlink\" title=\"非index页面刷新报404\"></a>非index页面刷新报404</h2><p>由于采用了<code>Vue-router</code>前端路由。因此在非index页面刷新会出现404的问题。</p>\n<p>原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。</p>\n<p>以下是nginx的解决方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name favweb.cn;</span><br><span class=\"line\">    access_log  off;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /home/vuejs/dist;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">      try_files $uri $uri/ /index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"页面统计问题\"><a href=\"#页面统计问题\" class=\"headerlink\" title=\"页面统计问题\"></a>页面统计问题</h2><p>由于Google Analytics的不可用，采用的是百度统计。</p>\n<p>发现统计数据都是只有主页，因此又是因为SPA的问题。</p>\n<p>解决方案是在前端路由切换的时候，手动调用PV追踪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, pageURL]);</span><br></pre></td></tr></table></figure>\n\n<p>Vuejs的配置为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-router&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router(config)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>._hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, to.path])</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span><br><span class=\"line\">tar xzf redis-4.0.2.tar.gz</span><br><span class=\"line\">cd redis-4.0.2</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用配置\"><a href=\"#常用配置\" class=\"headerlink\" title=\"常用配置\"></a>常用配置</h2><p>以<code>MacOS</code>的<code>homebrew</code>安装方式为例。其中<code>redis.conf</code>文件在<code>/usr/local/etc/</code>。</p>\n<h3 id=\"后台运行\"><a href=\"#后台运行\" class=\"headerlink\" title=\"后台运行\"></a>后台运行</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 原来</span><br><span class=\"line\">daemonize no</span><br><span class=\"line\"></span><br><span class=\"line\"># 改成</span><br><span class=\"line\">daemonize yes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加密码\"><a href=\"#增加密码\" class=\"headerlink\" title=\"增加密码\"></a>增加密码</h3><p>找到<code>requirepass</code>，去掉前面的注释符号<code>#</code>，后面改成自己的密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#原来</span><br><span class=\"line\">#requirepass yourPassword</span><br><span class=\"line\"></span><br><span class=\"line\">#改成</span><br><span class=\"line\">requirepass yourPassword</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h3><p>找到<code>bind</code>，将<code>127.0.0.1</code>改成<code>0.0.0.0</code>即可。</p>\n<p>因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。</p>\n<p>因此要开启这个之前，一定要先设置好密码。</p>\n"},{"title":"从零开始，部署一个Web应用（二）MongoDB & nginx","date":"2017-10-21T13:37:14.000Z","desc":"for beginner, how to build an web application","_content":"\n这篇文章，就总结一些部署`MongoDB`和`nginx`遇到的问题。\n\n# MongoDB\n\n安装的是社区版本([MongoDB Community Edition](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/))。\n\n## 安装\n\n先创建Mongodb在yum的配置文件：\n\n```\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n> 可动态改变版本号\n\n然后使用`yum`安装：\n\n```\nsudo yum install -y mongodb-org\n```\n\n## 安全相关\n\n如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。\n\n在MongoDB中，常用的是增加[用户访问限制](https://docs.mongodb.com/manual/tutorial/enable-authentication/)。\n\n### 高级管理员\n\n第一步，是先创建一个高级管理员。这个高级管理员可**管理其他用户**：\n\n```\n> use admin\n> db.createUser(\n  {\n    user: \"myUserAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]\n  }\n)\n```\n\n> 注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。\n\n可以这样以该角色进入MongoDB的命令行：\n\n```\nmongo --port 27017 -u \"myUserAdmin\" -p \"abc123\" --authenticationDatabase \"admin\"\n```\n\n### 增加其他用户\n\nMongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入`test`数据库：\n\n```\nuse test\n```\n\n然后创建角色时，设置账户，密码以及对应的数据库权限，比如：\n\n```\ndb.createUser(\n  {\n    user: \"testAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"readWrite\", db: \"test\" },\n             { role: \"read\", db: \"reporting\" } ]\n  }\n)\n```\n\n# nginx\n\n安装nginx之前，需要先将nginx的依赖安装完：\n\n- gcc 安装：`yum install gcc-c++`\n- PCRE pcre-devel 安装：`yum install -y pcre pcre-devel`\n- zlib 安装: `yum install -y zlib zlib-devel`\n- OpenSSL 安装: `yum install -y openssl openssl-devel`\n\n## 安装\n\n```\n# 下载Nginx\nwget -c https://nginx.org/download/nginx-1.10.1.tar.gz\n\n# 解压：\ntar -zxvf nginx-1.10.1.tar.gz\n\n# 进入nginx解压目录\ncd nginx-1.10.1 \n\n# 配置：\n./configure\n\n# 编译安装:\nmake\nmake install\n\n# 查找安装路径：\nwhereis nginx\n```\n\n## 环境变量\n\n因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用`nginx`命令。\n\n设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/bin\n```\n\n> 假设上面的whereis nginx返回的是/usr/local/nginx\n\n## 开启SSL模块\n\n切换到安装的源码包，我是安装在`/usr/local/src/nginx-1.11.3`。\n\n修改配置：\n\n```\n./configure --prefix=/usr/local/nginx --with-http_ssl_modul\n```\n\n执行`make`之后，切记**不要执行**`make install`，否则就覆盖安装了。\n\n先备份已安装好的nginx:\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak\n```\n\n然后关闭已启动的nginx：\n\n```\n# 查看进程号\nps -ef|grep nginx\nkill -QUIT [进程号]\n```\n\n将刚刚编译好的nginx覆盖掉原有的nginx:\n\n```\ncp ./objs/nginx /usr/local/nginx/sbin/\n```\n\n启动nginx，仍可以通过命令查看是否已经加入成功\n\n```\n/usr/local/nginx/sbin/nginx -V　\n```","source":"_posts/about-deploly-favweb-2.md","raw":"---\ntitle: 从零开始，部署一个Web应用（二）MongoDB & nginx\ndate: 2017-10-21 21:37:14\ntags: vue.js\ndesc: for beginner, how to build an web application\n---\n\n这篇文章，就总结一些部署`MongoDB`和`nginx`遇到的问题。\n\n# MongoDB\n\n安装的是社区版本([MongoDB Community Edition](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/))。\n\n## 安装\n\n先创建Mongodb在yum的配置文件：\n\n```\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n> 可动态改变版本号\n\n然后使用`yum`安装：\n\n```\nsudo yum install -y mongodb-org\n```\n\n## 安全相关\n\n如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。\n\n在MongoDB中，常用的是增加[用户访问限制](https://docs.mongodb.com/manual/tutorial/enable-authentication/)。\n\n### 高级管理员\n\n第一步，是先创建一个高级管理员。这个高级管理员可**管理其他用户**：\n\n```\n> use admin\n> db.createUser(\n  {\n    user: \"myUserAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]\n  }\n)\n```\n\n> 注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。\n\n可以这样以该角色进入MongoDB的命令行：\n\n```\nmongo --port 27017 -u \"myUserAdmin\" -p \"abc123\" --authenticationDatabase \"admin\"\n```\n\n### 增加其他用户\n\nMongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入`test`数据库：\n\n```\nuse test\n```\n\n然后创建角色时，设置账户，密码以及对应的数据库权限，比如：\n\n```\ndb.createUser(\n  {\n    user: \"testAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"readWrite\", db: \"test\" },\n             { role: \"read\", db: \"reporting\" } ]\n  }\n)\n```\n\n# nginx\n\n安装nginx之前，需要先将nginx的依赖安装完：\n\n- gcc 安装：`yum install gcc-c++`\n- PCRE pcre-devel 安装：`yum install -y pcre pcre-devel`\n- zlib 安装: `yum install -y zlib zlib-devel`\n- OpenSSL 安装: `yum install -y openssl openssl-devel`\n\n## 安装\n\n```\n# 下载Nginx\nwget -c https://nginx.org/download/nginx-1.10.1.tar.gz\n\n# 解压：\ntar -zxvf nginx-1.10.1.tar.gz\n\n# 进入nginx解压目录\ncd nginx-1.10.1 \n\n# 配置：\n./configure\n\n# 编译安装:\nmake\nmake install\n\n# 查找安装路径：\nwhereis nginx\n```\n\n## 环境变量\n\n因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用`nginx`命令。\n\n设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/bin\n```\n\n> 假设上面的whereis nginx返回的是/usr/local/nginx\n\n## 开启SSL模块\n\n切换到安装的源码包，我是安装在`/usr/local/src/nginx-1.11.3`。\n\n修改配置：\n\n```\n./configure --prefix=/usr/local/nginx --with-http_ssl_modul\n```\n\n执行`make`之后，切记**不要执行**`make install`，否则就覆盖安装了。\n\n先备份已安装好的nginx:\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak\n```\n\n然后关闭已启动的nginx：\n\n```\n# 查看进程号\nps -ef|grep nginx\nkill -QUIT [进程号]\n```\n\n将刚刚编译好的nginx覆盖掉原有的nginx:\n\n```\ncp ./objs/nginx /usr/local/nginx/sbin/\n```\n\n启动nginx，仍可以通过命令查看是否已经加入成功\n\n```\n/usr/local/nginx/sbin/nginx -V　\n```","slug":"about-deploly-favweb-2","published":1,"updated":"2020-05-23T05:59:59.000Z","_id":"ckxvfmfeh0035brqqc2frc291","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇文章，就总结一些部署<code>MongoDB</code>和<code>nginx</code>遇到的问题。</p>\n<h1 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h1><p>安装的是社区版本(<a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\">MongoDB Community Edition</a>)。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>先创建Mongodb在yum的配置文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mongodb-org-3.4]</span><br><span class=\"line\">name=MongoDB Repository</span><br><span class=\"line\">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可动态改变版本号</p>\n</blockquote>\n<p>然后使用<code>yum</code>安装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安全相关\"><a href=\"#安全相关\" class=\"headerlink\" title=\"安全相关\"></a>安全相关</h2><p>如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。</p>\n<p>在MongoDB中，常用的是增加<a href=\"https://docs.mongodb.com/manual/tutorial/enable-authentication/\">用户访问限制</a>。</p>\n<h3 id=\"高级管理员\"><a href=\"#高级管理员\" class=\"headerlink\" title=\"高级管理员\"></a>高级管理员</h3><p>第一步，是先创建一个高级管理员。这个高级管理员可<strong>管理其他用户</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin</span><br><span class=\"line\">&gt; db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;myUserAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。</p>\n</blockquote>\n<p>可以这样以该角色进入MongoDB的命令行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo --port 27017 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加其他用户\"><a href=\"#增加其他用户\" class=\"headerlink\" title=\"增加其他用户\"></a>增加其他用户</h3><p>MongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入<code>test</code>数据库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use test</span><br></pre></td></tr></table></figure>\n\n<p>然后创建角色时，设置账户，密码以及对应的数据库权限，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;testAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;,</span><br><span class=\"line\">             &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h1><p>安装nginx之前，需要先将nginx的依赖安装完：</p>\n<ul>\n<li>gcc 安装：<code>yum install gcc-c++</code></li>\n<li>PCRE pcre-devel 安装：<code>yum install -y pcre pcre-devel</code></li>\n<li>zlib 安装: <code>yum install -y zlib zlib-devel</code></li>\n<li>OpenSSL 安装: <code>yum install -y openssl openssl-devel</code></li>\n</ul>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载Nginx</span><br><span class=\"line\">wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 解压：</span><br><span class=\"line\">tar -zxvf nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 进入nginx解压目录</span><br><span class=\"line\">cd nginx-1.10.1 </span><br><span class=\"line\"></span><br><span class=\"line\"># 配置：</span><br><span class=\"line\">./configure</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译安装:</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\"># 查找安装路径：</span><br><span class=\"line\">whereis nginx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用<code>nginx</code>命令。</p>\n<p>设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/bin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假设上面的whereis nginx返回的是/usr/local/nginx</p>\n</blockquote>\n<h2 id=\"开启SSL模块\"><a href=\"#开启SSL模块\" class=\"headerlink\" title=\"开启SSL模块\"></a>开启SSL模块</h2><p>切换到安装的源码包，我是安装在<code>/usr/local/src/nginx-1.11.3</code>。</p>\n<p>修改配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/local/nginx --with-http_ssl_modul</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>make</code>之后，切记<strong>不要执行</strong><code>make install</code>，否则就覆盖安装了。</p>\n<p>先备份已安装好的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>\n\n<p>然后关闭已启动的nginx：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看进程号</span><br><span class=\"line\">ps -ef|grep nginx</span><br><span class=\"line\">kill -QUIT [进程号]</span><br></pre></td></tr></table></figure>\n\n<p>将刚刚编译好的nginx覆盖掉原有的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure>\n\n<p>启动nginx，仍可以通过命令查看是否已经加入成功</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/nginx/sbin/nginx -V　</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>这篇文章，就总结一些部署<code>MongoDB</code>和<code>nginx</code>遇到的问题。</p>\n<h1 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h1><p>安装的是社区版本(<a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\">MongoDB Community Edition</a>)。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>先创建Mongodb在yum的配置文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mongodb-org-3.4]</span><br><span class=\"line\">name=MongoDB Repository</span><br><span class=\"line\">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可动态改变版本号</p>\n</blockquote>\n<p>然后使用<code>yum</code>安装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安全相关\"><a href=\"#安全相关\" class=\"headerlink\" title=\"安全相关\"></a>安全相关</h2><p>如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。</p>\n<p>在MongoDB中，常用的是增加<a href=\"https://docs.mongodb.com/manual/tutorial/enable-authentication/\">用户访问限制</a>。</p>\n<h3 id=\"高级管理员\"><a href=\"#高级管理员\" class=\"headerlink\" title=\"高级管理员\"></a>高级管理员</h3><p>第一步，是先创建一个高级管理员。这个高级管理员可<strong>管理其他用户</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin</span><br><span class=\"line\">&gt; db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;myUserAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。</p>\n</blockquote>\n<p>可以这样以该角色进入MongoDB的命令行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo --port 27017 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加其他用户\"><a href=\"#增加其他用户\" class=\"headerlink\" title=\"增加其他用户\"></a>增加其他用户</h3><p>MongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入<code>test</code>数据库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use test</span><br></pre></td></tr></table></figure>\n\n<p>然后创建角色时，设置账户，密码以及对应的数据库权限，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;testAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;,</span><br><span class=\"line\">             &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h1><p>安装nginx之前，需要先将nginx的依赖安装完：</p>\n<ul>\n<li>gcc 安装：<code>yum install gcc-c++</code></li>\n<li>PCRE pcre-devel 安装：<code>yum install -y pcre pcre-devel</code></li>\n<li>zlib 安装: <code>yum install -y zlib zlib-devel</code></li>\n<li>OpenSSL 安装: <code>yum install -y openssl openssl-devel</code></li>\n</ul>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载Nginx</span><br><span class=\"line\">wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 解压：</span><br><span class=\"line\">tar -zxvf nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 进入nginx解压目录</span><br><span class=\"line\">cd nginx-1.10.1 </span><br><span class=\"line\"></span><br><span class=\"line\"># 配置：</span><br><span class=\"line\">./configure</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译安装:</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\"># 查找安装路径：</span><br><span class=\"line\">whereis nginx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用<code>nginx</code>命令。</p>\n<p>设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/bin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假设上面的whereis nginx返回的是/usr/local/nginx</p>\n</blockquote>\n<h2 id=\"开启SSL模块\"><a href=\"#开启SSL模块\" class=\"headerlink\" title=\"开启SSL模块\"></a>开启SSL模块</h2><p>切换到安装的源码包，我是安装在<code>/usr/local/src/nginx-1.11.3</code>。</p>\n<p>修改配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/local/nginx --with-http_ssl_modul</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>make</code>之后，切记<strong>不要执行</strong><code>make install</code>，否则就覆盖安装了。</p>\n<p>先备份已安装好的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>\n\n<p>然后关闭已启动的nginx：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看进程号</span><br><span class=\"line\">ps -ef|grep nginx</span><br><span class=\"line\">kill -QUIT [进程号]</span><br></pre></td></tr></table></figure>\n\n<p>将刚刚编译好的nginx覆盖掉原有的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure>\n\n<p>启动nginx，仍可以通过命令查看是否已经加入成功</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/nginx/sbin/nginx -V　</span><br></pre></td></tr></table></figure>"},{"title":"从零开始，部署一个Web应用（一）","date":"2017-10-14T12:37:14.000Z","desc":"for beginner, how to build an web application","_content":"\n起始篇，先介绍一个整个系列文章涉及到的开发环境，技术盏。\n\n## 环境\n\n开发环境：\n\n设备：MacBook Pro 2015\n环境：Node.js v8.9.3 + WebPack v3.0\nIDE：Sublime Text + Visual Studio Code\n\n生产环境：\n\n设备：腾讯云CVM(香港)\n系统：CentOS 7.2 64位\n\n## 技术盏\n\n前端采用了Vue.js + Vue-router + Element-UI\n\n> 采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。\n\n> 而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。\n\n后端采用 Node.js + Think.js\n\n> 因为个人技术盏限制，故采用比较擅长的Node.js。\n\n> 采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。\n\n数据库采用MongoDB + Redis\n\n> MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。\n\n> Redis是用来保存Session，邀请码等数据。\n\n服务器部署：Nginx + Node.js反向代理\n\n> 利用Nginx来实现负载均衡\n\n代码管理：[Coding](https://coding.net)\n\n> 由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。","source":"_posts/about-deploly-favweb-1.md","raw":"---\ntitle: 从零开始，部署一个Web应用（一）\ndate: 2017-10-14 20:37:14\ntags: vue.js\ndesc: for beginner, how to build an web application\n---\n\n起始篇，先介绍一个整个系列文章涉及到的开发环境，技术盏。\n\n## 环境\n\n开发环境：\n\n设备：MacBook Pro 2015\n环境：Node.js v8.9.3 + WebPack v3.0\nIDE：Sublime Text + Visual Studio Code\n\n生产环境：\n\n设备：腾讯云CVM(香港)\n系统：CentOS 7.2 64位\n\n## 技术盏\n\n前端采用了Vue.js + Vue-router + Element-UI\n\n> 采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。\n\n> 而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。\n\n后端采用 Node.js + Think.js\n\n> 因为个人技术盏限制，故采用比较擅长的Node.js。\n\n> 采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。\n\n数据库采用MongoDB + Redis\n\n> MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。\n\n> Redis是用来保存Session，邀请码等数据。\n\n服务器部署：Nginx + Node.js反向代理\n\n> 利用Nginx来实现负载均衡\n\n代码管理：[Coding](https://coding.net)\n\n> 由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。","slug":"about-deploly-favweb-1","published":1,"updated":"2020-05-23T05:59:55.000Z","_id":"ckxvfmfej0036brqq1bfld27k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>起始篇，先介绍一个整个系列文章涉及到的开发环境，技术盏。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>开发环境：</p>\n<p>设备：MacBook Pro 2015<br>环境：Node.js v8.9.3 + WebPack v3.0<br>IDE：Sublime Text + Visual Studio Code</p>\n<p>生产环境：</p>\n<p>设备：腾讯云CVM(香港)<br>系统：CentOS 7.2 64位</p>\n<h2 id=\"技术盏\"><a href=\"#技术盏\" class=\"headerlink\" title=\"技术盏\"></a>技术盏</h2><p>前端采用了Vue.js + Vue-router + Element-UI</p>\n<blockquote>\n<p>采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。</p>\n</blockquote>\n<blockquote>\n<p>而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。</p>\n</blockquote>\n<p>后端采用 Node.js + Think.js</p>\n<blockquote>\n<p>因为个人技术盏限制，故采用比较擅长的Node.js。</p>\n</blockquote>\n<blockquote>\n<p>采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。</p>\n</blockquote>\n<p>数据库采用MongoDB + Redis</p>\n<blockquote>\n<p>MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。</p>\n</blockquote>\n<blockquote>\n<p>Redis是用来保存Session，邀请码等数据。</p>\n</blockquote>\n<p>服务器部署：Nginx + Node.js反向代理</p>\n<blockquote>\n<p>利用Nginx来实现负载均衡</p>\n</blockquote>\n<p>代码管理：<a href=\"https://coding.net/\">Coding</a></p>\n<blockquote>\n<p>由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>起始篇，先介绍一个整个系列文章涉及到的开发环境，技术盏。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>开发环境：</p>\n<p>设备：MacBook Pro 2015<br>环境：Node.js v8.9.3 + WebPack v3.0<br>IDE：Sublime Text + Visual Studio Code</p>\n<p>生产环境：</p>\n<p>设备：腾讯云CVM(香港)<br>系统：CentOS 7.2 64位</p>\n<h2 id=\"技术盏\"><a href=\"#技术盏\" class=\"headerlink\" title=\"技术盏\"></a>技术盏</h2><p>前端采用了Vue.js + Vue-router + Element-UI</p>\n<blockquote>\n<p>采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。</p>\n</blockquote>\n<blockquote>\n<p>而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。</p>\n</blockquote>\n<p>后端采用 Node.js + Think.js</p>\n<blockquote>\n<p>因为个人技术盏限制，故采用比较擅长的Node.js。</p>\n</blockquote>\n<blockquote>\n<p>采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。</p>\n</blockquote>\n<p>数据库采用MongoDB + Redis</p>\n<blockquote>\n<p>MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。</p>\n</blockquote>\n<blockquote>\n<p>Redis是用来保存Session，邀请码等数据。</p>\n</blockquote>\n<p>服务器部署：Nginx + Node.js反向代理</p>\n<blockquote>\n<p>利用Nginx来实现负载均衡</p>\n</blockquote>\n<p>代码管理：<a href=\"https://coding.net/\">Coding</a></p>\n<blockquote>\n<p>由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。</p>\n</blockquote>\n"},{"title":"JavaScript 内存管理","date":"2017-03-05T01:40:57.000Z","desc":"js内存管理 js垃圾回收","_content":"\nJavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。\n\n<!--more-->\n\n## 内存生命周期\n\n不管什么程序语言，内存生命周期基本是一致的：\n\n1. 分配你所需要的内存\n2. 使用分配到的内存（读／写）\n3. 不需要时将其回收\n\n其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。\n\n## 垃圾回收\n\nJavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。\n\n我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：\n\n－ Reference-counting（引用计数） \n－ Mark-and-sweep（标记清除）\n\n#### 引用\n\n一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。\n\n#### 引用计数\n\n其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决**循环引用**的问题：\n\n```js\nvar div;\nwindow.onload = function(){\n  div = document.getElementById(\"myDivElement\");\n  div.circularReference = div;\n  div.lotsOfData = new Array(10000).join(\"*\");\n};\n```\n\n这时DOM 元素`myDivElement`就永远不会被回收了。\n\n#### 标记清除\n\n这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。\n\n这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象`window`。\n\n然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。\n\n这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。\n\n这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。\n\n本文主要内容参考：[Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)\n","source":"_posts/memory-management.md","raw":"---\ntitle: JavaScript 内存管理\ndate: 2017-03-05 09:40:57\ntags: \n- JavaScript\n- 内存管理\n- 垃圾回收\ndesc: js内存管理 js垃圾回收\n---\n\nJavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。\n\n<!--more-->\n\n## 内存生命周期\n\n不管什么程序语言，内存生命周期基本是一致的：\n\n1. 分配你所需要的内存\n2. 使用分配到的内存（读／写）\n3. 不需要时将其回收\n\n其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。\n\n## 垃圾回收\n\nJavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。\n\n我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：\n\n－ Reference-counting（引用计数） \n－ Mark-and-sweep（标记清除）\n\n#### 引用\n\n一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。\n\n#### 引用计数\n\n其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决**循环引用**的问题：\n\n```js\nvar div;\nwindow.onload = function(){\n  div = document.getElementById(\"myDivElement\");\n  div.circularReference = div;\n  div.lotsOfData = new Array(10000).join(\"*\");\n};\n```\n\n这时DOM 元素`myDivElement`就永远不会被回收了。\n\n#### 标记清除\n\n这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。\n\n这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象`window`。\n\n然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。\n\n这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。\n\n这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。\n\n本文主要内容参考：[Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)\n","slug":"memory-management","published":1,"updated":"2020-05-23T06:07:33.000Z","_id":"ckxvfmfem0039brqq7tqldh2s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：</p>\n<ol>\n<li>分配你所需要的内存</li>\n<li>使用分配到的内存（读／写）</li>\n<li>不需要时将其回收</li>\n</ol>\n<p>其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。</p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><p>JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。</p>\n<p>我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：</p>\n<p>－ Reference-counting（引用计数）<br>－ Mark-and-sweep（标记清除）</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。</p>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决<strong>循环引用</strong>的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myDivElement&quot;</span>);</span><br><span class=\"line\">  div.circularReference = div;</span><br><span class=\"line\">  div.lotsOfData = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时DOM 元素<code>myDivElement</code>就永远不会被回收了。</p>\n<h4 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h4><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>\n<p>这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象<code>window</code>。</p>\n<p>然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。</p>\n<p>这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。</p>\n<p>这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。</p>\n<p>本文主要内容参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\">Memory Management</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>JavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。</p>","more":"<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：</p>\n<ol>\n<li>分配你所需要的内存</li>\n<li>使用分配到的内存（读／写）</li>\n<li>不需要时将其回收</li>\n</ol>\n<p>其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。</p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><p>JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。</p>\n<p>我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：</p>\n<p>－ Reference-counting（引用计数）<br>－ Mark-and-sweep（标记清除）</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。</p>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决<strong>循环引用</strong>的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myDivElement&quot;</span>);</span><br><span class=\"line\">  div.circularReference = div;</span><br><span class=\"line\">  div.lotsOfData = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时DOM 元素<code>myDivElement</code>就永远不会被回收了。</p>\n<h4 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h4><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>\n<p>这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象<code>window</code>。</p>\n<p>然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。</p>\n<p>这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。</p>\n<p>这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。</p>\n<p>本文主要内容参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\">Memory Management</a></p>"},{"title":"组件封装的思考","desc":"小程序组件封装的思考","_content":"\n## 前言\n\n在小程序开发的早期，是没有 **自定义组件(component)**，仅有 **自定义模板(template)** 的。最早接触到组件开发还是在使用 `React`、`Vue` 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多\n\n## 为什么要有组件？\n\n对于这个问题，很多人的第一反应也许是：代码复用\n\n的确，代码复用是组件的核心职责，但它还有更大的使命：性能\n\n因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果\n\n![](/images/components/components-graph.png)\n\n## 生命周期\n\n在 `Vue` 中，每个页面是一个 `Vue` 实例，而组件又是可复用的 `Vue` 实例，因此可以理解成，页面和组件是相同的生命周期\n\n而小程序就将页面和组件拆分成两个类：`Page` 和 `Component`，因此接收的生命周期函数也是不一样的。比如，`Page` 接收的是：`onLoad`、`onShow`、`onReady`等函数，而 `Component` 则接收 `created`、`attached`、`ready` 等函数\n\n> 命名风格都不一致，真是让人头大\n\n![](/images/components/miniprogram-lifecycle.png)\n\n## 数据传递\n\n### Vue\n\n`Vue` 的组件间数据传递的机制是这样的：父组件通过`property`传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件\n\n在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境\n\n为了解决这个问题，`Vue` 推出了 `Vuex` 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：\n\n![](/images/components/vuex.png)\n\n### 小程序\n\n小程序同样有类似的机制，`property`和事件。此外还提供了获取 **子组件实例** 的方法：`selectComponent()` 和  定义组件间关系的字段 `relations`\n\n其中常用的就是获取子组件实例，比如:\n\n```html\n<parent-component>\n    <child-component id=\"child\"></child-component>\n</parent-component>\n```\n\n此时，在`parent-component`组件中可以直接获取`child-component`的实例：\n\n```js\nComponent({\n    attached() {\n        let $child = this.selectComponent('#child')\n\n        // $child.doSomeThing()\n    }\n})\n```\n\n## 实战\n\n### 背景\n\n> 制作一个 **对话框(modal)** 组件\n\n也许有的读者会感到困惑，官方不是有提供 `wx.showModal` 可以直接用吗，为什么要重复造轮子\n\n其实，当你的产品想要结合 `Modal` 和 `Button` 的 `open-type` 能力时，你就会明白重复造轮子的必要性以及`wx.showModal`的局限性\n\n### 属性定义\n\n对话框的常见属性可以参考`wx.showModal`\n\n除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：`visible`\n\n此时，有两种选择，第一种是将这个变量存在页面上，通过`property`传递给`Modal`组件；另外一种，就是作为`Modal`组件`data`中的一员\n\n### property传递\n\n通过`property`传递的话，就相当于将 `Modal` 的控制权交到对应的页面，举例：\n\n```html\n<!-- home.wxml -->\n\n<modal visible=\"{{visible}}\" />\n```\n\n```js\n// home.js\n\nPage({\n    data: {\n        visible: false\n    },\n    toggleModal() {\n        this.setData({ visible: !this.data.visible })\n    }\n})\n```\n\n此时对应的 `Modal`：\n\n```js\n// modal.js\n\nComponent({\n    properties: {\n        visible: {\n            type: Boolean,\n            value: false,\n            observer(newVal, oldVal) {\n                this.setData({ visible: newVal })\n            }\n        }\n    }\n})\n```\n\n> 这里和`Vue`框架有个差异，`Vue`对于传进来的property会自动赋值，而小程序则需要自己手动赋值\n\n#### 问题与办法\n\n当 `visible` 这个变量被 `Modal` 和 `Page` 同时使用时，会出现不显示的问题。\n\n为了便于描述，我通过描述真实场景来讲解：\n\n1. 当页面需要显示对话框时，`Page` 传递 `visible=true` 给 `Modal`\n2. 经过一段时间之后，用户关闭了对话框，此时 `Modal` 将自身的 `visible` 设置为 `false`\n3. 当页面需要再次出现对话框时，`Page` 继续传递`visible=true` 给 `Modal`，**此时发现对话框不会显示**\n\n通过分析可以发现，由于 `Page` 两次传递相同的 `visible=true` 给 `Modal` ，因此第二次传递的时候，被 `Modal` 直接忽略掉了。\n\n这个问题也很好解决，大致思路就是保证每次传递的值不同即可：\n\n- 传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）\n- 利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如`{ visible: true } !== { visible: true }`)\n\n### 组件自身属性\n\n这种是我推荐的方案。将 `visible` 属性交由组件 `Modal` 自行管理：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    },\n    methods: {\n        show() {\n            this.setData({ visible: true })\n        }\n    }\n})\n```\n\n由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的`setData`，如：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.setData({ visible: true })\n```\n\n但是不建议这样使用，而是组件暴露方法让外部调用：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.show()\n```\n\n### 组件的事件\n\n通常，对话框都会有按钮，一个或两个。\n\n因此 `Modal` 需要与父组件通过 **事件(event)** 的方式传递信息：当前点击了取消还是确定按钮：\n\n```html\n<!-- home.wxml -->\n\n<modal id=\"modal\" bind:btntap=\"handleModalTap\" />\n```\n\n```js\n// home.js\n\nPage({\n    showModal() {\n        let $modal = this.selectComponent('#modal')\n\n        $modal.show()\n    },\n\n    // 其他方法\n\n    handleModalTap(e) {\n        let { type } = e.detail\n\n        // type = cancel or confirm\n    }\n})\n```\n\n在 `Modal` 的构造函数则是这样的：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    }\n    methods: {\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n```html\n<!-- modal.wxml -->\n\n<view class=\"wrapper\">\n    <!-- 省略其他结构 -->\n    <view class=\"foot\" bindtap=\"handleBtnTap\">\n        <button data-type=\"cancel\">取消</button>\n        <button data-type=\"confirm\">确定</button>\n    </view>\n</view>\n```\n\n这样设计 `Modal` 组件，的确可以满足使用，但是不够好用\n\n因为展示对话框时使用的是 `showModal` 而用户操作之后又是通过另外一个方法 `handleModalTap` 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护\n\n所以，我建议结合 `Promise` 来封装 `Modal`\n\n### 省略事件\n\n由于展示对话框之后，用户必然要操作，因此可以在 `showModal` 的时候，通过 `Promise` 返回对应的操作信息即可\n\n另外，需要引入发布订阅机制（以下使用 `Node.js` 的 `Events` 举例）：\n\n```js\n// modal.js\n\nconst EventEmitter = require('events');\nconst ee = new EventEmitter();\n\nComponent({\n    data: {\n        visible: false\n    },\n\n    methods: {\n        show() {\n            this.setData({ visible: true })\n\n            return new Promise((resolve, reject) => {\n                ee.on('cancel', () => {\n                    reject()\n                })\n                ee.on('confirm', () => {\n                    resolve()\n                })\n            })\n        },\n\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            ee.emit(type)\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n此时，在 `Page` 即可这样展示对话框：\n\n```js\n// home.js\n\nPage({\n    onLoad() {\n        let $modal = this.selectComponent('#modal')\n\n        $moda.show().then(() => {\n            // 当点击确认时\n        }).catch(() => {\n            // 当点击取消时\n        })\n    }\n})\n```\n\n## 总结\n\n组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！","source":"_posts/mini-program/thinking-about-components.md","raw":"---\ntitle: 组件封装的思考\ntags: 小程序\ndesc: 小程序组件封装的思考\n---\n\n## 前言\n\n在小程序开发的早期，是没有 **自定义组件(component)**，仅有 **自定义模板(template)** 的。最早接触到组件开发还是在使用 `React`、`Vue` 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多\n\n## 为什么要有组件？\n\n对于这个问题，很多人的第一反应也许是：代码复用\n\n的确，代码复用是组件的核心职责，但它还有更大的使命：性能\n\n因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果\n\n![](/images/components/components-graph.png)\n\n## 生命周期\n\n在 `Vue` 中，每个页面是一个 `Vue` 实例，而组件又是可复用的 `Vue` 实例，因此可以理解成，页面和组件是相同的生命周期\n\n而小程序就将页面和组件拆分成两个类：`Page` 和 `Component`，因此接收的生命周期函数也是不一样的。比如，`Page` 接收的是：`onLoad`、`onShow`、`onReady`等函数，而 `Component` 则接收 `created`、`attached`、`ready` 等函数\n\n> 命名风格都不一致，真是让人头大\n\n![](/images/components/miniprogram-lifecycle.png)\n\n## 数据传递\n\n### Vue\n\n`Vue` 的组件间数据传递的机制是这样的：父组件通过`property`传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件\n\n在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境\n\n为了解决这个问题，`Vue` 推出了 `Vuex` 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：\n\n![](/images/components/vuex.png)\n\n### 小程序\n\n小程序同样有类似的机制，`property`和事件。此外还提供了获取 **子组件实例** 的方法：`selectComponent()` 和  定义组件间关系的字段 `relations`\n\n其中常用的就是获取子组件实例，比如:\n\n```html\n<parent-component>\n    <child-component id=\"child\"></child-component>\n</parent-component>\n```\n\n此时，在`parent-component`组件中可以直接获取`child-component`的实例：\n\n```js\nComponent({\n    attached() {\n        let $child = this.selectComponent('#child')\n\n        // $child.doSomeThing()\n    }\n})\n```\n\n## 实战\n\n### 背景\n\n> 制作一个 **对话框(modal)** 组件\n\n也许有的读者会感到困惑，官方不是有提供 `wx.showModal` 可以直接用吗，为什么要重复造轮子\n\n其实，当你的产品想要结合 `Modal` 和 `Button` 的 `open-type` 能力时，你就会明白重复造轮子的必要性以及`wx.showModal`的局限性\n\n### 属性定义\n\n对话框的常见属性可以参考`wx.showModal`\n\n除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：`visible`\n\n此时，有两种选择，第一种是将这个变量存在页面上，通过`property`传递给`Modal`组件；另外一种，就是作为`Modal`组件`data`中的一员\n\n### property传递\n\n通过`property`传递的话，就相当于将 `Modal` 的控制权交到对应的页面，举例：\n\n```html\n<!-- home.wxml -->\n\n<modal visible=\"{{visible}}\" />\n```\n\n```js\n// home.js\n\nPage({\n    data: {\n        visible: false\n    },\n    toggleModal() {\n        this.setData({ visible: !this.data.visible })\n    }\n})\n```\n\n此时对应的 `Modal`：\n\n```js\n// modal.js\n\nComponent({\n    properties: {\n        visible: {\n            type: Boolean,\n            value: false,\n            observer(newVal, oldVal) {\n                this.setData({ visible: newVal })\n            }\n        }\n    }\n})\n```\n\n> 这里和`Vue`框架有个差异，`Vue`对于传进来的property会自动赋值，而小程序则需要自己手动赋值\n\n#### 问题与办法\n\n当 `visible` 这个变量被 `Modal` 和 `Page` 同时使用时，会出现不显示的问题。\n\n为了便于描述，我通过描述真实场景来讲解：\n\n1. 当页面需要显示对话框时，`Page` 传递 `visible=true` 给 `Modal`\n2. 经过一段时间之后，用户关闭了对话框，此时 `Modal` 将自身的 `visible` 设置为 `false`\n3. 当页面需要再次出现对话框时，`Page` 继续传递`visible=true` 给 `Modal`，**此时发现对话框不会显示**\n\n通过分析可以发现，由于 `Page` 两次传递相同的 `visible=true` 给 `Modal` ，因此第二次传递的时候，被 `Modal` 直接忽略掉了。\n\n这个问题也很好解决，大致思路就是保证每次传递的值不同即可：\n\n- 传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）\n- 利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如`{ visible: true } !== { visible: true }`)\n\n### 组件自身属性\n\n这种是我推荐的方案。将 `visible` 属性交由组件 `Modal` 自行管理：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    },\n    methods: {\n        show() {\n            this.setData({ visible: true })\n        }\n    }\n})\n```\n\n由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的`setData`，如：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.setData({ visible: true })\n```\n\n但是不建议这样使用，而是组件暴露方法让外部调用：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.show()\n```\n\n### 组件的事件\n\n通常，对话框都会有按钮，一个或两个。\n\n因此 `Modal` 需要与父组件通过 **事件(event)** 的方式传递信息：当前点击了取消还是确定按钮：\n\n```html\n<!-- home.wxml -->\n\n<modal id=\"modal\" bind:btntap=\"handleModalTap\" />\n```\n\n```js\n// home.js\n\nPage({\n    showModal() {\n        let $modal = this.selectComponent('#modal')\n\n        $modal.show()\n    },\n\n    // 其他方法\n\n    handleModalTap(e) {\n        let { type } = e.detail\n\n        // type = cancel or confirm\n    }\n})\n```\n\n在 `Modal` 的构造函数则是这样的：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    }\n    methods: {\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n```html\n<!-- modal.wxml -->\n\n<view class=\"wrapper\">\n    <!-- 省略其他结构 -->\n    <view class=\"foot\" bindtap=\"handleBtnTap\">\n        <button data-type=\"cancel\">取消</button>\n        <button data-type=\"confirm\">确定</button>\n    </view>\n</view>\n```\n\n这样设计 `Modal` 组件，的确可以满足使用，但是不够好用\n\n因为展示对话框时使用的是 `showModal` 而用户操作之后又是通过另外一个方法 `handleModalTap` 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护\n\n所以，我建议结合 `Promise` 来封装 `Modal`\n\n### 省略事件\n\n由于展示对话框之后，用户必然要操作，因此可以在 `showModal` 的时候，通过 `Promise` 返回对应的操作信息即可\n\n另外，需要引入发布订阅机制（以下使用 `Node.js` 的 `Events` 举例）：\n\n```js\n// modal.js\n\nconst EventEmitter = require('events');\nconst ee = new EventEmitter();\n\nComponent({\n    data: {\n        visible: false\n    },\n\n    methods: {\n        show() {\n            this.setData({ visible: true })\n\n            return new Promise((resolve, reject) => {\n                ee.on('cancel', () => {\n                    reject()\n                })\n                ee.on('confirm', () => {\n                    resolve()\n                })\n            })\n        },\n\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            ee.emit(type)\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n此时，在 `Page` 即可这样展示对话框：\n\n```js\n// home.js\n\nPage({\n    onLoad() {\n        let $modal = this.selectComponent('#modal')\n\n        $moda.show().then(() => {\n            // 当点击确认时\n        }).catch(() => {\n            // 当点击取消时\n        })\n    }\n})\n```\n\n## 总结\n\n组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！","slug":"mini-program/thinking-about-components","published":1,"date":"2020-05-23T06:40:41.000Z","updated":"2020-05-23T06:40:41.000Z","_id":"ckxvfmfyd003fbrqqf6e3351w","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在小程序开发的早期，是没有 **自定义组件(component)**，仅有 <strong>自定义模板(template)</strong> 的。最早接触到组件开发还是在使用 <code>React</code>、<code>Vue</code> 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多</p>\n<h2 id=\"为什么要有组件？\"><a href=\"#为什么要有组件？\" class=\"headerlink\" title=\"为什么要有组件？\"></a>为什么要有组件？</h2><p>对于这个问题，很多人的第一反应也许是：代码复用</p>\n<p>的确，代码复用是组件的核心职责，但它还有更大的使命：性能</p>\n<p>因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果</p>\n<p><img src=\"/images/components/components-graph.png\"></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>在 <code>Vue</code> 中，每个页面是一个 <code>Vue</code> 实例，而组件又是可复用的 <code>Vue</code> 实例，因此可以理解成，页面和组件是相同的生命周期</p>\n<p>而小程序就将页面和组件拆分成两个类：<code>Page</code> 和 <code>Component</code>，因此接收的生命周期函数也是不一样的。比如，<code>Page</code> 接收的是：<code>onLoad</code>、<code>onShow</code>、<code>onReady</code>等函数，而 <code>Component</code> 则接收 <code>created</code>、<code>attached</code>、<code>ready</code> 等函数</p>\n<blockquote>\n<p>命名风格都不一致，真是让人头大</p>\n</blockquote>\n<p><img src=\"/images/components/miniprogram-lifecycle.png\"></p>\n<h2 id=\"数据传递\"><a href=\"#数据传递\" class=\"headerlink\" title=\"数据传递\"></a>数据传递</h2><h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p><code>Vue</code> 的组件间数据传递的机制是这样的：父组件通过<code>property</code>传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件</p>\n<p>在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境</p>\n<p>为了解决这个问题，<code>Vue</code> 推出了 <code>Vuex</code> 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：</p>\n<p><img src=\"/images/components/vuex.png\"></p>\n<h3 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h3><p>小程序同样有类似的机制，<code>property</code>和事件。此外还提供了获取 <strong>子组件实例</strong> 的方法：<code>selectComponent()</code> 和  定义组件间关系的字段 <code>relations</code></p>\n<p>其中常用的就是获取子组件实例，比如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child-component</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;child&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，在<code>parent-component</code>组件中可以直接获取<code>child-component</code>的实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">attached</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $child = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#child&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// $child.doSomeThing()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>制作一个 <strong>对话框(modal)</strong> 组件</p>\n</blockquote>\n<p>也许有的读者会感到困惑，官方不是有提供 <code>wx.showModal</code> 可以直接用吗，为什么要重复造轮子</p>\n<p>其实，当你的产品想要结合 <code>Modal</code> 和 <code>Button</code> 的 <code>open-type</code> 能力时，你就会明白重复造轮子的必要性以及<code>wx.showModal</code>的局限性</p>\n<h3 id=\"属性定义\"><a href=\"#属性定义\" class=\"headerlink\" title=\"属性定义\"></a>属性定义</h3><p>对话框的常见属性可以参考<code>wx.showModal</code></p>\n<p>除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：<code>visible</code></p>\n<p>此时，有两种选择，第一种是将这个变量存在页面上，通过<code>property</code>传递给<code>Modal</code>组件；另外一种，就是作为<code>Modal</code>组件<code>data</code>中的一员</p>\n<h3 id=\"property传递\"><a href=\"#property传递\" class=\"headerlink\" title=\"property传递\"></a>property传递</h3><p>通过<code>property</code>传递的话，就相当于将 <code>Modal</code> 的控制权交到对应的页面，举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">visible</span>=<span class=\"string\">&quot;&#123;&#123;visible&#125;&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">toggleModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: !<span class=\"built_in\">this</span>.data.visible &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时对应的 <code>Modal</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">observer</span>(<span class=\"params\">newVal, oldVal</span>)</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: newVal &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里和<code>Vue</code>框架有个差异，<code>Vue</code>对于传进来的property会自动赋值，而小程序则需要自己手动赋值</p>\n</blockquote>\n<h4 id=\"问题与办法\"><a href=\"#问题与办法\" class=\"headerlink\" title=\"问题与办法\"></a>问题与办法</h4><p>当 <code>visible</code> 这个变量被 <code>Modal</code> 和 <code>Page</code> 同时使用时，会出现不显示的问题。</p>\n<p>为了便于描述，我通过描述真实场景来讲解：</p>\n<ol>\n<li>当页面需要显示对话框时，<code>Page</code> 传递 <code>visible=true</code> 给 <code>Modal</code></li>\n<li>经过一段时间之后，用户关闭了对话框，此时 <code>Modal</code> 将自身的 <code>visible</code> 设置为 <code>false</code></li>\n<li>当页面需要再次出现对话框时，<code>Page</code> 继续传递<code>visible=true</code> 给 <code>Modal</code>，<strong>此时发现对话框不会显示</strong></li>\n</ol>\n<p>通过分析可以发现，由于 <code>Page</code> 两次传递相同的 <code>visible=true</code> 给 <code>Modal</code> ，因此第二次传递的时候，被 <code>Modal</code> 直接忽略掉了。</p>\n<p>这个问题也很好解决，大致思路就是保证每次传递的值不同即可：</p>\n<ul>\n<li>传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）</li>\n<li>利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如<code>&#123; visible: true &#125; !== &#123; visible: true &#125;</code>)</li>\n</ul>\n<h3 id=\"组件自身属性\"><a href=\"#组件自身属性\" class=\"headerlink\" title=\"组件自身属性\"></a>组件自身属性</h3><p>这种是我推荐的方案。将 <code>visible</code> 属性交由组件 <code>Modal</code> 自行管理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的<code>setData</code>，如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>但是不建议这样使用，而是组件暴露方法让外部调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.show()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件的事件\"><a href=\"#组件的事件\" class=\"headerlink\" title=\"组件的事件\"></a>组件的事件</h3><p>通常，对话框都会有按钮，一个或两个。</p>\n<p>因此 <code>Modal</code> 需要与父组件通过 <strong>事件(event)</strong> 的方式传递信息：当前点击了取消还是确定按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;modal&quot;</span> <span class=\"attr\">bind:btntap</span>=<span class=\"string\">&quot;handleModalTap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">showModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $modal.show()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleModalTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; type &#125; = e.detail</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// type = cancel or confirm</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Modal</code> 的构造函数则是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- modal.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 省略其他结构 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;foot&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleBtnTap&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;cancel&quot;</span>&gt;</span>取消<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;confirm&quot;</span>&gt;</span>确定<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样设计 <code>Modal</code> 组件，的确可以满足使用，但是不够好用</p>\n<p>因为展示对话框时使用的是 <code>showModal</code> 而用户操作之后又是通过另外一个方法 <code>handleModalTap</code> 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护</p>\n<p>所以，我建议结合 <code>Promise</code> 来封装 <code>Modal</code></p>\n<h3 id=\"省略事件\"><a href=\"#省略事件\" class=\"headerlink\" title=\"省略事件\"></a>省略事件</h3><p>由于展示对话框之后，用户必然要操作，因此可以在 <code>showModal</code> 的时候，通过 <code>Promise</code> 返回对应的操作信息即可</p>\n<p>另外，需要引入发布订阅机制（以下使用 <code>Node.js</code> 的 <code>Events</code> 举例）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ee = <span class=\"keyword\">new</span> EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;cancel&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    reject()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;confirm&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    resolve()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            ee.emit(type)</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时，在 <code>Page</code> 即可这样展示对话框：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $moda.show().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击确认时</span></span><br><span class=\"line\">        &#125;).catch(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击取消时</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在小程序开发的早期，是没有 **自定义组件(component)**，仅有 <strong>自定义模板(template)</strong> 的。最早接触到组件开发还是在使用 <code>React</code>、<code>Vue</code> 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多</p>\n<h2 id=\"为什么要有组件？\"><a href=\"#为什么要有组件？\" class=\"headerlink\" title=\"为什么要有组件？\"></a>为什么要有组件？</h2><p>对于这个问题，很多人的第一反应也许是：代码复用</p>\n<p>的确，代码复用是组件的核心职责，但它还有更大的使命：性能</p>\n<p>因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果</p>\n<p><img src=\"/images/components/components-graph.png\"></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>在 <code>Vue</code> 中，每个页面是一个 <code>Vue</code> 实例，而组件又是可复用的 <code>Vue</code> 实例，因此可以理解成，页面和组件是相同的生命周期</p>\n<p>而小程序就将页面和组件拆分成两个类：<code>Page</code> 和 <code>Component</code>，因此接收的生命周期函数也是不一样的。比如，<code>Page</code> 接收的是：<code>onLoad</code>、<code>onShow</code>、<code>onReady</code>等函数，而 <code>Component</code> 则接收 <code>created</code>、<code>attached</code>、<code>ready</code> 等函数</p>\n<blockquote>\n<p>命名风格都不一致，真是让人头大</p>\n</blockquote>\n<p><img src=\"/images/components/miniprogram-lifecycle.png\"></p>\n<h2 id=\"数据传递\"><a href=\"#数据传递\" class=\"headerlink\" title=\"数据传递\"></a>数据传递</h2><h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p><code>Vue</code> 的组件间数据传递的机制是这样的：父组件通过<code>property</code>传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件</p>\n<p>在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境</p>\n<p>为了解决这个问题，<code>Vue</code> 推出了 <code>Vuex</code> 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：</p>\n<p><img src=\"/images/components/vuex.png\"></p>\n<h3 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h3><p>小程序同样有类似的机制，<code>property</code>和事件。此外还提供了获取 <strong>子组件实例</strong> 的方法：<code>selectComponent()</code> 和  定义组件间关系的字段 <code>relations</code></p>\n<p>其中常用的就是获取子组件实例，比如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child-component</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;child&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，在<code>parent-component</code>组件中可以直接获取<code>child-component</code>的实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">attached</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $child = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#child&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// $child.doSomeThing()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>制作一个 <strong>对话框(modal)</strong> 组件</p>\n</blockquote>\n<p>也许有的读者会感到困惑，官方不是有提供 <code>wx.showModal</code> 可以直接用吗，为什么要重复造轮子</p>\n<p>其实，当你的产品想要结合 <code>Modal</code> 和 <code>Button</code> 的 <code>open-type</code> 能力时，你就会明白重复造轮子的必要性以及<code>wx.showModal</code>的局限性</p>\n<h3 id=\"属性定义\"><a href=\"#属性定义\" class=\"headerlink\" title=\"属性定义\"></a>属性定义</h3><p>对话框的常见属性可以参考<code>wx.showModal</code></p>\n<p>除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：<code>visible</code></p>\n<p>此时，有两种选择，第一种是将这个变量存在页面上，通过<code>property</code>传递给<code>Modal</code>组件；另外一种，就是作为<code>Modal</code>组件<code>data</code>中的一员</p>\n<h3 id=\"property传递\"><a href=\"#property传递\" class=\"headerlink\" title=\"property传递\"></a>property传递</h3><p>通过<code>property</code>传递的话，就相当于将 <code>Modal</code> 的控制权交到对应的页面，举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">visible</span>=<span class=\"string\">&quot;&#123;&#123;visible&#125;&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">toggleModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: !<span class=\"built_in\">this</span>.data.visible &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时对应的 <code>Modal</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">observer</span>(<span class=\"params\">newVal, oldVal</span>)</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: newVal &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里和<code>Vue</code>框架有个差异，<code>Vue</code>对于传进来的property会自动赋值，而小程序则需要自己手动赋值</p>\n</blockquote>\n<h4 id=\"问题与办法\"><a href=\"#问题与办法\" class=\"headerlink\" title=\"问题与办法\"></a>问题与办法</h4><p>当 <code>visible</code> 这个变量被 <code>Modal</code> 和 <code>Page</code> 同时使用时，会出现不显示的问题。</p>\n<p>为了便于描述，我通过描述真实场景来讲解：</p>\n<ol>\n<li>当页面需要显示对话框时，<code>Page</code> 传递 <code>visible=true</code> 给 <code>Modal</code></li>\n<li>经过一段时间之后，用户关闭了对话框，此时 <code>Modal</code> 将自身的 <code>visible</code> 设置为 <code>false</code></li>\n<li>当页面需要再次出现对话框时，<code>Page</code> 继续传递<code>visible=true</code> 给 <code>Modal</code>，<strong>此时发现对话框不会显示</strong></li>\n</ol>\n<p>通过分析可以发现，由于 <code>Page</code> 两次传递相同的 <code>visible=true</code> 给 <code>Modal</code> ，因此第二次传递的时候，被 <code>Modal</code> 直接忽略掉了。</p>\n<p>这个问题也很好解决，大致思路就是保证每次传递的值不同即可：</p>\n<ul>\n<li>传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）</li>\n<li>利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如<code>&#123; visible: true &#125; !== &#123; visible: true &#125;</code>)</li>\n</ul>\n<h3 id=\"组件自身属性\"><a href=\"#组件自身属性\" class=\"headerlink\" title=\"组件自身属性\"></a>组件自身属性</h3><p>这种是我推荐的方案。将 <code>visible</code> 属性交由组件 <code>Modal</code> 自行管理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的<code>setData</code>，如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>但是不建议这样使用，而是组件暴露方法让外部调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.show()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件的事件\"><a href=\"#组件的事件\" class=\"headerlink\" title=\"组件的事件\"></a>组件的事件</h3><p>通常，对话框都会有按钮，一个或两个。</p>\n<p>因此 <code>Modal</code> 需要与父组件通过 <strong>事件(event)</strong> 的方式传递信息：当前点击了取消还是确定按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;modal&quot;</span> <span class=\"attr\">bind:btntap</span>=<span class=\"string\">&quot;handleModalTap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">showModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $modal.show()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleModalTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; type &#125; = e.detail</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// type = cancel or confirm</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Modal</code> 的构造函数则是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- modal.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 省略其他结构 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;foot&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleBtnTap&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;cancel&quot;</span>&gt;</span>取消<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;confirm&quot;</span>&gt;</span>确定<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样设计 <code>Modal</code> 组件，的确可以满足使用，但是不够好用</p>\n<p>因为展示对话框时使用的是 <code>showModal</code> 而用户操作之后又是通过另外一个方法 <code>handleModalTap</code> 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护</p>\n<p>所以，我建议结合 <code>Promise</code> 来封装 <code>Modal</code></p>\n<h3 id=\"省略事件\"><a href=\"#省略事件\" class=\"headerlink\" title=\"省略事件\"></a>省略事件</h3><p>由于展示对话框之后，用户必然要操作，因此可以在 <code>showModal</code> 的时候，通过 <code>Promise</code> 返回对应的操作信息即可</p>\n<p>另外，需要引入发布订阅机制（以下使用 <code>Node.js</code> 的 <code>Events</code> 举例）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ee = <span class=\"keyword\">new</span> EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;cancel&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    reject()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;confirm&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    resolve()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            ee.emit(type)</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时，在 <code>Page</code> 即可这样展示对话框：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $moda.show().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击确认时</span></span><br><span class=\"line\">        &#125;).catch(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击取消时</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！</p>\n"},{"title":"订阅消息的思考","desc":"小程序订阅消息的思考","_content":"\n## 前言\n\n小程序的早期定位是“即用即走”或者说是“用完即走”。\n但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。\n让用户回流的关键手段就是 **订阅消息**，通过点击订阅消息，可直接回到小程序。\n\n## 背景\n\n早期小程序提供的是 **模板消息**，用户每次点击或者完成支付，都会生成一个`formId`或者`paypay_id`，开发者可以通过这个`formId`给用户发送一次模板消息。\n\n因此，开发者的常规做法：尽可能地在每个按钮上都封装`form`，用以收集`formId`；收集的`formId`并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些`formId`发送模板消息。\n\n这样会存在几个问题：\n- 用户会被莫名的骚扰（因为`formId`有7天的有效期）\n- 用户收到的模板消息是无预期的（因为`formId`可以发任意的模板消息）\n- 开发者在每个页面每个可点击区域都封装了`form`，导致代码混乱\n\n为了解决以上问题，小程序团队就采用了 **订阅消息** 来替换 **模板消息**。\n\n> 小程序模板消息接口于2020年1月10日下线\n\n## 订阅消息的优势\n\n**订阅消息** 与 **模板消息** 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：\n\n![](/images/subscribe/request-subscribe-message.jpg)\n\n另外，**对订阅消息的发送时限不做限制**，即可以在任意时间给用户发送一条模板消息，而不像以前的`formId`有7天的有效期。\n\n从开发者的角度看：订阅消息是使用接口调用([wx.requestSubscribeMessage](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html))，不再是以前那样，一定要用`Button`。**对于代码维护和开发效率来说，都是利好的**。\n\n从代码维护上讲，开发者不用再层层嵌套`form`了，简化了许多代码；另外，以前模板消息是通过`Button`封装的，拜托了这层束缚之后，就不用再重置`Button`的样式了，对于开发效率也是有一定的帮助。\n\n### 模板消息\n```html\n<form bindsubmit=\"addFormId\" report-submit>\n    <button class=\"invite-btn\" form-type=\"submit\">\n        邀请好友\n    </button>\n</form>\n```\n\n```js\nPage({\n    data: {},\n    addFormId(e) {\n        let { formId } = e.detail;\n        // save formId\n    }\n})\n```\n\n### 订阅消息\n\n```html\n<view class=\"invite-btn\" bindtap=\"handleInvite\">邀请好友</view>\n```\n\n```js\nPage({\n    handleInvite() {\n        wx.requestSubscribeMessage({\n            tmplIds: [''] // 订阅的模板ID\n        })\n    }\n})\n```\n\n\n\n> 但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。\n\n## 订阅消息的类型\n\n以往的模板消息，每次发送消息需要消耗一个`formId`，而`formId`有7天的有效期，因此小程序无法召回7天以前的活跃用户。\n\n而订阅消息则提供了两种类型：\n- 一次性订阅\n- 长期订阅\n\n其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。\n\n不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。\n\n## 开发的差异\n\n### 小程序端\n\n以往的模板消息方式，需要前端将每次收集到的`formId`，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。\n\n另外每次发起消息订阅，都会有弹窗出现：\n\n![](/images/subscribe/WechatIMG198.jpg)\n\n用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。\n\n若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：\n\n![](/images/subscribe/WechatIMG199.jpg)\n\n其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。\n\n如果用户关闭接收所有订阅消息，那么调用`wx.requestSubscribeMessage`时，会触发`fail`，并返回如下信息：\n\n```js\n{\n    errCode: 20004,\n    errMsg: 'The main switch is switched off',\n    // 用户关闭了主开关，无法进行订阅\n}\n```\n\n## 总结\n\n订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往`formId`的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。\n\n因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。","source":"_posts/mini-program/think-about-subscribe.md","raw":"---\ntitle: 订阅消息的思考\ntags: 小程序\ndesc: 小程序订阅消息的思考\n---\n\n## 前言\n\n小程序的早期定位是“即用即走”或者说是“用完即走”。\n但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。\n让用户回流的关键手段就是 **订阅消息**，通过点击订阅消息，可直接回到小程序。\n\n## 背景\n\n早期小程序提供的是 **模板消息**，用户每次点击或者完成支付，都会生成一个`formId`或者`paypay_id`，开发者可以通过这个`formId`给用户发送一次模板消息。\n\n因此，开发者的常规做法：尽可能地在每个按钮上都封装`form`，用以收集`formId`；收集的`formId`并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些`formId`发送模板消息。\n\n这样会存在几个问题：\n- 用户会被莫名的骚扰（因为`formId`有7天的有效期）\n- 用户收到的模板消息是无预期的（因为`formId`可以发任意的模板消息）\n- 开发者在每个页面每个可点击区域都封装了`form`，导致代码混乱\n\n为了解决以上问题，小程序团队就采用了 **订阅消息** 来替换 **模板消息**。\n\n> 小程序模板消息接口于2020年1月10日下线\n\n## 订阅消息的优势\n\n**订阅消息** 与 **模板消息** 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：\n\n![](/images/subscribe/request-subscribe-message.jpg)\n\n另外，**对订阅消息的发送时限不做限制**，即可以在任意时间给用户发送一条模板消息，而不像以前的`formId`有7天的有效期。\n\n从开发者的角度看：订阅消息是使用接口调用([wx.requestSubscribeMessage](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html))，不再是以前那样，一定要用`Button`。**对于代码维护和开发效率来说，都是利好的**。\n\n从代码维护上讲，开发者不用再层层嵌套`form`了，简化了许多代码；另外，以前模板消息是通过`Button`封装的，拜托了这层束缚之后，就不用再重置`Button`的样式了，对于开发效率也是有一定的帮助。\n\n### 模板消息\n```html\n<form bindsubmit=\"addFormId\" report-submit>\n    <button class=\"invite-btn\" form-type=\"submit\">\n        邀请好友\n    </button>\n</form>\n```\n\n```js\nPage({\n    data: {},\n    addFormId(e) {\n        let { formId } = e.detail;\n        // save formId\n    }\n})\n```\n\n### 订阅消息\n\n```html\n<view class=\"invite-btn\" bindtap=\"handleInvite\">邀请好友</view>\n```\n\n```js\nPage({\n    handleInvite() {\n        wx.requestSubscribeMessage({\n            tmplIds: [''] // 订阅的模板ID\n        })\n    }\n})\n```\n\n\n\n> 但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。\n\n## 订阅消息的类型\n\n以往的模板消息，每次发送消息需要消耗一个`formId`，而`formId`有7天的有效期，因此小程序无法召回7天以前的活跃用户。\n\n而订阅消息则提供了两种类型：\n- 一次性订阅\n- 长期订阅\n\n其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。\n\n不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。\n\n## 开发的差异\n\n### 小程序端\n\n以往的模板消息方式，需要前端将每次收集到的`formId`，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。\n\n另外每次发起消息订阅，都会有弹窗出现：\n\n![](/images/subscribe/WechatIMG198.jpg)\n\n用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。\n\n若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：\n\n![](/images/subscribe/WechatIMG199.jpg)\n\n其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。\n\n如果用户关闭接收所有订阅消息，那么调用`wx.requestSubscribeMessage`时，会触发`fail`，并返回如下信息：\n\n```js\n{\n    errCode: 20004,\n    errMsg: 'The main switch is switched off',\n    // 用户关闭了主开关，无法进行订阅\n}\n```\n\n## 总结\n\n订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往`formId`的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。\n\n因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。","slug":"mini-program/think-about-subscribe","published":1,"date":"2020-05-23T06:40:26.000Z","updated":"2020-05-23T06:40:26.000Z","_id":"ckxvfmfyf003hbrqqgevj3p7y","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的早期定位是“即用即走”或者说是“用完即走”。<br>但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。<br>让用户回流的关键手段就是 <strong>订阅消息</strong>，通过点击订阅消息，可直接回到小程序。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>早期小程序提供的是 <strong>模板消息</strong>，用户每次点击或者完成支付，都会生成一个<code>formId</code>或者<code>paypay_id</code>，开发者可以通过这个<code>formId</code>给用户发送一次模板消息。</p>\n<p>因此，开发者的常规做法：尽可能地在每个按钮上都封装<code>form</code>，用以收集<code>formId</code>；收集的<code>formId</code>并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些<code>formId</code>发送模板消息。</p>\n<p>这样会存在几个问题：</p>\n<ul>\n<li>用户会被莫名的骚扰（因为<code>formId</code>有7天的有效期）</li>\n<li>用户收到的模板消息是无预期的（因为<code>formId</code>可以发任意的模板消息）</li>\n<li>开发者在每个页面每个可点击区域都封装了<code>form</code>，导致代码混乱</li>\n</ul>\n<p>为了解决以上问题，小程序团队就采用了 <strong>订阅消息</strong> 来替换 <strong>模板消息</strong>。</p>\n<blockquote>\n<p>小程序模板消息接口于2020年1月10日下线</p>\n</blockquote>\n<h2 id=\"订阅消息的优势\"><a href=\"#订阅消息的优势\" class=\"headerlink\" title=\"订阅消息的优势\"></a>订阅消息的优势</h2><p><strong>订阅消息</strong> 与 <strong>模板消息</strong> 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：</p>\n<p><img src=\"/images/subscribe/request-subscribe-message.jpg\"></p>\n<p>另外，<strong>对订阅消息的发送时限不做限制</strong>，即可以在任意时间给用户发送一条模板消息，而不像以前的<code>formId</code>有7天的有效期。</p>\n<p>从开发者的角度看：订阅消息是使用接口调用(<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html\">wx.requestSubscribeMessage</a>)，不再是以前那样，一定要用<code>Button</code>。<strong>对于代码维护和开发效率来说，都是利好的</strong>。</p>\n<p>从代码维护上讲，开发者不用再层层嵌套<code>form</code>了，简化了许多代码；另外，以前模板消息是通过<code>Button</code>封装的，拜托了这层束缚之后，就不用再重置<code>Button</code>的样式了，对于开发效率也是有一定的帮助。</p>\n<h3 id=\"模板消息\"><a href=\"#模板消息\" class=\"headerlink\" title=\"模板消息\"></a>模板消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">bindsubmit</span>=<span class=\"string\">&quot;addFormId&quot;</span> <span class=\"attr\">report-submit</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">form-type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span></span><br><span class=\"line\">        邀请好友</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addFormId</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; formId &#125; = e.detail;</span><br><span class=\"line\">        <span class=\"comment\">// save formId</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"订阅消息\"><a href=\"#订阅消息\" class=\"headerlink\" title=\"订阅消息\"></a>订阅消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleInvite&quot;</span>&gt;</span>邀请好友<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleInvite</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        wx.requestSubscribeMessage(&#123;</span><br><span class=\"line\">            <span class=\"attr\">tmplIds</span>: [<span class=\"string\">&#x27;&#x27;</span>] <span class=\"comment\">// 订阅的模板ID</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。</p>\n</blockquote>\n<h2 id=\"订阅消息的类型\"><a href=\"#订阅消息的类型\" class=\"headerlink\" title=\"订阅消息的类型\"></a>订阅消息的类型</h2><p>以往的模板消息，每次发送消息需要消耗一个<code>formId</code>，而<code>formId</code>有7天的有效期，因此小程序无法召回7天以前的活跃用户。</p>\n<p>而订阅消息则提供了两种类型：</p>\n<ul>\n<li>一次性订阅</li>\n<li>长期订阅</li>\n</ul>\n<p>其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。</p>\n<p>不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。</p>\n<h2 id=\"开发的差异\"><a href=\"#开发的差异\" class=\"headerlink\" title=\"开发的差异\"></a>开发的差异</h2><h3 id=\"小程序端\"><a href=\"#小程序端\" class=\"headerlink\" title=\"小程序端\"></a>小程序端</h3><p>以往的模板消息方式，需要前端将每次收集到的<code>formId</code>，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。</p>\n<p>另外每次发起消息订阅，都会有弹窗出现：</p>\n<p><img src=\"/images/subscribe/WechatIMG198.jpg\"></p>\n<p>用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。</p>\n<p>若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：</p>\n<p><img src=\"/images/subscribe/WechatIMG199.jpg\"></p>\n<p>其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。</p>\n<p>如果用户关闭接收所有订阅消息，那么调用<code>wx.requestSubscribeMessage</code>时，会触发<code>fail</code>，并返回如下信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">errCode</span>: <span class=\"number\">20004</span>,</span><br><span class=\"line\">    <span class=\"attr\">errMsg</span>: <span class=\"string\">&#x27;The main switch is switched off&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 用户关闭了主开关，无法进行订阅</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往<code>formId</code>的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。</p>\n<p>因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的早期定位是“即用即走”或者说是“用完即走”。<br>但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。<br>让用户回流的关键手段就是 <strong>订阅消息</strong>，通过点击订阅消息，可直接回到小程序。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>早期小程序提供的是 <strong>模板消息</strong>，用户每次点击或者完成支付，都会生成一个<code>formId</code>或者<code>paypay_id</code>，开发者可以通过这个<code>formId</code>给用户发送一次模板消息。</p>\n<p>因此，开发者的常规做法：尽可能地在每个按钮上都封装<code>form</code>，用以收集<code>formId</code>；收集的<code>formId</code>并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些<code>formId</code>发送模板消息。</p>\n<p>这样会存在几个问题：</p>\n<ul>\n<li>用户会被莫名的骚扰（因为<code>formId</code>有7天的有效期）</li>\n<li>用户收到的模板消息是无预期的（因为<code>formId</code>可以发任意的模板消息）</li>\n<li>开发者在每个页面每个可点击区域都封装了<code>form</code>，导致代码混乱</li>\n</ul>\n<p>为了解决以上问题，小程序团队就采用了 <strong>订阅消息</strong> 来替换 <strong>模板消息</strong>。</p>\n<blockquote>\n<p>小程序模板消息接口于2020年1月10日下线</p>\n</blockquote>\n<h2 id=\"订阅消息的优势\"><a href=\"#订阅消息的优势\" class=\"headerlink\" title=\"订阅消息的优势\"></a>订阅消息的优势</h2><p><strong>订阅消息</strong> 与 <strong>模板消息</strong> 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：</p>\n<p><img src=\"/images/subscribe/request-subscribe-message.jpg\"></p>\n<p>另外，<strong>对订阅消息的发送时限不做限制</strong>，即可以在任意时间给用户发送一条模板消息，而不像以前的<code>formId</code>有7天的有效期。</p>\n<p>从开发者的角度看：订阅消息是使用接口调用(<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html\">wx.requestSubscribeMessage</a>)，不再是以前那样，一定要用<code>Button</code>。<strong>对于代码维护和开发效率来说，都是利好的</strong>。</p>\n<p>从代码维护上讲，开发者不用再层层嵌套<code>form</code>了，简化了许多代码；另外，以前模板消息是通过<code>Button</code>封装的，拜托了这层束缚之后，就不用再重置<code>Button</code>的样式了，对于开发效率也是有一定的帮助。</p>\n<h3 id=\"模板消息\"><a href=\"#模板消息\" class=\"headerlink\" title=\"模板消息\"></a>模板消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">bindsubmit</span>=<span class=\"string\">&quot;addFormId&quot;</span> <span class=\"attr\">report-submit</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">form-type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span></span><br><span class=\"line\">        邀请好友</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addFormId</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; formId &#125; = e.detail;</span><br><span class=\"line\">        <span class=\"comment\">// save formId</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"订阅消息\"><a href=\"#订阅消息\" class=\"headerlink\" title=\"订阅消息\"></a>订阅消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleInvite&quot;</span>&gt;</span>邀请好友<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleInvite</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        wx.requestSubscribeMessage(&#123;</span><br><span class=\"line\">            <span class=\"attr\">tmplIds</span>: [<span class=\"string\">&#x27;&#x27;</span>] <span class=\"comment\">// 订阅的模板ID</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。</p>\n</blockquote>\n<h2 id=\"订阅消息的类型\"><a href=\"#订阅消息的类型\" class=\"headerlink\" title=\"订阅消息的类型\"></a>订阅消息的类型</h2><p>以往的模板消息，每次发送消息需要消耗一个<code>formId</code>，而<code>formId</code>有7天的有效期，因此小程序无法召回7天以前的活跃用户。</p>\n<p>而订阅消息则提供了两种类型：</p>\n<ul>\n<li>一次性订阅</li>\n<li>长期订阅</li>\n</ul>\n<p>其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。</p>\n<p>不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。</p>\n<h2 id=\"开发的差异\"><a href=\"#开发的差异\" class=\"headerlink\" title=\"开发的差异\"></a>开发的差异</h2><h3 id=\"小程序端\"><a href=\"#小程序端\" class=\"headerlink\" title=\"小程序端\"></a>小程序端</h3><p>以往的模板消息方式，需要前端将每次收集到的<code>formId</code>，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。</p>\n<p>另外每次发起消息订阅，都会有弹窗出现：</p>\n<p><img src=\"/images/subscribe/WechatIMG198.jpg\"></p>\n<p>用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。</p>\n<p>若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：</p>\n<p><img src=\"/images/subscribe/WechatIMG199.jpg\"></p>\n<p>其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。</p>\n<p>如果用户关闭接收所有订阅消息，那么调用<code>wx.requestSubscribeMessage</code>时，会触发<code>fail</code>，并返回如下信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">errCode</span>: <span class=\"number\">20004</span>,</span><br><span class=\"line\">    <span class=\"attr\">errMsg</span>: <span class=\"string\">&#x27;The main switch is switched off&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 用户关闭了主开关，无法进行订阅</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往<code>formId</code>的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。</p>\n<p>因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。</p>\n"},{"title":"全局变量的管理","desc":"小程序的全局变量要如何管理","_content":"\n## 前言\n\n> 在浏览器的环境下有一个全局变量：`window`。\n若定义变量时，遗漏了`var`，此时声明的变量就变成了全局变量，自动挂载到`window`下，可当做`window`的属性来访问，也可以直接访问。\n\n小程序的底层也是通过Web实现的，因此同样存在`window`对象，但是微信团队做了些处理：\n\n![](/images/global-window.png)\n\n微信团队将`window`设置成了`writable:false`，且值也为`undefined`。\n\n即我们无法像在`web`那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的`wx`、`global`。\n\n## 问题\n\n虽然`window`是只读的，但是`global`是可写的:\n\n![](/images/global-global.png)\n\n因此常见的做法，就是将需要全局访问的变量都保存到`global`下，间接声明了全局变量。\n\n全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。\n\n另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。\n\n> 同理，setStorage也存在同样的问题。\n\n## 思考\n\n简单地将这些变量改成`readonly`肯定是不可取的，这影响了日常的开发。\n\n在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：\n\n- 命名空间\n- 模块化\n\n其中 **模块化** 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。\n\n因此 **命名空间** 是可以深入探索的思路。\n\n## 实践\n\n### 命名空间\n\n命名空间是一种常用的代码组织形式。\n\n大致做法是，先通过命名分配空间，再使用空间。\n\n> 我的习惯是，用业务或者功能来命名空间\n\n```js\nglobal.localStorage = {\n    doSet() {},\n    doGet() {},\n    doClear() {}\n}\n\nglobal.util = {\n    format() {},\n    valide() {}\n}\n```\n\n命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。\n\n### Symbol\n\n`Symbol`是ES2015中新增的基本数据类型。这个类型有个特别之处，每个`Symbol()`返回的值都是独一无二的，举个例子：\n\n```js\nSymbol('foo') === Symbol('foo') // false\n```\n\n因此通过`Symbol`的方式，可以完美避免变量被覆盖：\n\n```js\n// car.js\nlet car = Symbol()\nglobal[car] = {}\n\n// health.js\nlet health = Symbol()\nglobal[health] = {}\n```\n\n由于每个`Symbol`返回的值是唯一的，因此这个`Symbol`可以单独保存，以便各个文件引用。\n\n> 由于 `Symbol` 属于新特性，因此需要关注下兼容性\n\n![](/images/compatibility-symbol.jpg)\n\n### 管理声明\n\n通过`Symbol`的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。\n\n我想到的办法就是给 `global` 增加个代理，对 `global` 的任何操作，都先经过代理检测，这样就有了强力的保障。\n\n因此，可以使用新特性：`Proxy` 来监听 `global` 的变更，举例说明：\n\n```js\nglobal = new Proxy(global, {\n    set(obj, prop, val) {\n        if (prop in obj) {\n            throw new TypeError(`${prop}: 该属性已定义！`)\n        }\n\n        // 可以做其他策略\n        // 或者上报数据，让你知道有哪些人偷偷定义了全局对象\n        obj[prop] = val\n        return true\n    },\n})\n```\n\n> 由于 `Proxy` 属于新特性，因此需要关注下兼容性\n\n![](/images/compatibility-proxy.jpg)\n\n## 总结\n\n使用 `Proxy` 之后，能对 `global` 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。","source":"_posts/mini-program/global-data-manage.md","raw":"---\ntitle: 全局变量的管理\ntags: 小程序\ndesc: 小程序的全局变量要如何管理\n---\n\n## 前言\n\n> 在浏览器的环境下有一个全局变量：`window`。\n若定义变量时，遗漏了`var`，此时声明的变量就变成了全局变量，自动挂载到`window`下，可当做`window`的属性来访问，也可以直接访问。\n\n小程序的底层也是通过Web实现的，因此同样存在`window`对象，但是微信团队做了些处理：\n\n![](/images/global-window.png)\n\n微信团队将`window`设置成了`writable:false`，且值也为`undefined`。\n\n即我们无法像在`web`那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的`wx`、`global`。\n\n## 问题\n\n虽然`window`是只读的，但是`global`是可写的:\n\n![](/images/global-global.png)\n\n因此常见的做法，就是将需要全局访问的变量都保存到`global`下，间接声明了全局变量。\n\n全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。\n\n另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。\n\n> 同理，setStorage也存在同样的问题。\n\n## 思考\n\n简单地将这些变量改成`readonly`肯定是不可取的，这影响了日常的开发。\n\n在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：\n\n- 命名空间\n- 模块化\n\n其中 **模块化** 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。\n\n因此 **命名空间** 是可以深入探索的思路。\n\n## 实践\n\n### 命名空间\n\n命名空间是一种常用的代码组织形式。\n\n大致做法是，先通过命名分配空间，再使用空间。\n\n> 我的习惯是，用业务或者功能来命名空间\n\n```js\nglobal.localStorage = {\n    doSet() {},\n    doGet() {},\n    doClear() {}\n}\n\nglobal.util = {\n    format() {},\n    valide() {}\n}\n```\n\n命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。\n\n### Symbol\n\n`Symbol`是ES2015中新增的基本数据类型。这个类型有个特别之处，每个`Symbol()`返回的值都是独一无二的，举个例子：\n\n```js\nSymbol('foo') === Symbol('foo') // false\n```\n\n因此通过`Symbol`的方式，可以完美避免变量被覆盖：\n\n```js\n// car.js\nlet car = Symbol()\nglobal[car] = {}\n\n// health.js\nlet health = Symbol()\nglobal[health] = {}\n```\n\n由于每个`Symbol`返回的值是唯一的，因此这个`Symbol`可以单独保存，以便各个文件引用。\n\n> 由于 `Symbol` 属于新特性，因此需要关注下兼容性\n\n![](/images/compatibility-symbol.jpg)\n\n### 管理声明\n\n通过`Symbol`的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。\n\n我想到的办法就是给 `global` 增加个代理，对 `global` 的任何操作，都先经过代理检测，这样就有了强力的保障。\n\n因此，可以使用新特性：`Proxy` 来监听 `global` 的变更，举例说明：\n\n```js\nglobal = new Proxy(global, {\n    set(obj, prop, val) {\n        if (prop in obj) {\n            throw new TypeError(`${prop}: 该属性已定义！`)\n        }\n\n        // 可以做其他策略\n        // 或者上报数据，让你知道有哪些人偷偷定义了全局对象\n        obj[prop] = val\n        return true\n    },\n})\n```\n\n> 由于 `Proxy` 属于新特性，因此需要关注下兼容性\n\n![](/images/compatibility-proxy.jpg)\n\n## 总结\n\n使用 `Proxy` 之后，能对 `global` 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。","slug":"mini-program/global-data-manage","published":1,"date":"2020-05-23T06:39:16.000Z","updated":"2020-05-23T06:39:16.000Z","_id":"ckxvfmfyg003ibrqqabwped0e","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>在浏览器的环境下有一个全局变量：<code>window</code>。<br>若定义变量时，遗漏了<code>var</code>，此时声明的变量就变成了全局变量，自动挂载到<code>window</code>下，可当做<code>window</code>的属性来访问，也可以直接访问。</p>\n</blockquote>\n<p>小程序的底层也是通过Web实现的，因此同样存在<code>window</code>对象，但是微信团队做了些处理：</p>\n<p><img src=\"/images/global-window.png\"></p>\n<p>微信团队将<code>window</code>设置成了<code>writable:false</code>，且值也为<code>undefined</code>。</p>\n<p>即我们无法像在<code>web</code>那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的<code>wx</code>、<code>global</code>。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>虽然<code>window</code>是只读的，但是<code>global</code>是可写的:</p>\n<p><img src=\"/images/global-global.png\"></p>\n<p>因此常见的做法，就是将需要全局访问的变量都保存到<code>global</code>下，间接声明了全局变量。</p>\n<p>全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。</p>\n<p>另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。</p>\n<blockquote>\n<p>同理，setStorage也存在同样的问题。</p>\n</blockquote>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>简单地将这些变量改成<code>readonly</code>肯定是不可取的，这影响了日常的开发。</p>\n<p>在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：</p>\n<ul>\n<li>命名空间</li>\n<li>模块化</li>\n</ul>\n<p>其中 <strong>模块化</strong> 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。</p>\n<p>因此 <strong>命名空间</strong> 是可以深入探索的思路。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>命名空间是一种常用的代码组织形式。</p>\n<p>大致做法是，先通过命名分配空间，再使用空间。</p>\n<blockquote>\n<p>我的习惯是，用业务或者功能来命名空间</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span>.localStorage = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doSet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doGet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doClear</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.util = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">format</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">valide</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。</p>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p><code>Symbol</code>是ES2015中新增的基本数据类型。这个类型有个特别之处，每个<code>Symbol()</code>返回的值都是独一无二的，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>因此通过<code>Symbol</code>的方式，可以完美避免变量被覆盖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// car.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[car] = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// health.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> health = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[health] = &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于每个<code>Symbol</code>返回的值是唯一的，因此这个<code>Symbol</code>可以单独保存，以便各个文件引用。</p>\n<blockquote>\n<p>由于 <code>Symbol</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/images/compatibility-symbol.jpg\"></p>\n<h3 id=\"管理声明\"><a href=\"#管理声明\" class=\"headerlink\" title=\"管理声明\"></a>管理声明</h3><p>通过<code>Symbol</code>的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。</p>\n<p>我想到的办法就是给 <code>global</code> 增加个代理，对 <code>global</code> 的任何操作，都先经过代理检测，这样就有了强力的保障。</p>\n<p>因此，可以使用新特性：<code>Proxy</code> 来监听 <code>global</code> 的变更，举例说明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(<span class=\"built_in\">global</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">obj, prop, val</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">`<span class=\"subst\">$&#123;prop&#125;</span>: 该属性已定义！`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可以做其他策略</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者上报数据，让你知道有哪些人偷偷定义了全局对象</span></span><br><span class=\"line\">        obj[prop] = val</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于 <code>Proxy</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/images/compatibility-proxy.jpg\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用 <code>Proxy</code> 之后，能对 <code>global</code> 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>在浏览器的环境下有一个全局变量：<code>window</code>。<br>若定义变量时，遗漏了<code>var</code>，此时声明的变量就变成了全局变量，自动挂载到<code>window</code>下，可当做<code>window</code>的属性来访问，也可以直接访问。</p>\n</blockquote>\n<p>小程序的底层也是通过Web实现的，因此同样存在<code>window</code>对象，但是微信团队做了些处理：</p>\n<p><img src=\"/images/global-window.png\"></p>\n<p>微信团队将<code>window</code>设置成了<code>writable:false</code>，且值也为<code>undefined</code>。</p>\n<p>即我们无法像在<code>web</code>那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的<code>wx</code>、<code>global</code>。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>虽然<code>window</code>是只读的，但是<code>global</code>是可写的:</p>\n<p><img src=\"/images/global-global.png\"></p>\n<p>因此常见的做法，就是将需要全局访问的变量都保存到<code>global</code>下，间接声明了全局变量。</p>\n<p>全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。</p>\n<p>另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。</p>\n<blockquote>\n<p>同理，setStorage也存在同样的问题。</p>\n</blockquote>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>简单地将这些变量改成<code>readonly</code>肯定是不可取的，这影响了日常的开发。</p>\n<p>在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：</p>\n<ul>\n<li>命名空间</li>\n<li>模块化</li>\n</ul>\n<p>其中 <strong>模块化</strong> 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。</p>\n<p>因此 <strong>命名空间</strong> 是可以深入探索的思路。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>命名空间是一种常用的代码组织形式。</p>\n<p>大致做法是，先通过命名分配空间，再使用空间。</p>\n<blockquote>\n<p>我的习惯是，用业务或者功能来命名空间</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span>.localStorage = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doSet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doGet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doClear</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.util = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">format</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">valide</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。</p>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p><code>Symbol</code>是ES2015中新增的基本数据类型。这个类型有个特别之处，每个<code>Symbol()</code>返回的值都是独一无二的，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>因此通过<code>Symbol</code>的方式，可以完美避免变量被覆盖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// car.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[car] = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// health.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> health = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[health] = &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于每个<code>Symbol</code>返回的值是唯一的，因此这个<code>Symbol</code>可以单独保存，以便各个文件引用。</p>\n<blockquote>\n<p>由于 <code>Symbol</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/images/compatibility-symbol.jpg\"></p>\n<h3 id=\"管理声明\"><a href=\"#管理声明\" class=\"headerlink\" title=\"管理声明\"></a>管理声明</h3><p>通过<code>Symbol</code>的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。</p>\n<p>我想到的办法就是给 <code>global</code> 增加个代理，对 <code>global</code> 的任何操作，都先经过代理检测，这样就有了强力的保障。</p>\n<p>因此，可以使用新特性：<code>Proxy</code> 来监听 <code>global</code> 的变更，举例说明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(<span class=\"built_in\">global</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">obj, prop, val</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">`<span class=\"subst\">$&#123;prop&#125;</span>: 该属性已定义！`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可以做其他策略</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者上报数据，让你知道有哪些人偷偷定义了全局对象</span></span><br><span class=\"line\">        obj[prop] = val</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于 <code>Proxy</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/images/compatibility-proxy.jpg\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用 <code>Proxy</code> 之后，能对 <code>global</code> 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。</p>\n"},{"title":"小程序框架设计","desc":"小程序如何设计框架","_content":"\n## 前言\n\n其实说是框架设计，有点“夸大其词”。\n\n实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。\n\n## 封装Page\n\n对小程序的`Page`进行封装，是一个框架的基础，也是解决许多通用问题的利刃。\n\n如每个页面都需要设置分享`onShareAppMessage`，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装`Page`。\n\n一种方案是，通过`Page`来定义一个新的`Page`，如：`JPage`，然后每个页面不再使用`Page`注册页面，而是使用`JPage`。\n\n还有一种更好的方案，也是我所采取的方案：**劫持Page**。以至于不用改变每个页面的注册方式：\n\n```js\n// app.js\n\nlet realPage = Page\nPage = function Page(obj) {\n    let defaultPageConfig = {\n        onShareAppMessage() {\n            return {\n                title: '这里有很多有趣的壁纸',\n                path: `/pages/index/index`,\n                imageUrl: 'http://resoure.africans.cn/1.jpg',\n            }\n        }\n    }\n    return realPage({ ...defaultPageConfig, ...obj })\n}\n```\n\n这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：\n\n如果使用过 **云开发** 的读者，应该知道 **获取集合** 的步骤是这样的：\n\n```js\nlet db = wx.cloud.database()\nlet table = db.collection('wallpapers')\n```\n\n可以将这个 获取集合 的方法抽象成这样:\n\n```js\nlet getTable = (tableName) => {\n    let db = wx.cloud.database()\n    return db.collection(tableName)\n}\n```\n\n将这个方法放在`defaultPageConfig`里，以后每个页面都可以这样获取集合：\n\n```js\nthis.getTable('wallpapers')\n```\n\n## 环境\n\n每个小程序都有三种版本：开发版、体验版、正式版。\n\n往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？\n\n微信官网提供了 [wx.getAccountInfoSync](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html)，为了避免在`Page`对象里冗余太多信息，因此`env`添加至`App`：\n\n```js\nApp({\n    env: (function() {\n        let { miniProgram } = wx.getAccountInfoSync()\n        return miniProgram.envVersion\n    }())\n})\n```\n\n> 需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案\n\n\n后续可以这样使用：\n\n```js\nlet app = getApp()\nconsole.log(app.env) // develop\n```\n## 设备信息\n\n由于每个用户进入小程序之后，设备信息不可能发生变更。\n\n但在每个`Page`都封装这个信息会有点冗余，因此可以放进`App`里：\n\n```js\nApp({\n    getSystemInfo() {\n        let info = wx.getSystemInfoSync()\n\n        this.getSystemInfo = () => info\n        return info\n    }\n})\n```\n\n> 采用了缓存的机制，第一次调用时，调用`getSystemInfoSync`获取，第二次就直接返回缓存的设备信息了","source":"_posts/mini-program/frame-design.md","raw":"---\ntitle: 小程序框架设计\ntags: 小程序\ndesc: 小程序如何设计框架\n---\n\n## 前言\n\n其实说是框架设计，有点“夸大其词”。\n\n实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。\n\n## 封装Page\n\n对小程序的`Page`进行封装，是一个框架的基础，也是解决许多通用问题的利刃。\n\n如每个页面都需要设置分享`onShareAppMessage`，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装`Page`。\n\n一种方案是，通过`Page`来定义一个新的`Page`，如：`JPage`，然后每个页面不再使用`Page`注册页面，而是使用`JPage`。\n\n还有一种更好的方案，也是我所采取的方案：**劫持Page**。以至于不用改变每个页面的注册方式：\n\n```js\n// app.js\n\nlet realPage = Page\nPage = function Page(obj) {\n    let defaultPageConfig = {\n        onShareAppMessage() {\n            return {\n                title: '这里有很多有趣的壁纸',\n                path: `/pages/index/index`,\n                imageUrl: 'http://resoure.africans.cn/1.jpg',\n            }\n        }\n    }\n    return realPage({ ...defaultPageConfig, ...obj })\n}\n```\n\n这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：\n\n如果使用过 **云开发** 的读者，应该知道 **获取集合** 的步骤是这样的：\n\n```js\nlet db = wx.cloud.database()\nlet table = db.collection('wallpapers')\n```\n\n可以将这个 获取集合 的方法抽象成这样:\n\n```js\nlet getTable = (tableName) => {\n    let db = wx.cloud.database()\n    return db.collection(tableName)\n}\n```\n\n将这个方法放在`defaultPageConfig`里，以后每个页面都可以这样获取集合：\n\n```js\nthis.getTable('wallpapers')\n```\n\n## 环境\n\n每个小程序都有三种版本：开发版、体验版、正式版。\n\n往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？\n\n微信官网提供了 [wx.getAccountInfoSync](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html)，为了避免在`Page`对象里冗余太多信息，因此`env`添加至`App`：\n\n```js\nApp({\n    env: (function() {\n        let { miniProgram } = wx.getAccountInfoSync()\n        return miniProgram.envVersion\n    }())\n})\n```\n\n> 需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案\n\n\n后续可以这样使用：\n\n```js\nlet app = getApp()\nconsole.log(app.env) // develop\n```\n## 设备信息\n\n由于每个用户进入小程序之后，设备信息不可能发生变更。\n\n但在每个`Page`都封装这个信息会有点冗余，因此可以放进`App`里：\n\n```js\nApp({\n    getSystemInfo() {\n        let info = wx.getSystemInfoSync()\n\n        this.getSystemInfo = () => info\n        return info\n    }\n})\n```\n\n> 采用了缓存的机制，第一次调用时，调用`getSystemInfoSync`获取，第二次就直接返回缓存的设备信息了","slug":"mini-program/frame-design","published":1,"date":"2020-05-23T06:38:48.000Z","updated":"2020-05-23T06:38:48.000Z","_id":"ckxvfmfyh003kbrqq3h9c6n6f","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实说是框架设计，有点“夸大其词”。</p>\n<p>实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。</p>\n<h2 id=\"封装Page\"><a href=\"#封装Page\" class=\"headerlink\" title=\"封装Page\"></a>封装Page</h2><p>对小程序的<code>Page</code>进行封装，是一个框架的基础，也是解决许多通用问题的利刃。</p>\n<p>如每个页面都需要设置分享<code>onShareAppMessage</code>，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装<code>Page</code>。</p>\n<p>一种方案是，通过<code>Page</code>来定义一个新的<code>Page</code>，如：<code>JPage</code>，然后每个页面不再使用<code>Page</code>注册页面，而是使用<code>JPage</code>。</p>\n<p>还有一种更好的方案，也是我所采取的方案：<strong>劫持Page</strong>。以至于不用改变每个页面的注册方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> realPage = Page</span><br><span class=\"line\">Page = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Page</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultPageConfig = &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShareAppMessage</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;这里有很多有趣的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">`/pages/index/index`</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;http://resoure.africans.cn/1.jpg&#x27;</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> realPage(&#123; ...defaultPageConfig, ...obj &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：</p>\n<p>如果使用过 <strong>云开发</strong> 的读者，应该知道 <strong>获取集合</strong> 的步骤是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\"><span class=\"keyword\">let</span> table = db.collection(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以将这个 获取集合 的方法抽象成这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getTable = <span class=\"function\">(<span class=\"params\">tableName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db.collection(tableName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将这个方法放在<code>defaultPageConfig</code>里，以后每个页面都可以这样获取集合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.getTable(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>每个小程序都有三种版本：开发版、体验版、正式版。</p>\n<p>往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？</p>\n<p>微信官网提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html\">wx.getAccountInfoSync</a>，为了避免在<code>Page</code>对象里冗余太多信息，因此<code>env</code>添加至<code>App</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"attr\">env</span>: (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; miniProgram &#125; = wx.getAccountInfoSync()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> miniProgram.envVersion</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案</p>\n</blockquote>\n<p>后续可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> app = getApp()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(app.env) <span class=\"comment\">// develop</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"设备信息\"><a href=\"#设备信息\" class=\"headerlink\" title=\"设备信息\"></a>设备信息</h2><p>由于每个用户进入小程序之后，设备信息不可能发生变更。</p>\n<p>但在每个<code>Page</code>都封装这个信息会有点冗余，因此可以放进<code>App</code>里：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getSystemInfo</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> info = wx.getSystemInfoSync()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.getSystemInfo = <span class=\"function\">() =&gt;</span> info</span><br><span class=\"line\">        <span class=\"keyword\">return</span> info</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>采用了缓存的机制，第一次调用时，调用<code>getSystemInfoSync</code>获取，第二次就直接返回缓存的设备信息了</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实说是框架设计，有点“夸大其词”。</p>\n<p>实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。</p>\n<h2 id=\"封装Page\"><a href=\"#封装Page\" class=\"headerlink\" title=\"封装Page\"></a>封装Page</h2><p>对小程序的<code>Page</code>进行封装，是一个框架的基础，也是解决许多通用问题的利刃。</p>\n<p>如每个页面都需要设置分享<code>onShareAppMessage</code>，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装<code>Page</code>。</p>\n<p>一种方案是，通过<code>Page</code>来定义一个新的<code>Page</code>，如：<code>JPage</code>，然后每个页面不再使用<code>Page</code>注册页面，而是使用<code>JPage</code>。</p>\n<p>还有一种更好的方案，也是我所采取的方案：<strong>劫持Page</strong>。以至于不用改变每个页面的注册方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> realPage = Page</span><br><span class=\"line\">Page = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Page</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultPageConfig = &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShareAppMessage</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;这里有很多有趣的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">`/pages/index/index`</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;http://resoure.africans.cn/1.jpg&#x27;</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> realPage(&#123; ...defaultPageConfig, ...obj &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：</p>\n<p>如果使用过 <strong>云开发</strong> 的读者，应该知道 <strong>获取集合</strong> 的步骤是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\"><span class=\"keyword\">let</span> table = db.collection(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以将这个 获取集合 的方法抽象成这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getTable = <span class=\"function\">(<span class=\"params\">tableName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db.collection(tableName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将这个方法放在<code>defaultPageConfig</code>里，以后每个页面都可以这样获取集合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.getTable(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>每个小程序都有三种版本：开发版、体验版、正式版。</p>\n<p>往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？</p>\n<p>微信官网提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html\">wx.getAccountInfoSync</a>，为了避免在<code>Page</code>对象里冗余太多信息，因此<code>env</code>添加至<code>App</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"attr\">env</span>: (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; miniProgram &#125; = wx.getAccountInfoSync()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> miniProgram.envVersion</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案</p>\n</blockquote>\n<p>后续可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> app = getApp()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(app.env) <span class=\"comment\">// develop</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"设备信息\"><a href=\"#设备信息\" class=\"headerlink\" title=\"设备信息\"></a>设备信息</h2><p>由于每个用户进入小程序之后，设备信息不可能发生变更。</p>\n<p>但在每个<code>Page</code>都封装这个信息会有点冗余，因此可以放进<code>App</code>里：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getSystemInfo</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> info = wx.getSystemInfoSync()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.getSystemInfo = <span class=\"function\">() =&gt;</span> info</span><br><span class=\"line\">        <span class=\"keyword\">return</span> info</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>采用了缓存的机制，第一次调用时，调用<code>getSystemInfoSync</code>获取，第二次就直接返回缓存的设备信息了</p>\n</blockquote>\n"},{"title":"自定义tabbar","desc":"小程序如何自定义tabbar","_content":"\n## 前言\n\n由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。\n\n因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：\n\n![](/images/compare.jpg)\n\n## 分析\n\n原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。\n\n从 [小程序的官网文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar) 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：\n\n```json\n\"tabbar\": {\n    \"custom\": true\n}\n```\n \n设置了`custom`之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。\n\n而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）\n\n## 实践\n\n按照官网文档的描述，在根目录上创建组件的文件夹，命名`custom-tab-bar`，里面的文件和正常的组件保持一致。\n\n此时就可以将组件的样式和逻辑稍作调整：\n\n- 当进入首页时，背景色改成透明\n- 进入其他页面，背景色改回白色\n\n这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的`WXML`里显式引用。\n\n### 选中态\n\n由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？\n\n根据官网的描述，即是提供了接口`getTabBar`，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）\n\n需要在tabbar包含的每个页面的onShow里这样设置：\n\n```js\nPage({\n    onShow() {\n        if (typeof this.getTabBar === 'function') {\n            this.getTabBar().setData({ selected: 0 }) // 0代表第一个\n        }\n    }\n})\n```\n\n> 此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router\n\n### 兼容性\n\n为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉`custom:true`才会恢复渲染tabbar。\n\n所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。\n\n> 如果你知道有什么兼容办法，欢迎和我联系。","source":"_posts/mini-program/custom-tabbar.md","raw":"---\ntitle: 自定义tabbar\ntags: 小程序\ndesc: 小程序如何自定义tabbar\n---\n\n## 前言\n\n由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。\n\n因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：\n\n![](/images/compare.jpg)\n\n## 分析\n\n原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。\n\n从 [小程序的官网文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar) 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：\n\n```json\n\"tabbar\": {\n    \"custom\": true\n}\n```\n \n设置了`custom`之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。\n\n而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）\n\n## 实践\n\n按照官网文档的描述，在根目录上创建组件的文件夹，命名`custom-tab-bar`，里面的文件和正常的组件保持一致。\n\n此时就可以将组件的样式和逻辑稍作调整：\n\n- 当进入首页时，背景色改成透明\n- 进入其他页面，背景色改回白色\n\n这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的`WXML`里显式引用。\n\n### 选中态\n\n由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？\n\n根据官网的描述，即是提供了接口`getTabBar`，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）\n\n需要在tabbar包含的每个页面的onShow里这样设置：\n\n```js\nPage({\n    onShow() {\n        if (typeof this.getTabBar === 'function') {\n            this.getTabBar().setData({ selected: 0 }) // 0代表第一个\n        }\n    }\n})\n```\n\n> 此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router\n\n### 兼容性\n\n为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉`custom:true`才会恢复渲染tabbar。\n\n所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。\n\n> 如果你知道有什么兼容办法，欢迎和我联系。","slug":"mini-program/custom-tabbar","published":1,"date":"2020-05-23T06:38:14.000Z","updated":"2020-05-23T06:38:14.000Z","_id":"ckxvfmfyi003mbrqq0q58fvkr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。</p>\n<p>因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：</p>\n<p><img src=\"/images/compare.jpg\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。</p>\n<p>从 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar\">小程序的官网文档</a> 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;tabbar&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;custom&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置了<code>custom</code>之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。</p>\n<p>而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>按照官网文档的描述，在根目录上创建组件的文件夹，命名<code>custom-tab-bar</code>，里面的文件和正常的组件保持一致。</p>\n<p>此时就可以将组件的样式和逻辑稍作调整：</p>\n<ul>\n<li>当进入首页时，背景色改成透明</li>\n<li>进入其他页面，背景色改回白色</li>\n</ul>\n<p>这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的<code>WXML</code>里显式引用。</p>\n<h3 id=\"选中态\"><a href=\"#选中态\" class=\"headerlink\" title=\"选中态\"></a>选中态</h3><p>由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？</p>\n<p>根据官网的描述，即是提供了接口<code>getTabBar</code>，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）</p>\n<p>需要在tabbar包含的每个页面的onShow里这样设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span>.getTabBar === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.getTabBar().setData(&#123; <span class=\"attr\">selected</span>: <span class=\"number\">0</span> &#125;) <span class=\"comment\">// 0代表第一个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router</p>\n</blockquote>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉<code>custom:true</code>才会恢复渲染tabbar。</p>\n<p>所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。</p>\n<blockquote>\n<p>如果你知道有什么兼容办法，欢迎和我联系。</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。</p>\n<p>因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：</p>\n<p><img src=\"/images/compare.jpg\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。</p>\n<p>从 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar\">小程序的官网文档</a> 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;tabbar&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;custom&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置了<code>custom</code>之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。</p>\n<p>而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>按照官网文档的描述，在根目录上创建组件的文件夹，命名<code>custom-tab-bar</code>，里面的文件和正常的组件保持一致。</p>\n<p>此时就可以将组件的样式和逻辑稍作调整：</p>\n<ul>\n<li>当进入首页时，背景色改成透明</li>\n<li>进入其他页面，背景色改回白色</li>\n</ul>\n<p>这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的<code>WXML</code>里显式引用。</p>\n<h3 id=\"选中态\"><a href=\"#选中态\" class=\"headerlink\" title=\"选中态\"></a>选中态</h3><p>由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？</p>\n<p>根据官网的描述，即是提供了接口<code>getTabBar</code>，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）</p>\n<p>需要在tabbar包含的每个页面的onShow里这样设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span>.getTabBar === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.getTabBar().setData(&#123; <span class=\"attr\">selected</span>: <span class=\"number\">0</span> &#125;) <span class=\"comment\">// 0代表第一个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router</p>\n</blockquote>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉<code>custom:true</code>才会恢复渲染tabbar。</p>\n<p>所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。</p>\n<blockquote>\n<p>如果你知道有什么兼容办法，欢迎和我联系。</p>\n</blockquote>\n"},{"title":"自定义导航栏","desc":"小程序如何自定义导航栏","_content":"\n小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。\n\n> 自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域\n\n![](/images/custom-navigator/interface.jpg)\n\n## 作用\n\n最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。\n\n![](/images/custom-navigator/full-screen.jpeg)\n\n其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。\n\n需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过`wx.getMenuButtonBoundingClientRect`获取胶囊按钮的布局位置信息。\n\n## 布局信息\n\n由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。\n\n![](/images/custom-navigator/navigator.jpg)\n\n如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过`wx.getSystemInfo`获取系统信息，其中的`statusBarHeight`即是状态栏的高度。\n\n另外前文也提到了，胶囊按钮的信息可以通过`wx.getMenuButtonBoundingClientRect`获取。胶囊按钮与状态栏的距离可以这样计算：\n\n```js\nlet mb = wx.getMenuButtonBoundingClientRect();\nlet sh = wx.getSystemInfoSync().statusBarHeight // 为getSystemInfo的同步版本\n\nlet distance = mb.top - sh\n```\n\n基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的`distance`是一致的。所以，导航栏的高度是：\n\n```js\nlet nh = mb.height + distance * 2 // navigatorHeight\n```\n\n总计一下，导航栏的布局信息如下：\n\n```js\nlet navigator = {\n    top: sh\n    bottom: mb.bottom + distance\n    left: 0,\n    right: 0,\n    height: mb.height + distance * 2\n    width: wx.getSystemInfoSync().screenWidth\n}\n```\n\n## 兼容问题\n\n前文提到页面设置导航栏是要求`客户端7.0.0以上`；\n\n另外计算 **状态栏高度(statusBarHeight)** 需要`基础库版本1.9.0`以上；\n\n计算胶囊按钮的布局信息`wx.getMenuButtonBoundingClientRect`则要求`基础库2.1.0`；\n\n> 由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为`2.4.3`\n\n因此，只要判断当前用户的客户端是否为`7.0.0`或以上即可。\n\n## 注意事项\n\n由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意`position: fixed`的元素，此时应该将`top`对应的数值加上`statusBarHeight`和`navigator.height`，才能渲染正确。","source":"_posts/mini-program/custom-navigator.md","raw":"---\ntitle: 自定义导航栏\ntags: 小程序\ndesc: 小程序如何自定义导航栏\n---\n\n小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。\n\n> 自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域\n\n![](/images/custom-navigator/interface.jpg)\n\n## 作用\n\n最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。\n\n![](/images/custom-navigator/full-screen.jpeg)\n\n其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。\n\n需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过`wx.getMenuButtonBoundingClientRect`获取胶囊按钮的布局位置信息。\n\n## 布局信息\n\n由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。\n\n![](/images/custom-navigator/navigator.jpg)\n\n如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过`wx.getSystemInfo`获取系统信息，其中的`statusBarHeight`即是状态栏的高度。\n\n另外前文也提到了，胶囊按钮的信息可以通过`wx.getMenuButtonBoundingClientRect`获取。胶囊按钮与状态栏的距离可以这样计算：\n\n```js\nlet mb = wx.getMenuButtonBoundingClientRect();\nlet sh = wx.getSystemInfoSync().statusBarHeight // 为getSystemInfo的同步版本\n\nlet distance = mb.top - sh\n```\n\n基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的`distance`是一致的。所以，导航栏的高度是：\n\n```js\nlet nh = mb.height + distance * 2 // navigatorHeight\n```\n\n总计一下，导航栏的布局信息如下：\n\n```js\nlet navigator = {\n    top: sh\n    bottom: mb.bottom + distance\n    left: 0,\n    right: 0,\n    height: mb.height + distance * 2\n    width: wx.getSystemInfoSync().screenWidth\n}\n```\n\n## 兼容问题\n\n前文提到页面设置导航栏是要求`客户端7.0.0以上`；\n\n另外计算 **状态栏高度(statusBarHeight)** 需要`基础库版本1.9.0`以上；\n\n计算胶囊按钮的布局信息`wx.getMenuButtonBoundingClientRect`则要求`基础库2.1.0`；\n\n> 由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为`2.4.3`\n\n因此，只要判断当前用户的客户端是否为`7.0.0`或以上即可。\n\n## 注意事项\n\n由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意`position: fixed`的元素，此时应该将`top`对应的数值加上`statusBarHeight`和`navigator.height`，才能渲染正确。","slug":"mini-program/custom-navigator","published":1,"date":"2020-05-23T06:37:58.000Z","updated":"2020-05-23T06:37:58.000Z","_id":"ckxvfmfyj003obrqq59ph5r54","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。</p>\n<blockquote>\n<p>自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域</p>\n</blockquote>\n<p><img src=\"/images/custom-navigator/interface.jpg\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。</p>\n<p><img src=\"/images/custom-navigator/full-screen.jpeg\"></p>\n<p>其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。</p>\n<p>需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取胶囊按钮的布局位置信息。</p>\n<h2 id=\"布局信息\"><a href=\"#布局信息\" class=\"headerlink\" title=\"布局信息\"></a>布局信息</h2><p>由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。</p>\n<p><img src=\"/images/custom-navigator/navigator.jpg\"></p>\n<p>如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过<code>wx.getSystemInfo</code>获取系统信息，其中的<code>statusBarHeight</code>即是状态栏的高度。</p>\n<p>另外前文也提到了，胶囊按钮的信息可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取。胶囊按钮与状态栏的距离可以这样计算：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mb = wx.getMenuButtonBoundingClientRect();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sh = wx.getSystemInfoSync().statusBarHeight <span class=\"comment\">// 为getSystemInfo的同步版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> distance = mb.top - sh</span><br></pre></td></tr></table></figure>\n\n<p>基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的<code>distance</code>是一致的。所以，导航栏的高度是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nh = mb.height + distance * <span class=\"number\">2</span> <span class=\"comment\">// navigatorHeight</span></span><br></pre></td></tr></table></figure>\n\n<p>总计一下，导航栏的布局信息如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> navigator = &#123;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: sh</span><br><span class=\"line\">    <span class=\"attr\">bottom</span>: mb.bottom + distance</span><br><span class=\"line\">    <span class=\"attr\">left</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">right</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">height</span>: mb.height + distance * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attr\">width</span>: wx.getSystemInfoSync().screenWidth</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"兼容问题\"><a href=\"#兼容问题\" class=\"headerlink\" title=\"兼容问题\"></a>兼容问题</h2><p>前文提到页面设置导航栏是要求<code>客户端7.0.0以上</code>；</p>\n<p>另外计算 <strong>状态栏高度(statusBarHeight)</strong> 需要<code>基础库版本1.9.0</code>以上；</p>\n<p>计算胶囊按钮的布局信息<code>wx.getMenuButtonBoundingClientRect</code>则要求<code>基础库2.1.0</code>；</p>\n<blockquote>\n<p>由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为<code>2.4.3</code></p>\n</blockquote>\n<p>因此，只要判断当前用户的客户端是否为<code>7.0.0</code>或以上即可。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意<code>position: fixed</code>的元素，此时应该将<code>top</code>对应的数值加上<code>statusBarHeight</code>和<code>navigator.height</code>，才能渲染正确。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。</p>\n<blockquote>\n<p>自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域</p>\n</blockquote>\n<p><img src=\"/images/custom-navigator/interface.jpg\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。</p>\n<p><img src=\"/images/custom-navigator/full-screen.jpeg\"></p>\n<p>其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。</p>\n<p>需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取胶囊按钮的布局位置信息。</p>\n<h2 id=\"布局信息\"><a href=\"#布局信息\" class=\"headerlink\" title=\"布局信息\"></a>布局信息</h2><p>由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。</p>\n<p><img src=\"/images/custom-navigator/navigator.jpg\"></p>\n<p>如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过<code>wx.getSystemInfo</code>获取系统信息，其中的<code>statusBarHeight</code>即是状态栏的高度。</p>\n<p>另外前文也提到了，胶囊按钮的信息可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取。胶囊按钮与状态栏的距离可以这样计算：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mb = wx.getMenuButtonBoundingClientRect();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sh = wx.getSystemInfoSync().statusBarHeight <span class=\"comment\">// 为getSystemInfo的同步版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> distance = mb.top - sh</span><br></pre></td></tr></table></figure>\n\n<p>基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的<code>distance</code>是一致的。所以，导航栏的高度是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nh = mb.height + distance * <span class=\"number\">2</span> <span class=\"comment\">// navigatorHeight</span></span><br></pre></td></tr></table></figure>\n\n<p>总计一下，导航栏的布局信息如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> navigator = &#123;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: sh</span><br><span class=\"line\">    <span class=\"attr\">bottom</span>: mb.bottom + distance</span><br><span class=\"line\">    <span class=\"attr\">left</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">right</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">height</span>: mb.height + distance * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attr\">width</span>: wx.getSystemInfoSync().screenWidth</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"兼容问题\"><a href=\"#兼容问题\" class=\"headerlink\" title=\"兼容问题\"></a>兼容问题</h2><p>前文提到页面设置导航栏是要求<code>客户端7.0.0以上</code>；</p>\n<p>另外计算 <strong>状态栏高度(statusBarHeight)</strong> 需要<code>基础库版本1.9.0</code>以上；</p>\n<p>计算胶囊按钮的布局信息<code>wx.getMenuButtonBoundingClientRect</code>则要求<code>基础库2.1.0</code>；</p>\n<blockquote>\n<p>由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为<code>2.4.3</code></p>\n</blockquote>\n<p>因此，只要判断当前用户的客户端是否为<code>7.0.0</code>或以上即可。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意<code>position: fixed</code>的元素，此时应该将<code>top</code>对应的数值加上<code>statusBarHeight</code>和<code>navigator.height</code>，才能渲染正确。</p>\n"},{"title":"编码规范的一些思考","desc":"如何制定前端的编码规范，以及前端工程化","_content":"\n## 引言\n\n古人常说，无规矩不成方圆。在编程的世界里也同样如此。\n\n从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。\n\n然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。\n\n## 现实\n\n在笔者呆过的团队，似乎都在重蹈覆辙：\n- 一开始不重视文档、规范，快速启动，敏捷开发\n- 等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码\n- 由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码\n\n如此往复，无形中浪费了许多因修复历史代码而产生的工作量。\n\n笔者认为，有可能是以下几种原因导致这种现象：\n\n- 团队早期人员少，项目急，人力不足\n- 前端开发仍不够成熟，没可落地的完整方案\n- 经验不足，无法意识到规范的重要性\n\n## 范围\n\n我们常说的代码规范属于编码规范的子集。\n\n笔者理解的编码规范包括一下几种：\n- 代码规范\n- 文件规范\n- 项目结构规范\n\n其中，**代码规范** 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。\n\n代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。\n\n**文件规范** 则包含：文件的命名规范，以及文件的类型规范（如图片）。\n\n**项目结构规范** 是规范化项目的结构，有利于项目的可读性。\n\n由于篇幅有限，文本将主要阐述 **代码规范** 的制定与落地实施。\n\n## 前端的特殊性\n\n若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。\n\n但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：\n\n- 编程语言：JavaScript、CSS、HTML\n- 框架：Vue、React、Angular\n- runtime：Node.js、小程序、浏览器\n- 语法糖：CoffeeScript、TypeScript\n\n其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。\n\n上述的runtime和语法糖都是针对于`JavaScript`而言，因此确定`JavsScript`的代码规范是首要任务。\n\n> 最好的结果就是每个人写得代码都是一样的。\n\n## 快速开始\n\n导致团队的代码规范难以指定的一个很大原因就是无法快速开始。\n\n因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)\n\n通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。\n\n对于`JavaScript`来说，最强力的代码分析检测工具非`ESLint`莫属，其涵盖了代码质量和编码风格的检测。\n\n### ESLint\n\n![](/images/code-guide/eslint.png)\n\nESLint官方有提供一个推荐方案，通过配置文件`.eslintrc`：\n\n```json\n{\n    \"extends\": \"eslint:recommended\"\n}\n```\n\n或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。\n\n使用`ESlint --init`即可开启交互式初始化ESLint配置。\n\n对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架`Vue`举例说明：\n\n`Vue`官方提供了ESLint的插件：[eslint-plugin-vue](https://eslint.vuejs.org/)\n\n通过此插件，可以利用ESLint检测`.vue`文件的`<template>`和`<script>`模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：\n\n```json\n{\n    \"extends\": \"plugin:vue/vue3-recommended\",\n    \"rules\": {\n\n    }\n}\n```\n\n> 另外，可以在`rules`里覆盖推荐的规范\n\n执行检测：\n\n```bash\nnpx eslint **/*.{js,vue}\n```\n\n### HTMLHint\n\n![](/images/code-guide/htmlhint.png)\n\n因为`HTML`不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：[HTMLHint Rules](https://github.com/htmlhint/HTMLHint/wiki/Rules)\n\n通过配置文件`.htmlhintrc`配置，默认配置如下：\n\n```json\n{\n   \"tagname-lowercase\": true,\n    \"attr-lowercase\": true,\n    \"attr-value-double-quotes\": true,\n    \"doctype-first\": true,\n    \"tag-pair\": true,\n    \"spec-char-escape\": true,\n    \"id-unique\": true,\n    \"src-not-empty\": true,\n    \"attr-no-duplication\": true,\n    \"title-require\": true\n}\n```\n\n执行检测：\n\n```bash\nnpx htmlhint **/*.html\n```\n\n### stylelint\n\n![](/images/code-guide/stylelint.png)\n\n`stylelint`是`CSS`的代码分析工具，类似于`ESLint`，`stylelint`也提供了 **标准配置(standard configuration)**，安装方式：\n\n```bash\nnpm install --save-dev stylelint stylelint-config-standard\n```\n\n在项目根目录创建配置文件`.stylelintrc.json`：\n\n```json\n{\n  \"extends\": \"stylelint-config-standard\"\n}\n```\n\n执行检测：\n\n```bash\nnpx stylelint \"**/*.css\"\n```\n\n## 实施方案\n\n如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以`GitLab`举例：\n\n每个仓库均可设置多个分支，在`GitLab`上对关键分支（比如`master`）的权限做严格把控，比如：\n\n- 不允许任何人直接push到关键分支（Allowed to push: No one)\n\n![](/images/code-guide/protect-branch.png)\n\n- 仅允许通过pipeline的 **合并请求(merge requests)** 进行合并\n\n![](/images/code-guide/merge-request.png)\n\n最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。\n\n## 总结\n\n编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。\n\n另外，需要切记的是，规范文档的落地不一定需要正式的`word`格式，`markdown`、`html`乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。","source":"_posts/mini-program/code-style-guide.md","raw":"---\ntitle: 编码规范的一些思考\ntags: 编码规范\ndesc: 如何制定前端的编码规范，以及前端工程化\n---\n\n## 引言\n\n古人常说，无规矩不成方圆。在编程的世界里也同样如此。\n\n从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。\n\n然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。\n\n## 现实\n\n在笔者呆过的团队，似乎都在重蹈覆辙：\n- 一开始不重视文档、规范，快速启动，敏捷开发\n- 等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码\n- 由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码\n\n如此往复，无形中浪费了许多因修复历史代码而产生的工作量。\n\n笔者认为，有可能是以下几种原因导致这种现象：\n\n- 团队早期人员少，项目急，人力不足\n- 前端开发仍不够成熟，没可落地的完整方案\n- 经验不足，无法意识到规范的重要性\n\n## 范围\n\n我们常说的代码规范属于编码规范的子集。\n\n笔者理解的编码规范包括一下几种：\n- 代码规范\n- 文件规范\n- 项目结构规范\n\n其中，**代码规范** 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。\n\n代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。\n\n**文件规范** 则包含：文件的命名规范，以及文件的类型规范（如图片）。\n\n**项目结构规范** 是规范化项目的结构，有利于项目的可读性。\n\n由于篇幅有限，文本将主要阐述 **代码规范** 的制定与落地实施。\n\n## 前端的特殊性\n\n若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。\n\n但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：\n\n- 编程语言：JavaScript、CSS、HTML\n- 框架：Vue、React、Angular\n- runtime：Node.js、小程序、浏览器\n- 语法糖：CoffeeScript、TypeScript\n\n其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。\n\n上述的runtime和语法糖都是针对于`JavaScript`而言，因此确定`JavsScript`的代码规范是首要任务。\n\n> 最好的结果就是每个人写得代码都是一样的。\n\n## 快速开始\n\n导致团队的代码规范难以指定的一个很大原因就是无法快速开始。\n\n因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)\n\n通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。\n\n对于`JavaScript`来说，最强力的代码分析检测工具非`ESLint`莫属，其涵盖了代码质量和编码风格的检测。\n\n### ESLint\n\n![](/images/code-guide/eslint.png)\n\nESLint官方有提供一个推荐方案，通过配置文件`.eslintrc`：\n\n```json\n{\n    \"extends\": \"eslint:recommended\"\n}\n```\n\n或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。\n\n使用`ESlint --init`即可开启交互式初始化ESLint配置。\n\n对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架`Vue`举例说明：\n\n`Vue`官方提供了ESLint的插件：[eslint-plugin-vue](https://eslint.vuejs.org/)\n\n通过此插件，可以利用ESLint检测`.vue`文件的`<template>`和`<script>`模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：\n\n```json\n{\n    \"extends\": \"plugin:vue/vue3-recommended\",\n    \"rules\": {\n\n    }\n}\n```\n\n> 另外，可以在`rules`里覆盖推荐的规范\n\n执行检测：\n\n```bash\nnpx eslint **/*.{js,vue}\n```\n\n### HTMLHint\n\n![](/images/code-guide/htmlhint.png)\n\n因为`HTML`不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：[HTMLHint Rules](https://github.com/htmlhint/HTMLHint/wiki/Rules)\n\n通过配置文件`.htmlhintrc`配置，默认配置如下：\n\n```json\n{\n   \"tagname-lowercase\": true,\n    \"attr-lowercase\": true,\n    \"attr-value-double-quotes\": true,\n    \"doctype-first\": true,\n    \"tag-pair\": true,\n    \"spec-char-escape\": true,\n    \"id-unique\": true,\n    \"src-not-empty\": true,\n    \"attr-no-duplication\": true,\n    \"title-require\": true\n}\n```\n\n执行检测：\n\n```bash\nnpx htmlhint **/*.html\n```\n\n### stylelint\n\n![](/images/code-guide/stylelint.png)\n\n`stylelint`是`CSS`的代码分析工具，类似于`ESLint`，`stylelint`也提供了 **标准配置(standard configuration)**，安装方式：\n\n```bash\nnpm install --save-dev stylelint stylelint-config-standard\n```\n\n在项目根目录创建配置文件`.stylelintrc.json`：\n\n```json\n{\n  \"extends\": \"stylelint-config-standard\"\n}\n```\n\n执行检测：\n\n```bash\nnpx stylelint \"**/*.css\"\n```\n\n## 实施方案\n\n如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以`GitLab`举例：\n\n每个仓库均可设置多个分支，在`GitLab`上对关键分支（比如`master`）的权限做严格把控，比如：\n\n- 不允许任何人直接push到关键分支（Allowed to push: No one)\n\n![](/images/code-guide/protect-branch.png)\n\n- 仅允许通过pipeline的 **合并请求(merge requests)** 进行合并\n\n![](/images/code-guide/merge-request.png)\n\n最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。\n\n## 总结\n\n编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。\n\n另外，需要切记的是，规范文档的落地不一定需要正式的`word`格式，`markdown`、`html`乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。","slug":"mini-program/code-style-guide","published":1,"date":"2020-05-23T06:37:30.000Z","updated":"2020-05-23T06:37:30.000Z","_id":"ckxvfmfyl003qbrqq1klxb6zg","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>古人常说，无规矩不成方圆。在编程的世界里也同样如此。</p>\n<p>从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。</p>\n<p>然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。</p>\n<h2 id=\"现实\"><a href=\"#现实\" class=\"headerlink\" title=\"现实\"></a>现实</h2><p>在笔者呆过的团队，似乎都在重蹈覆辙：</p>\n<ul>\n<li>一开始不重视文档、规范，快速启动，敏捷开发</li>\n<li>等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码</li>\n<li>由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码</li>\n</ul>\n<p>如此往复，无形中浪费了许多因修复历史代码而产生的工作量。</p>\n<p>笔者认为，有可能是以下几种原因导致这种现象：</p>\n<ul>\n<li>团队早期人员少，项目急，人力不足</li>\n<li>前端开发仍不够成熟，没可落地的完整方案</li>\n<li>经验不足，无法意识到规范的重要性</li>\n</ul>\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><p>我们常说的代码规范属于编码规范的子集。</p>\n<p>笔者理解的编码规范包括一下几种：</p>\n<ul>\n<li>代码规范</li>\n<li>文件规范</li>\n<li>项目结构规范</li>\n</ul>\n<p>其中，<strong>代码规范</strong> 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。</p>\n<p>代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。</p>\n<p><strong>文件规范</strong> 则包含：文件的命名规范，以及文件的类型规范（如图片）。</p>\n<p><strong>项目结构规范</strong> 是规范化项目的结构，有利于项目的可读性。</p>\n<p>由于篇幅有限，文本将主要阐述 <strong>代码规范</strong> 的制定与落地实施。</p>\n<h2 id=\"前端的特殊性\"><a href=\"#前端的特殊性\" class=\"headerlink\" title=\"前端的特殊性\"></a>前端的特殊性</h2><p>若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。</p>\n<p>但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：</p>\n<ul>\n<li>编程语言：JavaScript、CSS、HTML</li>\n<li>框架：Vue、React、Angular</li>\n<li>runtime：Node.js、小程序、浏览器</li>\n<li>语法糖：CoffeeScript、TypeScript</li>\n</ul>\n<p>其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。</p>\n<p>上述的runtime和语法糖都是针对于<code>JavaScript</code>而言，因此确定<code>JavsScript</code>的代码规范是首要任务。</p>\n<blockquote>\n<p>最好的结果就是每个人写得代码都是一样的。</p>\n</blockquote>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>导致团队的代码规范难以指定的一个很大原因就是无法快速开始。</p>\n<p>因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)</p>\n<p>通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。</p>\n<p>对于<code>JavaScript</code>来说，最强力的代码分析检测工具非<code>ESLint</code>莫属，其涵盖了代码质量和编码风格的检测。</p>\n<h3 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p><img src=\"/images/code-guide/eslint.png\"></p>\n<p>ESLint官方有提供一个推荐方案，通过配置文件<code>.eslintrc</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;eslint:recommended&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。</p>\n<p>使用<code>ESlint --init</code>即可开启交互式初始化ESLint配置。</p>\n<p>对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架<code>Vue</code>举例说明：</p>\n<p><code>Vue</code>官方提供了ESLint的插件：<a href=\"https://eslint.vuejs.org/\">eslint-plugin-vue</a></p>\n<p>通过此插件，可以利用ESLint检测<code>.vue</code>文件的<code>&lt;template&gt;</code>和<code>&lt;script&gt;</code>模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;plugin:vue/vue3-recommended&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;rules&quot;</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外，可以在<code>rules</code>里覆盖推荐的规范</p>\n</blockquote>\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx eslint **/*.&#123;js,vue&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMLHint\"><a href=\"#HTMLHint\" class=\"headerlink\" title=\"HTMLHint\"></a>HTMLHint</h3><p><img src=\"/images/code-guide/htmlhint.png\"></p>\n<p>因为<code>HTML</code>不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：<a href=\"https://github.com/htmlhint/HTMLHint/wiki/Rules\">HTMLHint Rules</a></p>\n<p>通过配置文件<code>.htmlhintrc</code>配置，默认配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">&quot;tagname-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-value-double-quotes&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;doctype-first&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;tag-pair&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;spec-char-escape&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;id-unique&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;src-not-empty&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-no-duplication&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;title-require&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx htmlhint **/*.html</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"stylelint\"><a href=\"#stylelint\" class=\"headerlink\" title=\"stylelint\"></a>stylelint</h3><p><img src=\"/images/code-guide/stylelint.png\"></p>\n<p><code>stylelint</code>是<code>CSS</code>的代码分析工具，类似于<code>ESLint</code>，<code>stylelint</code>也提供了 **标准配置(standard configuration)**，安装方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev stylelint stylelint-config-standard</span><br></pre></td></tr></table></figure>\n\n<p>在项目根目录创建配置文件<code>.stylelintrc.json</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;stylelint-config-standard&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx stylelint <span class=\"string\">&quot;**/*.css&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h2><p>如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以<code>GitLab</code>举例：</p>\n<p>每个仓库均可设置多个分支，在<code>GitLab</code>上对关键分支（比如<code>master</code>）的权限做严格把控，比如：</p>\n<ul>\n<li>不允许任何人直接push到关键分支（Allowed to push: No one)</li>\n</ul>\n<p><img src=\"/images/code-guide/protect-branch.png\"></p>\n<ul>\n<li>仅允许通过pipeline的 <strong>合并请求(merge requests)</strong> 进行合并</li>\n</ul>\n<p><img src=\"/images/code-guide/merge-request.png\"></p>\n<p>最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。</p>\n<p>另外，需要切记的是，规范文档的落地不一定需要正式的<code>word</code>格式，<code>markdown</code>、<code>html</code>乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>古人常说，无规矩不成方圆。在编程的世界里也同样如此。</p>\n<p>从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。</p>\n<p>然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。</p>\n<h2 id=\"现实\"><a href=\"#现实\" class=\"headerlink\" title=\"现实\"></a>现实</h2><p>在笔者呆过的团队，似乎都在重蹈覆辙：</p>\n<ul>\n<li>一开始不重视文档、规范，快速启动，敏捷开发</li>\n<li>等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码</li>\n<li>由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码</li>\n</ul>\n<p>如此往复，无形中浪费了许多因修复历史代码而产生的工作量。</p>\n<p>笔者认为，有可能是以下几种原因导致这种现象：</p>\n<ul>\n<li>团队早期人员少，项目急，人力不足</li>\n<li>前端开发仍不够成熟，没可落地的完整方案</li>\n<li>经验不足，无法意识到规范的重要性</li>\n</ul>\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><p>我们常说的代码规范属于编码规范的子集。</p>\n<p>笔者理解的编码规范包括一下几种：</p>\n<ul>\n<li>代码规范</li>\n<li>文件规范</li>\n<li>项目结构规范</li>\n</ul>\n<p>其中，<strong>代码规范</strong> 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。</p>\n<p>代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。</p>\n<p><strong>文件规范</strong> 则包含：文件的命名规范，以及文件的类型规范（如图片）。</p>\n<p><strong>项目结构规范</strong> 是规范化项目的结构，有利于项目的可读性。</p>\n<p>由于篇幅有限，文本将主要阐述 <strong>代码规范</strong> 的制定与落地实施。</p>\n<h2 id=\"前端的特殊性\"><a href=\"#前端的特殊性\" class=\"headerlink\" title=\"前端的特殊性\"></a>前端的特殊性</h2><p>若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。</p>\n<p>但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：</p>\n<ul>\n<li>编程语言：JavaScript、CSS、HTML</li>\n<li>框架：Vue、React、Angular</li>\n<li>runtime：Node.js、小程序、浏览器</li>\n<li>语法糖：CoffeeScript、TypeScript</li>\n</ul>\n<p>其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。</p>\n<p>上述的runtime和语法糖都是针对于<code>JavaScript</code>而言，因此确定<code>JavsScript</code>的代码规范是首要任务。</p>\n<blockquote>\n<p>最好的结果就是每个人写得代码都是一样的。</p>\n</blockquote>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>导致团队的代码规范难以指定的一个很大原因就是无法快速开始。</p>\n<p>因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)</p>\n<p>通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。</p>\n<p>对于<code>JavaScript</code>来说，最强力的代码分析检测工具非<code>ESLint</code>莫属，其涵盖了代码质量和编码风格的检测。</p>\n<h3 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p><img src=\"/images/code-guide/eslint.png\"></p>\n<p>ESLint官方有提供一个推荐方案，通过配置文件<code>.eslintrc</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;eslint:recommended&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。</p>\n<p>使用<code>ESlint --init</code>即可开启交互式初始化ESLint配置。</p>\n<p>对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架<code>Vue</code>举例说明：</p>\n<p><code>Vue</code>官方提供了ESLint的插件：<a href=\"https://eslint.vuejs.org/\">eslint-plugin-vue</a></p>\n<p>通过此插件，可以利用ESLint检测<code>.vue</code>文件的<code>&lt;template&gt;</code>和<code>&lt;script&gt;</code>模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;plugin:vue/vue3-recommended&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;rules&quot;</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外，可以在<code>rules</code>里覆盖推荐的规范</p>\n</blockquote>\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx eslint **/*.&#123;js,vue&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMLHint\"><a href=\"#HTMLHint\" class=\"headerlink\" title=\"HTMLHint\"></a>HTMLHint</h3><p><img src=\"/images/code-guide/htmlhint.png\"></p>\n<p>因为<code>HTML</code>不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：<a href=\"https://github.com/htmlhint/HTMLHint/wiki/Rules\">HTMLHint Rules</a></p>\n<p>通过配置文件<code>.htmlhintrc</code>配置，默认配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">&quot;tagname-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-value-double-quotes&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;doctype-first&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;tag-pair&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;spec-char-escape&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;id-unique&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;src-not-empty&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-no-duplication&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;title-require&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx htmlhint **/*.html</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"stylelint\"><a href=\"#stylelint\" class=\"headerlink\" title=\"stylelint\"></a>stylelint</h3><p><img src=\"/images/code-guide/stylelint.png\"></p>\n<p><code>stylelint</code>是<code>CSS</code>的代码分析工具，类似于<code>ESLint</code>，<code>stylelint</code>也提供了 **标准配置(standard configuration)**，安装方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev stylelint stylelint-config-standard</span><br></pre></td></tr></table></figure>\n\n<p>在项目根目录创建配置文件<code>.stylelintrc.json</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;stylelint-config-standard&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx stylelint <span class=\"string\">&quot;**/*.css&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h2><p>如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以<code>GitLab</code>举例：</p>\n<p>每个仓库均可设置多个分支，在<code>GitLab</code>上对关键分支（比如<code>master</code>）的权限做严格把控，比如：</p>\n<ul>\n<li>不允许任何人直接push到关键分支（Allowed to push: No one)</li>\n</ul>\n<p><img src=\"/images/code-guide/protect-branch.png\"></p>\n<ul>\n<li>仅允许通过pipeline的 <strong>合并请求(merge requests)</strong> 进行合并</li>\n</ul>\n<p><img src=\"/images/code-guide/merge-request.png\"></p>\n<p>最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。</p>\n<p>另外，需要切记的是，规范文档的落地不一定需要正式的<code>word</code>格式，<code>markdown</code>、<code>html</code>乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。</p>\n"},{"title":"API Promise化","desc":"小程序如何将异步调用转成Promise调用","_content":"\n## 前言\n\n众所周知，前端一大坑就是回调函数。\n\n相信很多人是从`async/await`的温柔乡，掉到小程序重新写回调的大坑里的。\n\n由于开发者工具新增了 [增强编译](https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html) 从而原生支持了`async\\await`，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 **异步调用** 方式改成 **Promise的方式** 即可。\n\n## 分析与实践\n\n大致上可以有两种思路，第一种就是，逐个函数封装：\n\n```js\nlet promisify = func => args => new Promise((resolve, reject) => {\n    func(Object.assign(args, {\n        success: resolve,\n        fail: reject,\n    }))\n})\n\nlet _login = promisify(wx.login) // 将wx.login转成Promise形式的方法\n\n_login().then(res => console.log)\n```\n\n这种方式比较麻烦，每次调用都需要手动转换。\n\n### 劫持WX\n\n第二种就类似`Page`封装那样，劫持`wx`对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：\n\n- 同步方法是以`Sync`结尾的\n- 通过`typeof`判断是否为函数\n\n```js\n// promisify.js\n\nlet originalWX = wx\nlet props = Object.keys(wx)\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        wx[name] = promisify(fn)\n    }\n}\n```\n\n尝试封装之后，发现报错了。因为`wx.drawCanvas`只有`getter`没有`setter`，无法给它赋值。相当于这个方法是`readonly`。\n\n![](/images/promisify-error1.jpg)\n\n既然存在没有`setter`的方法，那么我看有多少方法是有`setter`的：\n\n```js\nObject.keys(wx).filter(name => {\n    let descriptor = Object.getOwnPropertyDescriptor(wx, name)\n    return typeof descriptor.set === 'function'\n})\n```\n\n结果是`[]`，相当于无法改变`wx`对象的每个属性值。\n\n![](/images/promisify-console1.jpg)\n\n### 复制模式\n\n虽然`wx`的属性都是`readonly`，不能劫持`wx`，但我发现`wx`是`writable`的。\n\n那么可以采用复制模式，将它的所有异步方法拷贝一份并`promisify`之后赋值到新对象，最后再将整个对象赋值给`wx`即可：\n\n```js\nlet props = Object.keys(wx)\nlet jwx = {}\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        jwx[name] = promisify(fn)\n    } else {\n        jwx[name] = fn\n    }\n}\n\nwx = jwx\n```\n\n这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了`promisify`。\n\n### 代理模式\n\n熟悉ES新特性的读者应该知道`Proxy`。\n\n它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上`Proxy`之后，对这个属性的任何行为都可以被代理。\n\n那么我们就可以给`wx`挂上代理：\n\n```js\nlet originalWX = wx\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return promisify(fn)\n        }\n    }\n});\n```\n\n代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。\n\n在实践中，我发现并不是所有同步方法都是以`Sync`结尾的。比如：`wx.getMenuButtonBoundingClientRect`。\n\n因此打算手动维护一个同步方法列表，将这项方法过滤掉：\n\n```js\nlet syncFuncList = ['getMenuButtonBoundingClientRect']\n// name为函数名\nlet isSync = name.endsWith('Sync') || syncFuncList.includes(name)\n```\n\n\n## 优化\n\n考虑到要兼容已上线的小程序，若匆忙替换`wx`，必会导致全局报错，因此可以如下处理：\n\n当用户调用API时，如果传入了`success`、`fail`、`complete`等回调方法的话，则仍继续使用回调的方式继续执行。那么`promisify`可以如下优化：\n\n```js\nlet originalWX = wx\nlet hasCallback = obj => {\n    let cbs = ['success', 'fail', 'complete']\n    return Object.keys(obj).some(k => cbs.includes(k))\n}\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return (obj) => {\n                if (!obj) return fn()\n                if (hasCallback(obj)) return fn(obj)\n                return promisify(fn)(obj)\n            }\n        }\n    }\n});\n```\n\n> 由于本文的前提是开启 **增强编译**，而该模式下也新增支持`Array.prototype.includes`，因此可以放心使用该ES7的新特性。\n\n## 后续\n\n由于发现了微信官方也提供了一个 [API Promise化](https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html) 的工具类库，因此增加了本章节。\n\n通过阅读源代码，发现官方的工具类库提供两个方法：`promisify` 和 `promisifyAll`\n\n其中`promisify`与前文的同名方法是几乎一致的。而`promisifyAll`则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：\n\n```js\nimport { promisifyAll } from 'miniprogram-api-promise';\n\nlet jwx = {}\n\npromisifyAll(wx, jwx)\n\nwx = jwx\n```\n\n另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。\n\n相当于我的做法是黑名单机制，而官方采用了白名单机制。\n\n> 最后再提醒下，开发者工具记得打开 **增强编译**","source":"_posts/mini-program/api-promisify.md","raw":"---\ntitle: API Promise化\ntags: 小程序\ndesc: 小程序如何将异步调用转成Promise调用\n---\n\n## 前言\n\n众所周知，前端一大坑就是回调函数。\n\n相信很多人是从`async/await`的温柔乡，掉到小程序重新写回调的大坑里的。\n\n由于开发者工具新增了 [增强编译](https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html) 从而原生支持了`async\\await`，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 **异步调用** 方式改成 **Promise的方式** 即可。\n\n## 分析与实践\n\n大致上可以有两种思路，第一种就是，逐个函数封装：\n\n```js\nlet promisify = func => args => new Promise((resolve, reject) => {\n    func(Object.assign(args, {\n        success: resolve,\n        fail: reject,\n    }))\n})\n\nlet _login = promisify(wx.login) // 将wx.login转成Promise形式的方法\n\n_login().then(res => console.log)\n```\n\n这种方式比较麻烦，每次调用都需要手动转换。\n\n### 劫持WX\n\n第二种就类似`Page`封装那样，劫持`wx`对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：\n\n- 同步方法是以`Sync`结尾的\n- 通过`typeof`判断是否为函数\n\n```js\n// promisify.js\n\nlet originalWX = wx\nlet props = Object.keys(wx)\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        wx[name] = promisify(fn)\n    }\n}\n```\n\n尝试封装之后，发现报错了。因为`wx.drawCanvas`只有`getter`没有`setter`，无法给它赋值。相当于这个方法是`readonly`。\n\n![](/images/promisify-error1.jpg)\n\n既然存在没有`setter`的方法，那么我看有多少方法是有`setter`的：\n\n```js\nObject.keys(wx).filter(name => {\n    let descriptor = Object.getOwnPropertyDescriptor(wx, name)\n    return typeof descriptor.set === 'function'\n})\n```\n\n结果是`[]`，相当于无法改变`wx`对象的每个属性值。\n\n![](/images/promisify-console1.jpg)\n\n### 复制模式\n\n虽然`wx`的属性都是`readonly`，不能劫持`wx`，但我发现`wx`是`writable`的。\n\n那么可以采用复制模式，将它的所有异步方法拷贝一份并`promisify`之后赋值到新对象，最后再将整个对象赋值给`wx`即可：\n\n```js\nlet props = Object.keys(wx)\nlet jwx = {}\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        jwx[name] = promisify(fn)\n    } else {\n        jwx[name] = fn\n    }\n}\n\nwx = jwx\n```\n\n这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了`promisify`。\n\n### 代理模式\n\n熟悉ES新特性的读者应该知道`Proxy`。\n\n它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上`Proxy`之后，对这个属性的任何行为都可以被代理。\n\n那么我们就可以给`wx`挂上代理：\n\n```js\nlet originalWX = wx\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return promisify(fn)\n        }\n    }\n});\n```\n\n代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。\n\n在实践中，我发现并不是所有同步方法都是以`Sync`结尾的。比如：`wx.getMenuButtonBoundingClientRect`。\n\n因此打算手动维护一个同步方法列表，将这项方法过滤掉：\n\n```js\nlet syncFuncList = ['getMenuButtonBoundingClientRect']\n// name为函数名\nlet isSync = name.endsWith('Sync') || syncFuncList.includes(name)\n```\n\n\n## 优化\n\n考虑到要兼容已上线的小程序，若匆忙替换`wx`，必会导致全局报错，因此可以如下处理：\n\n当用户调用API时，如果传入了`success`、`fail`、`complete`等回调方法的话，则仍继续使用回调的方式继续执行。那么`promisify`可以如下优化：\n\n```js\nlet originalWX = wx\nlet hasCallback = obj => {\n    let cbs = ['success', 'fail', 'complete']\n    return Object.keys(obj).some(k => cbs.includes(k))\n}\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return (obj) => {\n                if (!obj) return fn()\n                if (hasCallback(obj)) return fn(obj)\n                return promisify(fn)(obj)\n            }\n        }\n    }\n});\n```\n\n> 由于本文的前提是开启 **增强编译**，而该模式下也新增支持`Array.prototype.includes`，因此可以放心使用该ES7的新特性。\n\n## 后续\n\n由于发现了微信官方也提供了一个 [API Promise化](https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html) 的工具类库，因此增加了本章节。\n\n通过阅读源代码，发现官方的工具类库提供两个方法：`promisify` 和 `promisifyAll`\n\n其中`promisify`与前文的同名方法是几乎一致的。而`promisifyAll`则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：\n\n```js\nimport { promisifyAll } from 'miniprogram-api-promise';\n\nlet jwx = {}\n\npromisifyAll(wx, jwx)\n\nwx = jwx\n```\n\n另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。\n\n相当于我的做法是黑名单机制，而官方采用了白名单机制。\n\n> 最后再提醒下，开发者工具记得打开 **增强编译**","slug":"mini-program/api-promisify","published":1,"date":"2020-05-23T06:36:46.000Z","updated":"2020-05-23T06:36:46.000Z","_id":"ckxvfmfym003sbrqq21as5gbb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>众所周知，前端一大坑就是回调函数。</p>\n<p>相信很多人是从<code>async/await</code>的温柔乡，掉到小程序重新写回调的大坑里的。</p>\n<p>由于开发者工具新增了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html\">增强编译</a> 从而原生支持了<code>async\\await</code>，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 <strong>异步调用</strong> 方式改成 <strong>Promise的方式</strong> 即可。</p>\n<h2 id=\"分析与实践\"><a href=\"#分析与实践\" class=\"headerlink\" title=\"分析与实践\"></a>分析与实践</h2><p>大致上可以有两种思路，第一种就是，逐个函数封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promisify = <span class=\"function\"><span class=\"params\">func</span> =&gt;</span> <span class=\"function\"><span class=\"params\">args</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    func(<span class=\"built_in\">Object</span>.assign(args, &#123;</span><br><span class=\"line\">        <span class=\"attr\">success</span>: resolve,</span><br><span class=\"line\">        <span class=\"attr\">fail</span>: reject,</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _login = promisify(wx.login) <span class=\"comment\">// 将wx.login转成Promise形式的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">_login().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n<p>这种方式比较麻烦，每次调用都需要手动转换。</p>\n<h3 id=\"劫持WX\"><a href=\"#劫持WX\" class=\"headerlink\" title=\"劫持WX\"></a>劫持WX</h3><p>第二种就类似<code>Page</code>封装那样，劫持<code>wx</code>对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：</p>\n<ul>\n<li>同步方法是以<code>Sync</code>结尾的</li>\n<li>通过<code>typeof</code>判断是否为函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promisify.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        wx[name] = promisify(fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试封装之后，发现报错了。因为<code>wx.drawCanvas</code>只有<code>getter</code>没有<code>setter</code>，无法给它赋值。相当于这个方法是<code>readonly</code>。</p>\n<p><img src=\"/images/promisify-error1.jpg\"></p>\n<p>既然存在没有<code>setter</code>的方法，那么我看有多少方法是有<code>setter</code>的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(wx).filter(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(wx, name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> descriptor.set === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>结果是<code>[]</code>，相当于无法改变<code>wx</code>对象的每个属性值。</p>\n<p><img src=\"/images/promisify-console1.jpg\"></p>\n<h3 id=\"复制模式\"><a href=\"#复制模式\" class=\"headerlink\" title=\"复制模式\"></a>复制模式</h3><p>虽然<code>wx</code>的属性都是<code>readonly</code>，不能劫持<code>wx</code>，但我发现<code>wx</code>是<code>writable</code>的。</p>\n<p>那么可以采用复制模式，将它的所有异步方法拷贝一份并<code>promisify</code>之后赋值到新对象，最后再将整个对象赋值给<code>wx</code>即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        jwx[name] = promisify(fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        jwx[name] = fn</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了<code>promisify</code>。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>熟悉ES新特性的读者应该知道<code>Proxy</code>。</p>\n<p>它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上<code>Proxy</code>之后，对这个属性的任何行为都可以被代理。</p>\n<p>那么我们就可以给<code>wx</code>挂上代理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> promisify(fn)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。</p>\n<p>在实践中，我发现并不是所有同步方法都是以<code>Sync</code>结尾的。比如：<code>wx.getMenuButtonBoundingClientRect</code>。</p>\n<p>因此打算手动维护一个同步方法列表，将这项方法过滤掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> syncFuncList = [<span class=\"string\">&#x27;getMenuButtonBoundingClientRect&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// name为函数名</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isSync = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) || syncFuncList.includes(name)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>考虑到要兼容已上线的小程序，若匆忙替换<code>wx</code>，必会导致全局报错，因此可以如下处理：</p>\n<p>当用户调用API时，如果传入了<code>success</code>、<code>fail</code>、<code>complete</code>等回调方法的话，则仍继续使用回调的方式继续执行。那么<code>promisify</code>可以如下优化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> hasCallback = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cbs = [<span class=\"string\">&#x27;success&#x27;</span>, <span class=\"string\">&#x27;fail&#x27;</span>, <span class=\"string\">&#x27;complete&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(obj).some(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> cbs.includes(k))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span> fn()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasCallback(obj)) <span class=\"keyword\">return</span> fn(obj)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> promisify(fn)(obj)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于本文的前提是开启 <strong>增强编译</strong>，而该模式下也新增支持<code>Array.prototype.includes</code>，因此可以放心使用该ES7的新特性。</p>\n</blockquote>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>由于发现了微信官方也提供了一个 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html\">API Promise化</a> 的工具类库，因此增加了本章节。</p>\n<p>通过阅读源代码，发现官方的工具类库提供两个方法：<code>promisify</code> 和 <code>promisifyAll</code></p>\n<p>其中<code>promisify</code>与前文的同名方法是几乎一致的。而<code>promisifyAll</code>则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; promisifyAll &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;miniprogram-api-promise&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promisifyAll(wx, jwx)</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。</p>\n<p>相当于我的做法是黑名单机制，而官方采用了白名单机制。</p>\n<blockquote>\n<p>最后再提醒下，开发者工具记得打开 <strong>增强编译</strong></p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>众所周知，前端一大坑就是回调函数。</p>\n<p>相信很多人是从<code>async/await</code>的温柔乡，掉到小程序重新写回调的大坑里的。</p>\n<p>由于开发者工具新增了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html\">增强编译</a> 从而原生支持了<code>async\\await</code>，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 <strong>异步调用</strong> 方式改成 <strong>Promise的方式</strong> 即可。</p>\n<h2 id=\"分析与实践\"><a href=\"#分析与实践\" class=\"headerlink\" title=\"分析与实践\"></a>分析与实践</h2><p>大致上可以有两种思路，第一种就是，逐个函数封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promisify = <span class=\"function\"><span class=\"params\">func</span> =&gt;</span> <span class=\"function\"><span class=\"params\">args</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    func(<span class=\"built_in\">Object</span>.assign(args, &#123;</span><br><span class=\"line\">        <span class=\"attr\">success</span>: resolve,</span><br><span class=\"line\">        <span class=\"attr\">fail</span>: reject,</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _login = promisify(wx.login) <span class=\"comment\">// 将wx.login转成Promise形式的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">_login().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n<p>这种方式比较麻烦，每次调用都需要手动转换。</p>\n<h3 id=\"劫持WX\"><a href=\"#劫持WX\" class=\"headerlink\" title=\"劫持WX\"></a>劫持WX</h3><p>第二种就类似<code>Page</code>封装那样，劫持<code>wx</code>对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：</p>\n<ul>\n<li>同步方法是以<code>Sync</code>结尾的</li>\n<li>通过<code>typeof</code>判断是否为函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promisify.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        wx[name] = promisify(fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试封装之后，发现报错了。因为<code>wx.drawCanvas</code>只有<code>getter</code>没有<code>setter</code>，无法给它赋值。相当于这个方法是<code>readonly</code>。</p>\n<p><img src=\"/images/promisify-error1.jpg\"></p>\n<p>既然存在没有<code>setter</code>的方法，那么我看有多少方法是有<code>setter</code>的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(wx).filter(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(wx, name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> descriptor.set === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>结果是<code>[]</code>，相当于无法改变<code>wx</code>对象的每个属性值。</p>\n<p><img src=\"/images/promisify-console1.jpg\"></p>\n<h3 id=\"复制模式\"><a href=\"#复制模式\" class=\"headerlink\" title=\"复制模式\"></a>复制模式</h3><p>虽然<code>wx</code>的属性都是<code>readonly</code>，不能劫持<code>wx</code>，但我发现<code>wx</code>是<code>writable</code>的。</p>\n<p>那么可以采用复制模式，将它的所有异步方法拷贝一份并<code>promisify</code>之后赋值到新对象，最后再将整个对象赋值给<code>wx</code>即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        jwx[name] = promisify(fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        jwx[name] = fn</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了<code>promisify</code>。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>熟悉ES新特性的读者应该知道<code>Proxy</code>。</p>\n<p>它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上<code>Proxy</code>之后，对这个属性的任何行为都可以被代理。</p>\n<p>那么我们就可以给<code>wx</code>挂上代理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> promisify(fn)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。</p>\n<p>在实践中，我发现并不是所有同步方法都是以<code>Sync</code>结尾的。比如：<code>wx.getMenuButtonBoundingClientRect</code>。</p>\n<p>因此打算手动维护一个同步方法列表，将这项方法过滤掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> syncFuncList = [<span class=\"string\">&#x27;getMenuButtonBoundingClientRect&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// name为函数名</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isSync = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) || syncFuncList.includes(name)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>考虑到要兼容已上线的小程序，若匆忙替换<code>wx</code>，必会导致全局报错，因此可以如下处理：</p>\n<p>当用户调用API时，如果传入了<code>success</code>、<code>fail</code>、<code>complete</code>等回调方法的话，则仍继续使用回调的方式继续执行。那么<code>promisify</code>可以如下优化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> hasCallback = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cbs = [<span class=\"string\">&#x27;success&#x27;</span>, <span class=\"string\">&#x27;fail&#x27;</span>, <span class=\"string\">&#x27;complete&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(obj).some(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> cbs.includes(k))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span> fn()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasCallback(obj)) <span class=\"keyword\">return</span> fn(obj)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> promisify(fn)(obj)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于本文的前提是开启 <strong>增强编译</strong>，而该模式下也新增支持<code>Array.prototype.includes</code>，因此可以放心使用该ES7的新特性。</p>\n</blockquote>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>由于发现了微信官方也提供了一个 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html\">API Promise化</a> 的工具类库，因此增加了本章节。</p>\n<p>通过阅读源代码，发现官方的工具类库提供两个方法：<code>promisify</code> 和 <code>promisifyAll</code></p>\n<p>其中<code>promisify</code>与前文的同名方法是几乎一致的。而<code>promisifyAll</code>则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; promisifyAll &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;miniprogram-api-promise&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promisifyAll(wx, jwx)</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。</p>\n<p>相当于我的做法是黑名单机制，而官方采用了白名单机制。</p>\n<blockquote>\n<p>最后再提醒下，开发者工具记得打开 <strong>增强编译</strong></p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckxvfmf9u0001brqqc6ui9l7c","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmf9z0003brqq90an74pc"},{"post_id":"ckxvfmfb80004brqq4tlofoza","tag_id":"ckxvfmfba0006brqqcyo843ev","_id":"ckxvfmfbe000bbrqqf85tghfa"},{"post_id":"ckxvfmfb80005brqqgmjf2hb3","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"ckxvfmfc7000jbrqq8f0o0xqk"},{"post_id":"ckxvfmfb80005brqqgmjf2hb3","tag_id":"ckxvfmfbn000ebrqqfz4e8dck","_id":"ckxvfmfc9000lbrqq2pxu5rqq"},{"post_id":"ckxvfmfba0007brqqaulmgg5k","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"ckxvfmfcb000obrqqeiokdck1"},{"post_id":"ckxvfmfcb000pbrqq0z3ucsyg","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfcf000sbrqqhrswf33s"},{"post_id":"ckxvfmfbb0008brqqfaskh4yo","tag_id":"ckxvfmfc9000mbrqq8ukh22ll","_id":"ckxvfmfcj000wbrqq3mswh539"},{"post_id":"ckxvfmfbb0008brqqfaskh4yo","tag_id":"ckxvfmfcd000qbrqqhrgg4skw","_id":"ckxvfmfck000ybrqq60dqhpyb"},{"post_id":"ckxvfmfbc0009brqq351q2ux1","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfco0012brqq3eotao04"},{"post_id":"ckxvfmfbc0009brqq351q2ux1","tag_id":"ckxvfmfci000vbrqqb3hs8frk","_id":"ckxvfmfcs0014brqq24cue03a"},{"post_id":"ckxvfmfbe000cbrqq06fa8psr","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfcw001abrqq1lbnd27b"},{"post_id":"ckxvfmfbe000cbrqq06fa8psr","tag_id":"ckxvfmfcs0015brqq196f43oh","_id":"ckxvfmfd1001cbrqqbamof480"},{"post_id":"ckxvfmfbm000dbrqq4squfpbu","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfdc001ibrqq3u8u9000"},{"post_id":"ckxvfmfbm000dbrqq4squfpbu","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"ckxvfmfdd001kbrqqfyc4bmh7"},{"post_id":"ckxvfmfdj001nbrqq96cpbrnr","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"ckxvfmfdn001qbrqqgf309a66"},{"post_id":"ckxvfmfbv000fbrqq45hw9rv6","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfdo001rbrqq4y3w8hzo"},{"post_id":"ckxvfmfbv000fbrqq45hw9rv6","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"ckxvfmfdp001tbrqq0fe9fq37"},{"post_id":"ckxvfmfbz000gbrqq00054wui","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfdr001vbrqqf33c6dk0"},{"post_id":"ckxvfmfbz000gbrqq00054wui","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"ckxvfmfdr001wbrqq4qfhf7g4"},{"post_id":"ckxvfmfc6000ibrqqgrii3169","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfdt001zbrqqbvx417w7"},{"post_id":"ckxvfmfc6000ibrqqgrii3169","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"ckxvfmfdt0020brqq8hj4czt9"},{"post_id":"ckxvfmfc8000kbrqqddkn36p5","tag_id":"ckxvfmfds001ybrqq8ddj3zw1","_id":"ckxvfmfdv0022brqq30ct78aq"},{"post_id":"ckxvfmfca000nbrqqbu34c358","tag_id":"ckxvfmfdu0021brqq5lih8xby","_id":"ckxvfmfdx0024brqqbc5rckpk"},{"post_id":"ckxvfmfce000rbrqqd3ui3zpt","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfdy0027brqqfrx88ejw"},{"post_id":"ckxvfmfce000rbrqqd3ui3zpt","tag_id":"ckxvfmfdx0025brqqfknuh8q4","_id":"ckxvfmfdy0028brqq0v93fab2"},{"post_id":"ckxvfmfcf000tbrqqh4j62d07","tag_id":"ckxvfmfdy0026brqqbm46500t","_id":"ckxvfmfdz002abrqq81lkemhp"},{"post_id":"ckxvfmfcg000ubrqqdgcc86lp","tag_id":"ckxvfmfdy0029brqq071c7idn","_id":"ckxvfmfdz002cbrqqh6ei0s28"},{"post_id":"ckxvfmfcj000xbrqq10lwerlk","tag_id":"ckxvfmfdz002bbrqq1m2ugzy5","_id":"ckxvfmfe0002fbrqqb2yifuej"},{"post_id":"ckxvfmfcj000xbrqq10lwerlk","tag_id":"ckxvfmfe0002dbrqqa69xb0v5","_id":"ckxvfmfe0002gbrqq3ix2hqxi"},{"post_id":"ckxvfmfck000zbrqqg6j9457e","tag_id":"ckxvfmfe0002ebrqq2jge0ocw","_id":"ckxvfmfe1002ibrqqargfe9gh"},{"post_id":"ckxvfmfcn0011brqqfgwtbnl0","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfe2002kbrqq722i7u2p"},{"post_id":"ckxvfmfcn0011brqqfgwtbnl0","tag_id":"ckxvfmfe1002hbrqq77rrfbt6","_id":"ckxvfmfe2002lbrqq7w1j5etx"},{"post_id":"ckxvfmfcs0016brqq1fig8rui","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfe2002nbrqq559chxou"},{"post_id":"ckxvfmfcs0016brqq1fig8rui","tag_id":"ckxvfmfe1002jbrqqcqvsftac","_id":"ckxvfmfe2002obrqq8pi58ugs"},{"post_id":"ckxvfmfcu0019brqq7iygg312","tag_id":"ckxvfmfe2002mbrqqae966syr","_id":"ckxvfmfe5002qbrqqb07i2s8j"},{"post_id":"ckxvfmfd0001bbrqqbo8mbgqt","tag_id":"ckxvfmfdy0026brqqbm46500t","_id":"ckxvfmfe6002tbrqq59g18hga"},{"post_id":"ckxvfmfd0001bbrqqbo8mbgqt","tag_id":"ckxvfmfe5002rbrqqa8vlh53b","_id":"ckxvfmfe7002ubrqqfisubecl"},{"post_id":"ckxvfmfd3001ebrqqb3f43pj5","tag_id":"ckxvfmfe5002sbrqqc0j2b7e5","_id":"ckxvfmfe7002wbrqq5tjr9gs7"},{"post_id":"ckxvfmfd4001fbrqq9i5r6i6p","tag_id":"ckxvfmfe7002vbrqq5jkqdvtc","_id":"ckxvfmfe8002ybrqq2cam924g"},{"post_id":"ckxvfmfd5001gbrqq6t7q7ca3","tag_id":"ckxvfmfe7002xbrqqbyzm218y","_id":"ckxvfmfe80030brqqcfpa6zx0"},{"post_id":"ckxvfmfde001lbrqqg2qv6ym0","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"ckxvfmfeb0032brqq503t092m"},{"post_id":"ckxvfmfde001lbrqqg2qv6ym0","tag_id":"ckxvfmfe8002zbrqq7lr8154x","_id":"ckxvfmfeb0033brqq7k2h0u18"},{"post_id":"ckxvfmfdl001obrqq049pap06","tag_id":"ckxvfmfds001ybrqq8ddj3zw1","_id":"ckxvfmfeb0034brqqcq4q9wr2"},{"post_id":"ckxvfmfeh0035brqqc2frc291","tag_id":"ckxvfmfds001ybrqq8ddj3zw1","_id":"ckxvfmfek0037brqq6sh43b5b"},{"post_id":"ckxvfmfej0036brqq1bfld27k","tag_id":"ckxvfmfds001ybrqq8ddj3zw1","_id":"ckxvfmfel0038brqqf38d52yc"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfeo003cbrqq8cs494xq"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","tag_id":"ckxvfmfen003abrqqbrtedjdk","_id":"ckxvfmfeo003dbrqq7fzwf8q1"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","tag_id":"ckxvfmfen003bbrqq2bux9p36","_id":"ckxvfmfeo003ebrqq3sx7dfm2"},{"post_id":"ckxvfmfyd003fbrqqf6e3351w","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfyf003gbrqq70jkbyq5"},{"post_id":"ckxvfmfyf003hbrqqgevj3p7y","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfyh003jbrqq6szk3efi"},{"post_id":"ckxvfmfyg003ibrqqabwped0e","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfyi003lbrqq01qdc44z"},{"post_id":"ckxvfmfyh003kbrqq3h9c6n6f","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfyj003nbrqq7ofq1940"},{"post_id":"ckxvfmfyi003mbrqq0q58fvkr","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfyl003pbrqq3fsg84p6"},{"post_id":"ckxvfmfyj003obrqq59ph5r54","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfym003rbrqq4e6qhnpm"},{"post_id":"ckxvfmfym003sbrqq21as5gbb","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"ckxvfmfyn003ubrqq1jyef9kr"},{"post_id":"ckxvfmfyl003qbrqq1klxb6zg","tag_id":"ckxvfmfyn003tbrqqhuwo47s8","_id":"ckxvfmfyo003vbrqqfoww831t"}],"Tag":[{"name":"小程序","_id":"ckxvfmf9y0002brqqdzaza9jd"},{"name":"cookie","_id":"ckxvfmfba0006brqqcyo843ev"},{"name":"CSS","_id":"ckxvfmfbd000abrqq1qdj7wxd"},{"name":"BFC","_id":"ckxvfmfbn000ebrqqfz4e8dck"},{"name":"网络安全","_id":"ckxvfmfc9000mbrqq8ukh22ll"},{"name":"HTTP","_id":"ckxvfmfcd000qbrqqhrgg4skw"},{"name":"Session","_id":"ckxvfmfci000vbrqqb3hs8frk"},{"name":"JavaScript","_id":"ckxvfmfcl0010brqq3g9z1fxj"},{"name":"Storage","_id":"ckxvfmfcs0015brqq196f43oh"},{"name":"underscore.js","_id":"ckxvfmfd1001dbrqqggwadqsr"},{"name":"vue.js","_id":"ckxvfmfds001ybrqq8ddj3zw1"},{"name":"promise 宏任务 微任务","_id":"ckxvfmfdu0021brqq5lih8xby"},{"name":"事件","_id":"ckxvfmfdx0025brqqfknuh8q4"},{"name":"Node.js","_id":"ckxvfmfdy0026brqqbm46500t"},{"name":"MongoDB","_id":"ckxvfmfdy0029brqq071c7idn"},{"name":"ES6","_id":"ckxvfmfdz002bbrqq1m2ugzy5"},{"name":"模块化","_id":"ckxvfmfe0002dbrqqa69xb0v5"},{"name":"键盘","_id":"ckxvfmfe0002ebrqq2jge0ocw"},{"name":"Array","_id":"ckxvfmfe1002hbrqq77rrfbt6"},{"name":"闭包","_id":"ckxvfmfe1002jbrqqcqvsftac"},{"name":"HTML","_id":"ckxvfmfe2002mbrqqae966syr"},{"name":"Buffers","_id":"ckxvfmfe5002rbrqqa8vlh53b"},{"name":"History API","_id":"ckxvfmfe5002sbrqqc0j2b7e5"},{"name":"gulp","_id":"ckxvfmfe7002vbrqq5jkqdvtc"},{"name":"路由","_id":"ckxvfmfe7002xbrqqbyzm218y"},{"name":"盒模型","_id":"ckxvfmfe8002zbrqq7lr8154x"},{"name":"内存管理","_id":"ckxvfmfen003abrqqbrtedjdk"},{"name":"垃圾回收","_id":"ckxvfmfen003bbrqq2bux9p36"},{"name":"编码规范","_id":"ckxvfmfyn003tbrqqhuwo47s8"}]}}