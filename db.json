{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/subscribe/WechatIMG198.jpg","path":"images/subscribe/WechatIMG198.jpg","modified":0,"renderable":0},{"_id":"source/images/subscribe/WechatIMG199.jpg","path":"images/subscribe/WechatIMG199.jpg","modified":0,"renderable":0},{"_id":"source/images/subscribe/request-subscribe-message.jpg","path":"images/subscribe/request-subscribe-message.jpg","modified":0,"renderable":0},{"_id":"source/images/update/least-version-config.c2b188c7.png","path":"images/update/least-version-config.c2b188c7.png","modified":0,"renderable":0},{"_id":"source/images/update/least-version-tips.d8a1b4d4.jpg","path":"images/update/least-version-tips.d8a1b4d4.jpg","modified":0,"renderable":0},{"_id":"source/images/update/mock-update.jpg","path":"images/update/mock-update.jpg","modified":0,"renderable":0},{"_id":"source/images/update/update-logic.jpg","path":"images/update/update-logic.jpg","modified":0,"renderable":0},{"_id":"source/images/update/work-flow.png","path":"images/update/work-flow.png","modified":0,"renderable":0},{"_id":"source/images/custom-navigator/full-screen.jpeg","path":"images/custom-navigator/full-screen.jpeg","modified":0,"renderable":0},{"_id":"source/images/custom-navigator/interface.jpg","path":"images/custom-navigator/interface.jpg","modified":0,"renderable":0},{"_id":"source/images/custom-navigator/navigator.jpg","path":"images/custom-navigator/navigator.jpg","modified":0,"renderable":0},{"_id":"source/images/code-guide/eslint.png","path":"images/code-guide/eslint.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/eslint.svg","path":"images/code-guide/eslint.svg","modified":0,"renderable":0},{"_id":"source/images/code-guide/htmlhint.png","path":"images/code-guide/htmlhint.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/merge-request.png","path":"images/code-guide/merge-request.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/protect-branch.png","path":"images/code-guide/protect-branch.png","modified":0,"renderable":0},{"_id":"source/images/code-guide/stylelint.png","path":"images/code-guide/stylelint.png","modified":0,"renderable":0},{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/qrcode.png","path":"images/qrcode.png","modified":0,"renderable":0},{"_id":"source/images/global-window.png","path":"images/global-window.png","modified":0,"renderable":0},{"_id":"source/images/promisify-error1.jpg","path":"images/promisify-error1.jpg","modified":0,"renderable":0},{"_id":"source/images/promisify-console1.jpg","path":"images/promisify-console1.jpg","modified":0,"renderable":0},{"_id":"source/images/global-global.png","path":"images/global-global.png","modified":0,"renderable":0},{"_id":"source/images/compatibility-proxy.jpg","path":"images/compatibility-proxy.jpg","modified":0,"renderable":0},{"_id":"source/images/compatibility-symbol.jpg","path":"images/compatibility-symbol.jpg","modified":0,"renderable":0},{"_id":"source/images/compare.jpg","path":"images/compare.jpg","modified":0,"renderable":0},{"_id":"source/images/qrcode/wallpaper.jpg","path":"images/qrcode/wallpaper.jpg","modified":0,"renderable":0},{"_id":"source/images/qrcode/weather.jpg","path":"images/qrcode/weather.jpg","modified":0,"renderable":0},{"_id":"source/images/components/vuex.png","path":"images/components/vuex.png","modified":0,"renderable":0},{"_id":"source/images/components/miniprogram-lifecycle.png","path":"images/components/miniprogram-lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/components/lifecycle.png","path":"images/components/lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/components/components-graph.png","path":"images/components/components-graph.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/images/miniprogram/css-cascade.png","path":"images/miniprogram/css-cascade.png","modified":0,"renderable":0},{"_id":"source/images/miniprogram/eventflow.svg","path":"images/miniprogram/eventflow.svg","modified":0,"renderable":0},{"_id":"source/images/miniprogram/user-agent.png","path":"images/miniprogram/user-agent.png","modified":0,"renderable":0},{"_id":"source/images/ui-library/css-layer.png","path":"images/ui-library/css-layer.png","modified":0,"renderable":0},{"_id":"source/images/ui-library/foundation-adapter.png","path":"images/ui-library/foundation-adapter.png","modified":0,"renderable":0},{"_id":"source/images/ui-library/select.webp","path":"images/ui-library/select.webp","modified":0,"renderable":0},{"_id":"source/images/ui-library/select-tdesign.webp","path":"images/ui-library/select-tdesign.webp","modified":0,"renderable":0},{"_id":"source/images/ui-library/cross-frame.png","path":"images/ui-library/cross-frame.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/github-comment-2.png","path":"images/mp-github-action/github-comment-2.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/github-comment-3.png","path":"images/mp-github-action/github-comment-3.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/github-secrets.png","path":"images/mp-github-action/github-secrets.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/github-workflows.png","path":"images/mp-github-action/github-workflows.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/tdesign-web-preview.png","path":"images/mp-github-action/tdesign-web-preview.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/github-comment-1.png","path":"images/mp-github-action/github-comment-1.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/dev-flow.png","path":"images/mp-github-action/dev-flow.png","modified":0,"renderable":0},{"_id":"source/images/mp-github-action/miniprogram-version.png","path":"images/mp-github-action/miniprogram-version.png","modified":1,"renderable":0},{"_id":"source/images/vue3/vue-core-modules.png","path":"images/vue3/vue-core-modules.png","modified":1,"renderable":0},{"_id":"source/images/vue3/tree-data-flow.png","path":"images/vue3/tree-data-flow.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0.png","path":"images/miniprogram/0.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/realtime-log.jpg","path":"images/miniprogram/realtime-log.jpg","modified":1,"renderable":0},{"_id":"source/images/miniprogram/caniuse-proxy.png","path":"images/miniprogram/caniuse-proxy.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-1.png","path":"images/miniprogram/0-1.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-2.png","path":"images/miniprogram/0-2.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-3.png","path":"images/miniprogram/0-3.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-4.png","path":"images/miniprogram/0-4.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-5.png","path":"images/miniprogram/0-5.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-6.png","path":"images/miniprogram/0-6.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-7.png","path":"images/miniprogram/0-7.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-8.png","path":"images/miniprogram/0-8.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/0-9.png","path":"images/miniprogram/0-9.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/router/路由权限控制.png","path":"images/miniprogram/router/路由权限控制.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/router/demo1.png","path":"images/miniprogram/router/demo1.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/router/demo2.png","path":"images/miniprogram/router/demo2.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/router/demo3.png","path":"images/miniprogram/router/demo3.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/router/demo4.png","path":"images/miniprogram/router/demo4.png","modified":1,"renderable":0},{"_id":"source/images/miniprogram/router/router-methods.png","path":"images/miniprogram/router/router-methods.png","modified":1,"renderable":0},{"_id":"source/images/responsive-web/screen-width.png","path":"images/responsive-web/screen-width.png","modified":1,"renderable":0},{"_id":"source/images/responsive-web/viewport-width.png","path":"images/responsive-web/viewport-width.png","modified":1,"renderable":0},{"_id":"source/images/responsive-web/vw-compatibility.png","path":"images/responsive-web/vw-compatibility.png","modified":1,"renderable":0},{"_id":"source/images/responsive-web/window-width.png","path":"images/responsive-web/window-width.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1641017497024},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586452},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586484},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586549},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586578},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586599},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017585735},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586132},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586253},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586359},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641017586421},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1641017587609},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1641017586617},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1641017587613},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"eeefa2a465ff37e08499efb1d4f1c72517e5d103","modified":1641017587204},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1641017586679},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1641017586755},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1641017586789},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1641017587791},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1641017587793},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1641017587795},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1641017587798},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1641017587798},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1641017587804},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1641017587803},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1641017587804},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1641017587806},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1641017587808},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1641017587811},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1641017587813},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1641017587816},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1641017587818},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1641017587819},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1641017587374},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1641017587339},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1641017587481},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1641017587499},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1641017587503},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1641017587580},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1641017587587},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1641017587599},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1641017586771},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1641017587600},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1641017586764},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1641017586969},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1641017586800},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1641017587161},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1641017587680},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1641017587685},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1641017587689},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1641017587691},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1641017587697},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1641017587718},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1641017587717},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1641017587718},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1641017587720},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1641017587721},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1641017587723},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1641017587727},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1641017587728},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1641017587730},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1641017587734},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1641017586718},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"e2765287c6bc6eb97975a1bb4e325b046e95b392","modified":1641017587353},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1641017587485},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1641017587487},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1641017587491},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1641017587497},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1641017587573},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1641017587585},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1641017587592},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1641017587594},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1641017587597},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"251263b97de12f2b8d1fce2514e83430f2515b94","modified":1641017587603},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1641017587308},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1641017587370},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1641017587591},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1641017587710},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1641017587715},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1641017587730},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1641017587652},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1641017587735},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1641017587774},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1641017587778},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1641017587677},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1641017587782},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1641017586627},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1641017586631},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1641017586638},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1641017587102},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1641017586781},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1641017587143},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1641017587169},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1641017587183},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1641017587198},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1641017587203},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1641017587212},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1641017587231},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1641017587233},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1641017587263},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1641017587269},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1641017587276},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1641017587033},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1641017587136},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1641017587217},{"_id":"source/projects/index.md","hash":"16e838fea8ad5b10548e0214222baf1b881aaa58","modified":1690877991104},{"_id":"source/images/update/least-version-tips.d8a1b4d4.jpg","hash":"a782cd41abb91496e13706f7a7db4ce624455f03","modified":1585490501000},{"_id":"source/images/update/update-logic.jpg","hash":"70d151e85ae0679408fa39e6f2bf94433947cd6b","modified":1588952467000},{"_id":"source/images/update/work-flow.png","hash":"1b2e729bfadf4f08cf83fb592b1b2bb042c5295e","modified":1587999305000},{"_id":"source/images/subscribe/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1589614274000},{"_id":"source/images/subscribe/WechatIMG198.jpg","hash":"c000f7794a8789579e16d68a716b213c4ee1cba7","modified":1589614404000},{"_id":"source/images/subscribe/request-subscribe-message.jpg","hash":"b3271488a580dbce98a3bcfac111610ccfe821ae","modified":1589614707000},{"_id":"source/images/subscribe/WechatIMG199.jpg","hash":"981ae8012bf1648d9174f61b74d99e4946122590","modified":1589614310000},{"_id":"source/images/update/least-version-config.c2b188c7.png","hash":"a1ff51d63b4abfcefc659b685c32f859dbaf7890","modified":1585490486000},{"_id":"source/images/update/mock-update.jpg","hash":"7138fad05e68518c6ad395fe7f98c43c8d7a6a39","modified":1588950948000},{"_id":"source/images/compare.jpg","hash":"e726bb3dbeda342f8a64d3452e702c16a3d18e16","modified":1585475421000},{"_id":"source/images/global-global.png","hash":"85b94a1df6b3621067f5d6b28f550e04f7b96611","modified":1585575779000},{"_id":"source/images/promisify-console1.jpg","hash":"1b58397722b57e3bb4c96afbaca37ac7c4a0891a","modified":1585470367000},{"_id":"source/images/global-window.png","hash":"2b653f4236257e9c71668b59ed5d146efaf3525f","modified":1585575779000},{"_id":"source/images/promisify-error1.jpg","hash":"508698512945cd806429e8997cc950021a59a32e","modified":1585468844000},{"_id":"source/images/.DS_Store","hash":"80e4a3272117e4d05b3b75e0ffa76a78d6f1e543","modified":1691149760697},{"_id":"source/images/compatibility-symbol.jpg","hash":"45b033a76470731c16fec881e42ea54d310f63f4","modified":1585750906000},{"_id":"source/images/qrcode.png","hash":"0d7e51470337e44db91f9b0f6f7f02418104e229","modified":1585403103000},{"_id":"source/images/compatibility-proxy.jpg","hash":"fb4df64fc6be08b321b8677ab5f932e31bd34246","modified":1585750866000},{"_id":"source/images/custom-navigator/full-screen.jpeg","hash":"247b54a31fab005f31680808a7beae3c236bdbf1","modified":1588774602000},{"_id":"source/images/custom-navigator/navigator.jpg","hash":"6d91b3c9ec53e8d07c713a38ed9e65b0f446a02c","modified":1588777688000},{"_id":"source/images/custom-navigator/interface.jpg","hash":"9397a1ab3af50c5c8229ea2355e307b796fdcf21","modified":1588261085000},{"_id":"source/images/code-guide/eslint.png","hash":"0c39ed32c2895715d25ed1115b23e97dedc69fc2","modified":1588085168000},{"_id":"source/images/code-guide/eslint.svg","hash":"204482ca413433c80cd14fe369e2181dd97a2a40","modified":1588085073000},{"_id":"source/images/code-guide/htmlhint.png","hash":"85a5fbc53e53d6414bef948c5a0eb17529a7e3d2","modified":1588085228000},{"_id":"source/images/code-guide/merge-request.png","hash":"aac6b6747a65c362018441d58a0eb4709bc70b2f","modified":1586672835000},{"_id":"source/images/code-guide/protect-branch.png","hash":"fb4acac70517280f545cf8397ec24eb747ccd4f8","modified":1586672771000},{"_id":"source/images/code-guide/stylelint.png","hash":"0f4d319e4c5e20284d59dc420ca96e6b55ddd92c","modified":1588085210000},{"_id":"source/_posts/mini-program/update.md","hash":"3cf5123df8725fa17d1ed9c7aeae7ea0698080ea","modified":1641622493476},{"_id":"source/_data/projects.json","hash":"1675d653e65ed3863b18dfcc47711873710f18ef","modified":1512728601000},{"_id":"source/.DS_Store","hash":"18c56056f2cfd7de1c9dcf8851855709d3eec630","modified":1691147319740},{"_id":"source/_posts/.DS_Store","hash":"4fb061a3bc286069f198f429aa37d5069f348bbd","modified":1610866397000},{"_id":"source/favicon.png","hash":"267cfd461bbe03e88577f6e4c96b41d743aeadc4","modified":1590216278000},{"_id":"source/CNAME","hash":"71a4f395b9bbb9c0f326b3b124d584ea9e26010e","modified":1590217976000},{"_id":"source/_posts/about-deploly-favweb-2.md","hash":"d9bfb29d9aa751e64bdfa8480a3063dd85bc22cb","modified":1641630796797},{"_id":"source/_posts/about-deploly-favweb-3.md","hash":"e87521af2c9dff14239ae24ada70dcd479f33f7e","modified":1641630800579},{"_id":"source/_posts/about-deploly-favweb-1.md","hash":"1cf2749166c6484150aae3744911330b6a4c7a51","modified":1641630793796},{"_id":"source/_posts/JavaScript-detect.md","hash":"7b081c37b4817792e1c1d32df32f15bbf425c310","modified":1590214023000},{"_id":"source/_posts/css-background.md","hash":"0af094432e5e99a94568f54a06b85e87e07d7144","modified":1590214358000},{"_id":"source/_posts/front-end-router.md","hash":"86baa6b8c57f26f173b014ef09f2f711dd7b72e3","modified":1641631405789},{"_id":"source/_posts/es6-promise.md","hash":"27d958c2bd673f1dc0d6b9655cf51bd7d486aa40","modified":1641631323892},{"_id":"source/_posts/css-box-model.md","hash":"dd50bee88b495305b49e46b4091aa12d7eedb50d","modified":1590213956000},{"_id":"source/_posts/h5-history-api.md","hash":"fc799f0c37a3e9efd2db7d130b1f0c006424f845","modified":1641630072147},{"_id":"source/_posts/getting-started-with-gulp.md","hash":"0913eb06d77d8e5bd829671ac1ac263da2d1a89c","modified":1641629873918},{"_id":"source/_posts/how-to-use-buffers.md","hash":"3c191bb581416f03b908790f5b758659c03409b3","modified":1641630852895},{"_id":"source/_posts/html-send-email.md","hash":"adb9db2381eb4ce0611c9e3f39594cd9046caef7","modified":1641629928711},{"_id":"source/_posts/interact-with-app.md","hash":"cccd6b2c225ca85819b16b77c3d2d3c49a99f56e","modified":1641631290634},{"_id":"source/_posts/javascript-closure.md","hash":"843d488b3b3776272544fe17a6c64aa1acad444a","modified":1641631118254},{"_id":"source/_posts/memory-management.md","hash":"f6e1bede159ac59429c38ec3147167c976dc376a","modified":1641631141102},{"_id":"source/_posts/javascript-without-loops.md","hash":"bb8028bf0f971971148dc718ae6cb8dbee2d3d6a","modified":1641631137509},{"_id":"source/_posts/mobile-web-soft-keyboard.md","hash":"d29d4eab8c12dfc2472fc2068fc76b71abe21a49","modified":1641631356605},{"_id":"source/_posts/module-es6-vs-amd.md","hash":"364d57b0a68dfee640fafd5ef9ba1e134987ad17","modified":1641629497448},{"_id":"source/_posts/mongodb.md","hash":"62b6e7d16a989683a62dc6f624e9f082ab5e3e7c","modified":1641631245161},{"_id":"source/_posts/nvm-windows.md","hash":"0df66958fee5b07c6818f9505a10f5dc48b7639b","modified":1641631194125},{"_id":"source/_posts/practice-of-wxapp-1.md","hash":"a488af1b9522d8f12282c4c26374e10b767f69df","modified":1516288438000},{"_id":"source/_posts/promise.md","hash":"8b797c5132c69783d600f7bcef838c1ec78634bf","modified":1611152870000},{"_id":"source/_posts/some-summarize-about-event.md","hash":"4d5b3a3583c0bc9a78d5457d766cc900b7097e35","modified":1641631166287},{"_id":"source/_posts/summary-of-vuejs.md","hash":"d99bf6df3c8af6615e96e4468f4941f8c5f76f5a","modified":1691150594856},{"_id":"source/_posts/underscore-base-function.md","hash":"76f29692d7db37eab10d71d60b45ea42350e2313","modified":1590214162000},{"_id":"source/_posts/underscore-featured-function.md","hash":"52b163aa4dc0d61b7bd7cfbffdbe1be13c0cd278","modified":1590214174000},{"_id":"source/_posts/underscore-mix.md","hash":"acce7f1a2f9df585721cfb9c1a9863045b607580","modified":1590214179000},{"_id":"source/_posts/underscore-wrapper.md","hash":"da1e711311c1999e78d199ae3b5ebb16d6d88e6c","modified":1590214184000},{"_id":"source/_posts/using-web-storage-api.md","hash":"106cb9e543f2172f2c5d94098455794e743226ec","modified":1641630946153},{"_id":"source/_posts/web-safe-http-header.md","hash":"ac918ac97d1dfb93367d2e187c89623be7049a99","modified":1590214336000},{"_id":"source/_posts/wechat-miniapp-session.md","hash":"367bd80c92ae87b56c68181a52b449cec1343fe5","modified":1590214221000},{"_id":"source/_posts/what-is-bfc.md","hash":"d645461aa513069356fe2a688e53b525f6f44768","modified":1590214230000},{"_id":"source/_posts/what-is-cookie.md","hash":"ecbe3892f8d0b344466cf8a804649c0a2519a5a3","modified":1641630769285},{"_id":"source/_posts/white-space-and-wrap.md","hash":"a56e0d4354403b8a58cd44e5eeac1ed8d88744a8","modified":1590214243000},{"_id":"source/_posts/mini-program/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1590215479000},{"_id":"source/_posts/mini-program/api-promisify.md","hash":"6a1fead541e7a67c5437cfea346925a9eb01b88c","modified":1641622280640},{"_id":"source/_posts/mini-program/code-style-guide.md","hash":"7ed36420b0bc714399225a19bd1ef1e50cd6eb18","modified":1641622101444},{"_id":"source/_posts/mini-program/custom-navigator.md","hash":"71ecb2a31d1ae5af409981d07b6189e39d88b2ac","modified":1641622168724},{"_id":"source/_posts/mini-program/custom-tabbar.md","hash":"6d219fe5fa853039b550c5c25607c63c3d550615","modified":1641622420931},{"_id":"source/_posts/mini-program/frame-design.md","hash":"72a87ea1a3b28f5e72c1c0abedb8551aa93ee01e","modified":1641622448699},{"_id":"source/_posts/mini-program/global-data-manage.md","hash":"458916cf7b894b2a34ade038a02654b021d216fa","modified":1641622025736},{"_id":"source/_posts/mini-program/think-about-subscribe.md","hash":"59fbd497cd7a4d964e0b7625d0d096b0e8d38010","modified":1641622182021},{"_id":"source/_posts/mini-program/thinking-about-components.md","hash":"3c7000240cae0f6a414e9315eb01ebd348dcd3b7","modified":1641622531469},{"_id":"source/images/components/components-graph.png","hash":"2f4056d9c0448a3204386ddefd84025ea8a58967","modified":1586270751000},{"_id":"source/images/components/miniprogram-lifecycle.png","hash":"ea702f0624c4c43b902648df3eed268504489b34","modified":1586350800000},{"_id":"source/images/components/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1586350800000},{"_id":"source/images/qrcode/wallpaper.jpg","hash":"20de30ec07556f5b0cf0718124d830b26eaeed30","modified":1590217835000},{"_id":"source/images/qrcode/weather.jpg","hash":"3d1f0c66c35a08c9dea8c57abe133f750d1027a4","modified":1590217765000},{"_id":"source/images/components/lifecycle.png","hash":"297c3423ba2fe66ac397a67c4547c6aae41788aa","modified":1586271195000},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1641020194999},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1641020194999},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1641020194999},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1641020194999},{"_id":"public/content.json","hash":"98df0534cfd4c924b34a292ab79ba0f784f4d0aa","modified":1641634992497},{"_id":"public/manifest.json","hash":"071cf96d35284d890f09444a8b07f0a4b7313a0b","modified":1641020194999},{"_id":"public/projects/index.html","hash":"86ba649c259b81f9dea7277760a3de31f364b540","modified":1641634992497},{"_id":"public/2021/01/17/promise/index.html","hash":"52fb7e2713a34056d9767a600be571a9143ec6ac","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/update/index.html","hash":"ed4e3bd632dafdb83825678ca852b97d0369ff1f","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/thinking-about-components/index.html","hash":"18812c36fd224031f314d69886204a33c83f781c","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/think-about-subscribe/index.html","hash":"c27e3ebe76c83c525d17012f2853ed9536818375","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/global-data-manage/index.html","hash":"e050890b672a554ee379d8fd218b9739af0cd346","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/frame-design/index.html","hash":"128f3810d1e34a0e2b779fe10dc9ab6815491dcd","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/custom-tabbar/index.html","hash":"7835cf1667eb1cb7d79ee564b45b5a6734260a04","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/custom-navigator/index.html","hash":"6c1ba917cc8e980a5c38c00d95cdbb2f56380130","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/code-style-guide/index.html","hash":"cc5dae52ff282f649c9ed7d159fe7bff50deb27f","modified":1641476263332},{"_id":"public/2020/05/23/mini-program/api-promisify/index.html","hash":"f7d31430dff3640e977f70b706fa8a1daa691ebb","modified":1641476263332},{"_id":"public/2018/01/07/practice-of-wxapp-1/index.html","hash":"d563c0a00c3625b068e52d17fdaef50cff245a73","modified":1641476263332},{"_id":"public/2017/11/11/what-is-bfc/index.html","hash":"b3f64f2f972ed36ba6cd0c38c5b7676c67883fc7","modified":1641476263332},{"_id":"public/2017/11/05/what-is-cookie/index.html","hash":"86410f5cd94c420e0443731ef2d6b4496ee37b51","modified":1641634992497},{"_id":"public/2017/10/27/about-deploly-favweb-3/index.html","hash":"5327a62e4398d13f5e8c2caccd56c811d64ea802","modified":1641634992497},{"_id":"public/2017/10/21/about-deploly-favweb-2/index.html","hash":"9077c1d5e708a41aebb6f3bf3bf8047c3fe92439","modified":1641634992497},{"_id":"public/2017/10/14/about-deploly-favweb-1/index.html","hash":"5ae984645008b5567fc2fe30abbbb23d3bbfbe3e","modified":1641634992497},{"_id":"public/2017/10/06/how-to-use-buffers/index.html","hash":"dbbccd494f0240df2782a8dba57bf598c7d9e1a9","modified":1641634992497},{"_id":"public/2017/09/23/underscore-featured-function/index.html","hash":"38d185a1b2015506e80cfe0619449d3511ec6867","modified":1641476263332},{"_id":"public/2017/09/18/underscore-base-function/index.html","hash":"24e2ba194615ad40444cc36124940bf3cf3a2a14","modified":1641476263332},{"_id":"public/2017/09/11/underscore-mix/index.html","hash":"b87c64d1120b36c7d38fdd353c34243fe61d2c1d","modified":1641476263332},{"_id":"public/2017/09/04/underscore-wrapper/index.html","hash":"6498106d2d5ff89cc0ba678d6166016b52253b28","modified":1641476263332},{"_id":"public/2017/08/16/css-box-model/index.html","hash":"508f5986bbd4c2453e4103d7e21e037b185bd68e","modified":1641476263332},{"_id":"public/2017/08/07/using-web-storage-api/index.html","hash":"1e488ef16833e1eaf62836d521dc94131073e0eb","modified":1641634992497},{"_id":"public/2017/07/18/wechat-miniapp-session/index.html","hash":"4aa8c1f587d0018caf7ae5a09c0d280201a97bca","modified":1641476263332},{"_id":"public/2017/05/19/summary-of-vuejs/index.html","hash":"c8b053847c233d23220d67950603f8e54db0197e","modified":1641634992497},{"_id":"public/2017/03/05/javascript-closure/index.html","hash":"5c0aa02619623e0311585ce3299f5fd2cc849e86","modified":1641634992497},{"_id":"public/2017/03/05/memory-management/index.html","hash":"3a848c1510faa111774581b8c0cbf036274b8464","modified":1641634992497},{"_id":"public/2017/02/21/javascript-without-loops/index.html","hash":"5834522793242bb4ce82e2b358a13d832b12940f","modified":1641634992497},{"_id":"public/2016/11/24/some-summarize-about-event/index.html","hash":"04d8b58ca82a5575099e170d569ee556c003f310","modified":1641634992497},{"_id":"public/2016/11/15/JavaScript-detect/index.html","hash":"9bbe9fe1618e6946bdf8954ad33f8ad70c936f83","modified":1641476263332},{"_id":"public/2016/11/04/module-es6-vs-amd/index.html","hash":"635843dbc4286232c8f6578b78b739e017c30bac","modified":1641634992497},{"_id":"public/2016/11/03/nvm-windows/index.html","hash":"dad9452044b70afe8b26b66b7f50fc6648b32266","modified":1641634992497},{"_id":"public/2016/10/17/mongodb/index.html","hash":"3d8a6a22f5773bcb4fbd5e9709a1d8f942f319e8","modified":1641634992497},{"_id":"public/2016/09/26/interact-with-app/index.html","hash":"6dcafeb5a7015421bd6dd5e7b3d750a34c02a86e","modified":1641634992497},{"_id":"public/2016/09/23/getting-started-with-gulp/index.html","hash":"a81c25288b23a22da43e306a1f62e0bd046d2058","modified":1641634992497},{"_id":"public/2016/09/12/html-send-email/index.html","hash":"284f12aa3591b75ed311d9bbc29d0db7542e4b0a","modified":1641634992497},{"_id":"public/2016/08/05/es6-promise/index.html","hash":"dfde0169a131fa50bc879e1af5b1ebae7eb55984","modified":1641634992497},{"_id":"public/2016/07/22/mobile-web-soft-keyboard/index.html","hash":"9f4fbd386cdc1bdd208b856247a056428b70934e","modified":1641634992497},{"_id":"public/2016/07/05/h5-history-api/index.html","hash":"5071a525608f4e1a4a42c1e347972bc666d18710","modified":1641634992497},{"_id":"public/2016/05/09/web-safe-http-header/index.html","hash":"f7a74c56aa58a1acc0d45365803f198565e13b24","modified":1641476263332},{"_id":"public/2015/10/17/css-background/index.html","hash":"044c35d22090ff6ffa9f9fa6c52ca403860d18d6","modified":1641476263332},{"_id":"public/2015/10/14/white-space-and-wrap/index.html","hash":"3f1ad27ac3d516fecdf88878e01d75a3dba4be90","modified":1641476263332},{"_id":"public/2015/09/21/front-end-router/index.html","hash":"7e88dcabc7e1871959e5eca7ea3ba7ca8eece219","modified":1641634992497},{"_id":"public/archives/index.html","hash":"46322769873a653a1d3e15378772c0560e81e8a3","modified":1641634992497},{"_id":"public/index.html","hash":"7feb051886648182f59f84c8db5d8c5cbc74ca1e","modified":1641634992497},{"_id":"public/page/2/index.html","hash":"208dd2b92f6fa83e23362a8ef005aaffb580ea2f","modified":1641634992497},{"_id":"public/page/3/index.html","hash":"438ed6fde2230ac30a3fd2d1dcf3526e583855d2","modified":1641634992497},{"_id":"public/page/4/index.html","hash":"652c3f0acb2cfe463633b4448d7ff545b2852041","modified":1641634992497},{"_id":"public/page/5/index.html","hash":"84bef26844a92cb2eb220d63beac38c76fe48103","modified":1641634992497},{"_id":"public/tags/小程序/index.html","hash":"baad1ca2bdf8f14b1440dd7cb2c632d3b5ab1999","modified":1641634992497},{"_id":"public/tags/cookie/index.html","hash":"54563013000ec4de94228a2513341b5e86a5f5b5","modified":1641634992497},{"_id":"public/tags/CSS/index.html","hash":"e3b677b89e5874864efdbfb8bf916fcb1c4f8a65","modified":1641634992497},{"_id":"public/tags/BFC/index.html","hash":"bf0c80ad841f4bb9d942c78897c313a2e3b3f32a","modified":1641634992497},{"_id":"public/tags/网络安全/index.html","hash":"886686d09a6cd3bde92b4f3c5038678922ff9593","modified":1641634992497},{"_id":"public/tags/HTTP/index.html","hash":"12ff8a59e7af20c8cb55d340b69de2ec49740697","modified":1641634992497},{"_id":"public/tags/Session/index.html","hash":"491d809f102299d32f9e9e7a5f93e6232a274907","modified":1641634992497},{"_id":"public/tags/JavaScript/index.html","hash":"829c1394be3613268a7f7db4e8f19c829d7f862c","modified":1641634992497},{"_id":"public/tags/Storage/index.html","hash":"52c89477913a138a10d1034cb8e5a7ceb90438a8","modified":1641634992497},{"_id":"public/tags/underscore-js/index.html","hash":"6f51aa2d5e4163f6bcbd02f368e7847c4c83ce16","modified":1641634992497},{"_id":"public/tags/vue-js/index.html","hash":"567127ef0602ffa7636a612638b031bee1d0c352","modified":1641634992497},{"_id":"public/tags/promise-宏任务-微任务/index.html","hash":"b71a347be267679f12242363a647cd59c8730c0d","modified":1641476263332},{"_id":"public/tags/事件/index.html","hash":"ba52d4d513a1898b172d9b1424f34b4d264f91a4","modified":1641634992497},{"_id":"public/tags/Node-js/index.html","hash":"56538dd7aa44cb97821b7f084816c632cbc2da75","modified":1641634992497},{"_id":"public/tags/MongoDB/index.html","hash":"62c0ec2ed0b06466e1e80b566190aa3e55276496","modified":1641634992497},{"_id":"public/tags/ES6/index.html","hash":"46855dfbe9a064d9a22522d3ecc39cbd0a009baf","modified":1641634992497},{"_id":"public/tags/模块化/index.html","hash":"c76b9ea3f7fd61608f171ab6f2c8d6c1cfb18738","modified":1641634992497},{"_id":"public/tags/键盘/index.html","hash":"cbb313ca6c73963b0c4e195e9d0d57b9e2beffe7","modified":1641476263332},{"_id":"public/tags/Array/index.html","hash":"ad9b51adf1eda53391207f7941b79303be6c163a","modified":1641634992497},{"_id":"public/tags/闭包/index.html","hash":"533dc98a9bf05f949cee28d0f49f7549df74c81e","modified":1641634992497},{"_id":"public/tags/HTML/index.html","hash":"3664dfc01b895b9dee318efde722ecf4bea00de8","modified":1641634992497},{"_id":"public/tags/Buffers/index.html","hash":"4b089a688b6553c9b2f7dda84a526fdb587fd993","modified":1641634992497},{"_id":"public/tags/History-API/index.html","hash":"ab6989b823d365360871736f52f48c272fe3904e","modified":1641634992497},{"_id":"public/tags/gulp/index.html","hash":"6bb5dbdf1faecfafa717f14a34150ad2938483dc","modified":1641634992497},{"_id":"public/tags/路由/index.html","hash":"447aeec78af2b9323665fe134a9df48aac0de5c6","modified":1641634992497},{"_id":"public/tags/盒模型/index.html","hash":"ed9b59ed4bc31d734dcbf1135c3c76a19b85f4b5","modified":1641634992497},{"_id":"public/tags/内存管理/index.html","hash":"bb57ddb6e7cd70ef7ba677913f68fd1318b975f2","modified":1641634992497},{"_id":"public/tags/垃圾回收/index.html","hash":"c94e377aad449b362727a3c514c5ee446cae8579","modified":1641634992497},{"_id":"public/tags/编码规范/index.html","hash":"83b916e50f2525164b8e49799c6fce94138dd900","modified":1641634992497},{"_id":"public/categories/index.html","hash":"7c833b0fe964a070c56ec5d8155580f950f53af6","modified":1641634992497},{"_id":"public/tags/index.html","hash":"f60a89b489e93ce2deae1c0023d29973b117de0c","modified":1641634992497},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1641020194999},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1641020194999},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1641020194999},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1641020194999},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1641020194999},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1641020194999},{"_id":"public/images/subscribe/WechatIMG198.jpg","hash":"c000f7794a8789579e16d68a716b213c4ee1cba7","modified":1641476263332},{"_id":"public/images/subscribe/WechatIMG199.jpg","hash":"981ae8012bf1648d9174f61b74d99e4946122590","modified":1641476263332},{"_id":"public/images/subscribe/request-subscribe-message.jpg","hash":"b3271488a580dbce98a3bcfac111610ccfe821ae","modified":1641476263332},{"_id":"public/images/update/least-version-tips.d8a1b4d4.jpg","hash":"a782cd41abb91496e13706f7a7db4ce624455f03","modified":1641476263332},{"_id":"public/images/update/update-logic.jpg","hash":"70d151e85ae0679408fa39e6f2bf94433947cd6b","modified":1641476263332},{"_id":"public/images/update/work-flow.png","hash":"1b2e729bfadf4f08cf83fb592b1b2bb042c5295e","modified":1641476263332},{"_id":"public/images/custom-navigator/full-screen.jpeg","hash":"247b54a31fab005f31680808a7beae3c236bdbf1","modified":1641476263332},{"_id":"public/images/custom-navigator/navigator.jpg","hash":"6d91b3c9ec53e8d07c713a38ed9e65b0f446a02c","modified":1641476263332},{"_id":"public/images/code-guide/eslint.png","hash":"0c39ed32c2895715d25ed1115b23e97dedc69fc2","modified":1641476263332},{"_id":"public/images/code-guide/eslint.svg","hash":"204482ca413433c80cd14fe369e2181dd97a2a40","modified":1641476263332},{"_id":"public/images/code-guide/htmlhint.png","hash":"85a5fbc53e53d6414bef948c5a0eb17529a7e3d2","modified":1641476263332},{"_id":"public/images/code-guide/merge-request.png","hash":"aac6b6747a65c362018441d58a0eb4709bc70b2f","modified":1641476263332},{"_id":"public/images/code-guide/stylelint.png","hash":"0f4d319e4c5e20284d59dc420ca96e6b55ddd92c","modified":1641476263332},{"_id":"public/images/code-guide/protect-branch.png","hash":"fb4acac70517280f545cf8397ec24eb747ccd4f8","modified":1641476263332},{"_id":"public/favicon.png","hash":"267cfd461bbe03e88577f6e4c96b41d743aeadc4","modified":1641020194999},{"_id":"public/CNAME","hash":"71a4f395b9bbb9c0f326b3b124d584ea9e26010e","modified":1641020194999},{"_id":"public/images/promisify-error1.jpg","hash":"508698512945cd806429e8997cc950021a59a32e","modified":1641476263332},{"_id":"public/images/global-window.png","hash":"2b653f4236257e9c71668b59ed5d146efaf3525f","modified":1641476263332},{"_id":"public/images/promisify-console1.jpg","hash":"1b58397722b57e3bb4c96afbaca37ac7c4a0891a","modified":1641476263332},{"_id":"public/images/global-global.png","hash":"85b94a1df6b3621067f5d6b28f550e04f7b96611","modified":1641476263332},{"_id":"public/images/compare.jpg","hash":"e726bb3dbeda342f8a64d3452e702c16a3d18e16","modified":1641476263332},{"_id":"public/images/qrcode/wallpaper.jpg","hash":"20de30ec07556f5b0cf0718124d830b26eaeed30","modified":1641476263332},{"_id":"public/images/components/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1641476263332},{"_id":"public/images/qrcode/weather.jpg","hash":"3d1f0c66c35a08c9dea8c57abe133f750d1027a4","modified":1641476263332},{"_id":"public/images/components/components-graph.png","hash":"2f4056d9c0448a3204386ddefd84025ea8a58967","modified":1641476263332},{"_id":"public/images/components/miniprogram-lifecycle.png","hash":"ea702f0624c4c43b902648df3eed268504489b34","modified":1641476263332},{"_id":"public/images/update/least-version-config.c2b188c7.png","hash":"a1ff51d63b4abfcefc659b685c32f859dbaf7890","modified":1641476263332},{"_id":"public/images/qrcode.png","hash":"0d7e51470337e44db91f9b0f6f7f02418104e229","modified":1641476263332},{"_id":"public/images/update/mock-update.jpg","hash":"7138fad05e68518c6ad395fe7f98c43c8d7a6a39","modified":1641476263332},{"_id":"public/images/compatibility-proxy.jpg","hash":"fb4df64fc6be08b321b8677ab5f932e31bd34246","modified":1641476263332},{"_id":"public/images/compatibility-symbol.jpg","hash":"45b033a76470731c16fec881e42ea54d310f63f4","modified":1641476263332},{"_id":"public/images/components/lifecycle.png","hash":"297c3423ba2fe66ac397a67c4547c6aae41788aa","modified":1641476263332},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1641020194999},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1641020194999},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1641020194999},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1641020194999},{"_id":"public/css/default.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1641020194999},{"_id":"public/css/cyberpunk.css","hash":"073797b87e28376604d586c48beb66f6fe9cb504","modified":1641020194999},{"_id":"public/css/style.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1641020194999},{"_id":"public/images/custom-navigator/interface.jpg","hash":"9397a1ab3af50c5c8229ea2355e307b796fdcf21","modified":1641476263332},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909159},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909163},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909165},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909167},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909167},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909126},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909139},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909140},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909141},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641020909142},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1641020909109},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1641020909122},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1641020909109},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1641020909122},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1641020909122},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1641020909122},{"_id":"themes/icarus/package.json","hash":"eeefa2a465ff37e08499efb1d4f1c72517e5d103","modified":1641020909169},{"_id":"themes/icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1641020909123},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1641020909123},{"_id":"themes/icarus/.github/dependabot.yml","hash":"d532d0db30e42211f35823b9885f3ed1b2d51777","modified":1641020909115},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1641020909123},{"_id":"themes/icarus/.github/stale.yml","hash":"88c73f6216c5666d2f60b1e8fe690a3f6e561e42","modified":1641020909115},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1641020909125},{"_id":"themes/icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1641020909153},{"_id":"themes/icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1641020909154},{"_id":"themes/icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1641020909154},{"_id":"themes/icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1641020909155},{"_id":"themes/icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1641020909155},{"_id":"themes/icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1641020909155},{"_id":"themes/icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1641020909156},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1641020909156},{"_id":"themes/icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1641020909156},{"_id":"themes/icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1641020909156},{"_id":"themes/icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1641020909157},{"_id":"themes/icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1641020909157},{"_id":"themes/icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1641020909157},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1641020909158},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1641020909158},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1641020909158},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1641020909159},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1641020909159},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1641020909163},{"_id":"themes/icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1641020909164},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1641020909165},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1641020909166},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1641020909167},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1641020909168},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1641020909169},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"b49270a202d839c298e584b5d017f56140c7e7a0","modified":1641020909111},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"d801be6937df21e63113be8840b2e23c465db87b","modified":1641020909110},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1641020909112},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"5d3abdc1a2a79ef9822865184eced6e31066d8f6","modified":1641020909111},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1641020909113},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1641020909114},{"_id":"themes/icarus/.github/workflows/github-release.yml","hash":"48b6bd2cc567687a7b1648c55c8f9de9d44fa9e1","modified":1641020909120},{"_id":"themes/icarus/.github/workflows/npm-publish.yml","hash":"4eabc0c60cb7102fdd5e4b0fbd8c0ac4c17cc8d0","modified":1641020909121},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1641020909124},{"_id":"themes/icarus/.github/workflows/lint.yml","hash":"71f04b66e48f065285ba109939999876ef411598","modified":1641020909121},{"_id":"themes/icarus/.github/workflows/test.yml","hash":"69046b3b5c3d12cdca26380b7458cebeb2546dae","modified":1641020909122},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1641020909124},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1641020909138},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1641020909124},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1641020909144},{"_id":"themes/icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1641020909144},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1641020909144},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1641020909145},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1641020909145},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1641020909146},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1641020909145},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1641020909146},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1641020909146},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1641020909146},{"_id":"themes/icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1641020909147},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1641020909147},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1641020909149},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1641020909150},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1641020909152},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1641020909151},{"_id":"themes/icarus/layout/common/article.jsx","hash":"e2765287c6bc6eb97975a1bb4e325b046e95b392","modified":1641020909160},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1641020909160},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1641020909160},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1641471813781},{"_id":"themes/icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1641020909161},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1641020909161},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1641020909162},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1641020909162},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1641020909162},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1641020909162},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"251263b97de12f2b8d1fce2514e83430f2515b94","modified":1641020909163},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1641020909166},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1641020909166},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1641020909168},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1641020909170},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1641020909170},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1641020909170},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1641020909171},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1641020909171},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1641020909172},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1641020909172},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1641020909173},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1641020909174},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1641020909173},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1641020909174},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1641020909174},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1641020909173},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1641020909174},{"_id":"themes/icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1641020909126},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1641020909126},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1641020909127},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1641020909127},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1641020909129},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1641020909131},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1641020909132},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1641020909132},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1641020909133},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1641020909133},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1641020909133},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1641020909134},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1641020909140},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1641020909140},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1641020909143},{"_id":"source/_posts/miniprogram-function-property.md","hash":"94a17b06cc866b2fda44c3c1d8976fb2f5695317","modified":1641620986010},{"_id":"public/2022/01/06/miniprogram-function-property/index.html","hash":"392c460e546503ba886617ec7e667921413a3605","modified":1641476263332},{"_id":"public/tags/小程序/page/2/index.html","hash":"7cc456594c6defc94e1254283c58e4a92c30b32c","modified":1641634992497},{"_id":"public/tags/函数属性/index.html","hash":"7e06d7382de5af23ae715fb6242d91dae151ee2c","modified":1641476263332},{"_id":"public/tags/函数/index.html","hash":"a10bc40103c7173b387c63463cc2939065d5a2c9","modified":1641476263332},{"_id":"public/tags/属性/index.html","hash":"d11e76735418d26a89e645be000763dd0cef9b9f","modified":1641476263332},{"_id":"public/tags/tdesign/index.html","hash":"4f6b49cc0f76f261138a4df00400c9b452529314","modified":1641476263332},{"_id":"source/_posts/miniprogram/api-promisify.md","hash":"58de1fd204480c8ecdb574cbc082b382a6df6c4a","modified":1691145994264},{"_id":"source/_posts/miniprogram/custom-navigator.md","hash":"c117613109ef9f2631cf172a493b340341266f38","modified":1691146136919},{"_id":"source/_posts/miniprogram/frame-design.md","hash":"b059c8c9598c72fcb002e756c738915048821c72","modified":1691145918563},{"_id":"source/_posts/miniprogram/custom-tabbar.md","hash":"5fdb5b4043a794e56336fd743f1e60bb7e38ec52","modified":1691145954869},{"_id":"source/_posts/miniprogram/global-data-manage.md","hash":"3e9ef6d9367f7ee796ff983b8946c5e4f292987c","modified":1691146014613},{"_id":"source/_posts/miniprogram/code-style-guide.md","hash":"6ca4e969cacedfaccc723fbf4aefad4c7b261fd3","modified":1691146091088},{"_id":"source/_posts/miniprogram/miniprogram-function-property.md","hash":"8b277a2209d62e5e370adeeafd61405492e089b2","modified":1691148316575},{"_id":"source/_posts/miniprogram/think-about-subscribe.md","hash":"30f3e9741f4c3318a619ccbca7cfddd3a9a98fda","modified":1691146165419},{"_id":"source/_posts/miniprogram/thinking-about-components.md","hash":"a02f76866cf8f90dcde84c377dc0b6eddf15be1c","modified":1691146046145},{"_id":"source/_posts/miniprogram/update.md","hash":"a53608fd17ce7705fc70cff59680a6a01d228f37","modified":1691146114750},{"_id":"source/_posts/mini-program/miniprogram-function-property.md","hash":"7fa05837159fdc37d31091015bf631defe063036","modified":1641622480229},{"_id":"source/_posts/ advance/promise.md","hash":"57c1a1ea1368d2f95b77ea8ec730e8e70bf83900","modified":1641633626247},{"_id":"source/_posts/css/css-box-model.md","hash":"36a5fcd1ba194dde4ea3ba8a0fef173ea60be5c4","modified":1641630921537},{"_id":"source/_posts/css/what-is-bfc.md","hash":"2dc60127514afaf7ade16abee4bd8c3707a5bd16","modified":1641630751724},{"_id":"source/_posts/miniprogram/practice-of-wxapp-1.md","hash":"444526fa24ea949293f302f662bc929ca7b8b247","modified":1641630974003},{"_id":"source/_posts/underscore/underscore-base-function.md","hash":"5cf4266277d1b1707e1564972948dc5cdf142494","modified":1641630874030},{"_id":"source/_posts/underscore/underscore-mix.md","hash":"9c73d0874841ef0865f9d2a3bbca2e0c9e650569","modified":1641630878927},{"_id":"source/_posts/underscore/underscore-featured-function.md","hash":"e4b0799ed5cc9f81862e501478aa3e3a9beb2a33","modified":1641630876407},{"_id":"source/_posts/underscore/underscore-wrapper.md","hash":"71bd1555a05397c6283fe0650fa19a475b15ae1f","modified":1641630881682},{"_id":"source/_posts/javascript-detect.md","hash":"19afb47e161178ff0a737669b4f923772da90a9c","modified":1641631133398},{"_id":"source/_posts/miniprogram/wechat-miniapp-session.md","hash":"13154c36f90a390ced06c3e0992e66a91b478782","modified":1641630982954},{"_id":"source/_posts/css/css-background.md","hash":"0c8754d9c4c0e6c52fd5ebab5b75785199c58d23","modified":1641630295800},{"_id":"source/_posts/css/white-space-and-wrap.md","hash":"fb0696401197b461833bcb9ab7c0fc96af7352e3","modified":1641630350211},{"_id":"source/_posts/http/web-safe-http-header.md","hash":"ba4d8d8c68fafb80480fef30e9d004130205870b","modified":1641630233944},{"_id":"source/_about/index.md","hash":"00e274b1016fbdbda66d414cc9071dd53c965629","modified":1641632536715},{"_id":"source/about/index.md","hash":"ce1134bb356a529f8141c858a54253f006fcae6d","modified":1641633420464},{"_id":"public/about/index.html","hash":"8c1c11e60ad232e3aa7103572eedf3aa07a20322","modified":1641634992497},{"_id":"public/2022/01/06/miniprogram/miniprogram-function-property/index.html","hash":"b47a8d4d3302a31e82b4b8899c54d3564507f638","modified":1641634992497},{"_id":"public/2021/01/17/ advance/promise/index.html","hash":"f7c687d1e18db2a300ab231ef06fac47f5693c52","modified":1641634992497},{"_id":"public/2020/05/16/miniprogram/think-about-subscribe/index.html","hash":"edb1dc5bb3f8ebd854899685dec6ef6c8283160d","modified":1641634992497},{"_id":"public/2020/04/27/miniprogram/update/index.html","hash":"869f6716c481d9a2ba12ef58c77c56e8b1f71a77","modified":1641634992497},{"_id":"public/2020/04/07/miniprogram/global-data-manage/index.html","hash":"6a3934ec6f3775876963f5ab947e849fc3c4a087","modified":1641634992497},{"_id":"public/2020/04/12/miniprogram/code-style-guide/index.html","hash":"576f96f4a819b6c1a0db09c87782c4108bc8f38d","modified":1641634992497},{"_id":"public/2020/04/08/miniprogram/thinking-about-components/index.html","hash":"09cb40015683dedfefe7d296137affd315de40a9","modified":1641634992497},{"_id":"public/2020/04/01/miniprogram/api-promisify/index.html","hash":"c8205eba1f5fab1446a8dad44da394cd9d09dd1d","modified":1641634992497},{"_id":"public/2020/03/29/miniprogram/custom-tabbar/index.html","hash":"f5e8641532b1d7f38845c59eca4e0ed725ab994f","modified":1641634992497},{"_id":"public/2020/03/28/miniprogram/frame-design/index.html","hash":"82fc0e5af80ca00b45cb5c1ac167a8ed22f332bb","modified":1641634992497},{"_id":"public/2018/01/07/miniprogram/practice-of-wxapp-1/index.html","hash":"dfa138f373605f87d3b8cafe8b2c3c2aef4ed3b9","modified":1641634992497},{"_id":"public/2020/05/06/miniprogram/custom-navigator/index.html","hash":"fafc476312d1dfcae5f5344fed871824ec8d1e5c","modified":1641634992497},{"_id":"public/2017/11/11/css/what-is-bfc/index.html","hash":"804c8ad3b712285a310794ea1d1632da310e6f4a","modified":1641634992497},{"_id":"public/2017/09/23/underscore/underscore-featured-function/index.html","hash":"35479fde9fbea74bbb7d96648143531db9f41158","modified":1641634992497},{"_id":"public/2017/09/18/underscore/underscore-base-function/index.html","hash":"cfd7b9d6aea7e3ff4480a734f4eaa656ef302c14","modified":1641634992497},{"_id":"public/2017/09/11/underscore/underscore-mix/index.html","hash":"9b29dbbf53fac0548134165b232e5de5e0763f0d","modified":1641634992497},{"_id":"public/2017/09/04/underscore/underscore-wrapper/index.html","hash":"70a5a2d425dc891a13cedfdb1b191521a07ccabd","modified":1641634992497},{"_id":"public/2017/08/16/css/css-box-model/index.html","hash":"bbb3a5dcbddfe56bc81e96dcf8b3e1602caa16f4","modified":1641634992497},{"_id":"public/2017/07/18/miniprogram/wechat-miniapp-session/index.html","hash":"b61657322a8433d901c4e056bb1817197e9f9d14","modified":1641634992497},{"_id":"public/2016/11/15/javascript-detect/index.html","hash":"9a0311d96c219bc32b5458c7df033a32e3294fb2","modified":1641634992497},{"_id":"public/2015/10/17/css/css-background/index.html","hash":"9651193b377c44bdea9bd735307e2973cc520f14","modified":1641634992497},{"_id":"public/2016/05/09/http/web-safe-http-header/index.html","hash":"1a43cc5fd312be4e6621c183a7de69d354516b07","modified":1641634992497},{"_id":"public/2015/10/14/css/white-space-and-wrap/index.html","hash":"f1b296af2ddf1dc49a940ee38cfbb1e6648994d9","modified":1641634992497},{"_id":"public/categories/小程序/index.html","hash":"4364928fa5eb22aec255eb603c45377b796d9407","modified":1641634992497},{"_id":"public/categories/小程序/page/2/index.html","hash":"1ea5a192f2d9ea3d9495b40fd924dd72057129e2","modified":1641634992497},{"_id":"public/categories/源码解析/index.html","hash":"8fdf47f3dfa4c554c0eeecd1f0b21f9f284bec5b","modified":1641634992497},{"_id":"public/categories/源码解析/underscore/index.html","hash":"2fe9c94a1dd55578f2b4dbcf95c109134e4dab1b","modified":1641634992497},{"_id":"public/categories/CSS/index.html","hash":"03dcb97d6ec31628f169327bd584e5406638a715","modified":1641634992497},{"_id":"public/categories/工程实践/index.html","hash":"d2e839eb68c4815e70cf9b3dd651f70d36ed04ce","modified":1641634992497},{"_id":"public/categories/Node-js/index.html","hash":"e1c71f92f1501d9c0621d4e9c85d11eb9ac074bb","modified":1641634992497},{"_id":"public/categories/计算机网络/index.html","hash":"608466ce48c5b61f2a8b5784b30926243a1c8e75","modified":1641634992497},{"_id":"public/categories/前端/index.html","hash":"2f2f86957b071995a542b3e7867e03acb8302282","modified":1641634992497},{"_id":"public/categories/前端/page/2/index.html","hash":"a880dfde8d867bc6e2acc71413594760ba9faea3","modified":1641634992497},{"_id":"public/categories/前端/基础/index.html","hash":"9ae7e17c54f1ff6c6cc625c2ee27ba5baf1cc2d1","modified":1641634992497},{"_id":"public/categories/前端/基础/page/2/index.html","hash":"0570c45ab282e5740b1dd9bfddf035608616ae4e","modified":1641634992497},{"_id":"public/categories/前端/进阶/index.html","hash":"d55fc3933e7a8a994a8394287592ed223e6da27e","modified":1641634992497},{"_id":"public/categories/浏览器/index.html","hash":"28d5a8dc46de80db898ffa3542f594561337ff2f","modified":1641634992497},{"_id":"public/categories/框架/index.html","hash":"1c6e04540af0babee7ef2439ed5b1316d4e807d2","modified":1641634992497},{"_id":"public/categories/框架/Vue-js/index.html","hash":"319e3fde480e620bfa441d374758521756575cda","modified":1641634992497},{"_id":"public/categories/数据库/index.html","hash":"026e0e5a522983a30d0e18b5d4a3b53a3ed482fa","modified":1641634992497},{"_id":"public/categories/前端工程化/index.html","hash":"2baab604ce14db168b5539a08e1ee08707ef5e1c","modified":1641634992497},{"_id":"public/tags/自定义组件/index.html","hash":"efa01aa1e3730379a5aed59d0c2b053620937d90","modified":1641634992497},{"_id":"public/tags/promise/index.html","hash":"ed98ff543180c9f69ee6bdcd561c131a7efdcefb","modified":1641634992497},{"_id":"source/_posts/miniprogram/component-button.md","hash":"59aa0d55e1020e3d86d7ed9828f7ce00c50f5411","modified":1691149344962},{"_id":"source/images/miniprogram/eventflow.svg","hash":"c49141f75e224e038ad808655c369a190f11d1fb","modified":1690874737351},{"_id":"source/images/miniprogram/user-agent.png","hash":"fb0b772e12ea2d5cef15f4a6a7fbd3770f7406e4","modified":1690874737352},{"_id":"source/images/miniprogram/css-cascade.png","hash":"331146a8625826464878ebc2dad47fc41a549687","modified":1690874737351},{"_id":"source/_posts/about-code-reuse-for-uilib.md","hash":"269ca8f82ecf578bba98141999336e695b145bd1","modified":1691139729968},{"_id":"source/images/ui-libraray/select-tdesign.webp","hash":"f244ca2a44c5c35e416c6f41bc2b2f2af0c767b2","modified":1691139025726},{"_id":"source/images/ui-libraray/foundation-adapter.png","hash":"70004afdf88e6d46ee9e1fd561c0151659c4836d","modified":1638253501046},{"_id":"source/images/ui-libraray/css-layer.png","hash":"9260e4d3feb49027ff1fa86ddc1dd2c4e65e4ae5","modified":1638241896223},{"_id":"source/images/ui-libraray/select.webp","hash":"c4eba41c29322351a106f816b4be9279da1627f3","modified":1691139033098},{"_id":"source/images/ui-libraray/.DS_Store","hash":"8483efbb9d8486e14bd87b815807c5b68b814528","modified":1691139089282},{"_id":"source/images/ui-libraray/跨框架复用.png","hash":"1e921409f7ce3b3eb8e28da2db5271f46cb52334","modified":1638334573074},{"_id":"source/images/ui-library/css-layer.png","hash":"9260e4d3feb49027ff1fa86ddc1dd2c4e65e4ae5","modified":1638241896223},{"_id":"source/images/ui-library/foundation-adapter.png","hash":"70004afdf88e6d46ee9e1fd561c0151659c4836d","modified":1638253501046},{"_id":"source/images/ui-library/select.webp","hash":"c4eba41c29322351a106f816b4be9279da1627f3","modified":1691139033098},{"_id":"source/images/ui-library/select-tdesign.webp","hash":"f244ca2a44c5c35e416c6f41bc2b2f2af0c767b2","modified":1691139025726},{"_id":"source/images/ui-library/.DS_Store","hash":"ec36658ce94a960d1eca24e14931b96dc22dbad9","modified":1691140373677},{"_id":"source/images/ui-library/跨框架复用.png","hash":"1e921409f7ce3b3eb8e28da2db5271f46cb52334","modified":1638334573074},{"_id":"source/images/ui-library/cross-frame.png","hash":"1e921409f7ce3b3eb8e28da2db5271f46cb52334","modified":1638334573074},{"_id":"source/_posts/wechat-miniprogarm-with-github-action.md","hash":"28baa33f88fbabd49ce47d31c20af0bd81215573","modified":1691142122043},{"_id":"source/images/mp-github-action/dev-flow.png","hash":"8d68207bd304eeb631cb3040de3b72cbf77ab9aa","modified":1670578725164},{"_id":"source/images/mp-github-action/miniprogam-version.png","hash":"c625b504de1808e5064500da909362c650832af9","modified":1670581795804},{"_id":"source/images/mp-github-action/github-comment-2.png","hash":"a041b6dd8ef6d8b7104bd3b93c49c1f0e2ecc66a","modified":1670641855881},{"_id":"source/images/mp-github-action/github-comment-1.png","hash":"2c19ab27ea6513111aeb115ccf279814f77a400b","modified":1670641283555},{"_id":"source/images/mp-github-action/github-comment-3.png","hash":"bafd8a338249ee32f131c618a19479ca64acaab8","modified":1670642014751},{"_id":"source/images/mp-github-action/tdesign-web-preview.png","hash":"c7312d37ce4ee7e832b20de44b679e45c78ff9ba","modified":1670641188495},{"_id":"source/images/mp-github-action/github-secrets.png","hash":"c671c90082d583dd9d67949bc6289688d17da1c3","modified":1670579700047},{"_id":"source/images/mp-github-action/github-workflows.png","hash":"3c2116a4d4d5956124df6826fbb5f67e432f9560","modified":1670579968102},{"_id":"source/_posts/responsive-web.md","hash":"1063251d291a17b718a28d0de0c28f20fb9f6387","modified":1691150166994},{"_id":"source/_posts/fe-base/js-data-type-transform.md","hash":"2411081fc4a9ce7760cfdffb0c3d6634272f2d17","modified":1691151247609},{"_id":"source/_posts/vue3-on-tdesign.md","hash":"50f8b4d37ad5af7db26c58014c0ec0e41a7a15c4","modified":1691149373164},{"_id":"source/_posts/fe-base/js-data-type.md","hash":"9a6b20d71e5e1e2914555539c8512a486df24c45","modified":1691150850830},{"_id":"source/_posts/miniprogram/router-design.md","hash":"3921e65ae0e696287ffa452c265489074c75815f","modified":1691149309982},{"_id":"source/_posts/miniprogram/performance-optimization.md","hash":"e6e508f563100268cc9c6e66fc820f42b5e9ebfd","modified":1691147880449},{"_id":"source/_posts/miniprogram/handle-error.md","hash":"fea0ff7623d2f5edafe288dc4f2ab48ce24daa8d","modified":1691147618751},{"_id":"source/_posts/miniprogram/how-to-resue-method.md","hash":"9f0ada4fc93f4f8a6d2122f95fddbce29225d81b","modified":1691145901706},{"_id":"source/images/mp-github-action/.DS_Store","hash":"aff7476b8b7ba3f101dda9e90ffd5bea8b9df8f1","modified":1691142505351},{"_id":"source/_posts/vue/why-data-must-function.md","hash":"30ed0c98317940ac14f4bb1b13b312e2614b4c7b","modified":1691150742576},{"_id":"source/images/miniprogram/.DS_Store","hash":"3531b43552987a87a9234613a3a3e08b8e286670","modified":1691149721240},{"_id":"source/images/miniprogram/0-2.png","hash":"cf1f68ed64f41e59c01d3ff6cea5a76e9f82beca","modified":1691147997966},{"_id":"source/images/miniprogram/0-1.png","hash":"4e5f627b799a49e3228f03a6451e0dbe3c4b71c6","modified":1691147994652},{"_id":"source/images/miniprogram/0-3.png","hash":"df1b622848ea9360b4d3f6a43497a1f2a739a0ea","modified":1691148000350},{"_id":"source/images/mp-github-action/miniprogram-version.png","hash":"c625b504de1808e5064500da909362c650832af9","modified":1670581795804},{"_id":"source/images/miniprogram/0-4.png","hash":"457eb2b7bcbac203eed27d5fb2caf38b67829434","modified":1691148003250},{"_id":"source/images/miniprogram/0-6.png","hash":"ddf51975f7d870e1a3afc5c2f18e71f9b443a999","modified":1691148010916},{"_id":"source/images/miniprogram/0-8.png","hash":"8d3b0f7ea969f3a044297f6fd643c26f3ed025b6","modified":1691148017267},{"_id":"source/images/miniprogram/0-7.png","hash":"e1d419246a9a44ca81a856586a749403f106b9c9","modified":1691148014550},{"_id":"source/images/miniprogram/0-5.png","hash":"b9d3351d26313a9f6a1f22ae26a44c83cc818704","modified":1691148007216},{"_id":"source/images/miniprogram/0.png","hash":"1681791fdfaad2ab10a83ef349638118036b7721","modified":1691147990669},{"_id":"source/images/miniprogram/0-9.png","hash":"e4930afeb672b38b63698f7c50f88c298ab9565d","modified":1691148019404},{"_id":"source/images/vue3/.DS_Store","hash":"2cfad4c7535f7577a8ead8b76ac0576d3cf569b3","modified":1691145343907},{"_id":"source/images/miniprogram/router/.DS_Store","hash":"41bd94fe5038e2f456d8ecc98ca208f1e5477657","modified":1691149708931},{"_id":"source/images/vue3/vue-core-modules.png","hash":"77cac645a67233281c6779012131907f327c9f03","modified":1670757090161},{"_id":"source/images/vue3/tree-data-flow.png","hash":"9ca844141c2a4bdd2b7a4b3e87ed38bb7c419eac","modified":1670757115821},{"_id":"source/images/miniprogram/router/demo4.png","hash":"83ffe39a43575c96b4889c377dc05603453881ce","modified":1691148470697},{"_id":"source/images/miniprogram/router/router-methods.png","hash":"d181c89929e14bc58158028c0ec1865e92b845c7","modified":1691148459446},{"_id":"source/images/miniprogram/router/路由权限控制.png","hash":"d68d8f6b2754da08d506c80b94f3dc3bd823b47c","modified":1691148456015},{"_id":"source/images/miniprogram/caniuse-proxy.png","hash":"e923bac99beb0438afce3104fc2231710800822b","modified":1691147326429},{"_id":"source/images/responsive-web/vw-compatibility.png","hash":"6812142b3023a04842141192d4b16c3cc0d6b66b","modified":1691149749871},{"_id":"source/images/miniprogram/router/demo1.png","hash":"8cc9bb649be9aace0922a1c3394e61d87b9c5041","modified":1691148462329},{"_id":"source/images/miniprogram/router/demo2.png","hash":"b7b14485f2f687e28a3a646ce5dc6f7c311ad436","modified":1691148465063},{"_id":"source/images/miniprogram/router/demo3.png","hash":"1a2ee776f97169c1aeb3296cec640be53b03a7af","modified":1691148467064},{"_id":"source/images/responsive-web/screen-width.png","hash":"53bdb62db306973b34714dbf9a667a3bdf50f401","modified":1691149734435},{"_id":"source/images/responsive-web/viewport-width.png","hash":"5483d2e5d70c8b26a3b6f11d6cd89c2fd91c2246","modified":1691149746318},{"_id":"source/images/responsive-web/window-width.png","hash":"f64071524f4b813b7d815f89fe474d2703702082","modified":1691149742067},{"_id":"source/images/miniprogram/realtime-log.jpg","hash":"f126dae9fefaa7143878c26fc523bd22c5ca5dd5","modified":1691147330412}],"Category":[{"name":"小程序","_id":"cky5eqzvl0000i569bo4g38ik"},{"name":"源码解析","_id":"cky5gzxx1000cn669gnzfhy35"},{"name":"underscore","parent":"cky5gzxx1000cn669gnzfhy35","_id":"cky5gzxx2000dn669bt5a6ejc"},{"name":"promise","_id":"cky5ifbzz000on6691nsq35d8"},{"name":"advance","parent":"cky5ifbzz000on6691nsq35d8","_id":"cky5ifc00000pn669b4htcxcp"},{"name":"advance","_id":"cky5ifs4c000sn669e56t6i38"},{"name":"promise","parent":"cky5ifs4c000sn669e56t6i38","_id":"cky5ifs4c000tn66969de0s2a"},{"name":"前端进阶","_id":"cky5imh8z000xn66984j39fqm"},{"name":"promise","parent":"cky5imh8z000xn66984j39fqm","_id":"cky5imh8z000yn66917o948zf"},{"name":"CSS","_id":"cky5j2zgx0028n669azpo3iff"},{"name":"计算机网络","_id":"cky5j47cr002an66955pk4nsp"},{"name":"开发实践","_id":"cky5j5z71002cn669hmcb01ep"},{"name":"工程实践","_id":"cky5j68dc002en669eoww9sca"},{"name":"Node.js","_id":"cky5j9pz2002in669202042x8"},{"name":"前端基础","_id":"cky5jfe2q00001h69aso52bgy"},{"name":"前端","_id":"cky5jfz5o00021h69d5yjas9y"},{"name":"基础","parent":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jfz5p00031h693xds6401"},{"name":"进阶","parent":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jg4r700061h69a1ama3iy"},{"name":"浏览器","_id":"cky5jgj6p00091h69fhuc2iri"},{"name":"CSS","parent":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jj69u000f1h69ewsd16sb"},{"name":"框架","_id":"cky5jl08a000m1h69a5re5mq4"},{"name":"Vue.js","parent":"cky5jl08a000m1h69a5re5mq4","_id":"cky5jl08b000n1h690lvu79o7"},{"name":"数据库","_id":"cky5jv1pn0003da69ds7cdifg"},{"name":"前端工程化","_id":"cky5jzper0007da692we0470r"},{"name":"工程化","parent":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jzvcv0009da690j9o0qil"},{"name":"组件库","_id":"clkwcxj7g00006bsz7pg57jyh"},{"name":"工程化","parent":"cky5eqzvl0000i569bo4g38ik","_id":"clkwd0gv500036bsz1tf5e2i9"},{"name":"前端工程化","parent":"cky5eqzvl0000i569bo4g38ik","_id":"clkwd3625000b6bsz5kzv10ph"},{"name":"JavaScript","_id":"clkwgpvka00073tsz20wfh5sh"},{"name":"vue","_id":"clkwio80n000j3tszdeb1800w"},{"name":"基础知识","_id":"clkwirpmg000m3tsz7rwdcc5f"}],"Data":[{"_id":"projects","data":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}],"Page":[{"title":"我的项目","date":"2020-05-23T05:58:16.000Z","_content":"\n陆陆续续捣鼓了许多小工具，希望对大家有所帮助吧。\n\n## 开源项目\n\n### [Jeep-UI ](https://github.com/LeeJim/jeep-ui)\n<p>\n<img src=\"https://img.shields.io/npm/dw/jeep-ui\" />\n<img src=\"https://img.shields.io/github/stars/leejim/jeep-ui\" />\n</p>\n\n基于 Vue.js 2.x 框架的 UI 库，专注于快速生成 form 表单\n\n> 因为ElementUI比较繁琐，而突发奇想做出来\n\n### [smapp](https://marketplace.visualstudio.com/items?itemName=leejimqiu.smapp) \n<p>\n<img src=\"https://img.shields.io/visual-studio-marketplace/d/leejimqiu.smapp\" />\n<img src=\"https://img.shields.io/github/stars/leejim/smapp\" />\n</p>\n\nVSCode 插件，用于小程序开发，提供了一些自己想要的功能\n\n### [wxml-minifier](https://github.com/LeeJim/wxml-minifier)\n\n<p>\n<img src=\"https://img.shields.io/npm/dw/wxml-minifier\" />\n<img src=\"https://img.shields.io/github/stars/leejim/wxml-minifier\" />\n</p>\n微信小程序的 WXML 压缩工具。\n\n***\n\n## 小程序\n\n### 分享壁纸\n\n通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。\n\n![](/blog/images/qrcode/wallpaper.jpg)\n\n### 天气号\n\n初次尝试云开发，通过第三方API获取天气信息。\n\n![](/blog/images/qrcode/weather.jpg)\n\n***\n\n## Web应用\n\n### [Web Hunter](http://anyhub.cn)\n\n分享自己发现的有趣网站。\n\n本来时拿来练手全栈开发的，后来通过博客系统改造而成，更简单便捷用于验证项目是否有价值。\n","source":"projects/index.md","raw":"---\ntitle: 我的项目\ndate: 2020-05-23 13:58:16\n---\n\n陆陆续续捣鼓了许多小工具，希望对大家有所帮助吧。\n\n## 开源项目\n\n### [Jeep-UI ](https://github.com/LeeJim/jeep-ui)\n<p>\n<img src=\"https://img.shields.io/npm/dw/jeep-ui\" />\n<img src=\"https://img.shields.io/github/stars/leejim/jeep-ui\" />\n</p>\n\n基于 Vue.js 2.x 框架的 UI 库，专注于快速生成 form 表单\n\n> 因为ElementUI比较繁琐，而突发奇想做出来\n\n### [smapp](https://marketplace.visualstudio.com/items?itemName=leejimqiu.smapp) \n<p>\n<img src=\"https://img.shields.io/visual-studio-marketplace/d/leejimqiu.smapp\" />\n<img src=\"https://img.shields.io/github/stars/leejim/smapp\" />\n</p>\n\nVSCode 插件，用于小程序开发，提供了一些自己想要的功能\n\n### [wxml-minifier](https://github.com/LeeJim/wxml-minifier)\n\n<p>\n<img src=\"https://img.shields.io/npm/dw/wxml-minifier\" />\n<img src=\"https://img.shields.io/github/stars/leejim/wxml-minifier\" />\n</p>\n微信小程序的 WXML 压缩工具。\n\n***\n\n## 小程序\n\n### 分享壁纸\n\n通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。\n\n![](/blog/images/qrcode/wallpaper.jpg)\n\n### 天气号\n\n初次尝试云开发，通过第三方API获取天气信息。\n\n![](/blog/images/qrcode/weather.jpg)\n\n***\n\n## Web应用\n\n### [Web Hunter](http://anyhub.cn)\n\n分享自己发现的有趣网站。\n\n本来时拿来练手全栈开发的，后来通过博客系统改造而成，更简单便捷用于验证项目是否有价值。\n","updated":"2023-08-01T08:19:51.104Z","path":"projects/index.html","_id":"ckxvfmf4z0000brqqbgphei2y","comments":1,"layout":"page","content":"<p>陆陆续续捣鼓了许多小工具，希望对大家有所帮助吧。</p>\n<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><h3 id=\"Jeep-UI\"><a href=\"#Jeep-UI\" class=\"headerlink\" title=\"Jeep-UI \"></a><a href=\"https://github.com/LeeJim/jeep-ui\">Jeep-UI </a></h3><p>\n<img src=\"https://img.shields.io/npm/dw/jeep-ui\" />\n<img src=\"https://img.shields.io/github/stars/leejim/jeep-ui\" />\n</p>\n\n<p>基于 Vue.js 2.x 框架的 UI 库，专注于快速生成 form 表单</p>\n<blockquote>\n<p>因为ElementUI比较繁琐，而突发奇想做出来</p>\n</blockquote>\n<h3 id=\"smapp\"><a href=\"#smapp\" class=\"headerlink\" title=\"smapp\"></a><a href=\"https://marketplace.visualstudio.com/items?itemName=leejimqiu.smapp\">smapp</a></h3><p>\n<img src=\"https://img.shields.io/visual-studio-marketplace/d/leejimqiu.smapp\" />\n<img src=\"https://img.shields.io/github/stars/leejim/smapp\" />\n</p>\n\n<p>VSCode 插件，用于小程序开发，提供了一些自己想要的功能</p>\n<h3 id=\"wxml-minifier\"><a href=\"#wxml-minifier\" class=\"headerlink\" title=\"wxml-minifier\"></a><a href=\"https://github.com/LeeJim/wxml-minifier\">wxml-minifier</a></h3><p>\n<img src=\"https://img.shields.io/npm/dw/wxml-minifier\" />\n<img src=\"https://img.shields.io/github/stars/leejim/wxml-minifier\" />\n</p>\n微信小程序的 WXML 压缩工具。\n\n<hr>\n<h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><h3 id=\"分享壁纸\"><a href=\"#分享壁纸\" class=\"headerlink\" title=\"分享壁纸\"></a>分享壁纸</h3><p>通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。</p>\n<p><img src=\"/blog/images/qrcode/wallpaper.jpg\"></p>\n<h3 id=\"天气号\"><a href=\"#天气号\" class=\"headerlink\" title=\"天气号\"></a>天气号</h3><p>初次尝试云开发，通过第三方API获取天气信息。</p>\n<p><img src=\"/blog/images/qrcode/weather.jpg\"></p>\n<hr>\n<h2 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h2><h3 id=\"Web-Hunter\"><a href=\"#Web-Hunter\" class=\"headerlink\" title=\"Web Hunter\"></a><a href=\"http://anyhub.cn/\">Web Hunter</a></h3><p>分享自己发现的有趣网站。</p>\n<p>本来时拿来练手全栈开发的，后来通过博客系统改造而成，更简单便捷用于验证项目是否有价值。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<p>陆陆续续捣鼓了许多小工具，希望对大家有所帮助吧。</p>\n<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><h3 id=\"Jeep-UI\"><a href=\"#Jeep-UI\" class=\"headerlink\" title=\"Jeep-UI \"></a><a href=\"https://github.com/LeeJim/jeep-ui\">Jeep-UI </a></h3><p>\n<img src=\"https://img.shields.io/npm/dw/jeep-ui\" />\n<img src=\"https://img.shields.io/github/stars/leejim/jeep-ui\" />\n</p>\n\n<p>基于 Vue.js 2.x 框架的 UI 库，专注于快速生成 form 表单</p>\n<blockquote>\n<p>因为ElementUI比较繁琐，而突发奇想做出来</p>\n</blockquote>\n<h3 id=\"smapp\"><a href=\"#smapp\" class=\"headerlink\" title=\"smapp\"></a><a href=\"https://marketplace.visualstudio.com/items?itemName=leejimqiu.smapp\">smapp</a></h3><p>\n<img src=\"https://img.shields.io/visual-studio-marketplace/d/leejimqiu.smapp\" />\n<img src=\"https://img.shields.io/github/stars/leejim/smapp\" />\n</p>\n\n<p>VSCode 插件，用于小程序开发，提供了一些自己想要的功能</p>\n<h3 id=\"wxml-minifier\"><a href=\"#wxml-minifier\" class=\"headerlink\" title=\"wxml-minifier\"></a><a href=\"https://github.com/LeeJim/wxml-minifier\">wxml-minifier</a></h3><p>\n<img src=\"https://img.shields.io/npm/dw/wxml-minifier\" />\n<img src=\"https://img.shields.io/github/stars/leejim/wxml-minifier\" />\n</p>\n微信小程序的 WXML 压缩工具。\n\n<hr>\n<h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><h3 id=\"分享壁纸\"><a href=\"#分享壁纸\" class=\"headerlink\" title=\"分享壁纸\"></a>分享壁纸</h3><p>通过爬虫，将知乎上热门答案里的壁纸信息挖掘出来。</p>\n<p><img src=\"/blog/images/qrcode/wallpaper.jpg\"></p>\n<h3 id=\"天气号\"><a href=\"#天气号\" class=\"headerlink\" title=\"天气号\"></a>天气号</h3><p>初次尝试云开发，通过第三方API获取天气信息。</p>\n<p><img src=\"/blog/images/qrcode/weather.jpg\"></p>\n<hr>\n<h2 id=\"Web应用\"><a href=\"#Web应用\" class=\"headerlink\" title=\"Web应用\"></a>Web应用</h2><h3 id=\"Web-Hunter\"><a href=\"#Web-Hunter\" class=\"headerlink\" title=\"Web Hunter\"></a><a href=\"http://anyhub.cn/\">Web Hunter</a></h3><p>分享自己发现的有趣网站。</p>\n<p>本来时拿来练手全栈开发的，后来通过博客系统改造而成，更简单便捷用于验证项目是否有价值。</p>\n"},{"_content":"\n# LeeJim\n\nWeb 前端开发 / （正在努力增加斜杠称呼）\n\n挺反感那些人叫“码农”的，但回过来一想。\n\n其实连“码农”也不如，因为还没法达到 **自给自足** 的状态，只能称为“码工”，是一个工人。\n\n未来希望可以成为 **自给自足** 的“码农”，不再打工。\n\n> 之前总觉得需要独立开发一些 toC 的产品，但最近的思考是，其实 toT 也是一个不错的选择，成功的榜样比如 [尤雨溪](https://github.com/yyx990803) 或者 [antfu](https://github.com/antfu) 。\n> —— leejim 2022.1","source":"about/index.md","raw":"\n# LeeJim\n\nWeb 前端开发 / （正在努力增加斜杠称呼）\n\n挺反感那些人叫“码农”的，但回过来一想。\n\n其实连“码农”也不如，因为还没法达到 **自给自足** 的状态，只能称为“码工”，是一个工人。\n\n未来希望可以成为 **自给自足** 的“码农”，不再打工。\n\n> 之前总觉得需要独立开发一些 toC 的产品，但最近的思考是，其实 toT 也是一个不错的选择，成功的榜样比如 [尤雨溪](https://github.com/yyx990803) 或者 [antfu](https://github.com/antfu) 。\n> —— leejim 2022.1","date":"2022-01-08T09:17:00.464Z","updated":"2022-01-08T09:17:00.464Z","path":"about/index.html","_id":"cky5lo78k0000hl693wd7b6sv","title":"","comments":1,"layout":"page","content":"<h1 id=\"LeeJim\"><a href=\"#LeeJim\" class=\"headerlink\" title=\"LeeJim\"></a>LeeJim</h1><p>Web 前端开发 / （正在努力增加斜杠称呼）</p>\n<p>挺反感那些人叫“码农”的，但回过来一想。</p>\n<p>其实连“码农”也不如，因为还没法达到 <strong>自给自足</strong> 的状态，只能称为“码工”，是一个工人。</p>\n<p>未来希望可以成为 <strong>自给自足</strong> 的“码农”，不再打工。</p>\n<blockquote>\n<p>之前总觉得需要独立开发一些 toC 的产品，但最近的思考是，其实 toT 也是一个不错的选择，成功的榜样比如 <a href=\"https://github.com/yyx990803\">尤雨溪</a> 或者 <a href=\"https://github.com/antfu\">antfu</a> 。<br>—— leejim 2022.1</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"","more":"<h1 id=\"LeeJim\"><a href=\"#LeeJim\" class=\"headerlink\" title=\"LeeJim\"></a>LeeJim</h1><p>Web 前端开发 / （正在努力增加斜杠称呼）</p>\n<p>挺反感那些人叫“码农”的，但回过来一想。</p>\n<p>其实连“码农”也不如，因为还没法达到 <strong>自给自足</strong> 的状态，只能称为“码工”，是一个工人。</p>\n<p>未来希望可以成为 <strong>自给自足</strong> 的“码农”，不再打工。</p>\n<blockquote>\n<p>之前总觉得需要独立开发一些 toC 的产品，但最近的思考是，其实 toT 也是一个不错的选择，成功的榜样比如 <a href=\"https://github.com/yyx990803\">尤雨溪</a> 或者 <a href=\"https://github.com/antfu\">antfu</a> 。<br>—— leejim 2022.1</p>\n</blockquote>\n"}],"Post":[{"title":"什么是cookie","date":"2017-11-05T10:43:13.000Z","desc":"什么是cookie","toc":true,"_content":"\n起源，因为HTTP的无状态，无法知道两个请求是来自同个人。\n\n由NetScape工程师Lou Montulli与1994发表。正式确定于[RFC2109](http://tools.ietf.org/html/rfc2109)，最终演变成[RFC2965](http://tools.ietf.org/html/rfc2965)\n\n<!-- more -->\n\n## Cookie为何物？\n\n简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。\n\n### 创建\n\n服务器通过`Set-Cookie`的HTTP头来设置：\n\n```\nSet-Cookie: <em>value</em>[; expires=<em>date</em>][; domain=<em>domain</em>][; path=<em>path</em>][; secure]\n```\n\n客户端将多个cookie通过`Cookie`的HTTP头来返回服务器：\n\n```\nCookie: value1; value2; name1=value1\n```\n\n> 多个value直接由一个分号和一个空格分隔开\n\n### value编码\n\n在普遍持有的观念中，value一定要是`URL-endcoed`编码的。\n\n其实这是个谬论，在文档中，明确指出只有`分号、逗号、空格`才需要编码。\n\n### expires\n\n设置过期时间。需要使用GMT格式的时间。\n\n\n```\nSet-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT\n```\n\n> 若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除\n\n> 校验的时间是以客户端的时间为准\n\n### domain\n\n指定什么域名请求时需要发送该cookie。\n\n> 采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)\n\n### path\n\n指定域名下的对应路径的请求才发送cookie。\n\n\n### secure\n\n有这个标志，cookie只会在HTTPS协议的请求发送该cookie。\n\n## 维护Cookie和周期\n\n修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。\n\n\n### 自动删除\n\n以下三个原因导致cookie被浏览器自动删除：\n\n- 会话结束自动删除\n- expires到期自动删除\n- 超过上线自动删除相对较旧的cookie\n\n## 其他限制\n\n- HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。\n\n\n## 参考：\n\n- [HTTP cookies explained](https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/)\n- [Cookies and security](https://www.nczonline.net/blog/2009/05/12/cookies-and-security/)\n- [Simple cookie framework](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework)","source":"_posts/what-is-cookie.md","raw":"---\ntitle: 什么是cookie\ndate: 2017-11-05 18:43:13\ntags: cookie\ndesc: 什么是cookie\ntoc: true\ncategories:\n- 计算机网络\n---\n\n起源，因为HTTP的无状态，无法知道两个请求是来自同个人。\n\n由NetScape工程师Lou Montulli与1994发表。正式确定于[RFC2109](http://tools.ietf.org/html/rfc2109)，最终演变成[RFC2965](http://tools.ietf.org/html/rfc2965)\n\n<!-- more -->\n\n## Cookie为何物？\n\n简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。\n\n### 创建\n\n服务器通过`Set-Cookie`的HTTP头来设置：\n\n```\nSet-Cookie: <em>value</em>[; expires=<em>date</em>][; domain=<em>domain</em>][; path=<em>path</em>][; secure]\n```\n\n客户端将多个cookie通过`Cookie`的HTTP头来返回服务器：\n\n```\nCookie: value1; value2; name1=value1\n```\n\n> 多个value直接由一个分号和一个空格分隔开\n\n### value编码\n\n在普遍持有的观念中，value一定要是`URL-endcoed`编码的。\n\n其实这是个谬论，在文档中，明确指出只有`分号、逗号、空格`才需要编码。\n\n### expires\n\n设置过期时间。需要使用GMT格式的时间。\n\n\n```\nSet-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT\n```\n\n> 若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除\n\n> 校验的时间是以客户端的时间为准\n\n### domain\n\n指定什么域名请求时需要发送该cookie。\n\n> 采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)\n\n### path\n\n指定域名下的对应路径的请求才发送cookie。\n\n\n### secure\n\n有这个标志，cookie只会在HTTPS协议的请求发送该cookie。\n\n## 维护Cookie和周期\n\n修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。\n\n\n### 自动删除\n\n以下三个原因导致cookie被浏览器自动删除：\n\n- 会话结束自动删除\n- expires到期自动删除\n- 超过上线自动删除相对较旧的cookie\n\n## 其他限制\n\n- HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。\n\n\n## 参考：\n\n- [HTTP cookies explained](https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/)\n- [Cookies and security](https://www.nczonline.net/blog/2009/05/12/cookies-and-security/)\n- [Simple cookie framework](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework)","slug":"what-is-cookie","published":1,"updated":"2022-01-08T08:32:49.285Z","_id":"ckxvfmfb80004brqq4tlofoza","comments":1,"layout":"post","photos":[],"link":"","content":"<p>起源，因为HTTP的无状态，无法知道两个请求是来自同个人。</p>\n<p>由NetScape工程师Lou Montulli与1994发表。正式确定于<a href=\"http://tools.ietf.org/html/rfc2109\">RFC2109</a>，最终演变成<a href=\"http://tools.ietf.org/html/rfc2965\">RFC2965</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Cookie为何物？\"><a href=\"#Cookie为何物？\" class=\"headerlink\" title=\"Cookie为何物？\"></a>Cookie为何物？</h2><p>简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>服务器通过<code>Set-Cookie</code>的HTTP头来设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: &lt;em&gt;value&lt;/em&gt;[; expires=&lt;em&gt;date&lt;/em&gt;][; domain=&lt;em&gt;domain&lt;/em&gt;][; path=&lt;em&gt;path&lt;/em&gt;][; secure]</span><br></pre></td></tr></table></figure>\n\n<p>客户端将多个cookie通过<code>Cookie</code>的HTTP头来返回服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie: value1; value2; name1=value1</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>多个value直接由一个分号和一个空格分隔开</p>\n</blockquote>\n<h3 id=\"value编码\"><a href=\"#value编码\" class=\"headerlink\" title=\"value编码\"></a>value编码</h3><p>在普遍持有的观念中，value一定要是<code>URL-endcoed</code>编码的。</p>\n<p>其实这是个谬论，在文档中，明确指出只有<code>分号、逗号、空格</code>才需要编码。</p>\n<h3 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h3><p>设置过期时间。需要使用GMT格式的时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除</p>\n</blockquote>\n<blockquote>\n<p>校验的时间是以客户端的时间为准</p>\n</blockquote>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>指定什么域名请求时需要发送该cookie。</p>\n<blockquote>\n<p>采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)</p>\n</blockquote>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>指定域名下的对应路径的请求才发送cookie。</p>\n<h3 id=\"secure\"><a href=\"#secure\" class=\"headerlink\" title=\"secure\"></a>secure</h3><p>有这个标志，cookie只会在HTTPS协议的请求发送该cookie。</p>\n<h2 id=\"维护Cookie和周期\"><a href=\"#维护Cookie和周期\" class=\"headerlink\" title=\"维护Cookie和周期\"></a>维护Cookie和周期</h2><p>修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。</p>\n<h3 id=\"自动删除\"><a href=\"#自动删除\" class=\"headerlink\" title=\"自动删除\"></a>自动删除</h3><p>以下三个原因导致cookie被浏览器自动删除：</p>\n<ul>\n<li>会话结束自动删除</li>\n<li>expires到期自动删除</li>\n<li>超过上线自动删除相对较旧的cookie</li>\n</ul>\n<h2 id=\"其他限制\"><a href=\"#其他限制\" class=\"headerlink\" title=\"其他限制\"></a>其他限制</h2><ul>\n<li>HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/\">HTTP cookies explained</a></li>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/12/cookies-and-security/\">Cookies and security</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework\">Simple cookie framework</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>起源，因为HTTP的无状态，无法知道两个请求是来自同个人。</p>\n<p>由NetScape工程师Lou Montulli与1994发表。正式确定于<a href=\"http://tools.ietf.org/html/rfc2109\">RFC2109</a>，最终演变成<a href=\"http://tools.ietf.org/html/rfc2965\">RFC2965</a></p>","more":"<h2 id=\"Cookie为何物？\"><a href=\"#Cookie为何物？\" class=\"headerlink\" title=\"Cookie为何物？\"></a>Cookie为何物？</h2><p>简单说，就是一个简单的纯文本。服务器可根据这个文本来区别每个独立的用户。因此，cookie经常被应用于登录和信息校验。</p>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>服务器通过<code>Set-Cookie</code>的HTTP头来设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: &lt;em&gt;value&lt;/em&gt;[; expires=&lt;em&gt;date&lt;/em&gt;][; domain=&lt;em&gt;domain&lt;/em&gt;][; path=&lt;em&gt;path&lt;/em&gt;][; secure]</span><br></pre></td></tr></table></figure>\n\n<p>客户端将多个cookie通过<code>Cookie</code>的HTTP头来返回服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie: value1; value2; name1=value1</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>多个value直接由一个分号和一个空格分隔开</p>\n</blockquote>\n<h3 id=\"value编码\"><a href=\"#value编码\" class=\"headerlink\" title=\"value编码\"></a>value编码</h3><p>在普遍持有的观念中，value一定要是<code>URL-endcoed</code>编码的。</p>\n<p>其实这是个谬论，在文档中，明确指出只有<code>分号、逗号、空格</code>才需要编码。</p>\n<h3 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h3><p>设置过期时间。需要使用GMT格式的时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>若没设置时间，则一个会话周期（即关闭浏览器）就会自动被删除</p>\n</blockquote>\n<blockquote>\n<p>校验的时间是以客户端的时间为准</p>\n</blockquote>\n<h3 id=\"domain\"><a href=\"#domain\" class=\"headerlink\" title=\"domain\"></a>domain</h3><p>指定什么域名请求时需要发送该cookie。</p>\n<blockquote>\n<p>采用尾校验，即子域名也会发送(domain=yahoo.com，在my.yahoo.com也会发送)</p>\n</blockquote>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><p>指定域名下的对应路径的请求才发送cookie。</p>\n<h3 id=\"secure\"><a href=\"#secure\" class=\"headerlink\" title=\"secure\"></a>secure</h3><p>有这个标志，cookie只会在HTTPS协议的请求发送该cookie。</p>\n<h2 id=\"维护Cookie和周期\"><a href=\"#维护Cookie和周期\" class=\"headerlink\" title=\"维护Cookie和周期\"></a>维护Cookie和周期</h2><p>修改对应的值，需要保持其他的值不变才能修改成功。不然就等于新增了一个cookie。</p>\n<h3 id=\"自动删除\"><a href=\"#自动删除\" class=\"headerlink\" title=\"自动删除\"></a>自动删除</h3><p>以下三个原因导致cookie被浏览器自动删除：</p>\n<ul>\n<li>会话结束自动删除</li>\n<li>expires到期自动删除</li>\n<li>超过上线自动删除相对较旧的cookie</li>\n</ul>\n<h2 id=\"其他限制\"><a href=\"#其他限制\" class=\"headerlink\" title=\"其他限制\"></a>其他限制</h2><ul>\n<li>HTTP-Only: 这个将使浏览器无法使用JavaScript访问该cookie。</li>\n</ul>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/\">HTTP cookies explained</a></li>\n<li><a href=\"https://www.nczonline.net/blog/2009/05/12/cookies-and-security/\">Cookies and security</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie/Simple_document.cookie_framework\">Simple cookie framework</a></li>\n</ul>"},{"title":"使用Web Storage API","date":"2017-08-07T15:20:31.000Z","desc":"localStorage的使用与分析","toc":true,"_content":"\n其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。\n\n<!-- more -->\n\n> 说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。\n\n### MDN\n\n要探究Web API，首先就想到[MDN](https://developer.mozilla.org/en-US/)。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！\n\n#### 中英文版本的差异\n\n中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。\n\n比如：\n\n- 我们可以像访问对象一样来访问Storage\n```js\nlocalStorage.colorSetting = '#a4509b';\nlocalStorage['colorSetting'] = '#a4509b';\nlocalStorage.setItem('colorSetting', '#a4509b');\n```\n但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下[《The pitfalls of using objects as maps in JavaScript》](http://2ality.com/2012/01/objects-as-maps.html)。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。\n\n- 可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：\n```js\nfunction storageAvailable() {\n    try {\n        const mod = '__storage__test__'\n        localStorage.setItem(mod, mod);\n        localStorage.removeItem(mod);\n        return true;\n    } catch(e) {\n        return false;\n    }\n}\n```\n附上一个[Storage可用性检测函数的简要历史](https://gist.github.com/paulirish/5558557)\n\n### 基本概念\n\nWeb Storage提供了两种机制让我们实现离线存储：\n- localStorage\n- sessionStorage\n\n其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。\n\n另外需要注意的是，两种机制都是在**每个独立域名**下**分开独立存储数据**的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)\n\n意思就是，在`a.com`下无法访问到`b.com`的storage数据，当然这是基于安全性的考虑。\n\n### 跨域\n\n跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用`Access-Control-Allow-origin`解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。\n\n由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的`postMessage`方法：\n\n首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考[annn.me](http://annn.me/cross-domain-local-storage/)的流程图如下：\n\n![](http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg)\n\ngithub上已有一个比较完备的类库可以参考：[cross-storage](https://github.com/zendesk/cross-storage)","source":"_posts/using-web-storage-api.md","raw":"---\ntitle: 使用Web Storage API\ndate: 2017-08-07 23:20:31\ntags:\n- JavaScript\n- Storage\ndesc: localStorage的使用与分析\ntoc: true\ncategories:\n- [前端, 基础]\n- 浏览器\n---\n\n其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。\n\n<!-- more -->\n\n> 说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。\n\n### MDN\n\n要探究Web API，首先就想到[MDN](https://developer.mozilla.org/en-US/)。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！\n\n#### 中英文版本的差异\n\n中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。\n\n比如：\n\n- 我们可以像访问对象一样来访问Storage\n```js\nlocalStorage.colorSetting = '#a4509b';\nlocalStorage['colorSetting'] = '#a4509b';\nlocalStorage.setItem('colorSetting', '#a4509b');\n```\n但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下[《The pitfalls of using objects as maps in JavaScript》](http://2ality.com/2012/01/objects-as-maps.html)。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。\n\n- 可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：\n```js\nfunction storageAvailable() {\n    try {\n        const mod = '__storage__test__'\n        localStorage.setItem(mod, mod);\n        localStorage.removeItem(mod);\n        return true;\n    } catch(e) {\n        return false;\n    }\n}\n```\n附上一个[Storage可用性检测函数的简要历史](https://gist.github.com/paulirish/5558557)\n\n### 基本概念\n\nWeb Storage提供了两种机制让我们实现离线存储：\n- localStorage\n- sessionStorage\n\n其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。\n\n另外需要注意的是，两种机制都是在**每个独立域名**下**分开独立存储数据**的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)\n\n意思就是，在`a.com`下无法访问到`b.com`的storage数据，当然这是基于安全性的考虑。\n\n### 跨域\n\n跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用`Access-Control-Allow-origin`解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。\n\n由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的`postMessage`方法：\n\n首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考[annn.me](http://annn.me/cross-domain-local-storage/)的流程图如下：\n\n![](http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg)\n\ngithub上已有一个比较完备的类库可以参考：[cross-storage](https://github.com/zendesk/cross-storage)","slug":"using-web-storage-api","published":1,"updated":"2022-01-08T08:35:46.153Z","_id":"ckxvfmfbe000cbrqq06fa8psr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。</p>\n</blockquote>\n<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p>要探究Web API，首先就想到<a href=\"https://developer.mozilla.org/en-US/\">MDN</a>。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！</p>\n<h4 id=\"中英文版本的差异\"><a href=\"#中英文版本的差异\" class=\"headerlink\" title=\"中英文版本的差异\"></a>中英文版本的差异</h4><p>中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。</p>\n<p>比如：</p>\n<ul>\n<li><p>我们可以像访问对象一样来访问Storage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">localStorage</span>.colorSetting = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>[<span class=\"string\">&#x27;colorSetting&#x27;</span>] = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>.setItem(<span class=\"string\">&#x27;colorSetting&#x27;</span>, <span class=\"string\">&#x27;#a4509b&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下<a href=\"http://2ality.com/2012/01/objects-as-maps.html\">《The pitfalls of using objects as maps in JavaScript》</a>。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。</p>\n</li>\n<li><p>可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">storageAvailable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> mod = <span class=\"string\">&#x27;__storage__test__&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.setItem(mod, mod);</span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.removeItem(mod);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附上一个<a href=\"https://gist.github.com/paulirish/5558557\">Storage可用性检测函数的简要历史</a></p>\n</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>Web Storage提供了两种机制让我们实现离线存储：</p>\n<ul>\n<li>localStorage</li>\n<li>sessionStorage</li>\n</ul>\n<p>其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。</p>\n<p>另外需要注意的是，两种机制都是在<strong>每个独立域名</strong>下<strong>分开独立存储数据</strong>的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)</p>\n<p>意思就是，在<code>a.com</code>下无法访问到<code>b.com</code>的storage数据，当然这是基于安全性的考虑。</p>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用<code>Access-Control-Allow-origin</code>解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。</p>\n<p>由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的<code>postMessage</code>方法：</p>\n<p>首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考<a href=\"http://annn.me/cross-domain-local-storage/\">annn.me</a>的流程图如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg\"></p>\n<p>github上已有一个比较完备的类库可以参考：<a href=\"https://github.com/zendesk/cross-storage\">cross-storage</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>其实这是很简单的一个API。但这个API也存在不少问题可以深究一下。</p>","more":"<blockquote>\n<p>说到这个API，我就想起曾经一次面试：当时面试我的CTO拿出自己的iPhone6，打开一个网址，说这个页面在其他所有的手机都没问题，偏偏就是我的手机无法访问。我一瞧，果然一片空白，然后我敏锐地发现他的浏览器开启了隐私模式，我马上就猜到这是隐私模式下设置Storage的问题。和CTO扯了一些关于Storage API的知识后，关掉隐私模式果然没问题。</p>\n</blockquote>\n<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p>要探究Web API，首先就想到<a href=\"https://developer.mozilla.org/en-US/\">MDN</a>。因为平常习惯了中文阅读，所以也自然而然地打开中文语言。然而我脑袋一转，觉得这么简单的API阅读英文应该也是比较简单的吧，而且还可以顺便对比一下中英文版本练练自己的翻译。然而这个偶然的动作让我发现了英语阅读是多么地重要！</p>\n<h4 id=\"中英文版本的差异\"><a href=\"#中英文版本的差异\" class=\"headerlink\" title=\"中英文版本的差异\"></a>中英文版本的差异</h4><p>中文版本漏翻译了许多部分（有些还是很重要的），我觉得这估计是选择性翻译导致的问题。</p>\n<p>比如：</p>\n<ul>\n<li><p>我们可以像访问对象一样来访问Storage</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">localStorage</span>.colorSetting = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>[<span class=\"string\">&#x27;colorSetting&#x27;</span>] = <span class=\"string\">&#x27;#a4509b&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>.setItem(<span class=\"string\">&#x27;colorSetting&#x27;</span>, <span class=\"string\">&#x27;#a4509b&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>但是，不推荐这样使用，因为会有可能读取到Storage原型链上的属性，还有一些可能会遇到的“陷阱”，有一篇相关的阅读可以看一下<a href=\"http://2ality.com/2012/01/objects-as-maps.html\">《The pitfalls of using objects as maps in JavaScript》</a>。译者忽略这段内容，估计是觉得既然不推荐这样使用，就干脆不告诉你了。虽然这部分内容对使用这个API没什么帮助，但是它关联到了一些重要的其他JavaScript知识。</p>\n</li>\n<li><p>可用性检测。这个是很重要的一点，和我前面提到的那个故事有着密切的联系。因为在使用storage API的时候，我们需要检测一下当前环境这个API是否可用，如果不可用还继续使用的话，用户代理（一般就指浏览器）会抛出异常。如果是SPA(single page application)的话就会出现我前面那个故事一样的结果——白屏。而且MDN还提供了一个可用性检测的函数，不过这里我要推荐的是另一个写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">storageAvailable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> mod = <span class=\"string\">&#x27;__storage__test__&#x27;</span></span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.setItem(mod, mod);</span><br><span class=\"line\">        <span class=\"built_in\">localStorage</span>.removeItem(mod);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>附上一个<a href=\"https://gist.github.com/paulirish/5558557\">Storage可用性检测函数的简要历史</a></p>\n</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>Web Storage提供了两种机制让我们实现离线存储：</p>\n<ul>\n<li>localStorage</li>\n<li>sessionStorage</li>\n</ul>\n<p>其中，sessionStorage会存储数据，直到浏览器关闭才销毁数据。而localStorage则是持久式存储。</p>\n<p>另外需要注意的是，两种机制都是在<strong>每个独立域名</strong>下<strong>分开独立存储数据</strong>的。也就是浏览器的同源策略(相同协议；相同域名；相同端口)</p>\n<p>意思就是，在<code>a.com</code>下无法访问到<code>b.com</code>的storage数据，当然这是基于安全性的考虑。</p>\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>跨域是前端开发（面试）常遇到的问题。说到这个本人就好苦恼了，因为实际开发遇到的跨域问题，受到各种（后端）限制，通常简单地使用<code>Access-Control-Allow-origin</code>解决。因此跨域的问题真心没什么总结和心得，只能强行看人家的心得，来再次吸收与总结了。</p>\n<p>由于同源策略的限制，相同主域名，不同子域名的页面的storage都不能互相访问，因此要实现跨域访问的话，就必须采用其他的办法，比如HTML5提出的<code>postMessage</code>方法：</p>\n<p>首先设置一个控制中心hub，负责写入／读取／删除 storage。其他要相互交互的域名就都通过iframe引入这个hub，通过postMessage和hub交互，达到读写storage的目的。参考<a href=\"http://annn.me/cross-domain-local-storage/\">annn.me</a>的流程图如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6a47a305ly1fibkidw034j20si09x3z4.jpg\"></p>\n<p>github上已有一个比较完备的类库可以参考：<a href=\"https://github.com/zendesk/cross-storage\">cross-storage</a></p>"},{"title":"初用 Vue.js 的一些心得","date":"2017-05-19T12:40:03.000Z","desc":"summary of vuejs","toc":true,"_content":"\n其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。\n\n期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。\n\n<!-- more -->\n\n## input\n\ntype类型的选择\n\n### 初始版本\n\n```vue\n<template v-if=\"type === 'number'\">\n    <input type=\"number\" />\n</template>\n<template v-else-if=\"type === 'tel'\">\n    <input type=\"tel\" />\n</template>\n<template v-else>\n    <input type=\"text\" />\n</template>\n```\n\n原因：避免使用非法类型\n\n### 最终版本\n\n```vue\n<input :type=\"type\"/>\n\n<script type=\"es6\">\nexport default {\n    props: {\n        type: {\n            type: 'string',\n            default: 'text',\n            validator(type){\n                return ['password', 'tel', 'number'].indexOf(type) > -1\n            }\n        }\n    }\n}\n</script>\n```\n\n### 同步校验与异步校验\n\n#### 同步校验\n\ninput事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。\n\n#### 异步校验\n\n因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。\n\n```js\n\nexport default {\n    props: {\n        verify: { // 验证规则 {rule: '规则', errMsg: '错误信息提示'}\n            type: Object,\n            'validator'(value) {\n              return value.rule \n                && (value.rule instanceof RegExp || typeof value.rule === 'string')\n            }\n        },\n        asyncVerify: String, // 异步验证规则（URL地址）\n    },\n    methods: {\n        async validate() {\n\n            const {verify, inValue, asyncVerify} = this\n\n            let isValid\n\n            // 存在验证规则\n            if (verify) {\n\n              const {rule, errMsg} = verify\n\n              // 正则的验证规则\n              if (rule instanceof RegExp) {\n                isValid = rule.test(inValue)\n              }\n\n              // 字符串型内置类型验证\n              else if (typeof rule === 'string') {\n                switch (rule) {\n                  case 'tel':\n                    isValid = /^1[34578]\\d{9}$/.test(inValue)\n                    break\n\n                  case 'password':\n                    isValid = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]{6,12}$/.test(inValue)\n                    break\n\n                  case 'telCaptcha':\n                    isValid = /^\\d{6}$/.test(inValue)\n                    break\n\n                  case 'imgCaptcha':\n                    isValid = /^\\S{4}$/.test(inValue)\n                    break\n\n                  default:\n                  // no default\n                }\n              }\n\n              if (!isValid) {\n                this.$emit('show-error', errMsg || '格式错误')\n                return\n              }\n            }\n            \n\n            // 存在异步校验\n            if (asyncVerify) {\n              \n            }\n            \n      }\n    }\n}\n```\n\n## 数据流动问题\n\n### 情况\n\n一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError\n\n### 问题\n\n父元素传递'first error'，子元素自产生'second error'，此时父再传'first error'，子元素就会忽略，因为父元素传递的数据还没改变还是'first error'。\n\n### 解决\n\nA方法：子元素不自己产生childError，统一`$emit`发送给父元素，然后才传递给子元素\n\nB方法：父元素传递的数据，前缀加计数器以区别每次传递的数据\n\n## 错误信息往上传递\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" />\n\nshowError(error) {\n    // error = 谁的错误信息? 用户名 or 密码\n}\n\n```\n\n- A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可\n- B方法：使用curry化函数\n\n### A方法\n\n```js\n// bd-input\nthis.$emit('show-error', JSON.stringify([token, '出错了!']) )\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" token=\"username\"/>\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" token=\"password\"/>\n\nshowError(errObj) {\n    parsedErrObj = JSON.parse(errObj)\n\n    token = parsedErrObj[0] // 错误信息的宿主\n    error = parsedErrObj[1]\n}\n```\n\n### B方法\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"curryShowError('username')\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"curryShowError('password')\" type=\"password\" />\n\ncurryShowError(token) {\n    return function(error){\n\n    }\n}\n```\n\n\n","source":"_posts/summary-of-vuejs.md","raw":"---\ntitle: 初用 Vue.js 的一些心得\ndate: 2017-5-19 20:40:03\ntags: \n- vue\ndesc: summary of vuejs\ntoc: true\ncategories:\n- vue\n---\n\n其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。\n\n期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。\n\n<!-- more -->\n\n## input\n\ntype类型的选择\n\n### 初始版本\n\n```vue\n<template v-if=\"type === 'number'\">\n    <input type=\"number\" />\n</template>\n<template v-else-if=\"type === 'tel'\">\n    <input type=\"tel\" />\n</template>\n<template v-else>\n    <input type=\"text\" />\n</template>\n```\n\n原因：避免使用非法类型\n\n### 最终版本\n\n```vue\n<input :type=\"type\"/>\n\n<script type=\"es6\">\nexport default {\n    props: {\n        type: {\n            type: 'string',\n            default: 'text',\n            validator(type){\n                return ['password', 'tel', 'number'].indexOf(type) > -1\n            }\n        }\n    }\n}\n</script>\n```\n\n### 同步校验与异步校验\n\n#### 同步校验\n\ninput事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。\n\n#### 异步校验\n\n因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。\n\n```js\n\nexport default {\n    props: {\n        verify: { // 验证规则 {rule: '规则', errMsg: '错误信息提示'}\n            type: Object,\n            'validator'(value) {\n              return value.rule \n                && (value.rule instanceof RegExp || typeof value.rule === 'string')\n            }\n        },\n        asyncVerify: String, // 异步验证规则（URL地址）\n    },\n    methods: {\n        async validate() {\n\n            const {verify, inValue, asyncVerify} = this\n\n            let isValid\n\n            // 存在验证规则\n            if (verify) {\n\n              const {rule, errMsg} = verify\n\n              // 正则的验证规则\n              if (rule instanceof RegExp) {\n                isValid = rule.test(inValue)\n              }\n\n              // 字符串型内置类型验证\n              else if (typeof rule === 'string') {\n                switch (rule) {\n                  case 'tel':\n                    isValid = /^1[34578]\\d{9}$/.test(inValue)\n                    break\n\n                  case 'password':\n                    isValid = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]{6,12}$/.test(inValue)\n                    break\n\n                  case 'telCaptcha':\n                    isValid = /^\\d{6}$/.test(inValue)\n                    break\n\n                  case 'imgCaptcha':\n                    isValid = /^\\S{4}$/.test(inValue)\n                    break\n\n                  default:\n                  // no default\n                }\n              }\n\n              if (!isValid) {\n                this.$emit('show-error', errMsg || '格式错误')\n                return\n              }\n            }\n            \n\n            // 存在异步校验\n            if (asyncVerify) {\n              \n            }\n            \n      }\n    }\n}\n```\n\n## 数据流动问题\n\n### 情况\n\n一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError\n\n### 问题\n\n父元素传递'first error'，子元素自产生'second error'，此时父再传'first error'，子元素就会忽略，因为父元素传递的数据还没改变还是'first error'。\n\n### 解决\n\nA方法：子元素不自己产生childError，统一`$emit`发送给父元素，然后才传递给子元素\n\nB方法：父元素传递的数据，前缀加计数器以区别每次传递的数据\n\n## 错误信息往上传递\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" />\n\nshowError(error) {\n    // error = 谁的错误信息? 用户名 or 密码\n}\n\n```\n\n- A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可\n- B方法：使用curry化函数\n\n### A方法\n\n```js\n// bd-input\nthis.$emit('show-error', JSON.stringify([token, '出错了!']) )\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"showError\" type=\"text\" token=\"username\"/>\n\n// 密码\n<bd-input @show-error=\"showError\" type=\"password\" token=\"password\"/>\n\nshowError(errObj) {\n    parsedErrObj = JSON.parse(errObj)\n\n    token = parsedErrObj[0] // 错误信息的宿主\n    error = parsedErrObj[1]\n}\n```\n\n### B方法\n\n```js\n// bd-input\nthis.$emit('show-error', '出错了!')\n\n// 父组件\n\n// 用户名\n<bd-input @show-error=\"curryShowError('username')\" type=\"text\" />\n\n// 密码\n<bd-input @show-error=\"curryShowError('password')\" type=\"password\" />\n\ncurryShowError(token) {\n    return function(error){\n\n    }\n}\n```\n\n\n","slug":"summary-of-vuejs","published":1,"updated":"2023-08-04T12:03:14.856Z","_id":"ckxvfmfc8000kbrqqddkn36p5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。</p>\n<p>期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h2><p>type类型的选择</p>\n<h3 id=\"初始版本\"><a href=\"#初始版本\" class=\"headerlink\" title=\"初始版本\"></a>初始版本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-if=&quot;type === &#x27;number&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;number&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else-if=&quot;type === &#x27;tel&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;tel&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p>原因：避免使用非法类型</p>\n<h3 id=\"最终版本\"><a href=\"#最终版本\" class=\"headerlink\" title=\"最终版本\"></a>最终版本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input :type=&quot;type&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;es6&quot;&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        type: &#123;</span><br><span class=\"line\">            type: &#x27;string&#x27;,</span><br><span class=\"line\">            default: &#x27;text&#x27;,</span><br><span class=\"line\">            validator(type)&#123;</span><br><span class=\"line\">                return [&#x27;password&#x27;, &#x27;tel&#x27;, &#x27;number&#x27;].indexOf(type) &gt; -1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步校验与异步校验\"><a href=\"#同步校验与异步校验\" class=\"headerlink\" title=\"同步校验与异步校验\"></a>同步校验与异步校验</h3><h4 id=\"同步校验\"><a href=\"#同步校验\" class=\"headerlink\" title=\"同步校验\"></a>同步校验</h4><p>input事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。</p>\n<h4 id=\"异步校验\"><a href=\"#异步校验\" class=\"headerlink\" title=\"异步校验\"></a>异步校验</h4><p>因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">verify</span>: &#123; <span class=\"comment\">// 验证规则 &#123;rule: &#x27;规则&#x27;, errMsg: &#x27;错误信息提示&#x27;&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;validator&#x27;</span>(value) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> value.rule </span><br><span class=\"line\">                &amp;&amp; (value.rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span> || <span class=\"keyword\">typeof</span> value.rule === <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">asyncVerify</span>: <span class=\"built_in\">String</span>, <span class=\"comment\">// 异步验证规则（URL地址）</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">validate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123;verify, inValue, asyncVerify&#125; = <span class=\"built_in\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isValid</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在验证规则</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (verify) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">const</span> &#123;rule, errMsg&#125; = verify</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 正则的验证规则</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span>) &#123;</span><br><span class=\"line\">                isValid = rule.test(inValue)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 字符串型内置类型验证</span></span><br><span class=\"line\">              <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> rule === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (rule) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;tel&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^1[34578]\\d&#123;9&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;password&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]&#123;6,12&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;telCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\d&#123;6&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;imgCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\S&#123;4&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"attr\">default</span>:</span><br><span class=\"line\">                  <span class=\"comment\">// no default</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, errMsg || <span class=\"string\">&#x27;格式错误&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在异步校验</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (asyncVerify) &#123;</span><br><span class=\"line\">              </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据流动问题\"><a href=\"#数据流动问题\" class=\"headerlink\" title=\"数据流动问题\"></a>数据流动问题</h2><h3 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h3><p>一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>父元素传递’first error’，子元素自产生’second error’，此时父再传’first error’，子元素就会忽略，因为父元素传递的数据还没改变还是’first error’。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>A方法：子元素不自己产生childError，统一<code>$emit</code>发送给父元素，然后才传递给子元素</p>\n<p>B方法：父元素传递的数据，前缀加计数器以区别每次传递的数据</p>\n<h2 id=\"错误信息往上传递\"><a href=\"#错误信息往上传递\" class=\"headerlink\" title=\"错误信息往上传递\"></a>错误信息往上传递</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">error</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error = 谁的错误信息? 用户名 or 密码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可</li>\n<li>B方法：使用curry化函数</li>\n</ul>\n<h3 id=\"A方法\"><a href=\"#A方法\" class=\"headerlink\" title=\"A方法\"></a>A方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"built_in\">JSON</span>.stringify([token, <span class=\"string\">&#x27;出错了!&#x27;</span>]) )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> token=<span class=\"string\">&quot;username&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">token</span>=<span class=\"string\">&quot;password&quot;</span>/&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">errObj</span>)</span> &#123;</span><br><span class=\"line\">    parsedErrObj = <span class=\"built_in\">JSON</span>.parse(errObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    token = parsedErrObj[<span class=\"number\">0</span>] <span class=\"comment\">// 错误信息的宿主</span></span><br><span class=\"line\">    error = parsedErrObj[<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"B方法\"><a href=\"#B方法\" class=\"headerlink\" title=\"B方法\"></a>B方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;curryShowError(&#x27;username&#x27;)&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;curryShowError(&#x27;password&#x27;)&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">curryShowError</span>(<span class=\"params\">token</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>其实很多框架发展到后面，都是非常类似的。以前写过React，所以对Vue.js还是能比较快速地上手的。</p>\n<p>期间，遇到了不少问题，整理了一下，就和大家分享一下阁下小小的见解。</p>","more":"<h2 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h2><p>type类型的选择</p>\n<h3 id=\"初始版本\"><a href=\"#初始版本\" class=\"headerlink\" title=\"初始版本\"></a>初始版本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template v-if=&quot;type === &#x27;number&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;number&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else-if=&quot;type === &#x27;tel&#x27;&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;tel&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;template v-else&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; /&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p>原因：避免使用非法类型</p>\n<h3 id=\"最终版本\"><a href=\"#最终版本\" class=\"headerlink\" title=\"最终版本\"></a>最终版本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input :type=&quot;type&quot;/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;es6&quot;&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        type: &#123;</span><br><span class=\"line\">            type: &#x27;string&#x27;,</span><br><span class=\"line\">            default: &#x27;text&#x27;,</span><br><span class=\"line\">            validator(type)&#123;</span><br><span class=\"line\">                return [&#x27;password&#x27;, &#x27;tel&#x27;, &#x27;number&#x27;].indexOf(type) &gt; -1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步校验与异步校验\"><a href=\"#同步校验与异步校验\" class=\"headerlink\" title=\"同步校验与异步校验\"></a>同步校验与异步校验</h3><h4 id=\"同步校验\"><a href=\"#同步校验\" class=\"headerlink\" title=\"同步校验\"></a>同步校验</h4><p>input事件触发的时候，实时校验然后输出错误信息，blur事件触发的时候展示错误信息。</p>\n<h4 id=\"异步校验\"><a href=\"#异步校验\" class=\"headerlink\" title=\"异步校验\"></a>异步校验</h4><p>因为存在HTTP延迟，所以不能实时触发，就在同步校验成功之后才触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">props</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">verify</span>: &#123; <span class=\"comment\">// 验证规则 &#123;rule: &#x27;规则&#x27;, errMsg: &#x27;错误信息提示&#x27;&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;validator&#x27;</span>(value) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> value.rule </span><br><span class=\"line\">                &amp;&amp; (value.rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span> || <span class=\"keyword\">typeof</span> value.rule === <span class=\"string\">&#x27;string&#x27;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">asyncVerify</span>: <span class=\"built_in\">String</span>, <span class=\"comment\">// 异步验证规则（URL地址）</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">validate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123;verify, inValue, asyncVerify&#125; = <span class=\"built_in\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isValid</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在验证规则</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (verify) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">const</span> &#123;rule, errMsg&#125; = verify</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 正则的验证规则</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (rule <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RegExp</span>) &#123;</span><br><span class=\"line\">                isValid = rule.test(inValue)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"comment\">// 字符串型内置类型验证</span></span><br><span class=\"line\">              <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> rule === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (rule) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;tel&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^1[34578]\\d&#123;9&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;password&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9a-zA-Z]&#123;6,12&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;telCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\d&#123;6&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">case</span> <span class=\"string\">&#x27;imgCaptcha&#x27;</span>:</span><br><span class=\"line\">                    isValid = <span class=\"regexp\">/^\\S&#123;4&#125;$/</span>.test(inValue)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"attr\">default</span>:</span><br><span class=\"line\">                  <span class=\"comment\">// no default</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, errMsg || <span class=\"string\">&#x27;格式错误&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 存在异步校验</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (asyncVerify) &#123;</span><br><span class=\"line\">              </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据流动问题\"><a href=\"#数据流动问题\" class=\"headerlink\" title=\"数据流动问题\"></a>数据流动问题</h2><h3 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h3><p>一个父元素，一个子元素。父元素传递parentError给子元素，子元素自己也可以产生childError</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>父元素传递’first error’，子元素自产生’second error’，此时父再传’first error’，子元素就会忽略，因为父元素传递的数据还没改变还是’first error’。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>A方法：子元素不自己产生childError，统一<code>$emit</code>发送给父元素，然后才传递给子元素</p>\n<p>B方法：父元素传递的数据，前缀加计数器以区别每次传递的数据</p>\n<h2 id=\"错误信息往上传递\"><a href=\"#错误信息往上传递\" class=\"headerlink\" title=\"错误信息往上传递\"></a>错误信息往上传递</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">error</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error = 谁的错误信息? 用户名 or 密码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>A方法：给bd-input传入一个token，然后传错误信息的时候，把token带上即可</li>\n<li>B方法：使用curry化函数</li>\n</ul>\n<h3 id=\"A方法\"><a href=\"#A方法\" class=\"headerlink\" title=\"A方法\"></a>A方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"built_in\">JSON</span>.stringify([token, <span class=\"string\">&#x27;出错了!&#x27;</span>]) )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;showError&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> token=<span class=\"string\">&quot;username&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;showError&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">token</span>=<span class=\"string\">&quot;password&quot;</span>/&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">showError</span>(<span class=\"params\">errObj</span>)</span> &#123;</span><br><span class=\"line\">    parsedErrObj = <span class=\"built_in\">JSON</span>.parse(errObj)</span><br><span class=\"line\"></span><br><span class=\"line\">    token = parsedErrObj[<span class=\"number\">0</span>] <span class=\"comment\">// 错误信息的宿主</span></span><br><span class=\"line\">    error = parsedErrObj[<span class=\"number\">1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"B方法\"><a href=\"#B方法\" class=\"headerlink\" title=\"B方法\"></a>B方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bd-input</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;show-error&#x27;</span>, <span class=\"string\">&#x27;出错了!&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户名</span></span><br><span class=\"line\">&lt;bd-input @show-error=<span class=\"string\">&quot;curryShowError(&#x27;username&#x27;)&quot;</span> type=<span class=\"string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 密码</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">bd-input</span> @<span class=\"attr\">show-error</span>=<span class=\"string\">&quot;curryShowError(&#x27;password&#x27;)&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> /&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">curryShowError</span>(<span class=\"params\">token</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"关于事件绑定的一些知识","date":"2016-11-24T15:45:59.000Z","desc":null,"toc":true,"categores":[["前端","基础"],"浏览器"],"_content":"\n前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：\n\n<!-- more -->\n\n现在有一段HTML\n\n```html\n<ul id=\"list\">\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n```\n\n点击`li`的时候`alert`弹出`li`里面的文本内容，离开`ul`时`alert`提醒。\n\n注意，需要考虑性能和兼容性问题。\n\n### 分析点击事件\n\n首先，大家都知道的是，在`IE`下绑定事件是使用`attachEvent`的，而不是`addEventListener`，因此可以封装一个方法来绑定事件：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n```\n\n需要注意的是，使用`attachEvent`时，事件类型都是需要加个`on`前缀的。还有就是因为`attachEvent`是将事件绑定在冒泡阶段的，为了保持一致，所以使用`addEventListener`时，需指定第三个参数为false，否则就添加到事件捕获阶段了。\n\n其次，不能给每个`li`绑定事件，可以利用事件的冒泡机制，故需把事件绑定到`ul`上而不是`li`上。\n\n此时要拿到真正的`li`就要读取事件(event)的真实对象(target)了，这也是一个考察点：\n\n- 在IE上，事件(event)要需要通过`window.event`获取的。\n\n- 在IE上，事件对象(event target)的值是`event.srcElement`而不是`event.target`\n\n因此绑定点击事件的完整代码是这样的：\n\n```js\nvar list = document.getElementById('list')\n\naddEvent(list, 'click', function(event){\n  event = event || window.event;\n  var target = event.target || event.srcElement;\n  \n  alert(target.innerHTML)\n})\n```\n\n### 分析鼠标移开事件\n\n其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用`mouseout`事件就完了。然而这里隐藏了一个问题：就是当鼠标移入`ul`的子元素`li`时，也会触发`mouseout`事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。\n\n然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。\n\n在现代浏览器(`chrome`，`firefox`，`safari`等等)上，我们直接用`event.relatedTarget`就可以直接获取；而在IE上则比较繁琐，`mouseout`事件有一个叫`toElement`的元素（顾名思义就是鼠标移到了哪个元素），`mouseover`事件则有一个叫`fromElement`元素。\n\n因此，我们可以这么做：\n\n```js\n addEvent(list, 'mouseout', function(event){\n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n  if(!list.contains(t)) {\n    alert('!')\n  }\n})\n```\n\n### 取消冒泡\n\n其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。\n\n因为我们没有处理`list.contains(t)`的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：\n\n－ `IE`取消冒泡的方法是`event.cancelBubble = true`\n\n- 在符合`w3c`标准的浏览器上，则是使用`event.stopPropagation()`\n\n最终的代码是这样的：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n\nvar list = document.getElementById('list');\n\naddEvent(list, 'mouseout', function(event){\n  \n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n\n  if(list.contains(t)) {\n    event.cancelBubble = true;\n    event.stopPropagation();\n  }\n  else {\n    alert('你正在离开list!')\n  }\n})\n```\n","source":"_posts/some-summarize-about-event.md","raw":"---\ntitle: 关于事件绑定的一些知识\ndate: 2016-11-24 23:45:59\ntags:\n- JavaScript\n- 事件\ndesc:\ntoc: true\ncategores:\n- [前端, 基础]\n- 浏览器\n---\n\n前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：\n\n<!-- more -->\n\n现在有一段HTML\n\n```html\n<ul id=\"list\">\n  <li>a</li>\n  <li>b</li>\n  <li>c</li>\n</ul>\n```\n\n点击`li`的时候`alert`弹出`li`里面的文本内容，离开`ul`时`alert`提醒。\n\n注意，需要考虑性能和兼容性问题。\n\n### 分析点击事件\n\n首先，大家都知道的是，在`IE`下绑定事件是使用`attachEvent`的，而不是`addEventListener`，因此可以封装一个方法来绑定事件：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n```\n\n需要注意的是，使用`attachEvent`时，事件类型都是需要加个`on`前缀的。还有就是因为`attachEvent`是将事件绑定在冒泡阶段的，为了保持一致，所以使用`addEventListener`时，需指定第三个参数为false，否则就添加到事件捕获阶段了。\n\n其次，不能给每个`li`绑定事件，可以利用事件的冒泡机制，故需把事件绑定到`ul`上而不是`li`上。\n\n此时要拿到真正的`li`就要读取事件(event)的真实对象(target)了，这也是一个考察点：\n\n- 在IE上，事件(event)要需要通过`window.event`获取的。\n\n- 在IE上，事件对象(event target)的值是`event.srcElement`而不是`event.target`\n\n因此绑定点击事件的完整代码是这样的：\n\n```js\nvar list = document.getElementById('list')\n\naddEvent(list, 'click', function(event){\n  event = event || window.event;\n  var target = event.target || event.srcElement;\n  \n  alert(target.innerHTML)\n})\n```\n\n### 分析鼠标移开事件\n\n其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用`mouseout`事件就完了。然而这里隐藏了一个问题：就是当鼠标移入`ul`的子元素`li`时，也会触发`mouseout`事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。\n\n然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。\n\n在现代浏览器(`chrome`，`firefox`，`safari`等等)上，我们直接用`event.relatedTarget`就可以直接获取；而在IE上则比较繁琐，`mouseout`事件有一个叫`toElement`的元素（顾名思义就是鼠标移到了哪个元素），`mouseover`事件则有一个叫`fromElement`元素。\n\n因此，我们可以这么做：\n\n```js\n addEvent(list, 'mouseout', function(event){\n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n  if(!list.contains(t)) {\n    alert('!')\n  }\n})\n```\n\n### 取消冒泡\n\n其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。\n\n因为我们没有处理`list.contains(t)`的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：\n\n－ `IE`取消冒泡的方法是`event.cancelBubble = true`\n\n- 在符合`w3c`标准的浏览器上，则是使用`event.stopPropagation()`\n\n最终的代码是这样的：\n\n```js\n/**\n * @param {DOM} target 表示事件绑定的元素\n * @param {String} method 表示绑定的事件\n * @param {Function} handler 表示绑定的事件处理函数\n */\nfunction addEvent(target, method, handler) {\n  if (target.addEventListener) {\n    target.addEventListener(method, handler, false);\n  }\n  else if(target.attachEvent) {\n    target.attachEvent('on' + method, handler)\n  }\n else {\n    target['on'+method] = handler\n  }\n}\n\nvar list = document.getElementById('list');\n\naddEvent(list, 'mouseout', function(event){\n  \n  event = event || window.event;\n  var t = event.relatedTarget || event.toElement;\n\n  if(list.contains(t)) {\n    event.cancelBubble = true;\n    event.stopPropagation();\n  }\n  else {\n    alert('你正在离开list!')\n  }\n})\n```\n","slug":"some-summarize-about-event","published":1,"updated":"2022-01-08T08:39:26.287Z","_id":"ckxvfmfce000rbrqqd3ui3zpt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：</p>\n<span id=\"more\"></span>\n\n<p>现在有一段HTML</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>点击<code>li</code>的时候<code>alert</code>弹出<code>li</code>里面的文本内容，离开<code>ul</code>时<code>alert</code>提醒。</p>\n<p>注意，需要考虑性能和兼容性问题。</p>\n<h3 id=\"分析点击事件\"><a href=\"#分析点击事件\" class=\"headerlink\" title=\"分析点击事件\"></a>分析点击事件</h3><p>首先，大家都知道的是，在<code>IE</code>下绑定事件是使用<code>attachEvent</code>的，而不是<code>addEventListener</code>，因此可以封装一个方法来绑定事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用<code>attachEvent</code>时，事件类型都是需要加个<code>on</code>前缀的。还有就是因为<code>attachEvent</code>是将事件绑定在冒泡阶段的，为了保持一致，所以使用<code>addEventListener</code>时，需指定第三个参数为false，否则就添加到事件捕获阶段了。</p>\n<p>其次，不能给每个<code>li</code>绑定事件，可以利用事件的冒泡机制，故需把事件绑定到<code>ul</code>上而不是<code>li</code>上。</p>\n<p>此时要拿到真正的<code>li</code>就要读取事件(event)的真实对象(target)了，这也是一个考察点：</p>\n<ul>\n<li><p>在IE上，事件(event)要需要通过<code>window.event</code>获取的。</p>\n</li>\n<li><p>在IE上，事件对象(event target)的值是<code>event.srcElement</code>而不是<code>event.target</code></p>\n</li>\n</ul>\n<p>因此绑定点击事件的完整代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> target = event.target || event.srcElement;</span><br><span class=\"line\">  </span><br><span class=\"line\">  alert(target.innerHTML)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析鼠标移开事件\"><a href=\"#分析鼠标移开事件\" class=\"headerlink\" title=\"分析鼠标移开事件\"></a>分析鼠标移开事件</h3><p>其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用<code>mouseout</code>事件就完了。然而这里隐藏了一个问题：就是当鼠标移入<code>ul</code>的子元素<code>li</code>时，也会触发<code>mouseout</code>事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。</p>\n<p>然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。</p>\n<p>在现代浏览器(<code>chrome</code>，<code>firefox</code>，<code>safari</code>等等)上，我们直接用<code>event.relatedTarget</code>就可以直接获取；而在IE上则比较繁琐，<code>mouseout</code>事件有一个叫<code>toElement</code>的元素（顾名思义就是鼠标移到了哪个元素），<code>mouseover</code>事件则有一个叫<code>fromElement</code>元素。</p>\n<p>因此，我们可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!list.contains(t)) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"取消冒泡\"><a href=\"#取消冒泡\" class=\"headerlink\" title=\"取消冒泡\"></a>取消冒泡</h3><p>其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。</p>\n<p>因为我们没有处理<code>list.contains(t)</code>的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：</p>\n<p>－ <code>IE</code>取消冒泡的方法是<code>event.cancelBubble = true</code></p>\n<ul>\n<li>在符合<code>w3c</code>标准的浏览器上，则是使用<code>event.stopPropagation()</code></li>\n</ul>\n<p>最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(list.contains(t)) &#123;</span><br><span class=\"line\">    event.cancelBubble = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    event.stopPropagation();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;你正在离开list!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>前端开发无法避免的就是浏览器兼容问题，虽然我们现在几乎可以抛弃IE7甚至IE8，但是无法避免的是仍然有用户在使用这些远古时代的浏览器。因此面试大型互联网公司总会考察相关的知识。因此我现在分享一下我遇到的一个考题：</p>","more":"<p>现在有一段HTML</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>b<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>c<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>点击<code>li</code>的时候<code>alert</code>弹出<code>li</code>里面的文本内容，离开<code>ul</code>时<code>alert</code>提醒。</p>\n<p>注意，需要考虑性能和兼容性问题。</p>\n<h3 id=\"分析点击事件\"><a href=\"#分析点击事件\" class=\"headerlink\" title=\"分析点击事件\"></a>分析点击事件</h3><p>首先，大家都知道的是，在<code>IE</code>下绑定事件是使用<code>attachEvent</code>的，而不是<code>addEventListener</code>，因此可以封装一个方法来绑定事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用<code>attachEvent</code>时，事件类型都是需要加个<code>on</code>前缀的。还有就是因为<code>attachEvent</code>是将事件绑定在冒泡阶段的，为了保持一致，所以使用<code>addEventListener</code>时，需指定第三个参数为false，否则就添加到事件捕获阶段了。</p>\n<p>其次，不能给每个<code>li</code>绑定事件，可以利用事件的冒泡机制，故需把事件绑定到<code>ul</code>上而不是<code>li</code>上。</p>\n<p>此时要拿到真正的<code>li</code>就要读取事件(event)的真实对象(target)了，这也是一个考察点：</p>\n<ul>\n<li><p>在IE上，事件(event)要需要通过<code>window.event</code>获取的。</p>\n</li>\n<li><p>在IE上，事件对象(event target)的值是<code>event.srcElement</code>而不是<code>event.target</code></p>\n</li>\n</ul>\n<p>因此绑定点击事件的完整代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> target = event.target || event.srcElement;</span><br><span class=\"line\">  </span><br><span class=\"line\">  alert(target.innerHTML)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分析鼠标移开事件\"><a href=\"#分析鼠标移开事件\" class=\"headerlink\" title=\"分析鼠标移开事件\"></a>分析鼠标移开事件</h3><p>其实，这个才是这道题考察JavaScript能力的重点，因为通常情况下，我们就是使用<code>mouseout</code>事件就完了。然而这里隐藏了一个问题：就是当鼠标移入<code>ul</code>的子元素<code>li</code>时，也会触发<code>mouseout</code>事件的，所以这道题的重点就是考察面试者到底有没考虑到这个点。</p>\n<p>然而考察并没有结束，此时又出现了一个考察点：就是如何获取鼠标移出时移到哪个元素了。</p>\n<p>在现代浏览器(<code>chrome</code>，<code>firefox</code>，<code>safari</code>等等)上，我们直接用<code>event.relatedTarget</code>就可以直接获取；而在IE上则比较繁琐，<code>mouseout</code>事件有一个叫<code>toElement</code>的元素（顾名思义就是鼠标移到了哪个元素），<code>mouseover</code>事件则有一个叫<code>fromElement</code>元素。</p>\n<p>因此，我们可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!list.contains(t)) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"取消冒泡\"><a href=\"#取消冒泡\" class=\"headerlink\" title=\"取消冒泡\"></a>取消冒泡</h3><p>其实上面的代码就是最终的代码了，但是其实上面的代码我们偷了一个懒。</p>\n<p>因为我们没有处理<code>list.contains(t)</code>的情况，这时就应该是取消冒泡了。这里就引出来我所理解的最后一个考点：</p>\n<p>－ <code>IE</code>取消冒泡的方法是<code>event.cancelBubble = true</code></p>\n<ul>\n<li>在符合<code>w3c</code>标准的浏览器上，则是使用<code>event.stopPropagation()</code></li>\n</ul>\n<p>最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;DOM&#125;</span> </span>target 表示事件绑定的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;String&#125;</span> </span>method 表示绑定的事件</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Function&#125;</span> </span>handler 表示绑定的事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">target, method, handler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (target.addEventListener) &#123;</span><br><span class=\"line\">    target.addEventListener(method, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target.attachEvent) &#123;</span><br><span class=\"line\">    target.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + method, handler)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    target[<span class=\"string\">&#x27;on&#x27;</span>+method] = handler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;list&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">addEvent(list, <span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  event = event || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t = event.relatedTarget || event.toElement;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(list.contains(t)) &#123;</span><br><span class=\"line\">    event.cancelBubble = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    event.stopPropagation();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&#x27;你正在离开list!&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"多版本Node.js","date":"2016-11-03T09:06:19.000Z","desc":"Windows下安装多版本的Node.js","toc":true,"_content":"\n最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。\n\n然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。\n\n于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。\n\n所以我发现，拥有多版本的Node.js还是很有必要的。\n\n<!-- more -->\n\n## 开发环境\n\n#### linux / MacOs\n如果是在*nux的开发环境可以直接安装`nvm`即可\n\n#### Windows\n需要安装`nvm-window`。[github地址在此](https://github.com/coreybutler/nvm-windows)，[下载地址在此](https://github.com/coreybutler/nvm-windows/releases)\n\n在此我着重说一下`nvm-windows`需要注意的地方：\n\n- 安装`nvm-windows`之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）\n- 需要把NPM删掉(e.g. \"C:\\Users<user>\\AppData\\Roaming\\npm\")\n- 对应每个Node.js版本的全局安装方法都用重新安装，比如：\n\n```sh\nnvm use 4.0.0\nnpm install -g grunt\n\n\n#切换版本\nnvm use 7.0.0\nnpm install -g grunt\n```","source":"_posts/nvm-windows.md","raw":"---\ntitle: 多版本Node.js\ndate: 2016-11-03 17:06:19\ntags: Node.js\ndesc: Windows下安装多版本的Node.js\ntoc: true\ncategories:\n- Node.js\n---\n\n最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。\n\n然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。\n\n于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。\n\n所以我发现，拥有多版本的Node.js还是很有必要的。\n\n<!-- more -->\n\n## 开发环境\n\n#### linux / MacOs\n如果是在*nux的开发环境可以直接安装`nvm`即可\n\n#### Windows\n需要安装`nvm-window`。[github地址在此](https://github.com/coreybutler/nvm-windows)，[下载地址在此](https://github.com/coreybutler/nvm-windows/releases)\n\n在此我着重说一下`nvm-windows`需要注意的地方：\n\n- 安装`nvm-windows`之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）\n- 需要把NPM删掉(e.g. \"C:\\Users<user>\\AppData\\Roaming\\npm\")\n- 对应每个Node.js版本的全局安装方法都用重新安装，比如：\n\n```sh\nnvm use 4.0.0\nnpm install -g grunt\n\n\n#切换版本\nnvm use 7.0.0\nnpm install -g grunt\n```","slug":"nvm-windows","published":1,"updated":"2022-01-08T08:39:54.125Z","_id":"ckxvfmfcf000tbrqqh4j62d07","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。</p>\n<p>然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。</p>\n<p>于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。</p>\n<p>所以我发现，拥有多版本的Node.js还是很有必要的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><h4 id=\"linux-MacOs\"><a href=\"#linux-MacOs\" class=\"headerlink\" title=\"linux / MacOs\"></a>linux / MacOs</h4><p>如果是在*nux的开发环境可以直接安装<code>nvm</code>即可</p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>需要安装<code>nvm-window</code>。<a href=\"https://github.com/coreybutler/nvm-windows\">github地址在此</a>，<a href=\"https://github.com/coreybutler/nvm-windows/releases\">下载地址在此</a></p>\n<p>在此我着重说一下<code>nvm-windows</code>需要注意的地方：</p>\n<ul>\n<li>安装<code>nvm-windows</code>之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）</li>\n<li>需要把NPM删掉(e.g. “C:\\Users<user>\\AppData\\Roaming\\npm”)</li>\n<li>对应每个Node.js版本的全局安装方法都用重新安装，比如：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use 4.0.0</span><br><span class=\"line\">npm install -g grunt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#切换版本</span></span><br><span class=\"line\">nvm use 7.0.0</span><br><span class=\"line\">npm install -g grunt</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>最近，Node.js的LTS版本已经升级到6.9.1了，最新的版本都已经出到7.0了。</p>\n<p>然而我还在使用5.x版本，于是我将本地开发的Node.js升级到6.9.1。</p>\n<p>于是，悲剧发生了，以前的项目在新版本的Node.js下运行不了。</p>\n<p>所以我发现，拥有多版本的Node.js还是很有必要的。</p>","more":"<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><h4 id=\"linux-MacOs\"><a href=\"#linux-MacOs\" class=\"headerlink\" title=\"linux / MacOs\"></a>linux / MacOs</h4><p>如果是在*nux的开发环境可以直接安装<code>nvm</code>即可</p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>需要安装<code>nvm-window</code>。<a href=\"https://github.com/coreybutler/nvm-windows\">github地址在此</a>，<a href=\"https://github.com/coreybutler/nvm-windows/releases\">下载地址在此</a></p>\n<p>在此我着重说一下<code>nvm-windows</code>需要注意的地方：</p>\n<ul>\n<li>安装<code>nvm-windows</code>之前需把已安装的Node.js删除，（比如：如果“C:\\Program Files\\nodejs”这个目录存在的话就要删掉，不然NVM无法使用）</li>\n<li>需要把NPM删掉(e.g. “C:\\Users<user>\\AppData\\Roaming\\npm”)</li>\n<li>对应每个Node.js版本的全局安装方法都用重新安装，比如：</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm use 4.0.0</span><br><span class=\"line\">npm install -g grunt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#切换版本</span></span><br><span class=\"line\">nvm use 7.0.0</span><br><span class=\"line\">npm install -g grunt</span><br></pre></td></tr></table></figure>"},{"title":"MongoDB 使用记录","date":"2016-10-17T12:11:36.000Z","desc":null,"toc":true,"_content":"\n记录一下mongodb的使用记录，包含常用的启动、操作等命令。\n\n<!-- more -->\n\n\n## 初始化\n\n### 文件目录\n\n```sh\n-data #数据\n+ log #日志\n  - mongod.log\n+ conf #配置文件\n  - mongod.conf\nbin #二进制目录\n```\n\n\n### 启动的配置文件\n\n```sh\nport = 12345 #启动端口\ndbpath = data #数据路径\nlogpath = log/mongod.log #日志路径\nfork = true #表明启动的是后台进程 windows下无效\n```\n\n## 启动\n\n### 启动数据库\n\n```sh\nmongod -f conf/mongod.conf\n```\n\n### 连接数据库\n\n```sh\nmongo 127.0.0.1:12345/test\n```\n\n## 基本操作\n\n```sh\nshow dbs #显示所有数据库\nuse company #使用company数据库 不存在则自动创建\nshow collections #显示所有collection\nshow tables #效果同上\n```\n\n## CRUD\n\n### 插入数据\n\n```sh\ndb.company_list.insert({name: 'one'}) # company_list为collection，不存在则自动创建，然后插入一个数据\n\nfor(i=0;i<10;i++) db.company_list.insert({name: i}) #使用js的语法插入10个数据\n```\n\n### 查找数据\n\n```sh\ndb.company_list.find() #显示该collection的所有数据\n\ndb.company_list.find({name: 'one'}) #显示对应条件的数据\n\ndb.company_list.find().skip(2).limit(3).sort({name: 1}) #跳过前2个数据，按name排序获取3个数据\n```\n\n### 数据更新\n\n```sh\ndb.company_list.update({x:1}, {x:1000}) #第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即{x:1,y:1} => {x:1000}）\n\ndb.company_list.update({x:1}, {$set: {x:1000}}) #只修改x字段\n\ndb.company_list.update({x:99, {y:99}, true}) #修改一个不存在的数据则插入这个数据\n\ndb.company_list.update({x:1}, {y:99}, false, true}) #批量修改多条数据\n```\n\n### 删除数据\n\n\n```sh\ndb.company_list.remove({x:1}) #默认删除对应条件的所有数据\ndp.company_list.drop() #删除collection\n```\n\n## 索引相关\n\n```sh\ndb.company_list.getIndexes() #列出所有索引\ndb.company_list.ensureIndex({x:1}) #设置索引\n```\n\n### 索引的类型\n\n- _id索引\n- 单键索引\n- 多键索引\n- 复合索引\n- 过期索引\n- 全文索引\n- 地理位置索引\n\n## 权限相关\n\n### 创建用户\n\n\n```sh\ndb.createUser({\n    user: \"<name>\",\n    pwd: \"<cleartext password>\",\n    customData: {<any information},\n    roles: [{role: \"<role>\", db: \"<database>\"}]\n})\n```\n\n### 用户类型：\n- read\n- readWrite\n- dbAdmin\n- dbOwner\n- userAdmin \n","source":"_posts/mongodb.md","raw":"---\ntitle: MongoDB 使用记录\ndate: 2016-10-17 20:11:36\ntags: MongoDB\ndesc:\ntoc: true\ncategories:\n- 数据库\n---\n\n记录一下mongodb的使用记录，包含常用的启动、操作等命令。\n\n<!-- more -->\n\n\n## 初始化\n\n### 文件目录\n\n```sh\n-data #数据\n+ log #日志\n  - mongod.log\n+ conf #配置文件\n  - mongod.conf\nbin #二进制目录\n```\n\n\n### 启动的配置文件\n\n```sh\nport = 12345 #启动端口\ndbpath = data #数据路径\nlogpath = log/mongod.log #日志路径\nfork = true #表明启动的是后台进程 windows下无效\n```\n\n## 启动\n\n### 启动数据库\n\n```sh\nmongod -f conf/mongod.conf\n```\n\n### 连接数据库\n\n```sh\nmongo 127.0.0.1:12345/test\n```\n\n## 基本操作\n\n```sh\nshow dbs #显示所有数据库\nuse company #使用company数据库 不存在则自动创建\nshow collections #显示所有collection\nshow tables #效果同上\n```\n\n## CRUD\n\n### 插入数据\n\n```sh\ndb.company_list.insert({name: 'one'}) # company_list为collection，不存在则自动创建，然后插入一个数据\n\nfor(i=0;i<10;i++) db.company_list.insert({name: i}) #使用js的语法插入10个数据\n```\n\n### 查找数据\n\n```sh\ndb.company_list.find() #显示该collection的所有数据\n\ndb.company_list.find({name: 'one'}) #显示对应条件的数据\n\ndb.company_list.find().skip(2).limit(3).sort({name: 1}) #跳过前2个数据，按name排序获取3个数据\n```\n\n### 数据更新\n\n```sh\ndb.company_list.update({x:1}, {x:1000}) #第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即{x:1,y:1} => {x:1000}）\n\ndb.company_list.update({x:1}, {$set: {x:1000}}) #只修改x字段\n\ndb.company_list.update({x:99, {y:99}, true}) #修改一个不存在的数据则插入这个数据\n\ndb.company_list.update({x:1}, {y:99}, false, true}) #批量修改多条数据\n```\n\n### 删除数据\n\n\n```sh\ndb.company_list.remove({x:1}) #默认删除对应条件的所有数据\ndp.company_list.drop() #删除collection\n```\n\n## 索引相关\n\n```sh\ndb.company_list.getIndexes() #列出所有索引\ndb.company_list.ensureIndex({x:1}) #设置索引\n```\n\n### 索引的类型\n\n- _id索引\n- 单键索引\n- 多键索引\n- 复合索引\n- 过期索引\n- 全文索引\n- 地理位置索引\n\n## 权限相关\n\n### 创建用户\n\n\n```sh\ndb.createUser({\n    user: \"<name>\",\n    pwd: \"<cleartext password>\",\n    customData: {<any information},\n    roles: [{role: \"<role>\", db: \"<database>\"}]\n})\n```\n\n### 用户类型：\n- read\n- readWrite\n- dbAdmin\n- dbOwner\n- userAdmin \n","slug":"mongodb","published":1,"updated":"2022-01-08T08:40:45.161Z","_id":"ckxvfmfcg000ubrqqdgcc86lp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录一下mongodb的使用记录，包含常用的启动、操作等命令。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h3 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-data <span class=\"comment\">#数据</span></span><br><span class=\"line\">+ <span class=\"built_in\">log</span> <span class=\"comment\">#日志</span></span><br><span class=\"line\">  - mongod.log</span><br><span class=\"line\">+ conf <span class=\"comment\">#配置文件</span></span><br><span class=\"line\">  - mongod.conf</span><br><span class=\"line\">bin <span class=\"comment\">#二进制目录</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"启动的配置文件\"><a href=\"#启动的配置文件\" class=\"headerlink\" title=\"启动的配置文件\"></a>启动的配置文件</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port = 12345 <span class=\"comment\">#启动端口</span></span><br><span class=\"line\">dbpath = data <span class=\"comment\">#数据路径</span></span><br><span class=\"line\">logpath = <span class=\"built_in\">log</span>/mongod.log <span class=\"comment\">#日志路径</span></span><br><span class=\"line\">fork = <span class=\"literal\">true</span> <span class=\"comment\">#表明启动的是后台进程 windows下无效</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><h3 id=\"启动数据库\"><a href=\"#启动数据库\" class=\"headerlink\" title=\"启动数据库\"></a>启动数据库</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod -f conf/mongod.conf</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo 127.0.0.1:12345/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show dbs <span class=\"comment\">#显示所有数据库</span></span><br><span class=\"line\">use company <span class=\"comment\">#使用company数据库 不存在则自动创建</span></span><br><span class=\"line\">show collections <span class=\"comment\">#显示所有collection</span></span><br><span class=\"line\">show tables <span class=\"comment\">#效果同上</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h2><h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.insert(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\"># company_list为collection，不存在则自动创建，然后插入一个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=0;i&lt;10;i++) db.company_list.insert(&#123;name: i&#125;) <span class=\"comment\">#使用js的语法插入10个数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.find() <span class=\"comment\">#显示该collection的所有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\">#显示对应条件的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find().skip(2).<span class=\"built_in\">limit</span>(3).sort(&#123;name: 1&#125;) <span class=\"comment\">#跳过前2个数据，按name排序获取3个数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据更新\"><a href=\"#数据更新\" class=\"headerlink\" title=\"数据更新\"></a>数据更新</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;x:1000&#125;) <span class=\"comment\">#第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即&#123;x:1,y:1&#125; =&gt; &#123;x:1000&#125;）</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;<span class=\"variable\">$set</span>: &#123;x:1000&#125;&#125;) <span class=\"comment\">#只修改x字段</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:99, &#123;y:99&#125;, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#修改一个不存在的数据则插入这个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;y:99&#125;, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#批量修改多条数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.remove(&#123;x:1&#125;) <span class=\"comment\">#默认删除对应条件的所有数据</span></span><br><span class=\"line\">dp.company_list.drop() <span class=\"comment\">#删除collection</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引相关\"><a href=\"#索引相关\" class=\"headerlink\" title=\"索引相关\"></a>索引相关</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.getIndexes() <span class=\"comment\">#列出所有索引</span></span><br><span class=\"line\">db.company_list.ensureIndex(&#123;x:1&#125;) <span class=\"comment\">#设置索引</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h3><ul>\n<li>_id索引</li>\n<li>单键索引</li>\n<li>多键索引</li>\n<li>复合索引</li>\n<li>过期索引</li>\n<li>全文索引</li>\n<li>地理位置索引</li>\n</ul>\n<h2 id=\"权限相关\"><a href=\"#权限相关\" class=\"headerlink\" title=\"权限相关\"></a>权限相关</h2><h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(&#123;</span><br><span class=\"line\">    user: <span class=\"string\">&quot;&lt;name&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">pwd</span>: <span class=\"string\">&quot;&lt;cleartext password&gt;&quot;</span>,</span><br><span class=\"line\">    customData: &#123;&lt;any information&#125;,</span><br><span class=\"line\">    roles: [&#123;role: <span class=\"string\">&quot;&lt;role&gt;&quot;</span>, db: <span class=\"string\">&quot;&lt;database&gt;&quot;</span>&#125;]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户类型：\"><a href=\"#用户类型：\" class=\"headerlink\" title=\"用户类型：\"></a>用户类型：</h3><ul>\n<li>read</li>\n<li>readWrite</li>\n<li>dbAdmin</li>\n<li>dbOwner</li>\n<li>userAdmin </li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>记录一下mongodb的使用记录，包含常用的启动、操作等命令。</p>","more":"<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><h3 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-data <span class=\"comment\">#数据</span></span><br><span class=\"line\">+ <span class=\"built_in\">log</span> <span class=\"comment\">#日志</span></span><br><span class=\"line\">  - mongod.log</span><br><span class=\"line\">+ conf <span class=\"comment\">#配置文件</span></span><br><span class=\"line\">  - mongod.conf</span><br><span class=\"line\">bin <span class=\"comment\">#二进制目录</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"启动的配置文件\"><a href=\"#启动的配置文件\" class=\"headerlink\" title=\"启动的配置文件\"></a>启动的配置文件</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port = 12345 <span class=\"comment\">#启动端口</span></span><br><span class=\"line\">dbpath = data <span class=\"comment\">#数据路径</span></span><br><span class=\"line\">logpath = <span class=\"built_in\">log</span>/mongod.log <span class=\"comment\">#日志路径</span></span><br><span class=\"line\">fork = <span class=\"literal\">true</span> <span class=\"comment\">#表明启动的是后台进程 windows下无效</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><h3 id=\"启动数据库\"><a href=\"#启动数据库\" class=\"headerlink\" title=\"启动数据库\"></a>启动数据库</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod -f conf/mongod.conf</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo 127.0.0.1:12345/<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show dbs <span class=\"comment\">#显示所有数据库</span></span><br><span class=\"line\">use company <span class=\"comment\">#使用company数据库 不存在则自动创建</span></span><br><span class=\"line\">show collections <span class=\"comment\">#显示所有collection</span></span><br><span class=\"line\">show tables <span class=\"comment\">#效果同上</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h2><h3 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.insert(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\"># company_list为collection，不存在则自动创建，然后插入一个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=0;i&lt;10;i++) db.company_list.insert(&#123;name: i&#125;) <span class=\"comment\">#使用js的语法插入10个数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.find() <span class=\"comment\">#显示该collection的所有数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find(&#123;name: <span class=\"string\">&#x27;one&#x27;</span>&#125;) <span class=\"comment\">#显示对应条件的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.find().skip(2).<span class=\"built_in\">limit</span>(3).sort(&#123;name: 1&#125;) <span class=\"comment\">#跳过前2个数据，按name排序获取3个数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据更新\"><a href=\"#数据更新\" class=\"headerlink\" title=\"数据更新\"></a>数据更新</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;x:1000&#125;) <span class=\"comment\">#第一个参数是查找条件，第二个参数是修改后的数据 注意：修改后的完整数据（即&#123;x:1,y:1&#125; =&gt; &#123;x:1000&#125;）</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;<span class=\"variable\">$set</span>: &#123;x:1000&#125;&#125;) <span class=\"comment\">#只修改x字段</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:99, &#123;y:99&#125;, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#修改一个不存在的数据则插入这个数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.company_list.update(&#123;x:1&#125;, &#123;y:99&#125;, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125;) <span class=\"comment\">#批量修改多条数据</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.remove(&#123;x:1&#125;) <span class=\"comment\">#默认删除对应条件的所有数据</span></span><br><span class=\"line\">dp.company_list.drop() <span class=\"comment\">#删除collection</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引相关\"><a href=\"#索引相关\" class=\"headerlink\" title=\"索引相关\"></a>索引相关</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.company_list.getIndexes() <span class=\"comment\">#列出所有索引</span></span><br><span class=\"line\">db.company_list.ensureIndex(&#123;x:1&#125;) <span class=\"comment\">#设置索引</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h3><ul>\n<li>_id索引</li>\n<li>单键索引</li>\n<li>多键索引</li>\n<li>复合索引</li>\n<li>过期索引</li>\n<li>全文索引</li>\n<li>地理位置索引</li>\n</ul>\n<h2 id=\"权限相关\"><a href=\"#权限相关\" class=\"headerlink\" title=\"权限相关\"></a>权限相关</h2><h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(&#123;</span><br><span class=\"line\">    user: <span class=\"string\">&quot;&lt;name&gt;&quot;</span>,</span><br><span class=\"line\">    <span class=\"built_in\">pwd</span>: <span class=\"string\">&quot;&lt;cleartext password&gt;&quot;</span>,</span><br><span class=\"line\">    customData: &#123;&lt;any information&#125;,</span><br><span class=\"line\">    roles: [&#123;role: <span class=\"string\">&quot;&lt;role&gt;&quot;</span>, db: <span class=\"string\">&quot;&lt;database&gt;&quot;</span>&#125;]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户类型：\"><a href=\"#用户类型：\" class=\"headerlink\" title=\"用户类型：\"></a>用户类型：</h3><ul>\n<li>read</li>\n<li>readWrite</li>\n<li>dbAdmin</li>\n<li>dbOwner</li>\n<li>userAdmin </li>\n</ul>"},{"title":"JavaScript 模块(module)的差异","date":"2016-11-04T09:46:21.000Z","desc":null,"_content":"\n以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义\n\n<!-- more -->\n\n#### ES5方式输出模块\n\n- ES5方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:1\n```\n\n- ES5方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:1\n```\n\n#### ES6方式输出模块\n\n- ES6方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:2\n```\n\n- ES6方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:2\n```\n\n#### 总结\n\n上面的例子可以看出：\n\n- ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1\n- ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2\n\n因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用","source":"_posts/module-es6-vs-amd.md","raw":"---\ntitle: JavaScript 模块(module)的差异\ndate: 2016-11-4 17:46:21\ntags:\n- ES6\n- 模块化\ndesc:\ncategories:\n- [前端, 基础]\n---\n\n以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义\n\n<!-- more -->\n\n#### ES5方式输出模块\n\n- ES5方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:1\n```\n\n- ES5方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nmodule.exports = {a, add} //ES5输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:1\n```\n\n#### ES6方式输出模块\n\n- ES6方式输出模块，ES5方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nvar out = require('./out.js'); //ES5输入\n\nconsole.log('before:', out.a); // before:1\nout.add();\nconsole.log('after:', out.a); // after:2\n```\n\n- ES6方式输出模块，ES6方式输入\n\n```js\n// 输出out.js\nvar a = 1;\n\nfunction add(){\n a++;\n}\n\nexport {a, add} // ES6输出\n```\n\n```js\nimport {a, add} from './out.js'; //ES6输入\n\nconsole.log('before:', a); // before:1\nadd();\nconsole.log('after:', a); // after:2\n```\n\n#### 总结\n\n上面的例子可以看出：\n\n- ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1\n- ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2\n\n因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用","slug":"module-es6-vs-amd","published":1,"updated":"2022-01-08T08:11:37.448Z","_id":"ckxvfmfcj000xbrqq10lwerlk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义</p>\n<span id=\"more\"></span>\n\n<h4 id=\"ES5方式输出模块\"><a href=\"#ES5方式输出模块\" class=\"headerlink\" title=\"ES5方式输出模块\"></a>ES5方式输出模块</h4><ul>\n<li>ES5方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES5方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ES6方式输出模块\"><a href=\"#ES6方式输出模块\" class=\"headerlink\" title=\"ES6方式输出模块\"></a>ES6方式输出模块</h4><ul>\n<li>ES6方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>上面的例子可以看出：</p>\n<ul>\n<li>ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1</li>\n<li>ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2</li>\n</ul>\n<p>因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>以下ES5方式代表的是Node.js采用的CMD，ES6方式代表的是ES6提供的模块化定义</p>","more":"<h4 id=\"ES5方式输出模块\"><a href=\"#ES5方式输出模块\" class=\"headerlink\" title=\"ES5方式输出模块\"></a>ES5方式输出模块</h4><ul>\n<li>ES5方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES5方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;a, add&#125; <span class=\"comment\">//ES5输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ES6方式输出模块\"><a href=\"#ES6方式输出模块\" class=\"headerlink\" title=\"ES6方式输出模块\"></a>ES6方式输出模块</h4><ul>\n<li>ES6方式输出模块，ES5方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./out.js&#x27;</span>); <span class=\"comment\">//ES5输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, out.a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">out.add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, out.a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6方式输出模块，ES6方式输入</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出out.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> a++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;a, add&#125; <span class=\"comment\">// ES6输出</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;a, add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./out.js&#x27;</span>; <span class=\"comment\">//ES6输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;before:&#x27;</span>, a); <span class=\"comment\">// before:1</span></span><br><span class=\"line\">add();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;after:&#x27;</span>, a); <span class=\"comment\">// after:2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>上面的例子可以看出：</p>\n<ul>\n<li>ES5方式输出的a值都是不受原有的模块的代码影响的，永远都是1</li>\n<li>ES6方式输出的b值则是随着原有模块的代码影响，执行add()函数之后，变成了2</li>\n</ul>\n<p>因此可以得出结论：ES5输出的a值是模块里a的拷贝；而ES6输出的a值就是模块里a的引用</p>"},{"title":"iOS 软键盘弹出","date":"2016-07-22T04:22:50.000Z","desc":"移动开发,软键盘弹出,iOS键盘弹出","_content":"\n移动`WEB`开发经常要遇到控制软键盘：**弹出键盘**和**收起键盘**。\n\n<!--more-->\n\n```javascript\n // 弹出键盘\n input.focus();\n\n// 收起键盘\n input.blur();\n```\n\n在`Android`上，弹出和收起都比较正常，在任何时候调用都行。\n在`iOS`则不一样，一定要有在用户有实际交互时**马上**(right now)调用`focus`或者`blur`才行。比如：\n\n```javascript\n   btn.addEventListener('click', function(){\n     input.focus(); //弹出键盘\n   }, false);\n```\n\n如果此时使用了`setTimeout`：\n\n```javascript\n   btn.addEventListener('click', function(){\n     setTimeout(function(){\n       input.focus(); //键盘是不会弹出的\n     }, 50);\n   }, false);\n```\n\n或者此时我调用`ajax`请求再`focus`也是不会弹出来的\n\n```js\n  $.ajax({\n    //...\n  })\n  .then(function(){\n    input.focus(); //键盘是不会弹出的\n  })\n```","source":"_posts/mobile-web-soft-keyboard.md","raw":"---\ntitle: iOS 软键盘弹出\ndate: 2016-07-22 12:22:50\ndesc: 移动开发,软键盘弹出,iOS键盘弹出\ncategories:\n- 浏览器\n---\n\n移动`WEB`开发经常要遇到控制软键盘：**弹出键盘**和**收起键盘**。\n\n<!--more-->\n\n```javascript\n // 弹出键盘\n input.focus();\n\n// 收起键盘\n input.blur();\n```\n\n在`Android`上，弹出和收起都比较正常，在任何时候调用都行。\n在`iOS`则不一样，一定要有在用户有实际交互时**马上**(right now)调用`focus`或者`blur`才行。比如：\n\n```javascript\n   btn.addEventListener('click', function(){\n     input.focus(); //弹出键盘\n   }, false);\n```\n\n如果此时使用了`setTimeout`：\n\n```javascript\n   btn.addEventListener('click', function(){\n     setTimeout(function(){\n       input.focus(); //键盘是不会弹出的\n     }, 50);\n   }, false);\n```\n\n或者此时我调用`ajax`请求再`focus`也是不会弹出来的\n\n```js\n  $.ajax({\n    //...\n  })\n  .then(function(){\n    input.focus(); //键盘是不会弹出的\n  })\n```","slug":"mobile-web-soft-keyboard","published":1,"updated":"2022-01-08T08:42:36.605Z","_id":"ckxvfmfck000zbrqqg6j9457e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>移动<code>WEB</code>开发经常要遇到控制软键盘：<strong>弹出键盘</strong>和<strong>收起键盘</strong>。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 弹出键盘</span></span><br><span class=\"line\"> input.focus();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收起键盘</span></span><br><span class=\"line\"> input.blur();</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Android</code>上，弹出和收起都比较正常，在任何时候调用都行。<br>在<code>iOS</code>则不一样，一定要有在用户有实际交互时<strong>马上</strong>(right now)调用<code>focus</code>或者<code>blur</code>才行。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//弹出键盘</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果此时使用了<code>setTimeout</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>或者此时我调用<code>ajax</code>请求再<code>focus</code>也是不会弹出来的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>移动<code>WEB</code>开发经常要遇到控制软键盘：<strong>弹出键盘</strong>和<strong>收起键盘</strong>。</p>","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 弹出键盘</span></span><br><span class=\"line\"> input.focus();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收起键盘</span></span><br><span class=\"line\"> input.blur();</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Android</code>上，弹出和收起都比较正常，在任何时候调用都行。<br>在<code>iOS</code>则不一样，一定要有在用户有实际交互时<strong>马上</strong>(right now)调用<code>focus</code>或者<code>blur</code>才行。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//弹出键盘</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果此时使用了<code>setTimeout</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>或者此时我调用<code>ajax</code>请求再<code>focus</code>也是不会弹出来的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  input.focus(); <span class=\"comment\">//键盘是不会弹出的</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"正确使用 JavaScript 数组","date":"2017-02-20T16:08:29.000Z","desc":"JS数组进阶使用","toc":true,"_content":"\n\n首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。\n\n<!--more -->\n\n> “…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”\n－Luis Atencio\n\n## 循环\n\n我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。\n\n在JavaScript上至少有四五种循环的方式，其中最基础的就是`while`循环了。讲例子前，先设定一个函数和数组：\n\n```js\n// oodlify :: String -> String\nfunction oodlify(s) {\n    return s.replace(/[aeiou]/g, 'oodle');\n}\n\nconst input = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n那么，如果我们现在要使用`oodlify`函数操作一下数组里每个元素的话，如果我们使用`while`循环的话，是这样子的：\n\n```js\nlet i = 0;\nconst len = input.length;\nlet output = [];\n\nwhile (i < len) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n    i = i + 1;\n}\n```\n\n这里就有许多无谓的，但是又不得不做的工作。比如用`i`这个计数器来记住当前循环的位置，而且需要把`i`初始化成0，每次循环还要加一；比如要拿`i`和数组的长度`len`对比，这样才知道循环到什么时候停止。\n\n这时为了让清晰一点，我们可以使用JavaScript为我们提供的`for`循环：\n\n```js\nconst len = input.length;\nlet output = [];\n\nfor (let i = 0; i < len; i = i + 1) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n}\n```\n\n`for`循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。\n\n对比起`while`循环虽有一定改进，但是也会发生类似忘记给计数器`i`加一而导致死循环的情况。\n\n现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下`oodlify`函数而已。其实我们真的不想关什么计数器。\n\n因此，`ES2015`就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ `for...of`循环 ：\n\n```js\nlet output = [];\nfor (let item of input) {\n    let newItem = oodlify(item);\n    output.push(newItem);\n}\n```\n\n这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。\n\n如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。\n\n但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。\n\n## Mapping\n\n`for...of`循环的确比`for`循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如`output`数组，以及把每个操作过后的值push进去。\n\n其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：\n\n如果我们有两个数组需要使用`oodlify`函数操作的话呢？\n\n```js\nconst fellowship = [\n    'frodo',\n    'sam',\n    'gandalf',\n    'aragorn',\n    'boromir',\n    'legolas',\n    'gimli',\n];\n\nconst band = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n很明显，我们就要这样循环两个数组：\n\n```js\nlet bandoodle = [];\n\nfor (let item of band) {\n    let newItem = oodlify(item);\n    bandoodle.push(newItem);\n}\n\nlet floodleship = [];\n\nfor (let item of fellowship) {\n    let newItem = oodlify(item);\n    floodleship.push(newItem);\n}\n```\n\n这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nlet bandoodle = oodlifyArray(band);\nlet floodleship = oodlifyArray(fellowship);\n```\n\n这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？\n\n```js\nfunction izzlify(s) {\n    return s.replace(/[aeiou]+/g, 'izzle');\n}\n```\n\n这时，我们前面创建的`oodlifyArray`函数帮不了我们了。不过如果我们这时创建`izzlifyArray`函数的话，代码不就又有许多重复的部分了吗？\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nfunction izzlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = izzlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n```\n\n这两个函数是不是及其相似呢。\n\n如果此时我们将其抽象成一个模式的话呢：**我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组**。这个模式就称为`mapping`：\n\n```js\nfunction map(f, a) {\n    let output = [];\n    for (let item of a) {\n        output.push(f(item));\n    }\n    return output;\n}\n```\n\n其实我们并不需要自己手动写`mapping`函数，因为JavaScript提供了内置的`map`函数给我们使用，此时我们的代码是这样的：\n\n```js\nlet bandoodle     = band.map(oodlify);\nlet floodleship   = fellowship.map(oodlify);\nlet bandizzle     = band.map(izzlify);\nlet fellowshizzle = fellowship.map(izzlify);\n```\n\n## Reducing\n\n此时`map`是很方便了，但是并不能覆盖我们所有的循环需要。\n\n如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000},\n    {name: 'Spider-Man', strength: 25000},\n    {name: 'Hawk Eye', strength: 136},\n    {name: 'Thor', strength: 100000},\n    {name: 'Black Widow', strength: 136},\n    {name: 'Vision', strength: 5000},\n    {name: 'Scarlet Witch', strength: 60},\n    {name: 'Mystique', strength: 120},\n    {name: 'Namora', strength: 75000},\n];\n```\n\n如果我们要找到`strength`最大的那个的元素的话，使用`for...of`循环是这样的：\n\n```js\nlet strongest = {strength: 0};\nfor (hero of heroes) {\n    if (hero.strength > strongest.strength) {\n        strongest = hero;\n    }\n}\n```\n\n如果此时我们想累计一下所有的`strength`的话，循环里面就是这样的了：\n\n```js\nlet combinedStrength = 0;\nfor (hero of heroes) {\n    combinedStrength += hero.strength;\n}\n```\n\n这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：\n\n```js\nfunction greaterStrength(champion, contender) {\n    return (contender.strength > champion.strength) ? contender : champion;\n}\n\nfunction addStrength(tally, hero) {\n    return tally + hero.strength;\n}\n\n// 例子 1\nconst initialStrongest = {strength: 0};\nlet working = initialStrongest;\nfor (hero of heroes) {\n    working = greaterStrength(working, hero);\n}\nconst strongest = working;\n\n// 例子 2\nconst initialCombinedStrength = 0;\nworking = initialCombinedStrength;\nfor (hero of heroes) {\n    working = addStrength(working, hero);\n}\nconst combinedStrength = working;\n\n```\n\n此时我们可以抽象成这样一个函数：\n\n```js\nfunction reduce(f, initialVal, a) {\n    let working = initialVal;\n    for (item of a) {\n        working = f(working, item);\n    }\n    return working;\n}\n```\n\n其实这个方法JavaScript也提供了内置函数，就是`reduce`函数。这时代码是这样的：\n\n```js\nconst strongestHero = heroes.reduce(greaterStrength, {strength: 0});\nconst combinedStrength = heroes.reduce(addStrength, 0);\n```\n\n## Filtering\n\n前面的`map`函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；\n\n`reduce`则是将数组的全部值执行操作之后，最终输出一个值。\n\n如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000, sex: 'm'},\n    {name: 'Spider-Man', strength: 25000, sex: 'm'},\n    {name: 'Hawk Eye', strength: 136, sex: 'm'},\n    {name: 'Thor', strength: 100000, sex: 'm'},\n    {name: 'Black Widow', strength: 136, sex: 'f'},\n    {name: 'Vision', strength: 5000, sex: 'm'},\n    {name: 'Scarlet Witch', strength: 60, sex: 'f'},\n    {name: 'Mystique', strength: 120, sex: 'f'},\n    {name: 'Namora', strength: 75000, sex: 'f'},\n];\n```\n\n现在假设我们要做的两件事：\n\n1. 找到`sex = f`的元素\n2. 找到`strength > 500`的元素\n\n如果使用`for...of`循环的话，是这样的：\n\n```js\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (hero.sex === 'f') {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (hero.strength >= 500) {\n        superhumans.push(hero);\n    }\n}\n```\n\n由于有重复的地方，那么我们就把不同的地方抽取出来：\n\n```js\nfunction isFemaleHero(hero) {\n    return (hero.sex === 'f');\n}\n\nfunction isSuperhuman(hero) {\n    return (hero.strength >= 500);\n}\n\n\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (isFemaleHero(hero)) {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (isSuperhuman(hero)) {\n        superhumans.push(hero);\n    }\n}\n```\n\n此时就可以抽象成JavaScript内置的`filter`函数：\n\n```js\nfunction filter(predicate, arr) {\n\n    let working = [];\n\n    for (let item of arr) {\n\n        if (predicate(item)) {\n\n            working = working.concat(item);\n\n        }\n    }\n}\n\nconst femaleHeroes = filter(isFemaleHero, heroes);\nconst superhumans  = filter(isSuperhuman, heroes);\n```\n\n## Finding\n\n`filter`搞定了，那么如果我们只要找到一个元素呢。\n\n的确，我们同样可以使用`filter`函数完成这个目标，比如：\n\n```js\nfunction isBlackWidow(hero) {\n    return (hero.name === 'Black Widow');\n}\n\nconst blackWidow = heroes.filter(isBlackWidow)[0];\n```\n\n当然我们也同样会发现，这样的效率并不高。因为`filter`函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：\n\n```js\nfunction find(predicate, arr) {\n    for (let item of arr) {\n        if (predicate(item)) {\n            return item;\n        }\n    }\n}\n\nconst blackWidow = find(isBlackWidow, heroes);\n```\n\n正如大家所预期那样，JavaScript也同样提供了内置方法`find`给我们，因此我们最终的代码是这样的：\n\n```js\nconst blackWidow = heroes.find(isBlackWidow);\n```\n\n## 总结\n\n这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。\n\n现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：\n\n1. 摒弃了循环的控制结构，使代码更容易阅读。\n2. 通过使用适当的方法名称描述我们正在使用的方法。\n3. 减少了处理整个数组的问题，只需要关注我们的业务代码。\n\n在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。\n\n本文翻译自：[JavaScript Without Loops](http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email)\n\n","source":"_posts/javascript-without-loops.md","raw":"---\ntitle: 正确使用 JavaScript 数组\ndate: 2017-02-21 00:08:29\ntags:\n- JavaScript\n- Array\ndesc: JS数组进阶使用\ntoc: true\ncategories:\n- [前端, 基础]\n---\n\n\n首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。\n\n<!--more -->\n\n> “…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”\n－Luis Atencio\n\n## 循环\n\n我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。\n\n在JavaScript上至少有四五种循环的方式，其中最基础的就是`while`循环了。讲例子前，先设定一个函数和数组：\n\n```js\n// oodlify :: String -> String\nfunction oodlify(s) {\n    return s.replace(/[aeiou]/g, 'oodle');\n}\n\nconst input = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n那么，如果我们现在要使用`oodlify`函数操作一下数组里每个元素的话，如果我们使用`while`循环的话，是这样子的：\n\n```js\nlet i = 0;\nconst len = input.length;\nlet output = [];\n\nwhile (i < len) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n    i = i + 1;\n}\n```\n\n这里就有许多无谓的，但是又不得不做的工作。比如用`i`这个计数器来记住当前循环的位置，而且需要把`i`初始化成0，每次循环还要加一；比如要拿`i`和数组的长度`len`对比，这样才知道循环到什么时候停止。\n\n这时为了让清晰一点，我们可以使用JavaScript为我们提供的`for`循环：\n\n```js\nconst len = input.length;\nlet output = [];\n\nfor (let i = 0; i < len; i = i + 1) {\n\n    let item = input[i];\n    let newItem = oodlify(item);\n\n    output.push(newItem);\n}\n```\n\n`for`循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。\n\n对比起`while`循环虽有一定改进，但是也会发生类似忘记给计数器`i`加一而导致死循环的情况。\n\n现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下`oodlify`函数而已。其实我们真的不想关什么计数器。\n\n因此，`ES2015`就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ `for...of`循环 ：\n\n```js\nlet output = [];\nfor (let item of input) {\n    let newItem = oodlify(item);\n    output.push(newItem);\n}\n```\n\n这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。\n\n如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。\n\n但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。\n\n## Mapping\n\n`for...of`循环的确比`for`循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如`output`数组，以及把每个操作过后的值push进去。\n\n其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：\n\n如果我们有两个数组需要使用`oodlify`函数操作的话呢？\n\n```js\nconst fellowship = [\n    'frodo',\n    'sam',\n    'gandalf',\n    'aragorn',\n    'boromir',\n    'legolas',\n    'gimli',\n];\n\nconst band = [\n    'John',\n    'Paul',\n    'George',\n    'Ringo',\n];\n```\n\n很明显，我们就要这样循环两个数组：\n\n```js\nlet bandoodle = [];\n\nfor (let item of band) {\n    let newItem = oodlify(item);\n    bandoodle.push(newItem);\n}\n\nlet floodleship = [];\n\nfor (let item of fellowship) {\n    let newItem = oodlify(item);\n    floodleship.push(newItem);\n}\n```\n\n这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nlet bandoodle = oodlifyArray(band);\nlet floodleship = oodlifyArray(fellowship);\n```\n\n这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？\n\n```js\nfunction izzlify(s) {\n    return s.replace(/[aeiou]+/g, 'izzle');\n}\n```\n\n这时，我们前面创建的`oodlifyArray`函数帮不了我们了。不过如果我们这时创建`izzlifyArray`函数的话，代码不就又有许多重复的部分了吗？\n\n```js\nfunction oodlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = oodlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n\nfunction izzlifyArray(input) {\n    let output = [];\n\n    for (let item of input) {\n        let newItem = izzlify(item);\n        output.push(newItem);\n    }\n\n    return output;\n}\n```\n\n这两个函数是不是及其相似呢。\n\n如果此时我们将其抽象成一个模式的话呢：**我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组**。这个模式就称为`mapping`：\n\n```js\nfunction map(f, a) {\n    let output = [];\n    for (let item of a) {\n        output.push(f(item));\n    }\n    return output;\n}\n```\n\n其实我们并不需要自己手动写`mapping`函数，因为JavaScript提供了内置的`map`函数给我们使用，此时我们的代码是这样的：\n\n```js\nlet bandoodle     = band.map(oodlify);\nlet floodleship   = fellowship.map(oodlify);\nlet bandizzle     = band.map(izzlify);\nlet fellowshizzle = fellowship.map(izzlify);\n```\n\n## Reducing\n\n此时`map`是很方便了，但是并不能覆盖我们所有的循环需要。\n\n如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000},\n    {name: 'Spider-Man', strength: 25000},\n    {name: 'Hawk Eye', strength: 136},\n    {name: 'Thor', strength: 100000},\n    {name: 'Black Widow', strength: 136},\n    {name: 'Vision', strength: 5000},\n    {name: 'Scarlet Witch', strength: 60},\n    {name: 'Mystique', strength: 120},\n    {name: 'Namora', strength: 75000},\n];\n```\n\n如果我们要找到`strength`最大的那个的元素的话，使用`for...of`循环是这样的：\n\n```js\nlet strongest = {strength: 0};\nfor (hero of heroes) {\n    if (hero.strength > strongest.strength) {\n        strongest = hero;\n    }\n}\n```\n\n如果此时我们想累计一下所有的`strength`的话，循环里面就是这样的了：\n\n```js\nlet combinedStrength = 0;\nfor (hero of heroes) {\n    combinedStrength += hero.strength;\n}\n```\n\n这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：\n\n```js\nfunction greaterStrength(champion, contender) {\n    return (contender.strength > champion.strength) ? contender : champion;\n}\n\nfunction addStrength(tally, hero) {\n    return tally + hero.strength;\n}\n\n// 例子 1\nconst initialStrongest = {strength: 0};\nlet working = initialStrongest;\nfor (hero of heroes) {\n    working = greaterStrength(working, hero);\n}\nconst strongest = working;\n\n// 例子 2\nconst initialCombinedStrength = 0;\nworking = initialCombinedStrength;\nfor (hero of heroes) {\n    working = addStrength(working, hero);\n}\nconst combinedStrength = working;\n\n```\n\n此时我们可以抽象成这样一个函数：\n\n```js\nfunction reduce(f, initialVal, a) {\n    let working = initialVal;\n    for (item of a) {\n        working = f(working, item);\n    }\n    return working;\n}\n```\n\n其实这个方法JavaScript也提供了内置函数，就是`reduce`函数。这时代码是这样的：\n\n```js\nconst strongestHero = heroes.reduce(greaterStrength, {strength: 0});\nconst combinedStrength = heroes.reduce(addStrength, 0);\n```\n\n## Filtering\n\n前面的`map`函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；\n\n`reduce`则是将数组的全部值执行操作之后，最终输出一个值。\n\n如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：\n\n```js\nconst heroes = [\n    {name: 'Hulk', strength: 90000, sex: 'm'},\n    {name: 'Spider-Man', strength: 25000, sex: 'm'},\n    {name: 'Hawk Eye', strength: 136, sex: 'm'},\n    {name: 'Thor', strength: 100000, sex: 'm'},\n    {name: 'Black Widow', strength: 136, sex: 'f'},\n    {name: 'Vision', strength: 5000, sex: 'm'},\n    {name: 'Scarlet Witch', strength: 60, sex: 'f'},\n    {name: 'Mystique', strength: 120, sex: 'f'},\n    {name: 'Namora', strength: 75000, sex: 'f'},\n];\n```\n\n现在假设我们要做的两件事：\n\n1. 找到`sex = f`的元素\n2. 找到`strength > 500`的元素\n\n如果使用`for...of`循环的话，是这样的：\n\n```js\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (hero.sex === 'f') {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (hero.strength >= 500) {\n        superhumans.push(hero);\n    }\n}\n```\n\n由于有重复的地方，那么我们就把不同的地方抽取出来：\n\n```js\nfunction isFemaleHero(hero) {\n    return (hero.sex === 'f');\n}\n\nfunction isSuperhuman(hero) {\n    return (hero.strength >= 500);\n}\n\n\nlet femaleHeroes = [];\n\nfor (let hero of heroes) {\n    if (isFemaleHero(hero)) {\n        femaleHeroes.push(hero);\n    }\n}\n\nlet superhumans = [];\n\nfor (let hero of heroes) {\n    if (isSuperhuman(hero)) {\n        superhumans.push(hero);\n    }\n}\n```\n\n此时就可以抽象成JavaScript内置的`filter`函数：\n\n```js\nfunction filter(predicate, arr) {\n\n    let working = [];\n\n    for (let item of arr) {\n\n        if (predicate(item)) {\n\n            working = working.concat(item);\n\n        }\n    }\n}\n\nconst femaleHeroes = filter(isFemaleHero, heroes);\nconst superhumans  = filter(isSuperhuman, heroes);\n```\n\n## Finding\n\n`filter`搞定了，那么如果我们只要找到一个元素呢。\n\n的确，我们同样可以使用`filter`函数完成这个目标，比如：\n\n```js\nfunction isBlackWidow(hero) {\n    return (hero.name === 'Black Widow');\n}\n\nconst blackWidow = heroes.filter(isBlackWidow)[0];\n```\n\n当然我们也同样会发现，这样的效率并不高。因为`filter`函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：\n\n```js\nfunction find(predicate, arr) {\n    for (let item of arr) {\n        if (predicate(item)) {\n            return item;\n        }\n    }\n}\n\nconst blackWidow = find(isBlackWidow, heroes);\n```\n\n正如大家所预期那样，JavaScript也同样提供了内置方法`find`给我们，因此我们最终的代码是这样的：\n\n```js\nconst blackWidow = heroes.find(isBlackWidow);\n```\n\n## 总结\n\n这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。\n\n现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：\n\n1. 摒弃了循环的控制结构，使代码更容易阅读。\n2. 通过使用适当的方法名称描述我们正在使用的方法。\n3. 减少了处理整个数组的问题，只需要关注我们的业务代码。\n\n在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。\n\n本文翻译自：[JavaScript Without Loops](http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email)\n\n","slug":"javascript-without-loops","published":1,"updated":"2022-01-08T08:38:57.509Z","_id":"ckxvfmfcn0011brqqfgwtbnl0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>“…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”<br>－Luis Atencio</p>\n</blockquote>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。</p>\n<p>在JavaScript上至少有四五种循环的方式，其中最基础的就是<code>while</code>循环了。讲例子前，先设定一个函数和数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// oodlify :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]/g</span>, <span class=\"string\">&#x27;oodle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>那么，如果我们现在要使用<code>oodlify</code>函数操作一下数组里每个元素的话，如果我们使用<code>while</code>循环的话，是这样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; len) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">    i = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就有许多无谓的，但是又不得不做的工作。比如用<code>i</code>这个计数器来记住当前循环的位置，而且需要把<code>i</code>初始化成0，每次循环还要加一；比如要拿<code>i</code>和数组的长度<code>len</code>对比，这样才知道循环到什么时候停止。</p>\n<p>这时为了让清晰一点，我们可以使用JavaScript为我们提供的<code>for</code>循环：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>for</code>循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。</p>\n<p>对比起<code>while</code>循环虽有一定改进，但是也会发生类似忘记给计数器<code>i</code>加一而导致死循环的情况。</p>\n<p>现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下<code>oodlify</code>函数而已。其实我们真的不想关什么计数器。</p>\n<p>因此，<code>ES2015</code>就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ <code>for...of</code>循环 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。</p>\n<p>如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。</p>\n<p>但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。</p>\n<h2 id=\"Mapping\"><a href=\"#Mapping\" class=\"headerlink\" title=\"Mapping\"></a>Mapping</h2><p><code>for...of</code>循环的确比<code>for</code>循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如<code>output</code>数组，以及把每个操作过后的值push进去。</p>\n<p>其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：</p>\n<p>如果我们有两个数组需要使用<code>oodlify</code>函数操作的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fellowship = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;frodo&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;sam&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gandalf&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;aragorn&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;boromir&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;legolas&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gimli&#x27;</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> band = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>很明显，我们就要这样循环两个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> band) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    bandoodle.push(newItem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> fellowship) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    floodleship.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = oodlifyArray(band);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = oodlifyArray(fellowship);</span><br></pre></td></tr></table></figure>\n\n<p>这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]+/g</span>, <span class=\"string\">&#x27;izzle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时，我们前面创建的<code>oodlifyArray</code>函数帮不了我们了。不过如果我们这时创建<code>izzlifyArray</code>函数的话，代码不就又有许多重复的部分了吗？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = izzlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个函数是不是及其相似呢。</p>\n<p>如果此时我们将其抽象成一个模式的话呢：<strong>我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组</strong>。这个模式就称为<code>mapping</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">f, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        output.push(f(item));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我们并不需要自己手动写<code>mapping</code>函数，因为JavaScript提供了内置的<code>map</code>函数给我们使用，此时我们的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle     = band.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship   = fellowship.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> bandizzle     = band.map(izzlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> fellowshizzle = fellowship.map(izzlify);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reducing\"><a href=\"#Reducing\" class=\"headerlink\" title=\"Reducing\"></a>Reducing</h2><p>此时<code>map</code>是很方便了，但是并不能覆盖我们所有的循环需要。</p>\n<p>如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要找到<code>strength</code>最大的那个的元素的话，使用<code>for...of</code>循环是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt; strongest.strength) &#123;</span><br><span class=\"line\">        strongest = hero;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果此时我们想累计一下所有的<code>strength</code>的话，循环里面就是这样的了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> combinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    combinedStrength += hero.strength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greaterStrength</span>(<span class=\"params\">champion, contender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (contender.strength &gt; champion.strength) ? contender : champion;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addStrength</span>(<span class=\"params\">tally, hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tally + hero.strength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialStrongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> working = initialStrongest;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = greaterStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strongest = working;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialCombinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\">working = initialCombinedStrength;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = addStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = working;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此时我们可以抽象成这样一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">f, initialVal, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = initialVal;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        working = f(working, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> working;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这个方法JavaScript也提供了内置函数，就是<code>reduce</code>函数。这时代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> strongestHero = heroes.reduce(greaterStrength, &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = heroes.reduce(addStrength, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Filtering\"><a href=\"#Filtering\" class=\"headerlink\" title=\"Filtering\"></a>Filtering</h2><p>前面的<code>map</code>函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；</p>\n<p><code>reduce</code>则是将数组的全部值执行操作之后，最终输出一个值。</p>\n<p>如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>现在假设我们要做的两件事：</p>\n<ol>\n<li>找到<code>sex = f</code>的元素</li>\n<li>找到<code>strength &gt; 500</code>的元素</li>\n</ol>\n<p>如果使用<code>for...of</code>循环的话，是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt;= <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于有重复的地方，那么我们就把不同的地方抽取出来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFemaleHero</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSuperhuman</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.strength &gt;= <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFemaleHero(hero)) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSuperhuman(hero)) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以抽象成JavaScript内置的<code>filter</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            working = working.concat(item);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> femaleHeroes = filter(isFemaleHero, heroes);</span><br><span class=\"line\"><span class=\"keyword\">const</span> superhumans  = filter(isSuperhuman, heroes);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Finding\"><a href=\"#Finding\" class=\"headerlink\" title=\"Finding\"></a>Finding</h2><p><code>filter</code>搞定了，那么如果我们只要找到一个元素呢。</p>\n<p>的确，我们同样可以使用<code>filter</code>函数完成这个目标，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBlackWidow</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.name === <span class=\"string\">&#x27;Black Widow&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.filter(isBlackWidow)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n<p>当然我们也同样会发现，这样的效率并不高。因为<code>filter</code>函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = find(isBlackWidow, heroes);</span><br></pre></td></tr></table></figure>\n\n<p>正如大家所预期那样，JavaScript也同样提供了内置方法<code>find</code>给我们，因此我们最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.find(isBlackWidow);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。</p>\n<p>现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：</p>\n<ol>\n<li>摒弃了循环的控制结构，使代码更容易阅读。</li>\n<li>通过使用适当的方法名称描述我们正在使用的方法。</li>\n<li>减少了处理整个数组的问题，只需要关注我们的业务代码。</li>\n</ol>\n<p>在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。</p>\n<p>本文翻译自：<a href=\"http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email\">JavaScript Without Loops</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>首先，我们可以简单地认为缩进就是代码复杂性的指标（尽管很粗略）。因为缩进越多代表我们的嵌套越多，因此代码就越复杂。今天就拿数组来做具体的例子，来展示以下如何抛弃循环，减少缩进，正确地使用JavaScript数组。</p>","more":"<blockquote>\n<p>“…a loop is an imperative control structure that’s hard to reuse and difficult to plug in to other operations. In addition, it implies code that’s constantly changing or mutating in response to new iterations.”<br>－Luis Atencio</p>\n</blockquote>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>我们都知道，循环结构就是会无形地提高代码的复杂性。那我们现在看看在JavaScript上的循环是如何工作的。</p>\n<p>在JavaScript上至少有四五种循环的方式，其中最基础的就是<code>while</code>循环了。讲例子前，先设定一个函数和数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// oodlify :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]/g</span>, <span class=\"string\">&#x27;oodle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>那么，如果我们现在要使用<code>oodlify</code>函数操作一下数组里每个元素的话，如果我们使用<code>while</code>循环的话，是这样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; len) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">    i = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就有许多无谓的，但是又不得不做的工作。比如用<code>i</code>这个计数器来记住当前循环的位置，而且需要把<code>i</code>初始化成0，每次循环还要加一；比如要拿<code>i</code>和数组的长度<code>len</code>对比，这样才知道循环到什么时候停止。</p>\n<p>这时为了让清晰一点，我们可以使用JavaScript为我们提供的<code>for</code>循环：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> len = input.length;</span><br><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i = i + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = input[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\"></span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>for</code>循环的好处就是把与业务代码无关的计数逻辑放在了括号里面了。</p>\n<p>对比起<code>while</code>循环虽有一定改进，但是也会发生类似忘记给计数器<code>i</code>加一而导致死循环的情况。</p>\n<p>现在回想一下我们的最初目的：就只是给数组的每一个元素执行一下<code>oodlify</code>函数而已。其实我们真的不想关什么计数器。</p>\n<p>因此，<code>ES2015</code>就为我们提供了一个全新的可以让我们忽略计数器的循环结构－ <code>for...of</code>循环 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    output.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方式是不是简单多了！我们可以注意到，计数器和对比语句都没了。</p>\n<p>如果我们这就满足的话，我们的目标也算完成了，代码的确是简洁了不少。</p>\n<p>但是其实，我们可以对JavaScript的数组再深入挖掘一下，更上一层楼。</p>\n<h2 id=\"Mapping\"><a href=\"#Mapping\" class=\"headerlink\" title=\"Mapping\"></a>Mapping</h2><p><code>for...of</code>循环的确比<code>for</code>循环简洁不少，但是我们仍然写了一些不必要的初始化代码，比如<code>output</code>数组，以及把每个操作过后的值push进去。</p>\n<p>其实我们有办法写得更简单明了一点的。不过，现在我们来放大一下这个问题先：</p>\n<p>如果我们有两个数组需要使用<code>oodlify</code>函数操作的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fellowship = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;frodo&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;sam&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gandalf&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;aragorn&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;boromir&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;legolas&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;gimli&#x27;</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> band = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;John&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Paul&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;George&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;Ringo&#x27;</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>很明显，我们就要这样循环两个数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> band) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    bandoodle.push(newItem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> fellowship) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">    floodleship.push(newItem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这的确可以完成我们的目标，但是这样写得有点累赘。我们可以重构一下以减少重复的代码。因此我们可以创建一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> bandoodle = oodlifyArray(band);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship = oodlifyArray(fellowship);</span><br></pre></td></tr></table></figure>\n\n<p>这样是不是好看多了。但是问题来了，如果我们要使用其他函数来操作这个数组的话呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlify</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.replace(<span class=\"regexp\">/[aeiou]+/g</span>, <span class=\"string\">&#x27;izzle&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时，我们前面创建的<code>oodlifyArray</code>函数帮不了我们了。不过如果我们这时创建<code>izzlifyArray</code>函数的话，代码不就又有许多重复的部分了吗？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">oodlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = oodlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">izzlifyArray</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> input) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> newItem = izzlify(item);</span><br><span class=\"line\">        output.push(newItem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个函数是不是及其相似呢。</p>\n<p>如果此时我们将其抽象成一个模式的话呢：<strong>我们希望传入一个数组和一个函数，然后映射每个数组元素，最后输出一个数组</strong>。这个模式就称为<code>mapping</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">f, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> output = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        output.push(f(item));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实我们并不需要自己手动写<code>mapping</code>函数，因为JavaScript提供了内置的<code>map</code>函数给我们使用，此时我们的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bandoodle     = band.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> floodleship   = fellowship.map(oodlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> bandizzle     = band.map(izzlify);</span><br><span class=\"line\"><span class=\"keyword\">let</span> fellowshizzle = fellowship.map(izzlify);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reducing\"><a href=\"#Reducing\" class=\"headerlink\" title=\"Reducing\"></a>Reducing</h2><p>此时<code>map</code>是很方便了，但是并不能覆盖我们所有的循环需要。</p>\n<p>如果此时我们需要累计数组中的所有数组呢。我们假设有一个这样的数组：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要找到<code>strength</code>最大的那个的元素的话，使用<code>for...of</code>循环是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt; strongest.strength) &#123;</span><br><span class=\"line\">        strongest = hero;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果此时我们想累计一下所有的<code>strength</code>的话，循环里面就是这样的了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> combinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    combinedStrength += hero.strength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个例子我们都需要初始化一个变量来配合我们的操作。合并两个例子的话就是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greaterStrength</span>(<span class=\"params\">champion, contender</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (contender.strength &gt; champion.strength) ? contender : champion;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addStrength</span>(<span class=\"params\">tally, hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tally + hero.strength;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialStrongest = &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> working = initialStrongest;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = greaterStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> strongest = working;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子 2</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialCombinedStrength = <span class=\"number\">0</span>;</span><br><span class=\"line\">working = initialCombinedStrength;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    working = addStrength(working, hero);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = working;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此时我们可以抽象成这样一个函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">f, initialVal, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = initialVal;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (item <span class=\"keyword\">of</span> a) &#123;</span><br><span class=\"line\">        working = f(working, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> working;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这个方法JavaScript也提供了内置函数，就是<code>reduce</code>函数。这时代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> strongestHero = heroes.reduce(greaterStrength, &#123;<span class=\"attr\">strength</span>: <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> combinedStrength = heroes.reduce(addStrength, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Filtering\"><a href=\"#Filtering\" class=\"headerlink\" title=\"Filtering\"></a>Filtering</h2><p>前面的<code>map</code>函数是将数组的全部元素执行同个操作之后输出一个同样大小的数组；</p>\n<p><code>reduce</code>则是将数组的全部值执行操作之后，最终输出一个值。</p>\n<p>如果此时我们只是需要提取几个元素到一个数组内呢？为了更好得解释，我们来扩充一下之前的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> heroes = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hulk&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">90000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Spider-Man&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">25000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hawk Eye&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Thor&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">100000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Black Widow&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">136</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Vision&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">5000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;m&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Scarlet Witch&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">60</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Mystique&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">120</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Namora&#x27;</span>, <span class=\"attr\">strength</span>: <span class=\"number\">75000</span>, <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;f&#x27;</span>&#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>现在假设我们要做的两件事：</p>\n<ol>\n<li>找到<code>sex = f</code>的元素</li>\n<li>找到<code>strength &gt; 500</code>的元素</li>\n</ol>\n<p>如果使用<code>for...of</code>循环的话，是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hero.strength &gt;= <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于有重复的地方，那么我们就把不同的地方抽取出来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFemaleHero</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.sex === <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isSuperhuman</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.strength &gt;= <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> femaleHeroes = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFemaleHero(hero)) &#123;</span><br><span class=\"line\">        femaleHeroes.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> superhumans = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> hero <span class=\"keyword\">of</span> heroes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSuperhuman(hero)) &#123;</span><br><span class=\"line\">        superhumans.push(hero);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以抽象成JavaScript内置的<code>filter</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> working = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            working = working.concat(item);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> femaleHeroes = filter(isFemaleHero, heroes);</span><br><span class=\"line\"><span class=\"keyword\">const</span> superhumans  = filter(isSuperhuman, heroes);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Finding\"><a href=\"#Finding\" class=\"headerlink\" title=\"Finding\"></a>Finding</h2><p><code>filter</code>搞定了，那么如果我们只要找到一个元素呢。</p>\n<p>的确，我们同样可以使用<code>filter</code>函数完成这个目标，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBlackWidow</span>(<span class=\"params\">hero</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (hero.name === <span class=\"string\">&#x27;Black Widow&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.filter(isBlackWidow)[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n<p>当然我们也同样会发现，这样的效率并不高。因为<code>filter</code>函数会过滤所有的元素，尽管在前面已经找到了应该要找到的元素。因此我们可以写一个这样的查找函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">predicate, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (predicate(item)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = find(isBlackWidow, heroes);</span><br></pre></td></tr></table></figure>\n\n<p>正如大家所预期那样，JavaScript也同样提供了内置方法<code>find</code>给我们，因此我们最终的代码是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> blackWidow = heroes.find(isBlackWidow);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这些JavaScript内置的数组函数就是很好的例子，让我们学会了如何去抽象提取共同部分，以创造一个可以复用的函数。</p>\n<p>现在我们可以用内置函数完成几乎所有的数组操作。分析一下，我们可以看出每个函数都有以下特点：</p>\n<ol>\n<li>摒弃了循环的控制结构，使代码更容易阅读。</li>\n<li>通过使用适当的方法名称描述我们正在使用的方法。</li>\n<li>减少了处理整个数组的问题，只需要关注我们的业务代码。</li>\n</ol>\n<p>在每种情况下，JavaScript的内置函数都已经将问题分解为使用小的纯函数的解决方案。通过学习这几种内置函数能让我们消除几乎所有的循环结构，这是因为我们写的几乎所有循环都是在处理数组或者构建数组或者两者都有。因此使用内置函数不仅让我们在消除循环的同时，也为我们的代码增加了不少地可维护性。</p>\n<p>本文翻译自：<a href=\"http://jrsinclair.com/articles/2017/javascript-without-loops/?utm_source=javascriptweekly&utm_medium=email\">JavaScript Without Loops</a></p>"},{"title":"我所理解的JavaScript闭包","date":"2017-03-05T06:47:08.000Z","desc":"js闭包","toc":true,"_content":"\n闭包是JavaScript的一种特性，而不是函数。\n\n闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。\n\n<!--more-->\n\n## 使用场景\n\n#### 定义私有变量的时候\n\n```js\nfunction Application() {\n    var password = '123456';\n    \n    this.getPassword = function(){\n        return password;\n    }\n}\n\nvar app = new Application();\napp.getPassword();\n```\n\n`password`此时就是个私有变量，只能通过`getPassword`获取。\n\n\n## 变量作用域\n\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n\n变量的作用域无非就是两种：全局和局部（函数）。\n\nJavascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：\n\n```js\nvar color = 'blue';\n\nfunction changeColor(){\n\n    var anotherColor = 'red';\n    \n    function swapColors() {\n        var tempColor = anotherColor;\n        anotherColor = color;\n        color = tempColor;\n        \n        //这里可访问color，anotherColor和tempColor\n    }\n    \n    // 这里可访问color，anotherColor，但不能访问tempColor\n    swapColors();\n}\n\n// 这里只能访问color\nchangeColor();\n```\n\n本文主要参考：\n\n- [Private Members in JavaScript](http://www.crockford.com/javascript/private.html)\n- [学习Javascript闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)","source":"_posts/javascript-closure.md","raw":"---\ntitle: 我所理解的JavaScript闭包\ndate: 2017-03-05 14:47:08\ntags: \n- JavaScript\n- 闭包\ndesc: js闭包\ntoc: true\ncategories:\n- [前端, 基础]\n---\n\n闭包是JavaScript的一种特性，而不是函数。\n\n闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。\n\n<!--more-->\n\n## 使用场景\n\n#### 定义私有变量的时候\n\n```js\nfunction Application() {\n    var password = '123456';\n    \n    this.getPassword = function(){\n        return password;\n    }\n}\n\nvar app = new Application();\napp.getPassword();\n```\n\n`password`此时就是个私有变量，只能通过`getPassword`获取。\n\n\n## 变量作用域\n\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n\n变量的作用域无非就是两种：全局和局部（函数）。\n\nJavascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：\n\n```js\nvar color = 'blue';\n\nfunction changeColor(){\n\n    var anotherColor = 'red';\n    \n    function swapColors() {\n        var tempColor = anotherColor;\n        anotherColor = color;\n        color = tempColor;\n        \n        //这里可访问color，anotherColor和tempColor\n    }\n    \n    // 这里可访问color，anotherColor，但不能访问tempColor\n    swapColors();\n}\n\n// 这里只能访问color\nchangeColor();\n```\n\n本文主要参考：\n\n- [Private Members in JavaScript](http://www.crockford.com/javascript/private.html)\n- [学习Javascript闭包（Closure）](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)","slug":"javascript-closure","published":1,"updated":"2022-01-08T08:38:38.254Z","_id":"ckxvfmfcs0016brqq1fig8rui","comments":1,"layout":"post","photos":[],"link":"","content":"<p>闭包是JavaScript的一种特性，而不是函数。</p>\n<p>闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><h4 id=\"定义私有变量的时候\"><a href=\"#定义私有变量的时候\" class=\"headerlink\" title=\"定义私有变量的时候\"></a>定义私有变量的时候</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Application</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> password = <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.getPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Application();</span><br><span class=\"line\">app.getPassword();</span><br></pre></td></tr></table></figure>\n\n<p><code>password</code>此时就是个私有变量，只能通过<code>getPassword</code>获取。</p>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>\n<p>变量的作用域无非就是两种：全局和局部（函数）。</p>\n<p>Javascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">&#x27;blue&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> anotherColor = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColors</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tempColor = anotherColor;</span><br><span class=\"line\">        anotherColor = color;</span><br><span class=\"line\">        color = tempColor;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//这里可访问color，anotherColor和tempColor</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这里可访问color，anotherColor，但不能访问tempColor</span></span><br><span class=\"line\">    swapColors();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里只能访问color</span></span><br><span class=\"line\">changeColor();</span><br></pre></td></tr></table></figure>\n\n<p>本文主要参考：</p>\n<ul>\n<li><a href=\"http://www.crockford.com/javascript/private.html\">Private Members in JavaScript</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\">学习Javascript闭包（Closure）</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>闭包是JavaScript的一种特性，而不是函数。</p>\n<p>闭包使内部函数总是能访问外部函数的变量和参数，甚至在外部函数已经retuen的情况下。</p>","more":"<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><h4 id=\"定义私有变量的时候\"><a href=\"#定义私有变量的时候\" class=\"headerlink\" title=\"定义私有变量的时候\"></a>定义私有变量的时候</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Application</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> password = <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.getPassword = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Application();</span><br><span class=\"line\">app.getPassword();</span><br></pre></td></tr></table></figure>\n\n<p><code>password</code>此时就是个私有变量，只能通过<code>getPassword</code>获取。</p>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>\n<p>变量的作用域无非就是两种：全局和局部（函数）。</p>\n<p>Javascript语言的特殊之处，就在于作用域链（scope chain）：内部函数可以访问外部函数的变量，和全局的变量。举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">&#x27;blue&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeColor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> anotherColor = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swapColors</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tempColor = anotherColor;</span><br><span class=\"line\">        anotherColor = color;</span><br><span class=\"line\">        color = tempColor;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//这里可访问color，anotherColor和tempColor</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 这里可访问color，anotherColor，但不能访问tempColor</span></span><br><span class=\"line\">    swapColors();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里只能访问color</span></span><br><span class=\"line\">changeColor();</span><br></pre></td></tr></table></figure>\n\n<p>本文主要参考：</p>\n<ul>\n<li><a href=\"http://www.crockford.com/javascript/private.html\">Private Members in JavaScript</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\">学习Javascript闭包（Closure）</a></li>\n</ul>"},{"title":"Web 与原生应用的常见通信方式","date":"2016-09-26T10:08:19.000Z","desc":"web与APP的交互,web,iOS,Andriod,addJavascriptInterface,WebViewJavascriptBridge,初始化分支","toc":true,"_content":"\n在移动`web`开发过程中，一定会遇到`web`端与`APP`端交互的情况。下面就来分析下，`web`端到底是如何与`APP`端实现交互的。\n\n在`APP`端，`iOS`和`Andriod`的实现方式各不一样。\n\n大家都知道，我们的`javascript`大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的`javascript`提供了`window`,`navigator`等宿主对象。\n\n<!--more-->\n\n### Andriod\n\n在`Android`上，实现的方式就和上面这种方式类似，就是在`webview`上注册一个全局变量，然后我们再`js`直接调用即可。下面即表示在全局环境下定义了一个对象`androidEnv `:\n\n```java\nwebview.addJavascriptInterface(object, \"androidEnv\");\n```\n\n#### web调用Andriod\n\n`Andriod`在`webview`这个类里面定义的方法，我们在`js`都可以直接调用，这样就实现了`web`到`Andriod`的单向交互了，例如：\n\n```js\nAndriodEnv.sayHi(); //注意：sayHi是Andriod定义的方法\n```\n\n#### Andriod调用web\n\n然后，如果我们要实现`Andriod`到`web`的单向交互呢，道理也一样。即是`js`定义一个全局的函数，然后`Andriod`就可以直接调用了：\n\n```js\nfunction globalFunc(){\n  return 'hello Andriod';\n}\n```\n\n### iOS\n\n相反在`iOS`上，则没这么方便了，需要用到一个叫`WebViewJavascriptBridge`的桥接中间件。\n\n在`js`上我们需要判断这个`bridge`是否已经注册，如果有就直接拿来使用；否则就监听一下`brideg`的变化，然后再使用。因此我们先封装好一个方法：\n\n```js\nfunction connectWebViewJavascriptBridge(callback) {\n    if (window.WebViewJavascriptBridge) {\n      callback(WebViewJavascriptBridge);\n    }\n    else {\n      document.addEventListener('WebViewJavascriptBridgeReady', function() {\n        callback(WebViewJavascriptBridge);\n      }, false);\n    };\n  }\n```\n\n之后我们用一个`callback`来处理这个`bridge`：\n\n```js\nconnectWebViewJavascriptBridge(function(bridge) {\n\n    bridge.init(function(data, responseCallback) {});\n    \n});\n```\n\n到这个时候，基础工作就做完了，接下来就是`web`与`iOS`之间的交互了。\n\n#### web调用iOS\n\n```js\nbridge.callHandler('ObjC Echo', {'key':'value'}, function responseCallback(responseData) {\n    console.log(\"JS received response:\", responseData)\n})\n```\n\n其中，`ObjC Echo`是`iOS`上的对应方法（其实并不是函数，只是一个token），`{'key':'value'}`则是`web`传到`iOS`的参数，`responseData`则是`iOS`回传的数据。\n\n这里还有另外一种方法，就是我们可以直接利用`bridge`的`send`方法，直接将所有东西都`send`过去给`iOS`即可，例如：\n\n```js\nvar param = {\n  \"functionName\" : \"share\",\n  \"params\":{\n    \"title\" : opt.title,\n    \"desc\" : opt.desc\n  }\n};\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param);\n});\n\n```\n\n`send`可以接受两个参数，第二个参数就是回调函数了：\n\n```js\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param, function(data){\n    callback(data);\n  });\n\n});\n```\n\n\n#### iOS调用web\n\n```js\nbridge.registerHandler('JS Echo', function(data, responseCallback) {\n    console.log(\"JS Echo called with:\", data)\n    responseCallback(data)\n})\n```\n\n这里的`JS Echo`则是`JS`上注册的一个方法名，当`iOS`执行玩这个方法，我们就可以马上监听到并接受到一些数据`data`，之后我们还可以执行`responseCallback`回调`iOS`告诉它我们的处理情况。\n\n### 说说js代码\n\n知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。\n\n```js\njAPP = {\n  getUserName: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  },\n\n  getUserId: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  }\n}\n```\n\n**我认为的缺点**：\n\n- 重复判断设备信息，因为设备信息可以理解成`常量`，一经获取就不会更改，所以我们可以用`初始化分支`来优化。\n\n- 重复判断是否在APP内。同样可以采用`初始化分支`来优化，也就是说不在`APP`内的话，调用的方法都不需要初始化了。\n\n- `console.log`没有意义，只有在测试环境下能有，上生产应该去除。\n\n### 优化\n\n```js\nvar ua = navigator.userAgent().toLowerCase();\nvar inIOS = !!( ua.indexOf('iphone') > -1 || ua.indexOf('ipad') > -1 );\nvar inAndriod = !!( ua.indexOf('andriod') > -1 );\nvar inAPP = !!( ua.indexOf('your APP token') > -1 );\nvar jAPP = {};\n\nif(inAPP) {\n  \n  if(inIOS) {\n    jAPP.getUserId = function(){\n      //..\n    };\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n\n  else if(inAndriod) {\n\n    jAPP.getUserId = function(){\n      //..\n    };\n\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n}\n```\n\n`初始化分支`的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。**好处**在于不用重复判断分支。\n\n如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。\n\n### 参考\n\n> [JS与WebView交互存在的一些问题](http://www.jianshu.com/p/93cea79a2443)\n\n> [WebViewJavascriptBridge](https://github.com/marcuswestin/WebViewJavascriptBridge)","source":"_posts/interact-with-app.md","raw":"---\ntitle: Web 与原生应用的常见通信方式\ndate: 2016-09-26 18:08:19\ntags: \ndesc: web与APP的交互,web,iOS,Andriod,addJavascriptInterface,WebViewJavascriptBridge,初始化分支\ntoc: true\ncategories:\n- [前端, 基础]\n---\n\n在移动`web`开发过程中，一定会遇到`web`端与`APP`端交互的情况。下面就来分析下，`web`端到底是如何与`APP`端实现交互的。\n\n在`APP`端，`iOS`和`Andriod`的实现方式各不一样。\n\n大家都知道，我们的`javascript`大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的`javascript`提供了`window`,`navigator`等宿主对象。\n\n<!--more-->\n\n### Andriod\n\n在`Android`上，实现的方式就和上面这种方式类似，就是在`webview`上注册一个全局变量，然后我们再`js`直接调用即可。下面即表示在全局环境下定义了一个对象`androidEnv `:\n\n```java\nwebview.addJavascriptInterface(object, \"androidEnv\");\n```\n\n#### web调用Andriod\n\n`Andriod`在`webview`这个类里面定义的方法，我们在`js`都可以直接调用，这样就实现了`web`到`Andriod`的单向交互了，例如：\n\n```js\nAndriodEnv.sayHi(); //注意：sayHi是Andriod定义的方法\n```\n\n#### Andriod调用web\n\n然后，如果我们要实现`Andriod`到`web`的单向交互呢，道理也一样。即是`js`定义一个全局的函数，然后`Andriod`就可以直接调用了：\n\n```js\nfunction globalFunc(){\n  return 'hello Andriod';\n}\n```\n\n### iOS\n\n相反在`iOS`上，则没这么方便了，需要用到一个叫`WebViewJavascriptBridge`的桥接中间件。\n\n在`js`上我们需要判断这个`bridge`是否已经注册，如果有就直接拿来使用；否则就监听一下`brideg`的变化，然后再使用。因此我们先封装好一个方法：\n\n```js\nfunction connectWebViewJavascriptBridge(callback) {\n    if (window.WebViewJavascriptBridge) {\n      callback(WebViewJavascriptBridge);\n    }\n    else {\n      document.addEventListener('WebViewJavascriptBridgeReady', function() {\n        callback(WebViewJavascriptBridge);\n      }, false);\n    };\n  }\n```\n\n之后我们用一个`callback`来处理这个`bridge`：\n\n```js\nconnectWebViewJavascriptBridge(function(bridge) {\n\n    bridge.init(function(data, responseCallback) {});\n    \n});\n```\n\n到这个时候，基础工作就做完了，接下来就是`web`与`iOS`之间的交互了。\n\n#### web调用iOS\n\n```js\nbridge.callHandler('ObjC Echo', {'key':'value'}, function responseCallback(responseData) {\n    console.log(\"JS received response:\", responseData)\n})\n```\n\n其中，`ObjC Echo`是`iOS`上的对应方法（其实并不是函数，只是一个token），`{'key':'value'}`则是`web`传到`iOS`的参数，`responseData`则是`iOS`回传的数据。\n\n这里还有另外一种方法，就是我们可以直接利用`bridge`的`send`方法，直接将所有东西都`send`过去给`iOS`即可，例如：\n\n```js\nvar param = {\n  \"functionName\" : \"share\",\n  \"params\":{\n    \"title\" : opt.title,\n    \"desc\" : opt.desc\n  }\n};\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param);\n});\n\n```\n\n`send`可以接受两个参数，第二个参数就是回调函数了：\n\n```js\n\nconnectWebViewJavascriptBridge(function(bridge) {\n\n  bridge.send(param, function(data){\n    callback(data);\n  });\n\n});\n```\n\n\n#### iOS调用web\n\n```js\nbridge.registerHandler('JS Echo', function(data, responseCallback) {\n    console.log(\"JS Echo called with:\", data)\n    responseCallback(data)\n})\n```\n\n这里的`JS Echo`则是`JS`上注册的一个方法名，当`iOS`执行玩这个方法，我们就可以马上监听到并接受到一些数据`data`，之后我们还可以执行`responseCallback`回调`iOS`告诉它我们的处理情况。\n\n### 说说js代码\n\n知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。\n\n```js\njAPP = {\n  getUserName: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  },\n\n  getUserId: function(){\n    if(inAPP) {\n      if(iOS){\n        //...\n      }\n      if(Andriod){\n        //...\n      }\n    }\n    else {\n      //...\n      console.log('请在APP内打开')\n    }\n  }\n}\n```\n\n**我认为的缺点**：\n\n- 重复判断设备信息，因为设备信息可以理解成`常量`，一经获取就不会更改，所以我们可以用`初始化分支`来优化。\n\n- 重复判断是否在APP内。同样可以采用`初始化分支`来优化，也就是说不在`APP`内的话，调用的方法都不需要初始化了。\n\n- `console.log`没有意义，只有在测试环境下能有，上生产应该去除。\n\n### 优化\n\n```js\nvar ua = navigator.userAgent().toLowerCase();\nvar inIOS = !!( ua.indexOf('iphone') > -1 || ua.indexOf('ipad') > -1 );\nvar inAndriod = !!( ua.indexOf('andriod') > -1 );\nvar inAPP = !!( ua.indexOf('your APP token') > -1 );\nvar jAPP = {};\n\nif(inAPP) {\n  \n  if(inIOS) {\n    jAPP.getUserId = function(){\n      //..\n    };\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n\n  else if(inAndriod) {\n\n    jAPP.getUserId = function(){\n      //..\n    };\n\n    jAPP.getUserName = function(){\n      //..\n    };\n  }\n}\n```\n\n`初始化分支`的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。**好处**在于不用重复判断分支。\n\n如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。\n\n### 参考\n\n> [JS与WebView交互存在的一些问题](http://www.jianshu.com/p/93cea79a2443)\n\n> [WebViewJavascriptBridge](https://github.com/marcuswestin/WebViewJavascriptBridge)","slug":"interact-with-app","published":1,"updated":"2022-01-08T08:41:30.634Z","_id":"ckxvfmfct0017brqq83n24pwy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在移动<code>web</code>开发过程中，一定会遇到<code>web</code>端与<code>APP</code>端交互的情况。下面就来分析下，<code>web</code>端到底是如何与<code>APP</code>端实现交互的。</p>\n<p>在<code>APP</code>端，<code>iOS</code>和<code>Andriod</code>的实现方式各不一样。</p>\n<p>大家都知道，我们的<code>javascript</code>大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的<code>javascript</code>提供了<code>window</code>,<code>navigator</code>等宿主对象。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Andriod\"><a href=\"#Andriod\" class=\"headerlink\" title=\"Andriod\"></a>Andriod</h3><p>在<code>Android</code>上，实现的方式就和上面这种方式类似，就是在<code>webview</code>上注册一个全局变量，然后我们再<code>js</code>直接调用即可。下面即表示在全局环境下定义了一个对象<code>androidEnv </code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webview.addJavascriptInterface(object, <span class=\"string\">&quot;androidEnv&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"web调用Andriod\"><a href=\"#web调用Andriod\" class=\"headerlink\" title=\"web调用Andriod\"></a>web调用Andriod</h4><p><code>Andriod</code>在<code>webview</code>这个类里面定义的方法，我们在<code>js</code>都可以直接调用，这样就实现了<code>web</code>到<code>Andriod</code>的单向交互了，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AndriodEnv.sayHi(); <span class=\"comment\">//注意：sayHi是Andriod定义的方法</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Andriod调用web\"><a href=\"#Andriod调用web\" class=\"headerlink\" title=\"Andriod调用web\"></a>Andriod调用web</h4><p>然后，如果我们要实现<code>Andriod</code>到<code>web</code>的单向交互呢，道理也一样。即是<code>js</code>定义一个全局的函数，然后<code>Andriod</code>就可以直接调用了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">globalFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello Andriod&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p>相反在<code>iOS</code>上，则没这么方便了，需要用到一个叫<code>WebViewJavascriptBridge</code>的桥接中间件。</p>\n<p>在<code>js</code>上我们需要判断这个<code>bridge</code>是否已经注册，如果有就直接拿来使用；否则就监听一下<code>brideg</code>的变化，然后再使用。因此我们先封装好一个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connectWebViewJavascriptBridge</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class=\"line\">      callback(WebViewJavascriptBridge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">&#x27;WebViewJavascriptBridgeReady&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(WebViewJavascriptBridge);</span><br><span class=\"line\">      &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后我们用一个<code>callback</code>来处理这个<code>bridge</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    bridge.init(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>到这个时候，基础工作就做完了，接下来就是<code>web</code>与<code>iOS</code>之间的交互了。</p>\n<h4 id=\"web调用iOS\"><a href=\"#web调用iOS\" class=\"headerlink\" title=\"web调用iOS\"></a>web调用iOS</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.callHandler(<span class=\"string\">&#x27;ObjC Echo&#x27;</span>, &#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">responseCallback</span>(<span class=\"params\">responseData</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS received response:&quot;</span>, responseData)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>ObjC Echo</code>是<code>iOS</code>上的对应方法（其实并不是函数，只是一个token），<code>&#123;&#39;key&#39;:&#39;value&#39;&#125;</code>则是<code>web</code>传到<code>iOS</code>的参数，<code>responseData</code>则是<code>iOS</code>回传的数据。</p>\n<p>这里还有另外一种方法，就是我们可以直接利用<code>bridge</code>的<code>send</code>方法，直接将所有东西都<code>send</code>过去给<code>iOS</code>即可，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> param = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;functionName&quot;</span> : <span class=\"string\">&quot;share&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;params&quot;</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;title&quot;</span> : opt.title,</span><br><span class=\"line\">    <span class=\"string\">&quot;desc&quot;</span> : opt.desc</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>send</code>可以接受两个参数，第二个参数就是回调函数了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    callback(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"iOS调用web\"><a href=\"#iOS调用web\" class=\"headerlink\" title=\"iOS调用web\"></a>iOS调用web</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.registerHandler(<span class=\"string\">&#x27;JS Echo&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS Echo called with:&quot;</span>, data)</span><br><span class=\"line\">    responseCallback(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>JS Echo</code>则是<code>JS</code>上注册的一个方法名，当<code>iOS</code>执行玩这个方法，我们就可以马上监听到并接受到一些数据<code>data</code>，之后我们还可以执行<code>responseCallback</code>回调<code>iOS</code>告诉它我们的处理情况。</p>\n<h3 id=\"说说js代码\"><a href=\"#说说js代码\" class=\"headerlink\" title=\"说说js代码\"></a>说说js代码</h3><p>知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jAPP = &#123;</span><br><span class=\"line\">  <span class=\"attr\">getUserName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">getUserId</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我认为的缺点</strong>：</p>\n<ul>\n<li><p>重复判断设备信息，因为设备信息可以理解成<code>常量</code>，一经获取就不会更改，所以我们可以用<code>初始化分支</code>来优化。</p>\n</li>\n<li><p>重复判断是否在APP内。同样可以采用<code>初始化分支</code>来优化，也就是说不在<code>APP</code>内的话，调用的方法都不需要初始化了。</p>\n</li>\n<li><p><code>console.log</code>没有意义，只有在测试环境下能有，上生产应该去除。</p>\n</li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ua = navigator.userAgent().toLowerCase();</span><br><span class=\"line\"><span class=\"keyword\">var</span> inIOS = !!( ua.indexOf(<span class=\"string\">&#x27;iphone&#x27;</span>) &gt; -<span class=\"number\">1</span> || ua.indexOf(<span class=\"string\">&#x27;ipad&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAndriod = !!( ua.indexOf(<span class=\"string\">&#x27;andriod&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAPP = !!( ua.indexOf(<span class=\"string\">&#x27;your APP token&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> jAPP = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(inIOS) &#123;</span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(inAndriod) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>初始化分支</code>的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。<strong>好处</strong>在于不用重复判断分支。</p>\n<p>如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"http://www.jianshu.com/p/93cea79a2443\">JS与WebView交互存在的一些问题</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/marcuswestin/WebViewJavascriptBridge\">WebViewJavascriptBridge</a></p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在移动<code>web</code>开发过程中，一定会遇到<code>web</code>端与<code>APP</code>端交互的情况。下面就来分析下，<code>web</code>端到底是如何与<code>APP</code>端实现交互的。</p>\n<p>在<code>APP</code>端，<code>iOS</code>和<code>Andriod</code>的实现方式各不一样。</p>\n<p>大家都知道，我们的<code>javascript</code>大部分是运行在浏览器上的，这时浏览器的环境就是宿主环境(host environment)则给我们的<code>javascript</code>提供了<code>window</code>,<code>navigator</code>等宿主对象。</p>","more":"<h3 id=\"Andriod\"><a href=\"#Andriod\" class=\"headerlink\" title=\"Andriod\"></a>Andriod</h3><p>在<code>Android</code>上，实现的方式就和上面这种方式类似，就是在<code>webview</code>上注册一个全局变量，然后我们再<code>js</code>直接调用即可。下面即表示在全局环境下定义了一个对象<code>androidEnv </code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webview.addJavascriptInterface(object, <span class=\"string\">&quot;androidEnv&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"web调用Andriod\"><a href=\"#web调用Andriod\" class=\"headerlink\" title=\"web调用Andriod\"></a>web调用Andriod</h4><p><code>Andriod</code>在<code>webview</code>这个类里面定义的方法，我们在<code>js</code>都可以直接调用，这样就实现了<code>web</code>到<code>Andriod</code>的单向交互了，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AndriodEnv.sayHi(); <span class=\"comment\">//注意：sayHi是Andriod定义的方法</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Andriod调用web\"><a href=\"#Andriod调用web\" class=\"headerlink\" title=\"Andriod调用web\"></a>Andriod调用web</h4><p>然后，如果我们要实现<code>Andriod</code>到<code>web</code>的单向交互呢，道理也一样。即是<code>js</code>定义一个全局的函数，然后<code>Andriod</code>就可以直接调用了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">globalFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello Andriod&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h3><p>相反在<code>iOS</code>上，则没这么方便了，需要用到一个叫<code>WebViewJavascriptBridge</code>的桥接中间件。</p>\n<p>在<code>js</code>上我们需要判断这个<code>bridge</code>是否已经注册，如果有就直接拿来使用；否则就监听一下<code>brideg</code>的变化，然后再使用。因此我们先封装好一个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connectWebViewJavascriptBridge</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class=\"line\">      callback(WebViewJavascriptBridge);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">&#x27;WebViewJavascriptBridgeReady&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(WebViewJavascriptBridge);</span><br><span class=\"line\">      &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后我们用一个<code>callback</code>来处理这个<code>bridge</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    bridge.init(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>到这个时候，基础工作就做完了，接下来就是<code>web</code>与<code>iOS</code>之间的交互了。</p>\n<h4 id=\"web调用iOS\"><a href=\"#web调用iOS\" class=\"headerlink\" title=\"web调用iOS\"></a>web调用iOS</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.callHandler(<span class=\"string\">&#x27;ObjC Echo&#x27;</span>, &#123;<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">responseCallback</span>(<span class=\"params\">responseData</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS received response:&quot;</span>, responseData)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>ObjC Echo</code>是<code>iOS</code>上的对应方法（其实并不是函数，只是一个token），<code>&#123;&#39;key&#39;:&#39;value&#39;&#125;</code>则是<code>web</code>传到<code>iOS</code>的参数，<code>responseData</code>则是<code>iOS</code>回传的数据。</p>\n<p>这里还有另外一种方法，就是我们可以直接利用<code>bridge</code>的<code>send</code>方法，直接将所有东西都<code>send</code>过去给<code>iOS</code>即可，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> param = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;functionName&quot;</span> : <span class=\"string\">&quot;share&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;params&quot;</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;title&quot;</span> : opt.title,</span><br><span class=\"line\">    <span class=\"string\">&quot;desc&quot;</span> : opt.desc</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>send</code>可以接受两个参数，第二个参数就是回调函数了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">connectWebViewJavascriptBridge(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridge</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  bridge.send(param, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    callback(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"iOS调用web\"><a href=\"#iOS调用web\" class=\"headerlink\" title=\"iOS调用web\"></a>iOS调用web</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bridge.registerHandler(<span class=\"string\">&#x27;JS Echo&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, responseCallback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;JS Echo called with:&quot;</span>, data)</span><br><span class=\"line\">    responseCallback(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>JS Echo</code>则是<code>JS</code>上注册的一个方法名，当<code>iOS</code>执行玩这个方法，我们就可以马上监听到并接受到一些数据<code>data</code>，之后我们还可以执行<code>responseCallback</code>回调<code>iOS</code>告诉它我们的处理情况。</p>\n<h3 id=\"说说js代码\"><a href=\"#说说js代码\" class=\"headerlink\" title=\"说说js代码\"></a>说说js代码</h3><p>知道如何实现了之后，就涉及到软件工程的问题了。要如何编写代码结构，最优化实现我们的需求才是重中之重。首先先贴上一份代码，大家可以先考虑如何优化再往下看。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jAPP = &#123;</span><br><span class=\"line\">  <span class=\"attr\">getUserName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">getUserId</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(iOS)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Andriod)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;请在APP内打开&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>我认为的缺点</strong>：</p>\n<ul>\n<li><p>重复判断设备信息，因为设备信息可以理解成<code>常量</code>，一经获取就不会更改，所以我们可以用<code>初始化分支</code>来优化。</p>\n</li>\n<li><p>重复判断是否在APP内。同样可以采用<code>初始化分支</code>来优化，也就是说不在<code>APP</code>内的话，调用的方法都不需要初始化了。</p>\n</li>\n<li><p><code>console.log</code>没有意义，只有在测试环境下能有，上生产应该去除。</p>\n</li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ua = navigator.userAgent().toLowerCase();</span><br><span class=\"line\"><span class=\"keyword\">var</span> inIOS = !!( ua.indexOf(<span class=\"string\">&#x27;iphone&#x27;</span>) &gt; -<span class=\"number\">1</span> || ua.indexOf(<span class=\"string\">&#x27;ipad&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAndriod = !!( ua.indexOf(<span class=\"string\">&#x27;andriod&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> inAPP = !!( ua.indexOf(<span class=\"string\">&#x27;your APP token&#x27;</span>) &gt; -<span class=\"number\">1</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> jAPP = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(inAPP) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span>(inIOS) &#123;</span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(inAndriod) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    jAPP.getUserName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//..</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>初始化分支</code>的意思就是说在js脚本开始执行的的时候就确定好分支，而不是每次执行的时候才去确定分支。<strong>好处</strong>在于不用重复判断分支。</p>\n<p>如果你有更好的做法，希望你可以在下方给大家分享一下。谢谢。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"http://www.jianshu.com/p/93cea79a2443\">JS与WebView交互存在的一些问题</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/marcuswestin/WebViewJavascriptBridge\">WebViewJavascriptBridge</a></p>\n</blockquote>"},{"title":"使用 HTML 发送邮件","date":"2016-09-12T04:25:25.000Z","desc":"HTML发邮件,使用mailto协议","toc":true,"_content":"\n最近项目上的需求是在`HTML`上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。\n\n<!--more-->\n\n## 使用方法\n\n- 直接用`a`标签，然后`href`属性设置协议为`mailto`即可。然后后面可以跟一些参数\n\n```html\n  <a href=\"mailto:xxx@qq.com?subject=这是标题&cc=这是抄送&body=这是正文内容\">发送邮件</a>\n```\n\n- 其实和上面的方法差不多，不过是换了提交的方式，就是使用`form`表单，然后在`form`的`action`属性设置协议`mailto`即可。\n\n```html\n  <form action=\"mailto:xxx@qq.com\" method=\"get\">\n    <input type=\"text\" name=\"cc\" value=\"这是抄送\">\n    <input type=\"text\" name=\"subject\" value=\"这是标题\">\n    <textarea name=\"body\" cols=\"30\" rows=\"10\">这是内容</textarea>\n    <button type=\"submit\">发送邮件</button>\n  </form>\n```\n\n- 如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：\n\n```html\n  <a href=\"mailto:xxx@qq.com,yyy@qq.com\">发送邮件</a>\n```\n\n## 存在的问题\n\n很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。\n\n由于需求的问题，需要自由输入邮件的内容，所有就没使用`a`标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：\n\n1. 在`textarea`的内容格式提交到邮件系统就乱了（换行什么的丢失了）\n\n2. 在`ios`上出现的问题：点击发送的时候，`safari`浏览器提示“这是一张不安全的表单”。\n\n**分析**：\n\n出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用`encodeURIComponent`编码一下`textarea`的内容即可。\n\n出现问题2：则是因为在生产上，我们是使用`https`协议的，如果表单提交到`mailto`这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉`form`表单的提交，自己使用`location.href`跳转（与此同时编码一下`textarea`的内容，则完美解决以上两个问题），这时就类似`a`标签的方式了。（其实这个时候倒不如使用`a`标签提交）\n\n## 无法解决的问题\n\n- 在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）\n\n\n\n\n## 参考\n\n- [HTML的电子邮件链接标签mailto用法详解](http://www.5icool.org/a/201003/308.html)","source":"_posts/html-send-email.md","raw":"---\ntitle: 使用 HTML 发送邮件\ndate: 2016-09-12 12:25:25\ntags:\n- HTML\ndesc: HTML发邮件,使用mailto协议\ntoc: true\ncategories:\n- [前端, 基础]\n---\n\n最近项目上的需求是在`HTML`上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。\n\n<!--more-->\n\n## 使用方法\n\n- 直接用`a`标签，然后`href`属性设置协议为`mailto`即可。然后后面可以跟一些参数\n\n```html\n  <a href=\"mailto:xxx@qq.com?subject=这是标题&cc=这是抄送&body=这是正文内容\">发送邮件</a>\n```\n\n- 其实和上面的方法差不多，不过是换了提交的方式，就是使用`form`表单，然后在`form`的`action`属性设置协议`mailto`即可。\n\n```html\n  <form action=\"mailto:xxx@qq.com\" method=\"get\">\n    <input type=\"text\" name=\"cc\" value=\"这是抄送\">\n    <input type=\"text\" name=\"subject\" value=\"这是标题\">\n    <textarea name=\"body\" cols=\"30\" rows=\"10\">这是内容</textarea>\n    <button type=\"submit\">发送邮件</button>\n  </form>\n```\n\n- 如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：\n\n```html\n  <a href=\"mailto:xxx@qq.com,yyy@qq.com\">发送邮件</a>\n```\n\n## 存在的问题\n\n很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。\n\n由于需求的问题，需要自由输入邮件的内容，所有就没使用`a`标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：\n\n1. 在`textarea`的内容格式提交到邮件系统就乱了（换行什么的丢失了）\n\n2. 在`ios`上出现的问题：点击发送的时候，`safari`浏览器提示“这是一张不安全的表单”。\n\n**分析**：\n\n出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用`encodeURIComponent`编码一下`textarea`的内容即可。\n\n出现问题2：则是因为在生产上，我们是使用`https`协议的，如果表单提交到`mailto`这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉`form`表单的提交，自己使用`location.href`跳转（与此同时编码一下`textarea`的内容，则完美解决以上两个问题），这时就类似`a`标签的方式了。（其实这个时候倒不如使用`a`标签提交）\n\n## 无法解决的问题\n\n- 在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）\n\n\n\n\n## 参考\n\n- [HTML的电子邮件链接标签mailto用法详解](http://www.5icool.org/a/201003/308.html)","slug":"html-send-email","published":1,"updated":"2022-01-08T08:18:48.711Z","_id":"ckxvfmfcu0019brqq7iygg312","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近项目上的需求是在<code>HTML</code>上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><ul>\n<li>直接用<code>a</code>标签，然后<code>href</code>属性设置协议为<code>mailto</code>即可。然后后面可以跟一些参数</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com?subject=这是标题&amp;cc=这是抄送&amp;body=这是正文内容&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其实和上面的方法差不多，不过是换了提交的方式，就是使用<code>form</code>表单，然后在<code>form</code>的<code>action</code>属性设置协议<code>mailto</code>即可。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;mailto:xxx@qq.com&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;get&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cc&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是抄送&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;subject&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是标题&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;body&quot;</span> <span class=\"attr\">cols</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">rows</span>=<span class=\"string\">&quot;10&quot;</span>&gt;</span>这是内容<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com,yyy@qq.com&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><p>很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。</p>\n<p>由于需求的问题，需要自由输入邮件的内容，所有就没使用<code>a</code>标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：</p>\n<ol>\n<li><p>在<code>textarea</code>的内容格式提交到邮件系统就乱了（换行什么的丢失了）</p>\n</li>\n<li><p>在<code>ios</code>上出现的问题：点击发送的时候，<code>safari</code>浏览器提示“这是一张不安全的表单”。</p>\n</li>\n</ol>\n<p><strong>分析</strong>：</p>\n<p>出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用<code>encodeURIComponent</code>编码一下<code>textarea</code>的内容即可。</p>\n<p>出现问题2：则是因为在生产上，我们是使用<code>https</code>协议的，如果表单提交到<code>mailto</code>这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉<code>form</code>表单的提交，自己使用<code>location.href</code>跳转（与此同时编码一下<code>textarea</code>的内容，则完美解决以上两个问题），这时就类似<code>a</code>标签的方式了。（其实这个时候倒不如使用<code>a</code>标签提交）</p>\n<h2 id=\"无法解决的问题\"><a href=\"#无法解决的问题\" class=\"headerlink\" title=\"无法解决的问题\"></a>无法解决的问题</h2><ul>\n<li>在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.5icool.org/a/201003/308.html\">HTML的电子邮件链接标签mailto用法详解</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>最近项目上的需求是在<code>HTML</code>上直接调用系统的邮件系统发邮件，并添加收件人，标题等信息。看似简单，其实开发过程中也遇到了一些问题，现在来总结一下。</p>","more":"<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><ul>\n<li>直接用<code>a</code>标签，然后<code>href</code>属性设置协议为<code>mailto</code>即可。然后后面可以跟一些参数</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com?subject=这是标题&amp;cc=这是抄送&amp;body=这是正文内容&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其实和上面的方法差不多，不过是换了提交的方式，就是使用<code>form</code>表单，然后在<code>form</code>的<code>action</code>属性设置协议<code>mailto</code>即可。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;mailto:xxx@qq.com&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;get&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cc&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是抄送&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;subject&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;这是标题&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;body&quot;</span> <span class=\"attr\">cols</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">rows</span>=<span class=\"string\">&quot;10&quot;</span>&gt;</span>这是内容<span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果需要多个收件人则只需要在邮箱地址之间加个逗号，比如：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:xxx@qq.com,yyy@qq.com&quot;</span>&gt;</span>发送邮件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><p>很多时候到这里本就应该结束的，但是生活就像心电图，不能一帆风顺，否则你就挂了。</p>\n<p>由于需求的问题，需要自由输入邮件的内容，所有就没使用<code>a</code>标签（因为不想自己拼链接）。于是使用表单提交的方式，于是就出现了一下问题：</p>\n<ol>\n<li><p>在<code>textarea</code>的内容格式提交到邮件系统就乱了（换行什么的丢失了）</p>\n</li>\n<li><p>在<code>ios</code>上出现的问题：点击发送的时候，<code>safari</code>浏览器提示“这是一张不安全的表单”。</p>\n</li>\n</ol>\n<p><strong>分析</strong>：</p>\n<p>出现问题1：是因为表单提交的时候没有编码，导致换行的信息丢失，使用<code>encodeURIComponent</code>编码一下<code>textarea</code>的内容即可。</p>\n<p>出现问题2：则是因为在生产上，我们是使用<code>https</code>协议的，如果表单提交到<code>mailto</code>这个协议，则是安全级别下降（猜测的），于是safari就提示不安全了。针对这个问题，我的解决办法是禁掉<code>form</code>表单的提交，自己使用<code>location.href</code>跳转（与此同时编码一下<code>textarea</code>的内容，则完美解决以上两个问题），这时就类似<code>a</code>标签的方式了。（其实这个时候倒不如使用<code>a</code>标签提交）</p>\n<h2 id=\"无法解决的问题\"><a href=\"#无法解决的问题\" class=\"headerlink\" title=\"无法解决的问题\"></a>无法解决的问题</h2><ul>\n<li>在微信上无法唤起邮件系统，因为被微信禁掉了（反而在QQ上正常唤起）</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.5icool.org/a/201003/308.html\">HTML的电子邮件链接标签mailto用法详解</a></li>\n</ul>"},{"title":"如果使用Node.js的Buffers","date":"2017-10-06T09:14:44.000Z","desc":null,"from":"https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers/","toc":true,"_content":"\n# 为什么要有Buffers？\n\n在纯`JavaScript`开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让`JavaScript`需要处理纯二进制数据了。\n\n其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。\n\n所以，记住了，别使用二进制字符串(binary strings)，用**buffers**代替它！\n\n<!-- more -->\n\n# 什么是Buffers？\n\n在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。\n\n每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。\n\n> 另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)\n\n# 在哪里可以看到buffers\n\n一般情况，buffer经常可以在读取二进制数据流的时候看到，比如`fs.createReadStream`\n\n## 用法：\n\n### 创建buffer\n\n有许多方法可以生成新的buffers：\n\n```js\nvar buffer = new Buffer(8);\n```\n\n> 这个buffer是未初始化的，且包含8个字节(bytes)。\n\n```\nvar buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);\n```\n\n这个buffer用一个数组的内容来初始化。记住了，**数组里的数字表示的是字节(bytes)**\n\n```\nvar buffer = new Buffer(\"I'm a string!\", \"utf-8\")\n```\n\n通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：\n\n- \"ascii\"：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。\n- \"ucs2\"：一种双字节，小端存储的编码。可以编码一个unicode的子集。\n- \"base64\"：Base64字符串编码。\n- \"binary\"：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。\n\n### 写入buffer\n\n#### 创建一个buffer：\n\n```js\n> var buffer = new Buffer(16);\n```\n\n开始写入字符串：\n\n```\n> buffer.write(\"Hello\", \"utf-8\")\n5\n```\n\n`buffer.write`的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。\n\n`buffer.write`返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：\n\n```js\n> buffer.write(\" world!\", 5, \"utf-8\")\n7\n```\n\n当`buffer.write`有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。\n\n### 读取buffer\n\n#### toString：\n\n这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：\n\n```js\n> buffer.toString('utf-8')\n'Hello world!\\u0000�k\\t'\n```\n\n再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：\n\n```js\n> buffer.toString(\"utf-8\", 0, 12)\n'Hello world!'\n```\n\n#### 独立字节：\n\n你可以看到用类似数组的语法来设置独立位(individual bits)\n\n```js\n> buffer[12] = buffer[11];\n33\n> buffer[13] = \"1\".charCodeAt();\n49\n> buffer[14] = buffer[13];\n49\n> buffer[15] = 33\n33\n> buffer.toString(\"utf-8\")\n'Hello world!!11!'\n```\n\n在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。\n\n## 更多有趣用法\n\n### Buffer.isBuffer(object)\n\n这个方法是检测一个对象是否是buffer，类似于`Array.isArray`\n\n### Buffer.byteLength(string, encoding)\n\n通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：\n\n```js\n> var snowman = \"☃\";\n> snowman.length\n1\n> Buffer.byteLength(snowman)\n3\n```\n\n这个unicode的雪人只有两个字符，却占了3个字节。\n\n### buffer.length\n\n这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：\n\n```js\n> var buffer = new Buffer(16)\n> buffer.write(snowman)\n3\n> buffer.length\n16\n```\n\n在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。\n\n### buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n`buffer.copy`允许拷贝一个buffer的内容到另一个buffer。\n\n第一个参数表示**目标buffer**，就是要写入内容的buffer。\n\n另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：\n\n```js\n> var frosty = new Buffer(24)\n> var snowman = new Buffer(\"☃\", \"utf-8\")\n> frosty.write(\"Happy birthday! \", \"utf-8\")\n16\n> snowman.copy(frosty, 16)\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ☃'\n```\n\n在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。\n\n其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。\n\n### buffer.slice(start, end=buffer.length)\n\n这个方法的API可以说和`Array.prototype.slice`是一样的。\n\n不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：\n\n```js\n> var puddle = frosty.slice(16, 19)\n> puddle.toString()\n'☃'\n> puddle.write(\"___\")\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ___'\n```\n\n完。\n\n\n\n","source":"_posts/how-to-use-buffers.md","raw":"---\ntitle: 如果使用Node.js的Buffers\ndate: 2017-10-06 17:14:44\ntags: \n- Node.js\n- Buffers\ndesc: \nfrom: https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers/\ntoc: true\ncategories:\n- Node.js\n---\n\n# 为什么要有Buffers？\n\n在纯`JavaScript`开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让`JavaScript`需要处理纯二进制数据了。\n\n其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。\n\n所以，记住了，别使用二进制字符串(binary strings)，用**buffers**代替它！\n\n<!-- more -->\n\n# 什么是Buffers？\n\n在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。\n\n每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。\n\n> 另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)\n\n# 在哪里可以看到buffers\n\n一般情况，buffer经常可以在读取二进制数据流的时候看到，比如`fs.createReadStream`\n\n## 用法：\n\n### 创建buffer\n\n有许多方法可以生成新的buffers：\n\n```js\nvar buffer = new Buffer(8);\n```\n\n> 这个buffer是未初始化的，且包含8个字节(bytes)。\n\n```\nvar buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);\n```\n\n这个buffer用一个数组的内容来初始化。记住了，**数组里的数字表示的是字节(bytes)**\n\n```\nvar buffer = new Buffer(\"I'm a string!\", \"utf-8\")\n```\n\n通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：\n\n- \"ascii\"：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。\n- \"ucs2\"：一种双字节，小端存储的编码。可以编码一个unicode的子集。\n- \"base64\"：Base64字符串编码。\n- \"binary\"：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。\n\n### 写入buffer\n\n#### 创建一个buffer：\n\n```js\n> var buffer = new Buffer(16);\n```\n\n开始写入字符串：\n\n```\n> buffer.write(\"Hello\", \"utf-8\")\n5\n```\n\n`buffer.write`的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。\n\n`buffer.write`返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：\n\n```js\n> buffer.write(\" world!\", 5, \"utf-8\")\n7\n```\n\n当`buffer.write`有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。\n\n### 读取buffer\n\n#### toString：\n\n这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：\n\n```js\n> buffer.toString('utf-8')\n'Hello world!\\u0000�k\\t'\n```\n\n再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：\n\n```js\n> buffer.toString(\"utf-8\", 0, 12)\n'Hello world!'\n```\n\n#### 独立字节：\n\n你可以看到用类似数组的语法来设置独立位(individual bits)\n\n```js\n> buffer[12] = buffer[11];\n33\n> buffer[13] = \"1\".charCodeAt();\n49\n> buffer[14] = buffer[13];\n49\n> buffer[15] = 33\n33\n> buffer.toString(\"utf-8\")\n'Hello world!!11!'\n```\n\n在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。\n\n## 更多有趣用法\n\n### Buffer.isBuffer(object)\n\n这个方法是检测一个对象是否是buffer，类似于`Array.isArray`\n\n### Buffer.byteLength(string, encoding)\n\n通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：\n\n```js\n> var snowman = \"☃\";\n> snowman.length\n1\n> Buffer.byteLength(snowman)\n3\n```\n\n这个unicode的雪人只有两个字符，却占了3个字节。\n\n### buffer.length\n\n这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：\n\n```js\n> var buffer = new Buffer(16)\n> buffer.write(snowman)\n3\n> buffer.length\n16\n```\n\n在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。\n\n### buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n`buffer.copy`允许拷贝一个buffer的内容到另一个buffer。\n\n第一个参数表示**目标buffer**，就是要写入内容的buffer。\n\n另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：\n\n```js\n> var frosty = new Buffer(24)\n> var snowman = new Buffer(\"☃\", \"utf-8\")\n> frosty.write(\"Happy birthday! \", \"utf-8\")\n16\n> snowman.copy(frosty, 16)\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ☃'\n```\n\n在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。\n\n其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。\n\n### buffer.slice(start, end=buffer.length)\n\n这个方法的API可以说和`Array.prototype.slice`是一样的。\n\n不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：\n\n```js\n> var puddle = frosty.slice(16, 19)\n> puddle.toString()\n'☃'\n> puddle.write(\"___\")\n3\n> frosty.toString(\"utf-8\", 0, 19)\n'Happy birthday! ___'\n```\n\n完。\n\n\n\n","slug":"how-to-use-buffers","published":1,"updated":"2022-01-08T08:34:12.895Z","_id":"ckxvfmfd0001bbrqqbo8mbgqt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"为什么要有Buffers？\"><a href=\"#为什么要有Buffers？\" class=\"headerlink\" title=\"为什么要有Buffers？\"></a>为什么要有Buffers？</h1><p>在纯<code>JavaScript</code>开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让<code>JavaScript</code>需要处理纯二进制数据了。</p>\n<p>其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。</p>\n<p>所以，记住了，别使用二进制字符串(binary strings)，用<strong>buffers</strong>代替它！</p>\n<span id=\"more\"></span>\n\n<h1 id=\"什么是Buffers？\"><a href=\"#什么是Buffers？\" class=\"headerlink\" title=\"什么是Buffers？\"></a>什么是Buffers？</h1><p>在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。</p>\n<p>每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。</p>\n<blockquote>\n<p>另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)</p>\n</blockquote>\n<h1 id=\"在哪里可以看到buffers\"><a href=\"#在哪里可以看到buffers\" class=\"headerlink\" title=\"在哪里可以看到buffers\"></a>在哪里可以看到buffers</h1><p>一般情况，buffer经常可以在读取二进制数据流的时候看到，比如<code>fs.createReadStream</code></p>\n<h2 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h2><h3 id=\"创建buffer\"><a href=\"#创建buffer\" class=\"headerlink\" title=\"创建buffer\"></a>创建buffer</h3><p>有许多方法可以生成新的buffers：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个buffer是未初始化的，且包含8个字节(bytes)。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);</span><br></pre></td></tr></table></figure>\n\n<p>这个buffer用一个数组的内容来初始化。记住了，<strong>数组里的数字表示的是字节(bytes)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer(&quot;I&#x27;m a string!&quot;, &quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：</p>\n<ul>\n<li>“ascii”：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。</li>\n<li>“ucs2”：一种双字节，小端存储的编码。可以编码一个unicode的子集。</li>\n<li>“base64”：Base64字符串编码。</li>\n<li>“binary”：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。</li>\n</ul>\n<h3 id=\"写入buffer\"><a href=\"#写入buffer\" class=\"headerlink\" title=\"写入buffer\"></a>写入buffer</h3><h4 id=\"创建一个buffer：\"><a href=\"#创建一个buffer：\" class=\"headerlink\" title=\"创建一个buffer：\"></a>创建一个buffer：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>开始写入字符串：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(&quot;Hello&quot;, &quot;utf-8&quot;)</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><code>buffer.write</code>的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。</p>\n<p><code>buffer.write</code>返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(<span class=\"string\">&quot; world!&quot;</span>, <span class=\"number\">5</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>buffer.write</code>有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。</p>\n<h3 id=\"读取buffer\"><a href=\"#读取buffer\" class=\"headerlink\" title=\"读取buffer\"></a>读取buffer</h3><h4 id=\"toString：\"><a href=\"#toString：\" class=\"headerlink\" title=\"toString：\"></a>toString：</h4><p>这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!\\u0000�k\\t&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"独立字节：\"><a href=\"#独立字节：\" class=\"headerlink\" title=\"独立字节：\"></a>独立字节：</h4><p>你可以看到用类似数组的语法来设置独立位(individual bits)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer[<span class=\"number\">12</span>] = buffer[<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">13</span>] = <span class=\"string\">&quot;1&quot;</span>.charCodeAt();</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">14</span>] = buffer[<span class=\"number\">13</span>];</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">15</span>] = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!!11!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。</p>\n<h2 id=\"更多有趣用法\"><a href=\"#更多有趣用法\" class=\"headerlink\" title=\"更多有趣用法\"></a>更多有趣用法</h2><h3 id=\"Buffer-isBuffer-object\"><a href=\"#Buffer-isBuffer-object\" class=\"headerlink\" title=\"Buffer.isBuffer(object)\"></a>Buffer.isBuffer(object)</h3><p>这个方法是检测一个对象是否是buffer，类似于<code>Array.isArray</code></p>\n<h3 id=\"Buffer-byteLength-string-encoding\"><a href=\"#Buffer-byteLength-string-encoding\" class=\"headerlink\" title=\"Buffer.byteLength(string, encoding)\"></a>Buffer.byteLength(string, encoding)</h3><p>通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"string\">&quot;☃&quot;</span>;</span><br><span class=\"line\">&gt; snowman.length</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">&gt; Buffer.byteLength(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>这个unicode的雪人只有两个字符，却占了3个字节。</p>\n<h3 id=\"buffer-length\"><a href=\"#buffer-length\" class=\"headerlink\" title=\"buffer.length\"></a>buffer.length</h3><p>这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>)</span><br><span class=\"line\">&gt; buffer.write(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; buffer.length</span><br><span class=\"line\"><span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。</p>\n<h3 id=\"buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\"><a href=\"#buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\" class=\"headerlink\" title=\"buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\"></a>buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</h3><p><code>buffer.copy</code>允许拷贝一个buffer的内容到另一个buffer。</p>\n<p>第一个参数表示<strong>目标buffer</strong>，就是要写入内容的buffer。</p>\n<p>另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> frosty = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">24</span>)</span><br><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">&quot;☃&quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\">&gt; frosty.write(<span class=\"string\">&quot;Happy birthday! &quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">16</span></span><br><span class=\"line\">&gt; snowman.copy(frosty, <span class=\"number\">16</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ☃&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。</p>\n<p>其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。</p>\n<h3 id=\"buffer-slice-start-end-buffer-length\"><a href=\"#buffer-slice-start-end-buffer-length\" class=\"headerlink\" title=\"buffer.slice(start, end=buffer.length)\"></a>buffer.slice(start, end=buffer.length)</h3><p>这个方法的API可以说和<code>Array.prototype.slice</code>是一样的。</p>\n<p>不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> puddle = frosty.slice(<span class=\"number\">16</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\">&gt; puddle.toString()</span><br><span class=\"line\"><span class=\"string\">&#x27;☃&#x27;</span></span><br><span class=\"line\">&gt; puddle.write(<span class=\"string\">&quot;___&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ___&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>完。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h1 id=\"为什么要有Buffers？\"><a href=\"#为什么要有Buffers？\" class=\"headerlink\" title=\"为什么要有Buffers？\"></a>为什么要有Buffers？</h1><p>在纯<code>JavaScript</code>开发中，unicode编码的字符串也够好用的了，并不需要直接处理二进制数据(straight binary data)。在浏览器环境，大部分数据都是字符串的形式，这是足够的。然而，Node.js是服务器环境，必须要处理TCP流还有文件系统的读取和写入流，这就让<code>JavaScript</code>需要处理纯二进制数据了。</p>\n<p>其实，要解决这个问题直接使用字符串也是可以的，这也是Node.js一开始的做法。然而，这样的做法有许多问题，也很慢。</p>\n<p>所以，记住了，别使用二进制字符串(binary strings)，用<strong>buffers</strong>代替它！</p>","more":"<h1 id=\"什么是Buffers？\"><a href=\"#什么是Buffers？\" class=\"headerlink\" title=\"什么是Buffers？\"></a>什么是Buffers？</h1><p>在Node.js里，Buffers是专门设计来处理原始二进制数据的，是Buffer这个类的实例。</p>\n<p>每个buffer在V8引擎外都有内存分配。Buffer操作起来和包含数字的数组一样，但是不像数组那样自由设置大小的。并且buffer拥有一系列操作二进制数据的方法。</p>\n<blockquote>\n<p>另外，buffer里的“数字”代表的是byte并且限制大小是0到255(2^8-1)</p>\n</blockquote>\n<h1 id=\"在哪里可以看到buffers\"><a href=\"#在哪里可以看到buffers\" class=\"headerlink\" title=\"在哪里可以看到buffers\"></a>在哪里可以看到buffers</h1><p>一般情况，buffer经常可以在读取二进制数据流的时候看到，比如<code>fs.createReadStream</code></p>\n<h2 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h2><h3 id=\"创建buffer\"><a href=\"#创建buffer\" class=\"headerlink\" title=\"创建buffer\"></a>创建buffer</h3><p>有许多方法可以生成新的buffers：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个buffer是未初始化的，且包含8个字节(bytes)。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer([ 8, 6, 7, 5, 3, 0, 9]);</span><br></pre></td></tr></table></figure>\n\n<p>这个buffer用一个数组的内容来初始化。记住了，<strong>数组里的数字表示的是字节(bytes)</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var buffer = new Buffer(&quot;I&#x27;m a string!&quot;, &quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>通过第二个参数来指定编码(默认是utf-8)的字符串来初始化buffer。utf-8是在Node.js里最常用的编码，但是buffer还支持其他编码：</p>\n<ul>\n<li>“ascii”：这个编码方式很快，但是只限制ascii字符集。而且这个编码会将null转换成空格，而不像utf-8编码。</li>\n<li>“ucs2”：一种双字节，小端存储的编码。可以编码一个unicode的子集。</li>\n<li>“base64”：Base64字符串编码。</li>\n<li>“binary”：这个“二进制字符串”前面提到过，这个编码即将被弃用，避免使用这个。</li>\n</ul>\n<h3 id=\"写入buffer\"><a href=\"#写入buffer\" class=\"headerlink\" title=\"写入buffer\"></a>写入buffer</h3><h4 id=\"创建一个buffer：\"><a href=\"#创建一个buffer：\" class=\"headerlink\" title=\"创建一个buffer：\"></a>创建一个buffer：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>开始写入字符串：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(&quot;Hello&quot;, &quot;utf-8&quot;)</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><code>buffer.write</code>的第一个参数是写入buffer的字符串，而第二个参数是这个字符串的编码方式。如果字符串的编码是utf-8，那么这个参数是多余的。</p>\n<p><code>buffer.write</code>返回5，这代表我们写入了5个字节到这个buffer。事实上，“Hello“这个字符串也刚好是5个字符。这是因为刚好每个字符都是8位(bits)。这对补全字符串很重要：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.write(<span class=\"string\">&quot; world!&quot;</span>, <span class=\"number\">5</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>buffer.write</code>有3个参数的时候，第二个参数代表是偏移量，或者说是buffer开始写入的位置。</p>\n<h3 id=\"读取buffer\"><a href=\"#读取buffer\" class=\"headerlink\" title=\"读取buffer\"></a>读取buffer</h3><h4 id=\"toString：\"><a href=\"#toString：\" class=\"headerlink\" title=\"toString：\"></a>toString：</h4><p>这个方法可能是读取buffer最通用的方法了，因为很多buffer都包含文本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!\\u0000�k\\t&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>再一次，第一个参数代表编码方式。这里可以看到并没有用完整个buffer。幸运的是，我们知道写入了多少字节到这个buffer，我们可以简单地增加参数去割开这个字符串：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"独立字节：\"><a href=\"#独立字节：\" class=\"headerlink\" title=\"独立字节：\"></a>独立字节：</h4><p>你可以看到用类似数组的语法来设置独立位(individual bits)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; buffer[<span class=\"number\">12</span>] = buffer[<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">13</span>] = <span class=\"string\">&quot;1&quot;</span>.charCodeAt();</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">14</span>] = buffer[<span class=\"number\">13</span>];</span><br><span class=\"line\"><span class=\"number\">49</span></span><br><span class=\"line\">&gt; buffer[<span class=\"number\">15</span>] = <span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\">&gt; buffer.toString(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Hello world!!11!&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，手动地设置剩余的字节，这样就代表了“utf-8”编码的“！”和“1“字符了。</p>\n<h2 id=\"更多有趣用法\"><a href=\"#更多有趣用法\" class=\"headerlink\" title=\"更多有趣用法\"></a>更多有趣用法</h2><h3 id=\"Buffer-isBuffer-object\"><a href=\"#Buffer-isBuffer-object\" class=\"headerlink\" title=\"Buffer.isBuffer(object)\"></a>Buffer.isBuffer(object)</h3><p>这个方法是检测一个对象是否是buffer，类似于<code>Array.isArray</code></p>\n<h3 id=\"Buffer-byteLength-string-encoding\"><a href=\"#Buffer-byteLength-string-encoding\" class=\"headerlink\" title=\"Buffer.byteLength(string, encoding)\"></a>Buffer.byteLength(string, encoding)</h3><p>通过这个方法，你可以获取字符串(默认utf-8编码)的字节数。这个长度和字符串的长度(string length)不一样，因为很多字符需要更多的字节，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"string\">&quot;☃&quot;</span>;</span><br><span class=\"line\">&gt; snowman.length</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">&gt; Buffer.byteLength(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>这个unicode的雪人只有两个字符，却占了3个字节。</p>\n<h3 id=\"buffer-length\"><a href=\"#buffer-length\" class=\"headerlink\" title=\"buffer.length\"></a>buffer.length</h3><p>这个是buffer的长度，也代表分配了多少内存。这个不等于buffer内容的大小，因为buffer有可能是没满的，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">16</span>)</span><br><span class=\"line\">&gt; buffer.write(snowman)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; buffer.length</span><br><span class=\"line\"><span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里，我们只写入了3个字符，但是长度依然是16，因为这是已经初始化了的。</p>\n<h3 id=\"buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\"><a href=\"#buffer-copy-target-targetStart-0-sourceStart-0-sourceEnd-buffer-length\" class=\"headerlink\" title=\"buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\"></a>buffer.copy(target, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</h3><p><code>buffer.copy</code>允许拷贝一个buffer的内容到另一个buffer。</p>\n<p>第一个参数表示<strong>目标buffer</strong>，就是要写入内容的buffer。</p>\n<p>另外一个参数是指定需要拷贝到目标buffer的开始位置。看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> frosty = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">24</span>)</span><br><span class=\"line\">&gt; <span class=\"keyword\">var</span> snowman = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">&quot;☃&quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\">&gt; frosty.write(<span class=\"string\">&quot;Happy birthday! &quot;</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">16</span></span><br><span class=\"line\">&gt; snowman.copy(frosty, <span class=\"number\">16</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ☃&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子，拷贝了含有3个字节长度的“snowman”buffer到“forsty”buffer。</p>\n<p>其中forsty一开始写入了前16个字节，而snowman有3个字节长，因此结果就是19个字节长。</p>\n<h3 id=\"buffer-slice-start-end-buffer-length\"><a href=\"#buffer-slice-start-end-buffer-length\" class=\"headerlink\" title=\"buffer.slice(start, end=buffer.length)\"></a>buffer.slice(start, end=buffer.length)</h3><p>这个方法的API可以说和<code>Array.prototype.slice</code>是一样的。</p>\n<p>不过其中一个特别重要的区别是：这个slice方法不是简单地返回一个新的buffer，也不仅仅是内存中子集的引用。这个slice会改变原来的buffer！举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">var</span> puddle = frosty.slice(<span class=\"number\">16</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\">&gt; puddle.toString()</span><br><span class=\"line\"><span class=\"string\">&#x27;☃&#x27;</span></span><br><span class=\"line\">&gt; puddle.write(<span class=\"string\">&quot;___&quot;</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">&gt; frosty.toString(<span class=\"string\">&quot;utf-8&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"string\">&#x27;Happy birthday! ___&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>完。</p>"},{"title":"HTML5 History API","date":"2016-07-05T13:16:18.000Z","desc":"html5,history api,历史API,操作历史记录","toc":true,"_content":"\n在`DOM`中，`window`对象中有一个`history`的对象可以用来访问浏览器的历史记录，在`HTML5`中，更可以通过它来操作历史记录\n\n<!--more-->\n\n### 以前的API\n\n历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）\n\n```js\n  history.forward(); //前进\n  history.back(); //后退\n```\n\n移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）\n\n```js\n  history.go(-1) //相当于history.back();\n  history.go(1) //相当于history.forward();\n```\n\n其中，`history`有一个`length`的属性，就是历史记录的长度\n\n```js\n  var historyLength = history.length;\n```\n\n## 更强大的HTML5 Histroy API\n\n- `history.pushState()`\n- `history.replaceState()`\n两个方法配合`window.onpopstate`事件使用更佳。\n\n其中，`pushState()`方法接受三个参数\n- 状态对象（state obejct）即一个可序列化的`javascript`对象，与新历史记录相关联。可以使用`history.state`读取当前历史记录相关的数据对象。\n- 标题（title）目前暂时会忽略这个参数，以后可能会用上。\n- 地址（URL）新的历史记录的地址。\n\n举个例子，假设我们现在打开的是index.html\n\n```js\n  var stateObj = { country: 'China' };\n  setTimeout(function(){\n    history.pushState(stateObj, 'china', 'china.html');\n  }, 1000);\n```\n\n页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的`history.state`就是`stateObj`的拷贝，此时我们就可以利用这个数据来进行相关的操作了。\n如果此时我们点击后退，则URL变成index.html，此时`history.state=null`\n\n说到这里，你应该会有点困惑，好像这个`API`并没什么卵用，直接用`hash`配合`window.onhashchange`就可以做到啦，类似如下\n\n```js\n  location.href = 'www.someURL.com#/china.html?country=china';\n```\n\n上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应`伪URL`的相关的数据。\n\n不过对比而言，`pushState`也有它的优势：\n\n- 使用`hash`的方式时，如果当前`hash`的值不变（即url='www.someURL.com#foo'时，设置location.href = 'www.someURL.com#foo'），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同 url 时则会创建新的历史记录。\n- 绑定相关数据时，`history.state`可以说是可以绑定任意数据，而基于`hash`的方式则要把所有数据转换成相关的字符串\n\n`replaceState()`使用方法和`pushState()`基本一致。不同的是，`replaceState()`方法会修改当前历史记录而不是创建新的历史记录\n\n相关DEMO，敬请期待。。。","source":"_posts/h5-history-api.md","raw":"---\ntitle: HTML5 History API\ndate: 2016-07-05 21:16:18\ntags: History API\ndesc: html5,history api,历史API,操作历史记录\ntoc: true\ncategories:\n- [前端, 基础]\n- 浏览器\n---\n\n在`DOM`中，`window`对象中有一个`history`的对象可以用来访问浏览器的历史记录，在`HTML5`中，更可以通过它来操作历史记录\n\n<!--more-->\n\n### 以前的API\n\n历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）\n\n```js\n  history.forward(); //前进\n  history.back(); //后退\n```\n\n移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）\n\n```js\n  history.go(-1) //相当于history.back();\n  history.go(1) //相当于history.forward();\n```\n\n其中，`history`有一个`length`的属性，就是历史记录的长度\n\n```js\n  var historyLength = history.length;\n```\n\n## 更强大的HTML5 Histroy API\n\n- `history.pushState()`\n- `history.replaceState()`\n两个方法配合`window.onpopstate`事件使用更佳。\n\n其中，`pushState()`方法接受三个参数\n- 状态对象（state obejct）即一个可序列化的`javascript`对象，与新历史记录相关联。可以使用`history.state`读取当前历史记录相关的数据对象。\n- 标题（title）目前暂时会忽略这个参数，以后可能会用上。\n- 地址（URL）新的历史记录的地址。\n\n举个例子，假设我们现在打开的是index.html\n\n```js\n  var stateObj = { country: 'China' };\n  setTimeout(function(){\n    history.pushState(stateObj, 'china', 'china.html');\n  }, 1000);\n```\n\n页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的`history.state`就是`stateObj`的拷贝，此时我们就可以利用这个数据来进行相关的操作了。\n如果此时我们点击后退，则URL变成index.html，此时`history.state=null`\n\n说到这里，你应该会有点困惑，好像这个`API`并没什么卵用，直接用`hash`配合`window.onhashchange`就可以做到啦，类似如下\n\n```js\n  location.href = 'www.someURL.com#/china.html?country=china';\n```\n\n上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应`伪URL`的相关的数据。\n\n不过对比而言，`pushState`也有它的优势：\n\n- 使用`hash`的方式时，如果当前`hash`的值不变（即url='www.someURL.com#foo'时，设置location.href = 'www.someURL.com#foo'），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同 url 时则会创建新的历史记录。\n- 绑定相关数据时，`history.state`可以说是可以绑定任意数据，而基于`hash`的方式则要把所有数据转换成相关的字符串\n\n`replaceState()`使用方法和`pushState()`基本一致。不同的是，`replaceState()`方法会修改当前历史记录而不是创建新的历史记录\n\n相关DEMO，敬请期待。。。","slug":"h5-history-api","published":1,"updated":"2022-01-08T08:21:12.147Z","_id":"ckxvfmfd3001ebrqqb3f43pj5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在<code>DOM</code>中，<code>window</code>对象中有一个<code>history</code>的对象可以用来访问浏览器的历史记录，在<code>HTML5</code>中，更可以通过它来操作历史记录</p>\n<span id=\"more\"></span>\n\n<h3 id=\"以前的API\"><a href=\"#以前的API\" class=\"headerlink\" title=\"以前的API\"></a>以前的API</h3><p>历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.forward(); <span class=\"comment\">//前进</span></span><br><span class=\"line\">history.back(); <span class=\"comment\">//后退</span></span><br></pre></td></tr></table></figure>\n\n<p>移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.back();</span></span><br><span class=\"line\">history.go(<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.forward();</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>history</code>有一个<code>length</code>的属性，就是历史记录的长度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> historyLength = history.length;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更强大的HTML5-Histroy-API\"><a href=\"#更强大的HTML5-Histroy-API\" class=\"headerlink\" title=\"更强大的HTML5 Histroy API\"></a>更强大的HTML5 Histroy API</h2><ul>\n<li><code>history.pushState()</code></li>\n<li><code>history.replaceState()</code><br>两个方法配合<code>window.onpopstate</code>事件使用更佳。</li>\n</ul>\n<p>其中，<code>pushState()</code>方法接受三个参数</p>\n<ul>\n<li>状态对象（state obejct）即一个可序列化的<code>javascript</code>对象，与新历史记录相关联。可以使用<code>history.state</code>读取当前历史记录相关的数据对象。</li>\n<li>标题（title）目前暂时会忽略这个参数，以后可能会用上。</li>\n<li>地址（URL）新的历史记录的地址。</li>\n</ul>\n<p>举个例子，假设我们现在打开的是index.html</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stateObj = &#123; <span class=\"attr\">country</span>: <span class=\"string\">&#x27;China&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  history.pushState(stateObj, <span class=\"string\">&#x27;china&#x27;</span>, <span class=\"string\">&#x27;china.html&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的<code>history.state</code>就是<code>stateObj</code>的拷贝，此时我们就可以利用这个数据来进行相关的操作了。<br>如果此时我们点击后退，则URL变成index.html，此时<code>history.state=null</code></p>\n<p>说到这里，你应该会有点困惑，好像这个<code>API</code>并没什么卵用，直接用<code>hash</code>配合<code>window.onhashchange</code>就可以做到啦，类似如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location.href = <span class=\"string\">&#x27;www.someURL.com#/china.html?country=china&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应<code>伪URL</code>的相关的数据。</p>\n<p>不过对比而言，<code>pushState</code>也有它的优势：</p>\n<ul>\n<li>使用<code>hash</code>的方式时，如果当前<code>hash</code>的值不变（即url=’<a href=\"http://www.someurl.com/#foo&#39;%E6%97%B6%EF%BC%8C%E8%AE%BE%E7%BD%AElocation.href\">www.someURL.com#foo&#39;时，设置location.href</a> = ‘<a href=\"http://www.someurl.com/#foo&#39;%EF%BC%89%EF%BC%8C%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%EF%BC%8C%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%60onhashchange%60%E4%BA%8B%E4%BB%B6%E7%9A%84%EF%BC%8C%E8%80%8C%60history.pushState%60%E6%8F%92%E5%85%A5%E7%9B%B8%E5%90%8C\">www.someURL.com#foo&#39;），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同</a> url 时则会创建新的历史记录。</li>\n<li>绑定相关数据时，<code>history.state</code>可以说是可以绑定任意数据，而基于<code>hash</code>的方式则要把所有数据转换成相关的字符串</li>\n</ul>\n<p><code>replaceState()</code>使用方法和<code>pushState()</code>基本一致。不同的是，<code>replaceState()</code>方法会修改当前历史记录而不是创建新的历史记录</p>\n<p>相关DEMO，敬请期待。。。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在<code>DOM</code>中，<code>window</code>对象中有一个<code>history</code>的对象可以用来访问浏览器的历史记录，在<code>HTML5</code>中，更可以通过它来操作历史记录</p>","more":"<h3 id=\"以前的API\"><a href=\"#以前的API\" class=\"headerlink\" title=\"以前的API\"></a>以前的API</h3><p>历史记录的前进和后退（相当于点击浏览器上的前进和后退按钮）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.forward(); <span class=\"comment\">//前进</span></span><br><span class=\"line\">history.back(); <span class=\"comment\">//后退</span></span><br></pre></td></tr></table></figure>\n\n<p>移动到指定的历史记录位置（其中0为当前页，-1为上一页，1为下一页）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.back();</span></span><br><span class=\"line\">history.go(<span class=\"number\">1</span>) <span class=\"comment\">//相当于history.forward();</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>history</code>有一个<code>length</code>的属性，就是历史记录的长度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> historyLength = history.length;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"更强大的HTML5-Histroy-API\"><a href=\"#更强大的HTML5-Histroy-API\" class=\"headerlink\" title=\"更强大的HTML5 Histroy API\"></a>更强大的HTML5 Histroy API</h2><ul>\n<li><code>history.pushState()</code></li>\n<li><code>history.replaceState()</code><br>两个方法配合<code>window.onpopstate</code>事件使用更佳。</li>\n</ul>\n<p>其中，<code>pushState()</code>方法接受三个参数</p>\n<ul>\n<li>状态对象（state obejct）即一个可序列化的<code>javascript</code>对象，与新历史记录相关联。可以使用<code>history.state</code>读取当前历史记录相关的数据对象。</li>\n<li>标题（title）目前暂时会忽略这个参数，以后可能会用上。</li>\n<li>地址（URL）新的历史记录的地址。</li>\n</ul>\n<p>举个例子，假设我们现在打开的是index.html</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stateObj = &#123; <span class=\"attr\">country</span>: <span class=\"string\">&#x27;China&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  history.pushState(stateObj, <span class=\"string\">&#x27;china&#x27;</span>, <span class=\"string\">&#x27;china.html&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>页面加载完index.html，一秒之后URL就会变成china.html，然而页面并不会加载china.html，所以就算china.html这个页面不存在也没问题。此时的<code>history.state</code>就是<code>stateObj</code>的拷贝，此时我们就可以利用这个数据来进行相关的操作了。<br>如果此时我们点击后退，则URL变成index.html，此时<code>history.state=null</code></p>\n<p>说到这里，你应该会有点困惑，好像这个<code>API</code>并没什么卵用，直接用<code>hash</code>配合<code>window.onhashchange</code>就可以做到啦，类似如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location.href = <span class=\"string\">&#x27;www.someURL.com#/china.html?country=china&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个代码也能实现添加历史记录，并且不刷新页面，也有对应<code>伪URL</code>的相关的数据。</p>\n<p>不过对比而言，<code>pushState</code>也有它的优势：</p>\n<ul>\n<li>使用<code>hash</code>的方式时，如果当前<code>hash</code>的值不变（即url=’<a href=\"http://www.someurl.com/#foo&#39;%E6%97%B6%EF%BC%8C%E8%AE%BE%E7%BD%AElocation.href\">www.someURL.com#foo&#39;时，设置location.href</a> = ‘<a href=\"http://www.someurl.com/#foo&#39;%EF%BC%89%EF%BC%8C%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%EF%BC%8C%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%60onhashchange%60%E4%BA%8B%E4%BB%B6%E7%9A%84%EF%BC%8C%E8%80%8C%60history.pushState%60%E6%8F%92%E5%85%A5%E7%9B%B8%E5%90%8C\">www.someURL.com#foo&#39;），是不会创建新的历史记录的，也不会触发`onhashchange`事件的，而`history.pushState`插入相同</a> url 时则会创建新的历史记录。</li>\n<li>绑定相关数据时，<code>history.state</code>可以说是可以绑定任意数据，而基于<code>hash</code>的方式则要把所有数据转换成相关的字符串</li>\n</ul>\n<p><code>replaceState()</code>使用方法和<code>pushState()</code>基本一致。不同的是，<code>replaceState()</code>方法会修改当前历史记录而不是创建新的历史记录</p>\n<p>相关DEMO，敬请期待。。。</p>"},{"title":"开始拥抱 Gulp","date":"2016-09-23T04:17:53.000Z","desc":"getting-started-with-gulp,gulp,grunt,gulpfile,gruntfile","from":"https://markgoodyear.com/2014/01/getting-started-with-gulp/","toc":true,"_content":"\n前端工作流中常用的构建工具除了`grunt`，还有一个`gulp`(当然现在还有`webpack`)。`gulp`是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于`nodejs`流的构建工具，而且执行很快。\n\n<!--more-->\n\n既然有了`grunt`，为啥还要来学习`gulp`呢？这是一个好问题，用过`grunt`的都知道，每次写`Gruntfile.js`的时候，都要先写一大片的配置文件，而`gulp`和`grunt`最大的差别在于，`gulp`是执行代码覆盖配置的。这样的好处在于，`gulpfile.js`很容易写，而且阅读起来清晰明了，并且容易维护。\n\n`gulp`使用`node.js`的流(stream)，这让`gulp`构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看[这篇文章](https://github.com/substack/stream-handbook)（写得很好）\n\n`gulp`允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像`grunt`那样，为每一个`grunt`都写一些配置信息和输入输出路径。让我们看下使用`grunt`和`gulp`写的`Sass`编译：\n\n\n**Grunt**:\n\n```js\nsass: {\n  dist: {\n    options: {\n      style: 'expanded'\n    },\n    files: {\n      'dist/assets/css/main.css': 'src/styles/main.scss',\n    }\n  }\n},\n\nautoprefixer: {\n  dist: {\n    options: {\n      browsers: [\n        'last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'\n      ]\n    },\n    src: 'dist/assets/css/main.css',\n    dest: 'dist/assets/css/main.css'\n  }\n},\n\ngrunt.registerTask('styles', ['sass', 'autoprefixer']);\n```\n\n`Grunt`需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到`Sass`插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给`Autoprefixer`输入，然后我们再将文件输出保存起来。\n\n**gulp**:\n\n```js\ngulp.task('sass', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n});\n```\n\n使用`gulp`的时候，我们只需要输入一个文件，然后经过`Sass`插件修改，然后经过`Autoprefixer`插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。\n\n### 安装Gulp\n\n在我们钻研配置任务信息之前，我们需要安装`gulp`：\n\n```\n$ npm install gulp -g\n```\n\n以上命令会在全局环境上安装`gulp`，让我们可以使用`gulp`命令行。然后，我们需要在项目文件夹内安装本地的`gulp`，`cd`到你的项目路径，然后运行一下命令(执行命令前需确保项目下有`package.json`这个文件)\n\n```\n$ npm install gulp --save-dev\n```\n\n以上命令会在项目内安装本地的gulp并保存到`package.json`里的`devDependencies`\n\n### 安装gulp插件\n\n我们需要安装一些插件来完成以下的任务：\n\n- 编译sass ([gulp-ruby-sass](https://github.com/sindresorhus/gulp-ruby-sass))\n\n- 自动添加厂商前缀 ([gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer))\n\n- 压缩CSS ([gulp-cssnano](https://github.com/jonathanepollack/gulp-cssnano))\n\n- js检测 ([gulp-jshint](https://github.com/wearefractal/gulp-jshint))\n\n- 合并文件 ([gulp-concat](https://github.com/wearefractal/gulp-concat))\n\n- 压缩JS ([gulp-uglify](https://github.com/terinjokes/gulp-uglify))\n\n- 压缩图片 ([gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin))\n\n- 动态加载 ([gulp-livereload](https://github.com/vohof/gulp-livereload))\n\n- 缓存图片然后只压缩改变后的图片 ([gulp-cache](https://github.com/jgable/gulp-cache/))\n\n- 提示信息 ([gulp-notify](https://github.com/mikaelbr/gulp-notify))\n\n- 清除文件 ([del](https://www.npmjs.org/package/del))\n\n通过以下命令来安装这些插件：\n\n```\nnpm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n```\n\n这将会安装全部需要的插件并将它们保存到`package.json`的`devDependencies`里面。你可以[在这里](http://gulpjs.com/plugins/)找到gulp的全部插件。\n\n### 加载插件\n\n之后，我们要创建一个文件夹`gulpfile.js`并加载这些插件：\n\n```js\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n```\n\n这个时候，看起来是不是好像需要写的东西比`grunt`还多？其实，`gulp`插件和`grunt`插件有略微的不同——`gulp`插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，`grunt`的`imagemin`使用缓存来避免压缩已经压缩过的图片；而`gulp`则需要`cache`插件来协助完成这样的任务，当然`cache`插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？\n\n我们同样可以像`grunt`那样[自动加载所有已安装的插件](https://github.com/jackfranklin/gulp-load-tasks)，不过为了这篇文章，我们就将坚持纯手工工艺！\n\n### 创建任务\n\n#### Compile Sass, Autoprefix and minify\n\n首先，我们先配置`Sass`编译，然后使用`Autoprefixer`添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给`cssnao`压缩成一个`.min`版本，最后再输出到另一个目的地，最后的最后调用`notify`提示我们任务完成了：\n\n```js\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n```\n\n继续往下讲之前，有一点东西需要解释一下：\n\n```js\ngulp.task('styles', function() {...});\n```\n\n这里的`gulp.task`API是用来创建任务的。我们在命令行工具中可以使用`$ gulp styles`运行上面的任务。\n\n```js\nreturn sass('src/styles/main.scss', { style: 'expanded' })\n```\n\n这里是一个新的`gulp-rubu-sass`API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用`gulp.src`API来代替（在文章的下部分你将会看到）这同样可以使用`glob pattern`，比如：`/**/*.scss`来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)\n\n```js\n.pipe(autoprefixer('last 2 version'))\n```\n\n我们通过`.pipe()`来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。\n\n```js\n.pipe(gulp.dest('dist/assets/css'));\n```\n\n这里的`gulp.dest`API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出`expanded version`(正常大小版本)，另一个输出`minifed version`(压缩版本)\n\n我建议去看下`gulp`的[API文档](https://github.com/gulpjs/gulp/blob/master/docs/API.md)来更好地理解这些方法，它并不像听起来那么吓人！\n\n#### JSHint, concat, and minify JavaScript\n\n希望你现在对如何创建一个`gulp`任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：\n\n```js\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n```\n\n这里我们就是用`gulp.src`API来指定我们的输入文件。有一件事情需要注意的是，我们需要为`JSHint`指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在[JSHint官网](http://www.jshint.com/docs/reporters/)找到更多的信息。\n\n#### Compress Images\n\n接下来，我们设置图片压缩。\n\n```js\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n    .pipe(gulp.dest('dist/assets/img'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n```\n\n这里我们将拿到一些图片，然后导到`imagemin`插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的`gulp-cache`插件。为了实现这个，我们需要改变这一行：\n\n```js\n.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n```\n\n改成：\n\n```js\n.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true })))\n```\n\n现在就只用新的图片和改变过的图片会被压缩了，nice吧？\n\n#### Clean up!\n\n在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：\n\n```js\ngulp.task('clean', function() {\n    return del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img']);\n});\n```\n\n这里我们不需要使用`gulp`的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）\n\n#### The default task\n\n我们定义的default任务可以直接使用`$ gulp`运行，比如：\n\n```js\ngulp.task('default', ['clean'], function() {\n    gulp.start('styles', 'scripts', 'images');\n});\n```\n\n需要注意到的是，我们添加了一个数组到`gulp.task`上，在这里我们可以定义任务依赖。在这里例子里，`clean`任务将会在`gulp.start`之前先运行。`gulp`里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保`clean`任务完成之后才开始其他的任务。\n\n**注意**：\n\n建议是的不要在依赖任务中使用`gulp.start`，不过在这个脚本里为了确保`clean`完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）\n\n#### watch\n\n监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用`gulp.watch`API来开始监听文件。\n\n```js\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n});\n```\n我们可以通过`gulp.watch`API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行`$ gulp watch`，然后修改一下对应监听目录下的文件，就将会执行对应的任务。\n\n\n#### LiveReload\n\n`gulp`同样可以在文件修改的时候刷新页面，我们需要修改我们的`watch`任务来配置`LiveReload`服务：\n\n```js\ngulp.task('watch', function() {\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n为了让实现这个梦想，你需要安装和启用`LiveReload`的浏览器插件。或者你也可以[手动的添加这些东西](http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-)\n\n### 合并所有代码\n\n现在你拥有了一个完整的`gulpfile`了， 它来自于[这里](https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js)\n\n```js\n/*!\n * gulp\n * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n */\n\n// Load plugins\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n\n// Styles\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n\n// Scripts\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n\n// Images\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n    .pipe(gulp.dest('dist/images'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n\n// Clean\ngulp.task('clean', function() {\n  return del(['dist/styles', 'dist/scripts', 'dist/images']);\n});\n\n// Default task\ngulp.task('default', ['clean'], function() {\n  gulp.start('styles', 'scripts', 'images');\n});\n\n// Watch\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n我也使用`grunt`写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。[拿好了，不送了](https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js)\n\n本文翻译自：[Getting started with gulp](https://markgoodyear.com/2014/01/getting-started-with-gulp/)","source":"_posts/getting-started-with-gulp.md","raw":"---\ntitle: 开始拥抱 Gulp\ndate: 2016-09-23 12:17:53\ntags: gulp\ndesc: getting-started-with-gulp,gulp,grunt,gulpfile,gruntfile\nfrom: https://markgoodyear.com/2014/01/getting-started-with-gulp/\ntoc: true\ncategories:\n- 前端工程化\n---\n\n前端工作流中常用的构建工具除了`grunt`，还有一个`gulp`(当然现在还有`webpack`)。`gulp`是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于`nodejs`流的构建工具，而且执行很快。\n\n<!--more-->\n\n既然有了`grunt`，为啥还要来学习`gulp`呢？这是一个好问题，用过`grunt`的都知道，每次写`Gruntfile.js`的时候，都要先写一大片的配置文件，而`gulp`和`grunt`最大的差别在于，`gulp`是执行代码覆盖配置的。这样的好处在于，`gulpfile.js`很容易写，而且阅读起来清晰明了，并且容易维护。\n\n`gulp`使用`node.js`的流(stream)，这让`gulp`构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看[这篇文章](https://github.com/substack/stream-handbook)（写得很好）\n\n`gulp`允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像`grunt`那样，为每一个`grunt`都写一些配置信息和输入输出路径。让我们看下使用`grunt`和`gulp`写的`Sass`编译：\n\n\n**Grunt**:\n\n```js\nsass: {\n  dist: {\n    options: {\n      style: 'expanded'\n    },\n    files: {\n      'dist/assets/css/main.css': 'src/styles/main.scss',\n    }\n  }\n},\n\nautoprefixer: {\n  dist: {\n    options: {\n      browsers: [\n        'last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'\n      ]\n    },\n    src: 'dist/assets/css/main.css',\n    dest: 'dist/assets/css/main.css'\n  }\n},\n\ngrunt.registerTask('styles', ['sass', 'autoprefixer']);\n```\n\n`Grunt`需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到`Sass`插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给`Autoprefixer`输入，然后我们再将文件输出保存起来。\n\n**gulp**:\n\n```js\ngulp.task('sass', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n});\n```\n\n使用`gulp`的时候，我们只需要输入一个文件，然后经过`Sass`插件修改，然后经过`Autoprefixer`插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。\n\n### 安装Gulp\n\n在我们钻研配置任务信息之前，我们需要安装`gulp`：\n\n```\n$ npm install gulp -g\n```\n\n以上命令会在全局环境上安装`gulp`，让我们可以使用`gulp`命令行。然后，我们需要在项目文件夹内安装本地的`gulp`，`cd`到你的项目路径，然后运行一下命令(执行命令前需确保项目下有`package.json`这个文件)\n\n```\n$ npm install gulp --save-dev\n```\n\n以上命令会在项目内安装本地的gulp并保存到`package.json`里的`devDependencies`\n\n### 安装gulp插件\n\n我们需要安装一些插件来完成以下的任务：\n\n- 编译sass ([gulp-ruby-sass](https://github.com/sindresorhus/gulp-ruby-sass))\n\n- 自动添加厂商前缀 ([gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer))\n\n- 压缩CSS ([gulp-cssnano](https://github.com/jonathanepollack/gulp-cssnano))\n\n- js检测 ([gulp-jshint](https://github.com/wearefractal/gulp-jshint))\n\n- 合并文件 ([gulp-concat](https://github.com/wearefractal/gulp-concat))\n\n- 压缩JS ([gulp-uglify](https://github.com/terinjokes/gulp-uglify))\n\n- 压缩图片 ([gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin))\n\n- 动态加载 ([gulp-livereload](https://github.com/vohof/gulp-livereload))\n\n- 缓存图片然后只压缩改变后的图片 ([gulp-cache](https://github.com/jgable/gulp-cache/))\n\n- 提示信息 ([gulp-notify](https://github.com/mikaelbr/gulp-notify))\n\n- 清除文件 ([del](https://www.npmjs.org/package/del))\n\n通过以下命令来安装这些插件：\n\n```\nnpm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n```\n\n这将会安装全部需要的插件并将它们保存到`package.json`的`devDependencies`里面。你可以[在这里](http://gulpjs.com/plugins/)找到gulp的全部插件。\n\n### 加载插件\n\n之后，我们要创建一个文件夹`gulpfile.js`并加载这些插件：\n\n```js\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n```\n\n这个时候，看起来是不是好像需要写的东西比`grunt`还多？其实，`gulp`插件和`grunt`插件有略微的不同——`gulp`插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，`grunt`的`imagemin`使用缓存来避免压缩已经压缩过的图片；而`gulp`则需要`cache`插件来协助完成这样的任务，当然`cache`插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？\n\n我们同样可以像`grunt`那样[自动加载所有已安装的插件](https://github.com/jackfranklin/gulp-load-tasks)，不过为了这篇文章，我们就将坚持纯手工工艺！\n\n### 创建任务\n\n#### Compile Sass, Autoprefix and minify\n\n首先，我们先配置`Sass`编译，然后使用`Autoprefixer`添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给`cssnao`压缩成一个`.min`版本，最后再输出到另一个目的地，最后的最后调用`notify`提示我们任务完成了：\n\n```js\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n```\n\n继续往下讲之前，有一点东西需要解释一下：\n\n```js\ngulp.task('styles', function() {...});\n```\n\n这里的`gulp.task`API是用来创建任务的。我们在命令行工具中可以使用`$ gulp styles`运行上面的任务。\n\n```js\nreturn sass('src/styles/main.scss', { style: 'expanded' })\n```\n\n这里是一个新的`gulp-rubu-sass`API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用`gulp.src`API来代替（在文章的下部分你将会看到）这同样可以使用`glob pattern`，比如：`/**/*.scss`来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)\n\n```js\n.pipe(autoprefixer('last 2 version'))\n```\n\n我们通过`.pipe()`来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。\n\n```js\n.pipe(gulp.dest('dist/assets/css'));\n```\n\n这里的`gulp.dest`API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出`expanded version`(正常大小版本)，另一个输出`minifed version`(压缩版本)\n\n我建议去看下`gulp`的[API文档](https://github.com/gulpjs/gulp/blob/master/docs/API.md)来更好地理解这些方法，它并不像听起来那么吓人！\n\n#### JSHint, concat, and minify JavaScript\n\n希望你现在对如何创建一个`gulp`任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：\n\n```js\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n```\n\n这里我们就是用`gulp.src`API来指定我们的输入文件。有一件事情需要注意的是，我们需要为`JSHint`指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在[JSHint官网](http://www.jshint.com/docs/reporters/)找到更多的信息。\n\n#### Compress Images\n\n接下来，我们设置图片压缩。\n\n```js\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n    .pipe(gulp.dest('dist/assets/img'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n```\n\n这里我们将拿到一些图片，然后导到`imagemin`插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的`gulp-cache`插件。为了实现这个，我们需要改变这一行：\n\n```js\n.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n```\n\n改成：\n\n```js\n.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true })))\n```\n\n现在就只用新的图片和改变过的图片会被压缩了，nice吧？\n\n#### Clean up!\n\n在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：\n\n```js\ngulp.task('clean', function() {\n    return del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img']);\n});\n```\n\n这里我们不需要使用`gulp`的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）\n\n#### The default task\n\n我们定义的default任务可以直接使用`$ gulp`运行，比如：\n\n```js\ngulp.task('default', ['clean'], function() {\n    gulp.start('styles', 'scripts', 'images');\n});\n```\n\n需要注意到的是，我们添加了一个数组到`gulp.task`上，在这里我们可以定义任务依赖。在这里例子里，`clean`任务将会在`gulp.start`之前先运行。`gulp`里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保`clean`任务完成之后才开始其他的任务。\n\n**注意**：\n\n建议是的不要在依赖任务中使用`gulp.start`，不过在这个脚本里为了确保`clean`完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）\n\n#### watch\n\n监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用`gulp.watch`API来开始监听文件。\n\n```js\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n});\n```\n我们可以通过`gulp.watch`API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行`$ gulp watch`，然后修改一下对应监听目录下的文件，就将会执行对应的任务。\n\n\n#### LiveReload\n\n`gulp`同样可以在文件修改的时候刷新页面，我们需要修改我们的`watch`任务来配置`LiveReload`服务：\n\n```js\ngulp.task('watch', function() {\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n为了让实现这个梦想，你需要安装和启用`LiveReload`的浏览器插件。或者你也可以[手动的添加这些东西](http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-)\n\n### 合并所有代码\n\n现在你拥有了一个完整的`gulpfile`了， 它来自于[这里](https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js)\n\n```js\n/*!\n * gulp\n * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n */\n\n// Load plugins\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    cssnano = require('gulp-cssnano'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n\n// Styles\ngulp.task('styles', function() {\n  return sass('src/styles/main.scss', { style: 'expanded' })\n    .pipe(autoprefixer('last 2 version'))\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n\n// Scripts\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n\n// Images\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n    .pipe(gulp.dest('dist/images'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n\n// Clean\ngulp.task('clean', function() {\n  return del(['dist/styles', 'dist/scripts', 'dist/images']);\n});\n\n// Default task\ngulp.task('default', ['clean'], function() {\n  gulp.start('styles', 'scripts', 'images');\n});\n\n// Watch\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n我也使用`grunt`写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。[拿好了，不送了](https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js)\n\n本文翻译自：[Getting started with gulp](https://markgoodyear.com/2014/01/getting-started-with-gulp/)","slug":"getting-started-with-gulp","published":1,"updated":"2022-01-08T08:17:53.918Z","_id":"ckxvfmfd4001fbrqq9i5r6i6p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前端工作流中常用的构建工具除了<code>grunt</code>，还有一个<code>gulp</code>(当然现在还有<code>webpack</code>)。<code>gulp</code>是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于<code>nodejs</code>流的构建工具，而且执行很快。</p>\n<span id=\"more\"></span>\n\n<p>既然有了<code>grunt</code>，为啥还要来学习<code>gulp</code>呢？这是一个好问题，用过<code>grunt</code>的都知道，每次写<code>Gruntfile.js</code>的时候，都要先写一大片的配置文件，而<code>gulp</code>和<code>grunt</code>最大的差别在于，<code>gulp</code>是执行代码覆盖配置的。这样的好处在于，<code>gulpfile.js</code>很容易写，而且阅读起来清晰明了，并且容易维护。</p>\n<p><code>gulp</code>使用<code>node.js</code>的流(stream)，这让<code>gulp</code>构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看<a href=\"https://github.com/substack/stream-handbook\">这篇文章</a>（写得很好）</p>\n<p><code>gulp</code>允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像<code>grunt</code>那样，为每一个<code>grunt</code>都写一些配置信息和输入输出路径。让我们看下使用<code>grunt</code>和<code>gulp</code>写的<code>Sass</code>编译：</p>\n<p><strong>Grunt</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">files</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>: <span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">autoprefixer</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">browsers</span>: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">src</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dest</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">grunt.registerTask(<span class=\"string\">&#x27;styles&#x27;</span>, [<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"string\">&#x27;autoprefixer&#x27;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p><code>Grunt</code>需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到<code>Sass</code>插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给<code>Autoprefixer</code>输入，然后我们再将文件输出保存起来。</p>\n<p><strong>gulp</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>gulp</code>的时候，我们只需要输入一个文件，然后经过<code>Sass</code>插件修改，然后经过<code>Autoprefixer</code>插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。</p>\n<h3 id=\"安装Gulp\"><a href=\"#安装Gulp\" class=\"headerlink\" title=\"安装Gulp\"></a>安装Gulp</h3><p>在我们钻研配置任务信息之前，我们需要安装<code>gulp</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp -g</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在全局环境上安装<code>gulp</code>，让我们可以使用<code>gulp</code>命令行。然后，我们需要在项目文件夹内安装本地的<code>gulp</code>，<code>cd</code>到你的项目路径，然后运行一下命令(执行命令前需确保项目下有<code>package.json</code>这个文件)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在项目内安装本地的gulp并保存到<code>package.json</code>里的<code>devDependencies</code></p>\n<h3 id=\"安装gulp插件\"><a href=\"#安装gulp插件\" class=\"headerlink\" title=\"安装gulp插件\"></a>安装gulp插件</h3><p>我们需要安装一些插件来完成以下的任务：</p>\n<ul>\n<li><p>编译sass (<a href=\"https://github.com/sindresorhus/gulp-ruby-sass\">gulp-ruby-sass</a>)</p>\n</li>\n<li><p>自动添加厂商前缀 (<a href=\"https://github.com/Metrime/gulp-autoprefixer\">gulp-autoprefixer</a>)</p>\n</li>\n<li><p>压缩CSS (<a href=\"https://github.com/jonathanepollack/gulp-cssnano\">gulp-cssnano</a>)</p>\n</li>\n<li><p>js检测 (<a href=\"https://github.com/wearefractal/gulp-jshint\">gulp-jshint</a>)</p>\n</li>\n<li><p>合并文件 (<a href=\"https://github.com/wearefractal/gulp-concat\">gulp-concat</a>)</p>\n</li>\n<li><p>压缩JS (<a href=\"https://github.com/terinjokes/gulp-uglify\">gulp-uglify</a>)</p>\n</li>\n<li><p>压缩图片 (<a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a>)</p>\n</li>\n<li><p>动态加载 (<a href=\"https://github.com/vohof/gulp-livereload\">gulp-livereload</a>)</p>\n</li>\n<li><p>缓存图片然后只压缩改变后的图片 (<a href=\"https://github.com/jgable/gulp-cache/\">gulp-cache</a>)</p>\n</li>\n<li><p>提示信息 (<a href=\"https://github.com/mikaelbr/gulp-notify\">gulp-notify</a>)</p>\n</li>\n<li><p>清除文件 (<a href=\"https://www.npmjs.org/package/del\">del</a>)</p>\n</li>\n</ul>\n<p>通过以下命令来安装这些插件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>这将会安装全部需要的插件并将它们保存到<code>package.json</code>的<code>devDependencies</code>里面。你可以<a href=\"http://gulpjs.com/plugins/\">在这里</a>找到gulp的全部插件。</p>\n<h3 id=\"加载插件\"><a href=\"#加载插件\" class=\"headerlink\" title=\"加载插件\"></a>加载插件</h3><p>之后，我们要创建一个文件夹<code>gulpfile.js</code>并加载这些插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，看起来是不是好像需要写的东西比<code>grunt</code>还多？其实，<code>gulp</code>插件和<code>grunt</code>插件有略微的不同——<code>gulp</code>插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，<code>grunt</code>的<code>imagemin</code>使用缓存来避免压缩已经压缩过的图片；而<code>gulp</code>则需要<code>cache</code>插件来协助完成这样的任务，当然<code>cache</code>插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？</p>\n<p>我们同样可以像<code>grunt</code>那样<a href=\"https://github.com/jackfranklin/gulp-load-tasks\">自动加载所有已安装的插件</a>，不过为了这篇文章，我们就将坚持纯手工工艺！</p>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><h4 id=\"Compile-Sass-Autoprefix-and-minify\"><a href=\"#Compile-Sass-Autoprefix-and-minify\" class=\"headerlink\" title=\"Compile Sass, Autoprefix and minify\"></a>Compile Sass, Autoprefix and minify</h4><p>首先，我们先配置<code>Sass</code>编译，然后使用<code>Autoprefixer</code>添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给<code>cssnao</code>压缩成一个<code>.min</code>版本，最后再输出到另一个目的地，最后的最后调用<code>notify</code>提示我们任务完成了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>继续往下讲之前，有一点东西需要解释一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.task</code>API是用来创建任务的。我们在命令行工具中可以使用<code>$ gulp styles</code>运行上面的任务。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里是一个新的<code>gulp-rubu-sass</code>API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用<code>gulp.src</code>API来代替（在文章的下部分你将会看到）这同样可以使用<code>glob pattern</code>，比如：<code>/**/*.scss</code>来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>.pipe()</code>来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.dest</code>API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出<code>expanded version</code>(正常大小版本)，另一个输出<code>minifed version</code>(压缩版本)</p>\n<p>我建议去看下<code>gulp</code>的<a href=\"https://github.com/gulpjs/gulp/blob/master/docs/API.md\">API文档</a>来更好地理解这些方法，它并不像听起来那么吓人！</p>\n<h4 id=\"JSHint-concat-and-minify-JavaScript\"><a href=\"#JSHint-concat-and-minify-JavaScript\" class=\"headerlink\" title=\"JSHint, concat, and minify JavaScript\"></a>JSHint, concat, and minify JavaScript</h4><p>希望你现在对如何创建一个<code>gulp</code>任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们就是用<code>gulp.src</code>API来指定我们的输入文件。有一件事情需要注意的是，我们需要为<code>JSHint</code>指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在<a href=\"http://www.jshint.com/docs/reporters/\">JSHint官网</a>找到更多的信息。</p>\n<h4 id=\"Compress-Images\"><a href=\"#Compress-Images\" class=\"headerlink\" title=\"Compress Images\"></a>Compress Images</h4><p>接下来，我们设置图片压缩。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/img&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们将拿到一些图片，然后导到<code>imagemin</code>插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的<code>gulp-cache</code>插件。为了实现这个，我们需要改变这一行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br></pre></td></tr></table></figure>\n\n<p>改成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">5</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br></pre></td></tr></table></figure>\n\n<p>现在就只用新的图片和改变过的图片会被压缩了，nice吧？</p>\n<h4 id=\"Clean-up\"><a href=\"#Clean-up\" class=\"headerlink\" title=\"Clean up!\"></a>Clean up!</h4><p>在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/assets/css&#x27;</span>, <span class=\"string\">&#x27;dist/assets/js&#x27;</span>, <span class=\"string\">&#x27;dist/assets/img&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们不需要使用<code>gulp</code>的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）</p>\n<h4 id=\"The-default-task\"><a href=\"#The-default-task\" class=\"headerlink\" title=\"The default task\"></a>The default task</h4><p>我们定义的default任务可以直接使用<code>$ gulp</code>运行，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>需要注意到的是，我们添加了一个数组到<code>gulp.task</code>上，在这里我们可以定义任务依赖。在这里例子里，<code>clean</code>任务将会在<code>gulp.start</code>之前先运行。<code>gulp</code>里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保<code>clean</code>任务完成之后才开始其他的任务。</p>\n<p><strong>注意</strong>：</p>\n<p>建议是的不要在依赖任务中使用<code>gulp.start</code>，不过在这个脚本里为了确保<code>clean</code>完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）</p>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h4><p>监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用<code>gulp.watch</code>API来开始监听文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以通过<code>gulp.watch</code>API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行<code>$ gulp watch</code>，然后修改一下对应监听目录下的文件，就将会执行对应的任务。</p>\n<h4 id=\"LiveReload\"><a href=\"#LiveReload\" class=\"headerlink\" title=\"LiveReload\"></a>LiveReload</h4><p><code>gulp</code>同样可以在文件修改的时候刷新页面，我们需要修改我们的<code>watch</code>任务来配置<code>LiveReload</code>服务：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>为了让实现这个梦想，你需要安装和启用<code>LiveReload</code>的浏览器插件。或者你也可以<a href=\"http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-\">手动的添加这些东西</a></p>\n<h3 id=\"合并所有代码\"><a href=\"#合并所有代码\" class=\"headerlink\" title=\"合并所有代码\"></a>合并所有代码</h3><p>现在你拥有了一个完整的<code>gulpfile</code>了， 它来自于<a href=\"https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js\">这里</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\"> * gulp</span></span><br><span class=\"line\"><span class=\"comment\"> * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Load plugins</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Styles</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Scripts</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Images</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/images&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Clean</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/styles&#x27;</span>, <span class=\"string\">&#x27;dist/scripts&#x27;</span>, <span class=\"string\">&#x27;dist/images&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Default task</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Watch</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我也使用<code>grunt</code>写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。<a href=\"https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js\">拿好了，不送了</a></p>\n<p>本文翻译自：<a href=\"https://markgoodyear.com/2014/01/getting-started-with-gulp/\">Getting started with gulp</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>前端工作流中常用的构建工具除了<code>grunt</code>，还有一个<code>gulp</code>(当然现在还有<code>webpack</code>)。<code>gulp</code>是一个直观的，执行代码覆盖配置(code-over-configuration)的，基于<code>nodejs</code>流的构建工具，而且执行很快。</p>","more":"<p>既然有了<code>grunt</code>，为啥还要来学习<code>gulp</code>呢？这是一个好问题，用过<code>grunt</code>的都知道，每次写<code>Gruntfile.js</code>的时候，都要先写一大片的配置文件，而<code>gulp</code>和<code>grunt</code>最大的差别在于，<code>gulp</code>是执行代码覆盖配置的。这样的好处在于，<code>gulpfile.js</code>很容易写，而且阅读起来清晰明了，并且容易维护。</p>\n<p><code>gulp</code>使用<code>node.js</code>的流(stream)，这让<code>gulp</code>构建的时候不需要写入临时的文件/目录到硬盘上。如果你想要学习关于流(stream)的更多知识，可以看<a href=\"https://github.com/substack/stream-handbook\">这篇文章</a>（写得很好）</p>\n<p><code>gulp</code>允许将你输入的源文件使用管道(pipe)，让文件流经一堆的插件，最后输出出来。而不是像<code>grunt</code>那样，为每一个<code>grunt</code>都写一些配置信息和输入输出路径。让我们看下使用<code>grunt</code>和<code>gulp</code>写的<code>Sass</code>编译：</p>\n<p><strong>Grunt</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sass: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">files</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>: <span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">autoprefixer</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">dist</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">browsers</span>: [</span><br><span class=\"line\">        <span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">src</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">dest</span>: <span class=\"string\">&#x27;dist/assets/css/main.css&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">grunt.registerTask(<span class=\"string\">&#x27;styles&#x27;</span>, [<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"string\">&#x27;autoprefixer&#x27;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p><code>Grunt</code>需要为每个插件各自写配置信息，并且指定输入输出的路径。比如，我们输入一个文件到<code>Sass</code>插件，执行完就要保存输出的文件。然后我们再将sass的输出文件传递给<code>Autoprefixer</code>输入，然后我们再将文件输出保存起来。</p>\n<p><strong>gulp</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;sass&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>, <span class=\"string\">&#x27;safari 5&#x27;</span>, <span class=\"string\">&#x27;ie 8&#x27;</span>, <span class=\"string\">&#x27;ios 6&#x27;</span>, <span class=\"string\">&#x27;android 4&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>gulp</code>的时候，我们只需要输入一个文件，然后经过<code>Sass</code>插件修改，然后经过<code>Autoprefixer</code>插件修改，最后输出一个文件。这样会让我们的构建速度加快，因为我们避免了多次不必要的读取和写入。</p>\n<h3 id=\"安装Gulp\"><a href=\"#安装Gulp\" class=\"headerlink\" title=\"安装Gulp\"></a>安装Gulp</h3><p>在我们钻研配置任务信息之前，我们需要安装<code>gulp</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp -g</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在全局环境上安装<code>gulp</code>，让我们可以使用<code>gulp</code>命令行。然后，我们需要在项目文件夹内安装本地的<code>gulp</code>，<code>cd</code>到你的项目路径，然后运行一下命令(执行命令前需确保项目下有<code>package.json</code>这个文件)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会在项目内安装本地的gulp并保存到<code>package.json</code>里的<code>devDependencies</code></p>\n<h3 id=\"安装gulp插件\"><a href=\"#安装gulp插件\" class=\"headerlink\" title=\"安装gulp插件\"></a>安装gulp插件</h3><p>我们需要安装一些插件来完成以下的任务：</p>\n<ul>\n<li><p>编译sass (<a href=\"https://github.com/sindresorhus/gulp-ruby-sass\">gulp-ruby-sass</a>)</p>\n</li>\n<li><p>自动添加厂商前缀 (<a href=\"https://github.com/Metrime/gulp-autoprefixer\">gulp-autoprefixer</a>)</p>\n</li>\n<li><p>压缩CSS (<a href=\"https://github.com/jonathanepollack/gulp-cssnano\">gulp-cssnano</a>)</p>\n</li>\n<li><p>js检测 (<a href=\"https://github.com/wearefractal/gulp-jshint\">gulp-jshint</a>)</p>\n</li>\n<li><p>合并文件 (<a href=\"https://github.com/wearefractal/gulp-concat\">gulp-concat</a>)</p>\n</li>\n<li><p>压缩JS (<a href=\"https://github.com/terinjokes/gulp-uglify\">gulp-uglify</a>)</p>\n</li>\n<li><p>压缩图片 (<a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a>)</p>\n</li>\n<li><p>动态加载 (<a href=\"https://github.com/vohof/gulp-livereload\">gulp-livereload</a>)</p>\n</li>\n<li><p>缓存图片然后只压缩改变后的图片 (<a href=\"https://github.com/jgable/gulp-cache/\">gulp-cache</a>)</p>\n</li>\n<li><p>提示信息 (<a href=\"https://github.com/mikaelbr/gulp-notify\">gulp-notify</a>)</p>\n</li>\n<li><p>清除文件 (<a href=\"https://www.npmjs.org/package/del\">del</a>)</p>\n</li>\n</ul>\n<p>通过以下命令来安装这些插件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>这将会安装全部需要的插件并将它们保存到<code>package.json</code>的<code>devDependencies</code>里面。你可以<a href=\"http://gulpjs.com/plugins/\">在这里</a>找到gulp的全部插件。</p>\n<h3 id=\"加载插件\"><a href=\"#加载插件\" class=\"headerlink\" title=\"加载插件\"></a>加载插件</h3><p>之后，我们要创建一个文件夹<code>gulpfile.js</code>并加载这些插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候，看起来是不是好像需要写的东西比<code>grunt</code>还多？其实，<code>gulp</code>插件和<code>grunt</code>插件有略微的不同——<code>gulp</code>插件的理念是：每个插件只需做一件事然后把这件事做好就可以了（翻译得好渣，原文是they are designed to do one thing and one thing well）比如，<code>grunt</code>的<code>imagemin</code>使用缓存来避免压缩已经压缩过的图片；而<code>gulp</code>则需要<code>cache</code>插件来协助完成这样的任务，当然<code>cache</code>插件也可以缓存其他的文件。这就给你的构建任务添加了许多灵活性，很酷是吧？</p>\n<p>我们同样可以像<code>grunt</code>那样<a href=\"https://github.com/jackfranklin/gulp-load-tasks\">自动加载所有已安装的插件</a>，不过为了这篇文章，我们就将坚持纯手工工艺！</p>\n<h3 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h3><h4 id=\"Compile-Sass-Autoprefix-and-minify\"><a href=\"#Compile-Sass-Autoprefix-and-minify\" class=\"headerlink\" title=\"Compile Sass, Autoprefix and minify\"></a>Compile Sass, Autoprefix and minify</h4><p>首先，我们先配置<code>Sass</code>编译，然后使用<code>Autoprefixer</code>添加厂商前缀，这时可以先输出到一个目的地。之后，再将文件流传递给<code>cssnao</code>压缩成一个<code>.min</code>版本，最后再输出到另一个目的地，最后的最后调用<code>notify</code>提示我们任务完成了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>继续往下讲之前，有一点东西需要解释一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.task</code>API是用来创建任务的。我们在命令行工具中可以使用<code>$ gulp styles</code>运行上面的任务。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这里是一个新的<code>gulp-rubu-sass</code>API，我们用来定义源文件并可以添加一些参数配置；而在其他的许多插件中，我们将会用<code>gulp.src</code>API来代替（在文章的下部分你将会看到）这同样可以使用<code>glob pattern</code>，比如：<code>/**/*.scss</code>来匹配多个文件。（以下未翻译:By returning the stream it makes it asynchronous, ensuring the task is fully complete before we get a notification to say it’s finished.)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>.pipe()</code>来导数据流到一个插件。通常我们可以在各个插件的GitHubPage找到各自的options信息。为了方便大家，我已经在上面粘贴了它们的地址。管道(Pipes)是可链式调用的，因此你可以尽可能地添加插件到文件流中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/css&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>gulp.dest</code>API我们是用来设置输出路径的。一个任务可以有多个输出路径的，上面的例子就是一个用来输出<code>expanded version</code>(正常大小版本)，另一个输出<code>minifed version</code>(压缩版本)</p>\n<p>我建议去看下<code>gulp</code>的<a href=\"https://github.com/gulpjs/gulp/blob/master/docs/API.md\">API文档</a>来更好地理解这些方法，它并不像听起来那么吓人！</p>\n<h4 id=\"JSHint-concat-and-minify-JavaScript\"><a href=\"#JSHint-concat-and-minify-JavaScript\" class=\"headerlink\" title=\"JSHint, concat, and minify JavaScript\"></a>JSHint, concat, and minify JavaScript</h4><p>希望你现在对如何创建一个<code>gulp</code>任务有一个很好的idea，接下来我们将设置scripts任务去检测，合并和压缩js文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123;<span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span>&#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/js&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们就是用<code>gulp.src</code>API来指定我们的输入文件。有一件事情需要注意的是，我们需要为<code>JSHint</code>指定一个reporter，我使用的是适合大部分人使用的默认reporter，你可以在<a href=\"http://www.jshint.com/docs/reporters/\">JSHint官网</a>找到更多的信息。</p>\n<h4 id=\"Compress-Images\"><a href=\"#Compress-Images\" class=\"headerlink\" title=\"Compress Images\"></a>Compress Images</h4><p>接下来，我们设置图片压缩。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/assets/img&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们将拿到一些图片，然后导到<code>imagemin</code>插件。我们可以做得更好一点，就是使用缓存来避免重复压缩已经压缩过的图片——这只需要我们之前已经安装好的<code>gulp-cache</code>插件。为了实现这个，我们需要改变这一行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;))</span><br></pre></td></tr></table></figure>\n\n<p>改成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">5</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br></pre></td></tr></table></figure>\n\n<p>现在就只用新的图片和改变过的图片会被压缩了，nice吧？</p>\n<h4 id=\"Clean-up\"><a href=\"#Clean-up\" class=\"headerlink\" title=\"Clean up!\"></a>Clean up!</h4><p>在部署之前，清除输出目录再执行构建任务是一个好想法——为了避免一些在原目录也就是输出目录已经删除的文件还遗留在输出目录：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/assets/css&#x27;</span>, <span class=\"string\">&#x27;dist/assets/js&#x27;</span>, <span class=\"string\">&#x27;dist/assets/img&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们不需要使用<code>gulp</code>的插件，因为我们可以利用node模块的优点，我们使用return来确保在退出之前完成任务（翻译得有点渣，原文奉上：We don’t need to use a gulp plugin here as we can take advantage of Node modules directly within gulp. We use a return to ensure the task finishes before exiting.）</p>\n<h4 id=\"The-default-task\"><a href=\"#The-default-task\" class=\"headerlink\" title=\"The default task\"></a>The default task</h4><p>我们定义的default任务可以直接使用<code>$ gulp</code>运行，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>需要注意到的是，我们添加了一个数组到<code>gulp.task</code>上，在这里我们可以定义任务依赖。在这里例子里，<code>clean</code>任务将会在<code>gulp.start</code>之前先运行。<code>gulp</code>里的任务是并发的，所以无法确定各个任务的完成顺序，所以我们需要确保<code>clean</code>任务完成之后才开始其他的任务。</p>\n<p><strong>注意</strong>：</p>\n<p>建议是的不要在依赖任务中使用<code>gulp.start</code>，不过在这个脚本里为了确保<code>clean</code>完全完成，这似乎是最好的选择（原文：It’s advised against using gulp.start in favour of executing tasks in the dependency arrary, but in this scenario to ensure clean fully completes, it seems the best option）</p>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h4><p>监听我们的文件，然后当它们修改的时候执行相应的任务。首先我们要创建一个新的任务，然后使用<code>gulp.watch</code>API来开始监听文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们可以通过<code>gulp.watch</code>API来指定我们需要监听的文件，然后通过依赖数组来定义需要执行的任务。现在我们可以运行<code>$ gulp watch</code>，然后修改一下对应监听目录下的文件，就将会执行对应的任务。</p>\n<h4 id=\"LiveReload\"><a href=\"#LiveReload\" class=\"headerlink\" title=\"LiveReload\"></a>LiveReload</h4><p><code>gulp</code>同样可以在文件修改的时候刷新页面，我们需要修改我们的<code>watch</code>任务来配置<code>LiveReload</code>服务：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>为了让实现这个梦想，你需要安装和启用<code>LiveReload</code>的浏览器插件。或者你也可以<a href=\"http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-\">手动的添加这些东西</a></p>\n<h3 id=\"合并所有代码\"><a href=\"#合并所有代码\" class=\"headerlink\" title=\"合并所有代码\"></a>合并所有代码</h3><p>现在你拥有了一个完整的<code>gulpfile</code>了， 它来自于<a href=\"https://gist.github.com/markgoodyear/8497946#file-01-gulpfile-js\">这里</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*!</span></span><br><span class=\"line\"><span class=\"comment\"> * gulp</span></span><br><span class=\"line\"><span class=\"comment\"> * $ npm install gulp-ruby-sass gulp-autoprefixer gulp-cssnano gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Load plugins</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp&#x27;</span>),</span><br><span class=\"line\">    sass = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-ruby-sass&#x27;</span>),</span><br><span class=\"line\">    autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-autoprefixer&#x27;</span>),</span><br><span class=\"line\">    cssnano = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cssnano&#x27;</span>),</span><br><span class=\"line\">    jshint = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-jshint&#x27;</span>),</span><br><span class=\"line\">    uglify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-uglify&#x27;</span>),</span><br><span class=\"line\">    imagemin = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-imagemin&#x27;</span>),</span><br><span class=\"line\">    rename = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-rename&#x27;</span>),</span><br><span class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-concat&#x27;</span>),</span><br><span class=\"line\">    notify = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-notify&#x27;</span>),</span><br><span class=\"line\">    cache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-cache&#x27;</span>),</span><br><span class=\"line\">    livereload = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;gulp-livereload&#x27;</span>),</span><br><span class=\"line\">    del = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;del&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Styles</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sass(<span class=\"string\">&#x27;src/styles/main.scss&#x27;</span>, &#123; <span class=\"attr\">style</span>: <span class=\"string\">&#x27;expanded&#x27;</span> &#125;)</span><br><span class=\"line\">    .pipe(autoprefixer(<span class=\"string\">&#x27;last 2 version&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(cssnano())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/styles&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Styles task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Scripts</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>)</span><br><span class=\"line\">    .pipe(jshint(<span class=\"string\">&#x27;.jshintrc&#x27;</span>))</span><br><span class=\"line\">    .pipe(jshint.reporter(<span class=\"string\">&#x27;default&#x27;</span>))</span><br><span class=\"line\">    .pipe(concat(<span class=\"string\">&#x27;main.js&#x27;</span>))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(rename(&#123; <span class=\"attr\">suffix</span>: <span class=\"string\">&#x27;.min&#x27;</span> &#125;))</span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/scripts&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Scripts task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Images</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;images&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>)</span><br><span class=\"line\">    .pipe(cache(imagemin(&#123; <span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>, <span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>, <span class=\"attr\">interlaced</span>: <span class=\"literal\">true</span> &#125;)))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">&#x27;dist/images&#x27;</span>))</span><br><span class=\"line\">    .pipe(notify(&#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Images task complete&#x27;</span> &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Clean</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;clean&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> del([<span class=\"string\">&#x27;dist/styles&#x27;</span>, <span class=\"string\">&#x27;dist/scripts&#x27;</span>, <span class=\"string\">&#x27;dist/images&#x27;</span>]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Default task</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;default&#x27;</span>, [<span class=\"string\">&#x27;clean&#x27;</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.start(<span class=\"string\">&#x27;styles&#x27;</span>, <span class=\"string\">&#x27;scripts&#x27;</span>, <span class=\"string\">&#x27;images&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Watch</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">&#x27;watch&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .scss files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/styles/**/*.scss&#x27;</span>, [<span class=\"string\">&#x27;styles&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch .js files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/scripts/**/*.js&#x27;</span>, [<span class=\"string\">&#x27;scripts&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch image files</span></span><br><span class=\"line\">  gulp.watch(<span class=\"string\">&#x27;src/images/**/*&#x27;</span>, [<span class=\"string\">&#x27;images&#x27;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create LiveReload server</span></span><br><span class=\"line\">  livereload.listen();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Watch any files in dist/, reload on change</span></span><br><span class=\"line\">  gulp.watch([<span class=\"string\">&#x27;dist/**&#x27;</span>]).on(<span class=\"string\">&#x27;change&#x27;</span>, livereload.changed);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我也使用<code>grunt</code>写了一份配置文件来完成同样的东西，你可以对比一些有什么不一样。<a href=\"https://gist.github.com/markgoodyear/8497946#file-02-gruntfile-js\">拿好了，不送了</a></p>\n<p>本文翻译自：<a href=\"https://markgoodyear.com/2014/01/getting-started-with-gulp/\">Getting started with gulp</a></p>"},{"title":"简单实现前端路由","date":"2015-09-21T04:44:09.000Z","desc":"router","_content":"\n路由一直都是后端控制的，然而，其实我们前端也可以使用`hash`实现我们前端自己的路由。\n下面的代码就是参考他人代码实现的：\n\n<!--more-->\n\n```js\nvar router = {\n  routes: {},\n  currentUrl: '',\n  lastPanel: ''\n};\n\nrouter.init = function(){\n  window.addEventListener('load', this.update.bind(this), false);\n  window.addEventListener('hashchange', this.update.bind(this), false);\n};\n\nrouter.add = function(path, callback){\n  this.routes[path] = callback;\n};\n\nrouter.update = function(){\n  this.currentUrl = location.hash.slice(1) || '/';\n  this.routes[this.currentUrl]();\n}\n\nif(this === window && typeof window.document !== 'undefined') {\n  window.router = router;\n}\nelse if(typeof define === 'function') {\n  define('router', [], function(){\n    return router;\n  })\n}\n```","source":"_posts/front-end-router.md","raw":"---\ntitle: 简单实现前端路由\ndate: 2015-09-21 12:44:09\ntags: 路由\ndesc: router\ncategories:\n- [前端, 基础]\n---\n\n路由一直都是后端控制的，然而，其实我们前端也可以使用`hash`实现我们前端自己的路由。\n下面的代码就是参考他人代码实现的：\n\n<!--more-->\n\n```js\nvar router = {\n  routes: {},\n  currentUrl: '',\n  lastPanel: ''\n};\n\nrouter.init = function(){\n  window.addEventListener('load', this.update.bind(this), false);\n  window.addEventListener('hashchange', this.update.bind(this), false);\n};\n\nrouter.add = function(path, callback){\n  this.routes[path] = callback;\n};\n\nrouter.update = function(){\n  this.currentUrl = location.hash.slice(1) || '/';\n  this.routes[this.currentUrl]();\n}\n\nif(this === window && typeof window.document !== 'undefined') {\n  window.router = router;\n}\nelse if(typeof define === 'function') {\n  define('router', [], function(){\n    return router;\n  })\n}\n```","slug":"front-end-router","published":1,"updated":"2022-01-08T08:43:25.789Z","_id":"ckxvfmfd5001gbrqq6t7q7ca3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>路由一直都是后端控制的，然而，其实我们前端也可以使用<code>hash</code>实现我们前端自己的路由。<br>下面的代码就是参考他人代码实现的：</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = &#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">currentUrl</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastPanel</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, callback</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[path] = callback;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.update = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[<span class=\"built_in\">this</span>.currentUrl]();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.document !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.router = router;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> define === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">  define(<span class=\"string\">&#x27;router&#x27;</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> router;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>路由一直都是后端控制的，然而，其实我们前端也可以使用<code>hash</code>实现我们前端自己的路由。<br>下面的代码就是参考他人代码实现的：</p>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> router = &#123;</span><br><span class=\"line\">  <span class=\"attr\">routes</span>: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">currentUrl</span>: <span class=\"string\">&#x27;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastPanel</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"built_in\">this</span>.update.bind(<span class=\"built_in\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, callback</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[path] = callback;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">router.update = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.routes[<span class=\"built_in\">this</span>.currentUrl]();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">this</span> === <span class=\"built_in\">window</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.document !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.router = router;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> define === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">  define(<span class=\"string\">&#x27;router&#x27;</span>, [], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> router;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ES6 Promise","date":"2016-08-05T11:00:49.000Z","desc":["ES6","Promise"],"toc":true,"_content":"\n由于`js`的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。`ES6`(也叫`ES2015`)为了解决这个问题提出了`Promse`对象。\n\n<!--more-->\n\n### 出现Promise的原因\n\n当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。\n\n```javascript\n$.ajax({\n  //...\n})\n.then(function (data) {\n  // 要在第一个请求成功后才可以执行下一步\n  $.ajax({  \n    //...\n  })\n  .then(function (data) {\n    // ...\n  });\n});\n```\n\n**缺点**：\n\n1. 回调地狱，多个操作的时候就要无限嵌套回调函数了\n2. 如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了\n\n### 什么是Promise？\n\n一个`Promise`对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了`Promise`对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。\n\n#### resolve和reject\n\n```javascript\nfunction helloWorld (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello World!\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nhelloWorld(true).then(function (message) {\n    alert(message);\n}, function (error) {\n    alert(error);\n});\n```\n`resolve` 方法可以使`Promise`对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 `Hello World!` 字符串。\n`reject` 方法则是将`Promise`对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。\n\n### promise三种状态\n\n上面提到了 `resolve` 和 `reject` 可以改变`Promise`对象的状态，那么它究竟有哪些状态呢？\n`Promise`对象有三种对象\n1 `Fulfilled` 可以理解为成功的状态\n2 `Rejected` 可以理解为失败的状态\n3 `Pending` 可以理解为`Promise`对象实例创建时候的初始状态\n\n#### then和catch\n\nhelloWorld 的例子当中利用了 `then(onFulfilld, onRejected)` 方法来执行一个任务打印 \"Hello World!\"，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。\n\n```javascript\nfunction printHello (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nfunction printWorld () {\n    alert(\"World\");\n}\nfunction printExclamation () {\n    alert(\"!\");\n}\nprintHello(true)\n    .then(function(message){\n        alert(message);\n    })\n    .then(printWorld)\n    .then(printExclamation);\n```\n\n`catch` 方法是 `then(onFulfilled, onRejected)` 方法当中 `onRejected` 函数的一个简单的写法，也就是说可以写成`then(fn).catch(fn)`，相当于 `then(fn).then(null, fn)`。使用 `catch` 的写法比一般的写法更加清晰明确。\n\n#### Promise.all 和 Promise.race\n\n`Promise.all` 可以接收一个元素为 `Promise` 对象的数组作为参数，当这个数组里面所有的 `Promise` 对象都变为 `resolve` 时，该方法才会返回。\n\n```javascript\nvar p1 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"Hello\");\n    }, 3000);\n});\nvar p2 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"World\");\n    }, 1000);\n});\nPromise.all([p1, p2]).then(function (result) {\n    console.log(result); // [\"Hello\", \"World\"]\n});\n```\n\n`Promise.race` 在`promise`数组中任何一个`promise`对象变成`resolve`或者`reject`，马上执行函数\n\n```javascript\n// `delay`毫秒后执行resolve\nfunction timerPromisefy(delay) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay);\n    });\n}\n\n// 任何一个promise变为resolve或reject 的话程序就停止运行\nPromise.race([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64),\n    timerPromisefy(128)\n]).then(function (value) {\n    console.log(value);    // => 1\n});\n```\n\n**特殊地方**：\n\n```javascript\nvar promise = new Promise(function (resolve){\n    console.log(\"inner promise\"); // 1\n    resolve(42);\n});\npromise.then(function(value){\n    console.log(value); // 3\n});\nconsole.log(\"outer promise\"); // 2\n```\n\n输出结果是：`inner promise -> outer promise -> 42`\n","source":"_posts/es6-promise.md","raw":"---\ntitle: ES6 Promise\ndate: 2016-08-05 19:00:49\ntags:\ndesc: \n- ES6\n- Promise\ntoc: true\ncategories:\n- [前端, 基础]\n---\n\n由于`js`的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。`ES6`(也叫`ES2015`)为了解决这个问题提出了`Promse`对象。\n\n<!--more-->\n\n### 出现Promise的原因\n\n当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。\n\n```javascript\n$.ajax({\n  //...\n})\n.then(function (data) {\n  // 要在第一个请求成功后才可以执行下一步\n  $.ajax({  \n    //...\n  })\n  .then(function (data) {\n    // ...\n  });\n});\n```\n\n**缺点**：\n\n1. 回调地狱，多个操作的时候就要无限嵌套回调函数了\n2. 如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了\n\n### 什么是Promise？\n\n一个`Promise`对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了`Promise`对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。\n\n#### resolve和reject\n\n```javascript\nfunction helloWorld (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello World!\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nhelloWorld(true).then(function (message) {\n    alert(message);\n}, function (error) {\n    alert(error);\n});\n```\n`resolve` 方法可以使`Promise`对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 `Hello World!` 字符串。\n`reject` 方法则是将`Promise`对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。\n\n### promise三种状态\n\n上面提到了 `resolve` 和 `reject` 可以改变`Promise`对象的状态，那么它究竟有哪些状态呢？\n`Promise`对象有三种对象\n1 `Fulfilled` 可以理解为成功的状态\n2 `Rejected` 可以理解为失败的状态\n3 `Pending` 可以理解为`Promise`对象实例创建时候的初始状态\n\n#### then和catch\n\nhelloWorld 的例子当中利用了 `then(onFulfilld, onRejected)` 方法来执行一个任务打印 \"Hello World!\"，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。\n\n```javascript\nfunction printHello (ready) {\n    return new Promise(function (resolve, reject) {\n        if (ready) {\n            resolve(\"Hello\");\n        } else {\n            reject(\"Good bye!\");\n        }\n    });\n}\nfunction printWorld () {\n    alert(\"World\");\n}\nfunction printExclamation () {\n    alert(\"!\");\n}\nprintHello(true)\n    .then(function(message){\n        alert(message);\n    })\n    .then(printWorld)\n    .then(printExclamation);\n```\n\n`catch` 方法是 `then(onFulfilled, onRejected)` 方法当中 `onRejected` 函数的一个简单的写法，也就是说可以写成`then(fn).catch(fn)`，相当于 `then(fn).then(null, fn)`。使用 `catch` 的写法比一般的写法更加清晰明确。\n\n#### Promise.all 和 Promise.race\n\n`Promise.all` 可以接收一个元素为 `Promise` 对象的数组作为参数，当这个数组里面所有的 `Promise` 对象都变为 `resolve` 时，该方法才会返回。\n\n```javascript\nvar p1 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"Hello\");\n    }, 3000);\n});\nvar p2 = new Promise(function (resolve) {\n    setTimeout(function () {\n        resolve(\"World\");\n    }, 1000);\n});\nPromise.all([p1, p2]).then(function (result) {\n    console.log(result); // [\"Hello\", \"World\"]\n});\n```\n\n`Promise.race` 在`promise`数组中任何一个`promise`对象变成`resolve`或者`reject`，马上执行函数\n\n```javascript\n// `delay`毫秒后执行resolve\nfunction timerPromisefy(delay) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay);\n    });\n}\n\n// 任何一个promise变为resolve或reject 的话程序就停止运行\nPromise.race([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64),\n    timerPromisefy(128)\n]).then(function (value) {\n    console.log(value);    // => 1\n});\n```\n\n**特殊地方**：\n\n```javascript\nvar promise = new Promise(function (resolve){\n    console.log(\"inner promise\"); // 1\n    resolve(42);\n});\npromise.then(function(value){\n    console.log(value); // 3\n});\nconsole.log(\"outer promise\"); // 2\n```\n\n输出结果是：`inner promise -> outer promise -> 42`\n","slug":"es6-promise","published":1,"updated":"2022-01-08T08:42:03.892Z","_id":"ckxvfmfdd001jbrqqhyl7h2px","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于<code>js</code>的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。<code>ES6</code>(也叫<code>ES2015</code>)为了解决这个问题提出了<code>Promse</code>对象。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"出现Promise的原因\"><a href=\"#出现Promise的原因\" class=\"headerlink\" title=\"出现Promise的原因\"></a>出现Promise的原因</h3><p>当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 要在第一个请求成功后才可以执行下一步</span></span><br><span class=\"line\">  $.ajax(&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>回调地狱，多个操作的时候就要无限嵌套回调函数了</li>\n<li>如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了</li>\n</ol>\n<h3 id=\"什么是Promise？\"><a href=\"#什么是Promise？\" class=\"headerlink\" title=\"什么是Promise？\"></a>什么是Promise？</h3><p>一个<code>Promise</code>对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了<code>Promise</code>对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。</p>\n<h4 id=\"resolve和reject\"><a href=\"#resolve和reject\" class=\"headerlink\" title=\"resolve和reject\"></a>resolve和reject</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">helloWorld</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">helloWorld(<span class=\"literal\">true</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    alert(message);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>resolve</code> 方法可以使<code>Promise</code>对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 <code>Hello World!</code> 字符串。<br><code>reject</code> 方法则是将<code>Promise</code>对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。</p>\n<h3 id=\"promise三种状态\"><a href=\"#promise三种状态\" class=\"headerlink\" title=\"promise三种状态\"></a>promise三种状态</h3><p>上面提到了 <code>resolve</code> 和 <code>reject</code> 可以改变<code>Promise</code>对象的状态，那么它究竟有哪些状态呢？<br><code>Promise</code>对象有三种对象<br>1 <code>Fulfilled</code> 可以理解为成功的状态<br>2 <code>Rejected</code> 可以理解为失败的状态<br>3 <code>Pending</code> 可以理解为<code>Promise</code>对象实例创建时候的初始状态</p>\n<h4 id=\"then和catch\"><a href=\"#then和catch\" class=\"headerlink\" title=\"then和catch\"></a>then和catch</h4><p>helloWorld 的例子当中利用了 <code>then(onFulfilld, onRejected)</code> 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printHello</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printWorld</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printExclamation</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printHello(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>)</span>&#123;</span><br><span class=\"line\">        alert(message);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(printWorld)</span><br><span class=\"line\">    .then(printExclamation);</span><br></pre></td></tr></table></figure>\n\n<p><code>catch</code> 方法是 <code>then(onFulfilled, onRejected)</code> 方法当中 <code>onRejected</code> 函数的一个简单的写法，也就是说可以写成<code>then(fn).catch(fn)</code>，相当于 <code>then(fn).then(null, fn)</code>。使用 <code>catch</code> 的写法比一般的写法更加清晰明确。</p>\n<h4 id=\"Promise-all-和-Promise-race\"><a href=\"#Promise-all-和-Promise-race\" class=\"headerlink\" title=\"Promise.all 和 Promise.race\"></a>Promise.all 和 Promise.race</h4><p><code>Promise.all</code> 可以接收一个元素为 <code>Promise</code> 对象的数组作为参数，当这个数组里面所有的 <code>Promise</code> 对象都变为 <code>resolve</code> 时，该方法才会返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>Promise.race</code> 在<code>promise</code>数组中任何一个<code>promise</code>对象变成<code>resolve</code>或者<code>reject</code>，马上执行函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `delay`毫秒后执行resolve</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timerPromisefy</span>(<span class=\"params\">delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            resolve(delay);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 任何一个promise变为resolve或reject 的话程序就停止运行</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">1</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">32</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">64</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">128</span>)</span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);    <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>特殊地方</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;inner promise&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">    resolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;outer promise&quot;</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果是：<code>inner promise -&gt; outer promise -&gt; 42</code></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>由于<code>js</code>的异步执行特性，我们经常要使用到回调函数，然而当我们的回调函数还需要回调函数的时候，我们就逐渐步入了回调地狱的深渊。<code>ES6</code>(也叫<code>ES2015</code>)为了解决这个问题提出了<code>Promse</code>对象。</p>","more":"<h3 id=\"出现Promise的原因\"><a href=\"#出现Promise的原因\" class=\"headerlink\" title=\"出现Promise的原因\"></a>出现Promise的原因</h3><p>当我们多个接口异步请求时，后一个请求依赖前一个请求的结果时，就会像面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 要在第一个请求成功后才可以执行下一步</span></span><br><span class=\"line\">  $.ajax(&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>回调地狱，多个操作的时候就要无限嵌套回调函数了</li>\n<li>如果前后请求没有依赖的时候，也要等待前一个接口完成才能发送请求了</li>\n</ol>\n<h3 id=\"什么是Promise？\"><a href=\"#什么是Promise？\" class=\"headerlink\" title=\"什么是Promise？\"></a>什么是Promise？</h3><p>一个<code>Promise</code>对象可以理解为一次将要执行的操作（常常被用于异步操作），使用了<code>Promise</code>对象之后可以用一种链式调用的方式来组织代码，让代码更加直观。</p>\n<h4 id=\"resolve和reject\"><a href=\"#resolve和reject\" class=\"headerlink\" title=\"resolve和reject\"></a>resolve和reject</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">helloWorld</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">helloWorld(<span class=\"literal\">true</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    alert(message);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    alert(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>resolve</code> 方法可以使<code>Promise</code>对象的状态改变为成功，同时传递一个参数用于后续成功后的操作，在这个例子当中就是 <code>Hello World!</code> 字符串。<br><code>reject</code> 方法则是将<code>Promise</code>对象的状态改变为失败，同时将错误的信息传递到后续错误处理的操作。</p>\n<h3 id=\"promise三种状态\"><a href=\"#promise三种状态\" class=\"headerlink\" title=\"promise三种状态\"></a>promise三种状态</h3><p>上面提到了 <code>resolve</code> 和 <code>reject</code> 可以改变<code>Promise</code>对象的状态，那么它究竟有哪些状态呢？<br><code>Promise</code>对象有三种对象<br>1 <code>Fulfilled</code> 可以理解为成功的状态<br>2 <code>Rejected</code> 可以理解为失败的状态<br>3 <code>Pending</code> 可以理解为<code>Promise</code>对象实例创建时候的初始状态</p>\n<h4 id=\"then和catch\"><a href=\"#then和catch\" class=\"headerlink\" title=\"then和catch\"></a>then和catch</h4><p>helloWorld 的例子当中利用了 <code>then(onFulfilld, onRejected)</code> 方法来执行一个任务打印 “Hello World!”，在多个任务的情况下then 方法同样可以用一个清晰的方式完成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printHello</span> (<span class=\"params\">ready</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ready) &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&quot;Good bye!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printWorld</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printExclamation</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printHello(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>)</span>&#123;</span><br><span class=\"line\">        alert(message);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(printWorld)</span><br><span class=\"line\">    .then(printExclamation);</span><br></pre></td></tr></table></figure>\n\n<p><code>catch</code> 方法是 <code>then(onFulfilled, onRejected)</code> 方法当中 <code>onRejected</code> 函数的一个简单的写法，也就是说可以写成<code>then(fn).catch(fn)</code>，相当于 <code>then(fn).then(null, fn)</code>。使用 <code>catch</code> 的写法比一般的写法更加清晰明确。</p>\n<h4 id=\"Promise-all-和-Promise-race\"><a href=\"#Promise-all-和-Promise-race\" class=\"headerlink\" title=\"Promise.all 和 Promise.race\"></a>Promise.all 和 Promise.race</h4><p><code>Promise.all</code> 可以接收一个元素为 <code>Promise</code> 对象的数组作为参数，当这个数组里面所有的 <code>Promise</code> 对象都变为 <code>resolve</code> 时，该方法才会返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [&quot;Hello&quot;, &quot;World&quot;]</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>Promise.race</code> 在<code>promise</code>数组中任何一个<code>promise</code>对象变成<code>resolve</code>或者<code>reject</code>，马上执行函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `delay`毫秒后执行resolve</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timerPromisefy</span>(<span class=\"params\">delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            resolve(delay);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 任何一个promise变为resolve或reject 的话程序就停止运行</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">1</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">32</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">64</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">128</span>)</span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);    <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>特殊地方</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;inner promise&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">    resolve(<span class=\"number\">42</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;outer promise&quot;</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果是：<code>inner promise -&gt; outer promise -&gt; 42</code></p>"},{"title":"从零开始，部署一个Web应用（三）Vue.js & Redis","date":"2017-10-27T10:37:14.000Z","desc":"for beginner, how to build an web application","toc":true,"_content":"\n这篇文章，就总结一些`Vue.js`和`Redis`遇到的问题。\n\n<!-- more -->\n\n# Vue.js\n\n## 非index页面刷新报404\n\n由于采用了`Vue-router`前端路由。因此在非index页面刷新会出现404的问题。\n\n原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。\n\n以下是nginx的解决方案：\n\n```\nserver {\n    listen 80;\n    server_name favweb.cn;\n    access_log  off;\n\n    root /home/vuejs/dist;\n\n    location / {\n      try_files $uri $uri/ /index.html;\n    }\n}\n```\n\n## 页面统计问题\n\n由于Google Analytics的不可用，采用的是百度统计。\n\n发现统计数据都是只有主页，因此又是因为SPA的问题。\n\n解决方案是在前端路由切换的时候，手动调用PV追踪代码：\n\n```js\n_hmt.push(['_trackPageview', pageURL]);\n```\n\nVuejs的配置为：\n\n```js\nimport Router from 'vue-router'\n\nconst router = new Router(config)\n\nrouter.afterEach((to, from, next) => {\n  try {\n    window._hmt.push(['_trackPageview', to.path])\n  } catch (e) { }\n})\n```\n\n# Redis\n\n## 安装：\n\n```\nwget http://download.redis.io/releases/redis-4.0.2.tar.gz\ntar xzf redis-4.0.2.tar.gz\ncd redis-4.0.2\nmake\n```\n\n## 常用配置\n\n以`MacOS`的`homebrew`安装方式为例。其中`redis.conf`文件在`/usr/local/etc/`。\n\n### 后台运行\n\n```\n# 原来\ndaemonize no\n\n# 改成\ndaemonize yes\n```\n\n### 增加密码\n\n找到`requirepass`，去掉前面的注释符号`#`，后面改成自己的密码\n\n```\n#原来\n#requirepass yourPassword\n\n#改成\nrequirepass yourPassword\n```\n\n### 远程访问\n\n找到`bind`，将`127.0.0.1`改成`0.0.0.0`即可。\n\n因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。\n\n因此要开启这个之前，一定要先设置好密码。\n\n\n","source":"_posts/about-deploly-favweb-3.md","raw":"---\ntitle: 从零开始，部署一个Web应用（三）Vue.js & Redis\ndate: 2017-10-27 18:37:14\ntags: vue.js\ndesc: for beginner, how to build an web application\ntoc: true\ncategories:\n- 工程实践\n---\n\n这篇文章，就总结一些`Vue.js`和`Redis`遇到的问题。\n\n<!-- more -->\n\n# Vue.js\n\n## 非index页面刷新报404\n\n由于采用了`Vue-router`前端路由。因此在非index页面刷新会出现404的问题。\n\n原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。\n\n以下是nginx的解决方案：\n\n```\nserver {\n    listen 80;\n    server_name favweb.cn;\n    access_log  off;\n\n    root /home/vuejs/dist;\n\n    location / {\n      try_files $uri $uri/ /index.html;\n    }\n}\n```\n\n## 页面统计问题\n\n由于Google Analytics的不可用，采用的是百度统计。\n\n发现统计数据都是只有主页，因此又是因为SPA的问题。\n\n解决方案是在前端路由切换的时候，手动调用PV追踪代码：\n\n```js\n_hmt.push(['_trackPageview', pageURL]);\n```\n\nVuejs的配置为：\n\n```js\nimport Router from 'vue-router'\n\nconst router = new Router(config)\n\nrouter.afterEach((to, from, next) => {\n  try {\n    window._hmt.push(['_trackPageview', to.path])\n  } catch (e) { }\n})\n```\n\n# Redis\n\n## 安装：\n\n```\nwget http://download.redis.io/releases/redis-4.0.2.tar.gz\ntar xzf redis-4.0.2.tar.gz\ncd redis-4.0.2\nmake\n```\n\n## 常用配置\n\n以`MacOS`的`homebrew`安装方式为例。其中`redis.conf`文件在`/usr/local/etc/`。\n\n### 后台运行\n\n```\n# 原来\ndaemonize no\n\n# 改成\ndaemonize yes\n```\n\n### 增加密码\n\n找到`requirepass`，去掉前面的注释符号`#`，后面改成自己的密码\n\n```\n#原来\n#requirepass yourPassword\n\n#改成\nrequirepass yourPassword\n```\n\n### 远程访问\n\n找到`bind`，将`127.0.0.1`改成`0.0.0.0`即可。\n\n因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。\n\n因此要开启这个之前，一定要先设置好密码。\n\n\n","slug":"about-deploly-favweb-3","published":1,"updated":"2022-01-08T08:33:20.579Z","_id":"ckxvfmfdl001obrqq049pap06","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇文章，就总结一些<code>Vue.js</code>和<code>Redis</code>遇到的问题。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h1><h2 id=\"非index页面刷新报404\"><a href=\"#非index页面刷新报404\" class=\"headerlink\" title=\"非index页面刷新报404\"></a>非index页面刷新报404</h2><p>由于采用了<code>Vue-router</code>前端路由。因此在非index页面刷新会出现404的问题。</p>\n<p>原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。</p>\n<p>以下是nginx的解决方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name favweb.cn;</span><br><span class=\"line\">    access_log  off;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /home/vuejs/dist;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">      try_files $uri $uri/ /index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"页面统计问题\"><a href=\"#页面统计问题\" class=\"headerlink\" title=\"页面统计问题\"></a>页面统计问题</h2><p>由于Google Analytics的不可用，采用的是百度统计。</p>\n<p>发现统计数据都是只有主页，因此又是因为SPA的问题。</p>\n<p>解决方案是在前端路由切换的时候，手动调用PV追踪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, pageURL]);</span><br></pre></td></tr></table></figure>\n\n<p>Vuejs的配置为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-router&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router(config)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>._hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, to.path])</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span><br><span class=\"line\">tar xzf redis-4.0.2.tar.gz</span><br><span class=\"line\">cd redis-4.0.2</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用配置\"><a href=\"#常用配置\" class=\"headerlink\" title=\"常用配置\"></a>常用配置</h2><p>以<code>MacOS</code>的<code>homebrew</code>安装方式为例。其中<code>redis.conf</code>文件在<code>/usr/local/etc/</code>。</p>\n<h3 id=\"后台运行\"><a href=\"#后台运行\" class=\"headerlink\" title=\"后台运行\"></a>后台运行</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 原来</span><br><span class=\"line\">daemonize no</span><br><span class=\"line\"></span><br><span class=\"line\"># 改成</span><br><span class=\"line\">daemonize yes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加密码\"><a href=\"#增加密码\" class=\"headerlink\" title=\"增加密码\"></a>增加密码</h3><p>找到<code>requirepass</code>，去掉前面的注释符号<code>#</code>，后面改成自己的密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#原来</span><br><span class=\"line\">#requirepass yourPassword</span><br><span class=\"line\"></span><br><span class=\"line\">#改成</span><br><span class=\"line\">requirepass yourPassword</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h3><p>找到<code>bind</code>，将<code>127.0.0.1</code>改成<code>0.0.0.0</code>即可。</p>\n<p>因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。</p>\n<p>因此要开启这个之前，一定要先设置好密码。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>这篇文章，就总结一些<code>Vue.js</code>和<code>Redis</code>遇到的问题。</p>","more":"<h1 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h1><h2 id=\"非index页面刷新报404\"><a href=\"#非index页面刷新报404\" class=\"headerlink\" title=\"非index页面刷新报404\"></a>非index页面刷新报404</h2><p>由于采用了<code>Vue-router</code>前端路由。因此在非index页面刷新会出现404的问题。</p>\n<p>原理：Vue.js是单页面应用(SPA)，除了主页，其他页面都是利用hash或者HTML5 History API实现的，是浏览器虚拟的路由，故需要配置一下服务器。</p>\n<p>以下是nginx的解决方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name favweb.cn;</span><br><span class=\"line\">    access_log  off;</span><br><span class=\"line\"></span><br><span class=\"line\">    root /home/vuejs/dist;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">      try_files $uri $uri/ /index.html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"页面统计问题\"><a href=\"#页面统计问题\" class=\"headerlink\" title=\"页面统计问题\"></a>页面统计问题</h2><p>由于Google Analytics的不可用，采用的是百度统计。</p>\n<p>发现统计数据都是只有主页，因此又是因为SPA的问题。</p>\n<p>解决方案是在前端路由切换的时候，手动调用PV追踪代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, pageURL]);</span><br></pre></td></tr></table></figure>\n\n<p>Vuejs的配置为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue-router&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router(config)</span><br><span class=\"line\"></span><br><span class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>._hmt.push([<span class=\"string\">&#x27;_trackPageview&#x27;</span>, to.path])</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123; &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span><br><span class=\"line\">tar xzf redis-4.0.2.tar.gz</span><br><span class=\"line\">cd redis-4.0.2</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用配置\"><a href=\"#常用配置\" class=\"headerlink\" title=\"常用配置\"></a>常用配置</h2><p>以<code>MacOS</code>的<code>homebrew</code>安装方式为例。其中<code>redis.conf</code>文件在<code>/usr/local/etc/</code>。</p>\n<h3 id=\"后台运行\"><a href=\"#后台运行\" class=\"headerlink\" title=\"后台运行\"></a>后台运行</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 原来</span><br><span class=\"line\">daemonize no</span><br><span class=\"line\"></span><br><span class=\"line\"># 改成</span><br><span class=\"line\">daemonize yes</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加密码\"><a href=\"#增加密码\" class=\"headerlink\" title=\"增加密码\"></a>增加密码</h3><p>找到<code>requirepass</code>，去掉前面的注释符号<code>#</code>，后面改成自己的密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#原来</span><br><span class=\"line\">#requirepass yourPassword</span><br><span class=\"line\"></span><br><span class=\"line\">#改成</span><br><span class=\"line\">requirepass yourPassword</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h3><p>找到<code>bind</code>，将<code>127.0.0.1</code>改成<code>0.0.0.0</code>即可。</p>\n<p>因为安全问题，默认只绑定在127.0.0.1，这样的话就只有运行redis的那台机器可以访问，其他机器都无法访问。</p>\n<p>因此要开启这个之前，一定要先设置好密码。</p>"},{"title":"从零开始，部署一个Web应用（二）MongoDB & nginx","date":"2017-10-21T13:37:14.000Z","desc":"for beginner, how to build an web application","toc":true,"_content":"\n这篇文章，就总结一些部署`MongoDB`和`nginx`遇到的问题。\n\n<!-- more -->\n\n# MongoDB\n\n安装的是社区版本([MongoDB Community Edition](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/))。\n\n## 安装\n\n先创建Mongodb在yum的配置文件：\n\n```\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n> 可动态改变版本号\n\n然后使用`yum`安装：\n\n```\nsudo yum install -y mongodb-org\n```\n\n## 安全相关\n\n如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。\n\n在MongoDB中，常用的是增加[用户访问限制](https://docs.mongodb.com/manual/tutorial/enable-authentication/)。\n\n### 高级管理员\n\n第一步，是先创建一个高级管理员。这个高级管理员可**管理其他用户**：\n\n```\n> use admin\n> db.createUser(\n  {\n    user: \"myUserAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]\n  }\n)\n```\n\n> 注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。\n\n可以这样以该角色进入MongoDB的命令行：\n\n```\nmongo --port 27017 -u \"myUserAdmin\" -p \"abc123\" --authenticationDatabase \"admin\"\n```\n\n### 增加其他用户\n\nMongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入`test`数据库：\n\n```\nuse test\n```\n\n然后创建角色时，设置账户，密码以及对应的数据库权限，比如：\n\n```\ndb.createUser(\n  {\n    user: \"testAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"readWrite\", db: \"test\" },\n             { role: \"read\", db: \"reporting\" } ]\n  }\n)\n```\n\n# nginx\n\n安装nginx之前，需要先将nginx的依赖安装完：\n\n- gcc 安装：`yum install gcc-c++`\n- PCRE pcre-devel 安装：`yum install -y pcre pcre-devel`\n- zlib 安装: `yum install -y zlib zlib-devel`\n- OpenSSL 安装: `yum install -y openssl openssl-devel`\n\n## 安装\n\n```\n# 下载Nginx\nwget -c https://nginx.org/download/nginx-1.10.1.tar.gz\n\n# 解压：\ntar -zxvf nginx-1.10.1.tar.gz\n\n# 进入nginx解压目录\ncd nginx-1.10.1 \n\n# 配置：\n./configure\n\n# 编译安装:\nmake\nmake install\n\n# 查找安装路径：\nwhereis nginx\n```\n\n## 环境变量\n\n因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用`nginx`命令。\n\n设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/bin\n```\n\n> 假设上面的whereis nginx返回的是/usr/local/nginx\n\n## 开启SSL模块\n\n切换到安装的源码包，我是安装在`/usr/local/src/nginx-1.11.3`。\n\n修改配置：\n\n```\n./configure --prefix=/usr/local/nginx --with-http_ssl_modul\n```\n\n执行`make`之后，切记**不要执行**`make install`，否则就覆盖安装了。\n\n先备份已安装好的nginx:\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak\n```\n\n然后关闭已启动的nginx：\n\n```\n# 查看进程号\nps -ef|grep nginx\nkill -QUIT [进程号]\n```\n\n将刚刚编译好的nginx覆盖掉原有的nginx:\n\n```\ncp ./objs/nginx /usr/local/nginx/sbin/\n```\n\n启动nginx，仍可以通过命令查看是否已经加入成功\n\n```\n/usr/local/nginx/sbin/nginx -V　\n```","source":"_posts/about-deploly-favweb-2.md","raw":"---\ntitle: 从零开始，部署一个Web应用（二）MongoDB & nginx\ndate: 2017-10-21 21:37:14\ntags: vue.js\ndesc: for beginner, how to build an web application\ntoc: true\ncategories:\n- 工程实践\n---\n\n这篇文章，就总结一些部署`MongoDB`和`nginx`遇到的问题。\n\n<!-- more -->\n\n# MongoDB\n\n安装的是社区版本([MongoDB Community Edition](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/))。\n\n## 安装\n\n先创建Mongodb在yum的配置文件：\n\n```\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n> 可动态改变版本号\n\n然后使用`yum`安装：\n\n```\nsudo yum install -y mongodb-org\n```\n\n## 安全相关\n\n如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。\n\n在MongoDB中，常用的是增加[用户访问限制](https://docs.mongodb.com/manual/tutorial/enable-authentication/)。\n\n### 高级管理员\n\n第一步，是先创建一个高级管理员。这个高级管理员可**管理其他用户**：\n\n```\n> use admin\n> db.createUser(\n  {\n    user: \"myUserAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]\n  }\n)\n```\n\n> 注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。\n\n可以这样以该角色进入MongoDB的命令行：\n\n```\nmongo --port 27017 -u \"myUserAdmin\" -p \"abc123\" --authenticationDatabase \"admin\"\n```\n\n### 增加其他用户\n\nMongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入`test`数据库：\n\n```\nuse test\n```\n\n然后创建角色时，设置账户，密码以及对应的数据库权限，比如：\n\n```\ndb.createUser(\n  {\n    user: \"testAdmin\",\n    pwd: \"abc123\",\n    roles: [ { role: \"readWrite\", db: \"test\" },\n             { role: \"read\", db: \"reporting\" } ]\n  }\n)\n```\n\n# nginx\n\n安装nginx之前，需要先将nginx的依赖安装完：\n\n- gcc 安装：`yum install gcc-c++`\n- PCRE pcre-devel 安装：`yum install -y pcre pcre-devel`\n- zlib 安装: `yum install -y zlib zlib-devel`\n- OpenSSL 安装: `yum install -y openssl openssl-devel`\n\n## 安装\n\n```\n# 下载Nginx\nwget -c https://nginx.org/download/nginx-1.10.1.tar.gz\n\n# 解压：\ntar -zxvf nginx-1.10.1.tar.gz\n\n# 进入nginx解压目录\ncd nginx-1.10.1 \n\n# 配置：\n./configure\n\n# 编译安装:\nmake\nmake install\n\n# 查找安装路径：\nwhereis nginx\n```\n\n## 环境变量\n\n因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用`nginx`命令。\n\n设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/bin\n```\n\n> 假设上面的whereis nginx返回的是/usr/local/nginx\n\n## 开启SSL模块\n\n切换到安装的源码包，我是安装在`/usr/local/src/nginx-1.11.3`。\n\n修改配置：\n\n```\n./configure --prefix=/usr/local/nginx --with-http_ssl_modul\n```\n\n执行`make`之后，切记**不要执行**`make install`，否则就覆盖安装了。\n\n先备份已安装好的nginx:\n\n```\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak\n```\n\n然后关闭已启动的nginx：\n\n```\n# 查看进程号\nps -ef|grep nginx\nkill -QUIT [进程号]\n```\n\n将刚刚编译好的nginx覆盖掉原有的nginx:\n\n```\ncp ./objs/nginx /usr/local/nginx/sbin/\n```\n\n启动nginx，仍可以通过命令查看是否已经加入成功\n\n```\n/usr/local/nginx/sbin/nginx -V　\n```","slug":"about-deploly-favweb-2","published":1,"updated":"2022-01-08T08:33:16.797Z","_id":"ckxvfmfeh0035brqqc2frc291","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇文章，就总结一些部署<code>MongoDB</code>和<code>nginx</code>遇到的问题。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h1><p>安装的是社区版本(<a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\">MongoDB Community Edition</a>)。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>先创建Mongodb在yum的配置文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mongodb-org-3.4]</span><br><span class=\"line\">name=MongoDB Repository</span><br><span class=\"line\">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可动态改变版本号</p>\n</blockquote>\n<p>然后使用<code>yum</code>安装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安全相关\"><a href=\"#安全相关\" class=\"headerlink\" title=\"安全相关\"></a>安全相关</h2><p>如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。</p>\n<p>在MongoDB中，常用的是增加<a href=\"https://docs.mongodb.com/manual/tutorial/enable-authentication/\">用户访问限制</a>。</p>\n<h3 id=\"高级管理员\"><a href=\"#高级管理员\" class=\"headerlink\" title=\"高级管理员\"></a>高级管理员</h3><p>第一步，是先创建一个高级管理员。这个高级管理员可<strong>管理其他用户</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin</span><br><span class=\"line\">&gt; db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;myUserAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。</p>\n</blockquote>\n<p>可以这样以该角色进入MongoDB的命令行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo --port 27017 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加其他用户\"><a href=\"#增加其他用户\" class=\"headerlink\" title=\"增加其他用户\"></a>增加其他用户</h3><p>MongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入<code>test</code>数据库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use test</span><br></pre></td></tr></table></figure>\n\n<p>然后创建角色时，设置账户，密码以及对应的数据库权限，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;testAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;,</span><br><span class=\"line\">             &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h1><p>安装nginx之前，需要先将nginx的依赖安装完：</p>\n<ul>\n<li>gcc 安装：<code>yum install gcc-c++</code></li>\n<li>PCRE pcre-devel 安装：<code>yum install -y pcre pcre-devel</code></li>\n<li>zlib 安装: <code>yum install -y zlib zlib-devel</code></li>\n<li>OpenSSL 安装: <code>yum install -y openssl openssl-devel</code></li>\n</ul>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载Nginx</span><br><span class=\"line\">wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 解压：</span><br><span class=\"line\">tar -zxvf nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 进入nginx解压目录</span><br><span class=\"line\">cd nginx-1.10.1 </span><br><span class=\"line\"></span><br><span class=\"line\"># 配置：</span><br><span class=\"line\">./configure</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译安装:</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\"># 查找安装路径：</span><br><span class=\"line\">whereis nginx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用<code>nginx</code>命令。</p>\n<p>设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/bin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假设上面的whereis nginx返回的是/usr/local/nginx</p>\n</blockquote>\n<h2 id=\"开启SSL模块\"><a href=\"#开启SSL模块\" class=\"headerlink\" title=\"开启SSL模块\"></a>开启SSL模块</h2><p>切换到安装的源码包，我是安装在<code>/usr/local/src/nginx-1.11.3</code>。</p>\n<p>修改配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/local/nginx --with-http_ssl_modul</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>make</code>之后，切记<strong>不要执行</strong><code>make install</code>，否则就覆盖安装了。</p>\n<p>先备份已安装好的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>\n\n<p>然后关闭已启动的nginx：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看进程号</span><br><span class=\"line\">ps -ef|grep nginx</span><br><span class=\"line\">kill -QUIT [进程号]</span><br></pre></td></tr></table></figure>\n\n<p>将刚刚编译好的nginx覆盖掉原有的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure>\n\n<p>启动nginx，仍可以通过命令查看是否已经加入成功</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/nginx/sbin/nginx -V　</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>这篇文章，就总结一些部署<code>MongoDB</code>和<code>nginx</code>遇到的问题。</p>","more":"<h1 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h1><p>安装的是社区版本(<a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\">MongoDB Community Edition</a>)。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>先创建Mongodb在yum的配置文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mongodb-org-3.4]</span><br><span class=\"line\">name=MongoDB Repository</span><br><span class=\"line\">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可动态改变版本号</p>\n</blockquote>\n<p>然后使用<code>yum</code>安装：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安全相关\"><a href=\"#安全相关\" class=\"headerlink\" title=\"安全相关\"></a>安全相关</h2><p>如果是仅仅是本地开发，完全可以忽略这一步。但是如果要放到线上，就一定要增加安全验证。</p>\n<p>在MongoDB中，常用的是增加<a href=\"https://docs.mongodb.com/manual/tutorial/enable-authentication/\">用户访问限制</a>。</p>\n<h3 id=\"高级管理员\"><a href=\"#高级管理员\" class=\"headerlink\" title=\"高级管理员\"></a>高级管理员</h3><p>第一步，是先创建一个高级管理员。这个高级管理员可<strong>管理其他用户</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin</span><br><span class=\"line\">&gt; db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;myUserAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，admin用户是无法访问其他数据库的，访问其他数据库需要增加新用户。</p>\n</blockquote>\n<p>可以这样以该角色进入MongoDB的命令行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo --port 27017 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加其他用户\"><a href=\"#增加其他用户\" class=\"headerlink\" title=\"增加其他用户\"></a>增加其他用户</h3><p>MongoDB的用户权限是和数据库绑定的，故创建用户前需进入一个指定数据库，比如进入<code>test</code>数据库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use test</span><br></pre></td></tr></table></figure>\n\n<p>然后创建角色时，设置账户，密码以及对应的数据库权限，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.createUser(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    user: &quot;testAdmin&quot;,</span><br><span class=\"line\">    pwd: &quot;abc123&quot;,</span><br><span class=\"line\">    roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;,</span><br><span class=\"line\">             &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h1><p>安装nginx之前，需要先将nginx的依赖安装完：</p>\n<ul>\n<li>gcc 安装：<code>yum install gcc-c++</code></li>\n<li>PCRE pcre-devel 安装：<code>yum install -y pcre pcre-devel</code></li>\n<li>zlib 安装: <code>yum install -y zlib zlib-devel</code></li>\n<li>OpenSSL 安装: <code>yum install -y openssl openssl-devel</code></li>\n</ul>\n<h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 下载Nginx</span><br><span class=\"line\">wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 解压：</span><br><span class=\"line\">tar -zxvf nginx-1.10.1.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\"># 进入nginx解压目录</span><br><span class=\"line\">cd nginx-1.10.1 </span><br><span class=\"line\"></span><br><span class=\"line\"># 配置：</span><br><span class=\"line\">./configure</span><br><span class=\"line\"></span><br><span class=\"line\"># 编译安装:</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br><span class=\"line\"></span><br><span class=\"line\"># 查找安装路径：</span><br><span class=\"line\">whereis nginx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p>因为是二进制安装，所以环境变量需要手动设置，即此时不能直接使用<code>nginx</code>命令。</p>\n<p>设置环境变量的方法是：将nginx的二进制文件复制的系统bin目录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/bin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假设上面的whereis nginx返回的是/usr/local/nginx</p>\n</blockquote>\n<h2 id=\"开启SSL模块\"><a href=\"#开启SSL模块\" class=\"headerlink\" title=\"开启SSL模块\"></a>开启SSL模块</h2><p>切换到安装的源码包，我是安装在<code>/usr/local/src/nginx-1.11.3</code>。</p>\n<p>修改配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --prefix=/usr/local/nginx --with-http_ssl_modul</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>make</code>之后，切记<strong>不要执行</strong><code>make install</code>，否则就覆盖安装了。</p>\n<p>先备份已安装好的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure>\n\n<p>然后关闭已启动的nginx：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看进程号</span><br><span class=\"line\">ps -ef|grep nginx</span><br><span class=\"line\">kill -QUIT [进程号]</span><br></pre></td></tr></table></figure>\n\n<p>将刚刚编译好的nginx覆盖掉原有的nginx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ./objs/nginx /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure>\n\n<p>启动nginx，仍可以通过命令查看是否已经加入成功</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/nginx/sbin/nginx -V　</span><br></pre></td></tr></table></figure>"},{"title":"从零开始，部署一个Web应用（一）","date":"2017-10-14T12:37:14.000Z","desc":"for beginner, how to build an web application","toc":true,"_content":"\n起始篇，先介绍一个整个系列文章涉及到的开发环境，技术栈。\n\n<!-- more -->\n\n## 环境\n\n开发环境：\n\n设备：MacBook Pro 2015\n环境：Node.js v8.9.3 + WebPack v3.0\nIDE：Sublime Text + Visual Studio Code\n\n生产环境：\n\n设备：腾讯云CVM(香港)\n系统：CentOS 7.2 64位\n\n## 技术盏\n\n前端采用了Vue.js + Vue-router + Element-UI\n\n> 采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。\n\n> 而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。\n\n后端采用 Node.js + Think.js\n\n> 因为个人技术盏限制，故采用比较擅长的Node.js。\n\n> 采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。\n\n数据库采用MongoDB + Redis\n\n> MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。\n\n> Redis是用来保存Session，邀请码等数据。\n\n服务器部署：Nginx + Node.js反向代理\n\n> 利用Nginx来实现负载均衡\n\n代码管理：[Coding](https://coding.net)\n\n> 由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。","source":"_posts/about-deploly-favweb-1.md","raw":"---\ntitle: 从零开始，部署一个Web应用（一）\ndate: 2017-10-14 20:37:14\ntags: vue.js\ndesc: for beginner, how to build an web application\ntoc: true\ncategories:\n- 工程实践\n---\n\n起始篇，先介绍一个整个系列文章涉及到的开发环境，技术栈。\n\n<!-- more -->\n\n## 环境\n\n开发环境：\n\n设备：MacBook Pro 2015\n环境：Node.js v8.9.3 + WebPack v3.0\nIDE：Sublime Text + Visual Studio Code\n\n生产环境：\n\n设备：腾讯云CVM(香港)\n系统：CentOS 7.2 64位\n\n## 技术盏\n\n前端采用了Vue.js + Vue-router + Element-UI\n\n> 采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。\n\n> 而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。\n\n后端采用 Node.js + Think.js\n\n> 因为个人技术盏限制，故采用比较擅长的Node.js。\n\n> 采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。\n\n数据库采用MongoDB + Redis\n\n> MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。\n\n> Redis是用来保存Session，邀请码等数据。\n\n服务器部署：Nginx + Node.js反向代理\n\n> 利用Nginx来实现负载均衡\n\n代码管理：[Coding](https://coding.net)\n\n> 由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。","slug":"about-deploly-favweb-1","published":1,"updated":"2022-01-08T08:33:13.796Z","_id":"ckxvfmfej0036brqq1bfld27k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>起始篇，先介绍一个整个系列文章涉及到的开发环境，技术栈。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>开发环境：</p>\n<p>设备：MacBook Pro 2015<br>环境：Node.js v8.9.3 + WebPack v3.0<br>IDE：Sublime Text + Visual Studio Code</p>\n<p>生产环境：</p>\n<p>设备：腾讯云CVM(香港)<br>系统：CentOS 7.2 64位</p>\n<h2 id=\"技术盏\"><a href=\"#技术盏\" class=\"headerlink\" title=\"技术盏\"></a>技术盏</h2><p>前端采用了Vue.js + Vue-router + Element-UI</p>\n<blockquote>\n<p>采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。</p>\n</blockquote>\n<blockquote>\n<p>而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。</p>\n</blockquote>\n<p>后端采用 Node.js + Think.js</p>\n<blockquote>\n<p>因为个人技术盏限制，故采用比较擅长的Node.js。</p>\n</blockquote>\n<blockquote>\n<p>采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。</p>\n</blockquote>\n<p>数据库采用MongoDB + Redis</p>\n<blockquote>\n<p>MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。</p>\n</blockquote>\n<blockquote>\n<p>Redis是用来保存Session，邀请码等数据。</p>\n</blockquote>\n<p>服务器部署：Nginx + Node.js反向代理</p>\n<blockquote>\n<p>利用Nginx来实现负载均衡</p>\n</blockquote>\n<p>代码管理：<a href=\"https://coding.net/\">Coding</a></p>\n<blockquote>\n<p>由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>起始篇，先介绍一个整个系列文章涉及到的开发环境，技术栈。</p>","more":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>开发环境：</p>\n<p>设备：MacBook Pro 2015<br>环境：Node.js v8.9.3 + WebPack v3.0<br>IDE：Sublime Text + Visual Studio Code</p>\n<p>生产环境：</p>\n<p>设备：腾讯云CVM(香港)<br>系统：CentOS 7.2 64位</p>\n<h2 id=\"技术盏\"><a href=\"#技术盏\" class=\"headerlink\" title=\"技术盏\"></a>技术盏</h2><p>前端采用了Vue.js + Vue-router + Element-UI</p>\n<blockquote>\n<p>采用Vue.js是因为最近都在使用Vue.js技术盏，但是从未从零开始创建一个Vue.js项目。故想尝试一遍。</p>\n</blockquote>\n<blockquote>\n<p>而采用Elment-UI是因为不想花太多事件在UI的设计上，毕竟我的设计能力有限。</p>\n</blockquote>\n<p>后端采用 Node.js + Think.js</p>\n<blockquote>\n<p>因为个人技术盏限制，故采用比较擅长的Node.js。</p>\n</blockquote>\n<blockquote>\n<p>采用Think.js是因为目前所在公司是这个方案，也觉得这样比较省事，不想Express那样灵活，什么都需要自己配置。</p>\n</blockquote>\n<p>数据库采用MongoDB + Redis</p>\n<blockquote>\n<p>MongoDB是No SQL数据库，和JavaScipt的JSON格式完美匹配，为了高效开发而选。另外，数据结构的不确定性也是一个因素。</p>\n</blockquote>\n<blockquote>\n<p>Redis是用来保存Session，邀请码等数据。</p>\n</blockquote>\n<p>服务器部署：Nginx + Node.js反向代理</p>\n<blockquote>\n<p>利用Nginx来实现负载均衡</p>\n</blockquote>\n<p>代码管理：<a href=\"https://coding.net/\">Coding</a></p>\n<blockquote>\n<p>由于GitHub的私有仓库需要收费，所以选了一个国内的代码仓库。</p>\n</blockquote>"},{"title":"JavaScript 内存管理","date":"2017-03-05T01:40:57.000Z","desc":"js内存管理 js垃圾回收","toc":true,"_content":"\nJavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。\n\n<!--more-->\n\n## 内存生命周期\n\n不管什么程序语言，内存生命周期基本是一致的：\n\n1. 分配你所需要的内存\n2. 使用分配到的内存（读／写）\n3. 不需要时将其回收\n\n其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。\n\n## 垃圾回收\n\nJavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。\n\n我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：\n\n－ Reference-counting（引用计数） \n－ Mark-and-sweep（标记清除）\n\n#### 引用\n\n一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。\n\n#### 引用计数\n\n其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决**循环引用**的问题：\n\n```js\nvar div;\nwindow.onload = function(){\n  div = document.getElementById(\"myDivElement\");\n  div.circularReference = div;\n  div.lotsOfData = new Array(10000).join(\"*\");\n};\n```\n\n这时DOM 元素`myDivElement`就永远不会被回收了。\n\n#### 标记清除\n\n这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。\n\n这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象`window`。\n\n然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。\n\n这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。\n\n这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。\n\n本文主要内容参考：[Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)\n","source":"_posts/memory-management.md","raw":"---\ntitle: JavaScript 内存管理\ndate: 2017-03-05 09:40:57\ntags: \n- JavaScript\n- 内存管理\n- 垃圾回收\ndesc: js内存管理 js垃圾回收\ntoc: true\ncategories:\n- [前端, 基础]\n- 浏览器\n---\n\nJavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。\n\n<!--more-->\n\n## 内存生命周期\n\n不管什么程序语言，内存生命周期基本是一致的：\n\n1. 分配你所需要的内存\n2. 使用分配到的内存（读／写）\n3. 不需要时将其回收\n\n其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。\n\n## 垃圾回收\n\nJavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。\n\n我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：\n\n－ Reference-counting（引用计数） \n－ Mark-and-sweep（标记清除）\n\n#### 引用\n\n一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。\n\n#### 引用计数\n\n其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决**循环引用**的问题：\n\n```js\nvar div;\nwindow.onload = function(){\n  div = document.getElementById(\"myDivElement\");\n  div.circularReference = div;\n  div.lotsOfData = new Array(10000).join(\"*\");\n};\n```\n\n这时DOM 元素`myDivElement`就永远不会被回收了。\n\n#### 标记清除\n\n这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。\n\n这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象`window`。\n\n然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。\n\n这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。\n\n这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。\n\n本文主要内容参考：[Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)\n","slug":"memory-management","published":1,"updated":"2022-01-08T08:39:01.102Z","_id":"ckxvfmfem0039brqq7tqldh2s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：</p>\n<ol>\n<li>分配你所需要的内存</li>\n<li>使用分配到的内存（读／写）</li>\n<li>不需要时将其回收</li>\n</ol>\n<p>其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。</p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><p>JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。</p>\n<p>我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：</p>\n<p>－ Reference-counting（引用计数）<br>－ Mark-and-sweep（标记清除）</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。</p>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决<strong>循环引用</strong>的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myDivElement&quot;</span>);</span><br><span class=\"line\">  div.circularReference = div;</span><br><span class=\"line\">  div.lotsOfData = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时DOM 元素<code>myDivElement</code>就永远不会被回收了。</p>\n<h4 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h4><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>\n<p>这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象<code>window</code>。</p>\n<p>然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。</p>\n<p>这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。</p>\n<p>这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。</p>\n<p>本文主要内容参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\">Memory Management</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>JavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。</p>","more":"<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期\"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：</p>\n<ol>\n<li>分配你所需要的内存</li>\n<li>使用分配到的内存（读／写）</li>\n<li>不需要时将其回收</li>\n</ol>\n<p>其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。</p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><p>JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。</p>\n<p>我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：</p>\n<p>－ Reference-counting（引用计数）<br>－ Mark-and-sweep（标记清除）</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。</p>\n<h4 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h4><p>其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决<strong>循环引用</strong>的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> div;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;myDivElement&quot;</span>);</span><br><span class=\"line\">  div.circularReference = div;</span><br><span class=\"line\">  div.lotsOfData = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时DOM 元素<code>myDivElement</code>就永远不会被回收了。</p>\n<h4 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h4><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>\n<p>这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象<code>window</code>。</p>\n<p>然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。</p>\n<p>这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。</p>\n<p>这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。</p>\n<p>本文主要内容参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\">Memory Management</a></p>"},{"title":"理解underscore.js系列——③基础函数","date":"2017-09-18T06:52:42.000Z","desc":"理解underscore.js v1.8.3 源码解析","toc":true,"_content":"\n从`_.each`函数入手，理解`underscore.js`的基础函数，`_.each`的调用盏可以参考如下思维导图：\n\n![image](http://7xnh42.com1.z0.glb.clouddn.com/each.jpg)\n\n`underscore.js`的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，`_.each`也不例外。因此先来介绍内置的`cb`函数还有`optimizeCb`函数\n\n<!-- more -->\n\n### cb\n\n`cb`顾名思义，就是回调函数(CallBack的简称)的意思。\n\n```js\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 1\n    if (value == null) return _.identity; // 2\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 3\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value); // 4\n    return _.property(value);\n  };\n```\n\n1. 对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的`_.iteratee`\n2. 如果没有传入`value`，就使用`_.identity = function(value) { return value; }`\n3. 如果传入了`function`，则使用`optimizeCb`格式化一下\n4. 如果传入了`object`，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致\n5. 否则就将传入的值当成一个属性，返回一个匹配该属性的函数\n\n\n### optimizeCb\n\n格式化传入的回调函数，以统一迭代函数，方便后续使用\n\n```js\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    // 如果没有执行上下文，就直接返回该函数\n    if (context === void 0) return func;\n    switch (argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-parameter case has been omitted only because no current consumers\n      // made use of it.\n      case null:\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n```\n\n### collectNonEnumProps\n\n在IE9以下版本，会有一个bug：如果重写了`原不可枚举的属性`，使用`for...in`是不会返回的。\n\n相关信息可参考：[W3Help SJ5003](http://www.w3help.org/zh-cn/causes/SJ5003)\n\n```js\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    // 获取对象的构造函数，以获取对象的原型\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    // 将构造函数属性放入keys\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      // 如果obj有这个属性\n      // obj[prop] !== proto[prop] 说明重写了该属性\n      // keys不包含该属性\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n```\n\n这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章[待续](/)\n\n### restArgs\n\n`rest`是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：`function(value, ...rest)`\n\n```js\n  // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n  // This accumulates the arguments passed into an array, after a given index.\n  var restArgs = function(func, startIndex) {\n    // func.length可获取函数定义的参数个数\n    // eg: function (a, b) {}  => 2\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      // 将定义的最后一个参数和超过定义的参数都放进rest数组\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      // 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      // 将超出的部分(指rest)放在args数组的最后一位\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n```\n\n这里涉及到两个知识点：\n\n- `function.length`指的是函数定义的参数个数\n- `function.call`和`function.apply`的区别：`call`需逐个传入参数，而`apply`则将参数放进一个数组传入","source":"_posts/underscore/underscore-base-function.md","raw":"---\ntitle: 理解underscore.js系列——③基础函数\ndate: 2017-09-18 14:52:42\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\ntoc: true\ncategories:\n- 源码解析\n- underscore\n---\n\n从`_.each`函数入手，理解`underscore.js`的基础函数，`_.each`的调用盏可以参考如下思维导图：\n\n![image](http://7xnh42.com1.z0.glb.clouddn.com/each.jpg)\n\n`underscore.js`的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，`_.each`也不例外。因此先来介绍内置的`cb`函数还有`optimizeCb`函数\n\n<!-- more -->\n\n### cb\n\n`cb`顾名思义，就是回调函数(CallBack的简称)的意思。\n\n```js\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context); // 1\n    if (value == null) return _.identity; // 2\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount); // 3\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value); // 4\n    return _.property(value);\n  };\n```\n\n1. 对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的`_.iteratee`\n2. 如果没有传入`value`，就使用`_.identity = function(value) { return value; }`\n3. 如果传入了`function`，则使用`optimizeCb`格式化一下\n4. 如果传入了`object`，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致\n5. 否则就将传入的值当成一个属性，返回一个匹配该属性的函数\n\n\n### optimizeCb\n\n格式化传入的回调函数，以统一迭代函数，方便后续使用\n\n```js\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    // 如果没有执行上下文，就直接返回该函数\n    if (context === void 0) return func;\n    switch (argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-parameter case has been omitted only because no current consumers\n      // made use of it.\n      case null:\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n```\n\n### collectNonEnumProps\n\n在IE9以下版本，会有一个bug：如果重写了`原不可枚举的属性`，使用`for...in`是不会返回的。\n\n相关信息可参考：[W3Help SJ5003](http://www.w3help.org/zh-cn/causes/SJ5003)\n\n```js\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    // 获取对象的构造函数，以获取对象的原型\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    // 将构造函数属性放入keys\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      // 如果obj有这个属性\n      // obj[prop] !== proto[prop] 说明重写了该属性\n      // keys不包含该属性\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n```\n\n这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章[待续](/)\n\n### restArgs\n\n`rest`是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：`function(value, ...rest)`\n\n```js\n  // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n  // This accumulates the arguments passed into an array, after a given index.\n  var restArgs = function(func, startIndex) {\n    // func.length可获取函数定义的参数个数\n    // eg: function (a, b) {}  => 2\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      // 将定义的最后一个参数和超过定义的参数都放进rest数组\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      // 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      // 将超出的部分(指rest)放在args数组的最后一位\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n```\n\n这里涉及到两个知识点：\n\n- `function.length`指的是函数定义的参数个数\n- `function.call`和`function.apply`的区别：`call`需逐个传入参数，而`apply`则将参数放进一个数组传入","slug":"underscore/underscore-base-function","published":1,"updated":"2022-01-08T08:34:34.030Z","_id":"cky5gxvi20000n669b4en271i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>从<code>_.each</code>函数入手，理解<code>underscore.js</code>的基础函数，<code>_.each</code>的调用盏可以参考如下思维导图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/each.jpg\" alt=\"image\"></p>\n<p><code>underscore.js</code>的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，<code>_.each</code>也不例外。因此先来介绍内置的<code>cb</code>函数还有<code>optimizeCb</code>函数</p>\n<span id=\"more\"></span>\n\n<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p><code>cb</code>顾名思义，就是回调函数(CallBack的简称)的意思。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// An internal function to generate callbacks that can be applied to each</span></span><br><span class=\"line\"><span class=\"comment\">// element in a collection, returning the desired result — either `identity`,</span></span><br><span class=\"line\"><span class=\"comment\">// an arbitrary callback, a property matcher, or a property accessor.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.iteratee !== builtinIteratee) <span class=\"keyword\">return</span> _.iteratee(value, context); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> _.identity; <span class=\"comment\">// 2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(value)) <span class=\"keyword\">return</span> optimizeCb(value, context, argCount); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isObject(value) &amp;&amp; !_.isArray(value)) <span class=\"keyword\">return</span> _.matcher(value); <span class=\"comment\">// 4</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的<code>_.iteratee</code></li>\n<li>如果没有传入<code>value</code>，就使用<code>_.identity = function(value) &#123; return value; &#125;</code></li>\n<li>如果传入了<code>function</code>，则使用<code>optimizeCb</code>格式化一下</li>\n<li>如果传入了<code>object</code>，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致</li>\n<li>否则就将传入的值当成一个属性，返回一个匹配该属性的函数</li>\n</ol>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><p>格式化传入的回调函数，以统一迭代函数，方便后续使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Internal function that returns an efficient (for current engines) version</span></span><br><span class=\"line\"><span class=\"comment\">// of the passed-in callback, to be repeatedly applied in other Underscore</span></span><br><span class=\"line\"><span class=\"comment\">// functions.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> optimizeCb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有执行上下文，就直接返回该函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (context === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) <span class=\"keyword\">return</span> func;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (argCount) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class=\"line\">    <span class=\"comment\">// made use of it.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"literal\">null</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">accumulator, value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(context, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"collectNonEnumProps\"><a href=\"#collectNonEnumProps\" class=\"headerlink\" title=\"collectNonEnumProps\"></a>collectNonEnumProps</h3><p>在IE9以下版本，会有一个bug：如果重写了<code>原不可枚举的属性</code>，使用<code>for...in</code>是不会返回的。</p>\n<p>相关信息可参考：<a href=\"http://www.w3help.org/zh-cn/causes/SJ5003\">W3Help SJ5003</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Keys in IE &lt; 9 that won&#x27;t be iterated by `for key in ...` and thus missed.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hasEnumBug = !&#123;<span class=\"attr\">toString</span>: <span class=\"literal\">null</span>&#125;.propertyIsEnumerable(<span class=\"string\">&#x27;toString&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nonEnumerableProps = [<span class=\"string\">&#x27;valueOf&#x27;</span>, <span class=\"string\">&#x27;isPrototypeOf&#x27;</span>, <span class=\"string\">&#x27;toString&#x27;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;propertyIsEnumerable&#x27;</span>, <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>, <span class=\"string\">&#x27;toLocaleString&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> collectNonEnumProps = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, keys</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nonEnumIdx = nonEnumerableProps.length;</span><br><span class=\"line\">  <span class=\"comment\">// 获取对象的构造函数，以获取对象的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"title\">constructor</span> = <span class=\"title\">obj</span>.<span class=\"title\">constructor</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> proto = _.isFunction(<span class=\"title\">constructor</span>) &amp;&amp; <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span> || <span class=\"title\">ObjProto</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Constructor is a special case.</span></span><br><span class=\"line\">  <span class=\"comment\">// 将构造函数属性放入keys</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prop = <span class=\"string\">&#x27;constructor&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nonEnumIdx--) &#123;</span><br><span class=\"line\">    prop = nonEnumerableProps[nonEnumIdx];</span><br><span class=\"line\">    <span class=\"comment\">// 如果obj有这个属性</span></span><br><span class=\"line\">    <span class=\"comment\">// obj[prop] !== proto[prop] 说明重写了该属性</span></span><br><span class=\"line\">    <span class=\"comment\">// keys不包含该属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123;</span><br><span class=\"line\">      keys.push(prop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章<a href=\"/\">待续</a></p>\n<h3 id=\"restArgs\"><a href=\"#restArgs\" class=\"headerlink\" title=\"restArgs\"></a>restArgs</h3><p><code>rest</code>是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：<code>function(value, ...rest)</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to ES6&#x27;s rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)</span></span><br><span class=\"line\"><span class=\"comment\">// This accumulates the arguments passed into an array, after a given index.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restArgs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, startIndex</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// func.length可获取函数定义的参数个数</span></span><br><span class=\"line\">  <span class=\"comment\">// eg: function (a, b) &#123;&#125;  =&gt; 2</span></span><br><span class=\"line\">  startIndex = startIndex == <span class=\"literal\">null</span> ? func.length - <span class=\"number\">1</span> : +startIndex;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> length = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">arguments</span>.length - startIndex, <span class=\"number\">0</span>),</span><br><span class=\"line\">        rest = <span class=\"built_in\">Array</span>(length),</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将定义的最后一个参数和超过定义的参数都放进rest数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; index &lt; length; index++) &#123;</span><br><span class=\"line\">      rest[index] = <span class=\"built_in\">arguments</span>[index + startIndex];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (startIndex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>], rest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将超出的部分(指rest)放在args数组的最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>(startIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class=\"line\">      args[index] = <span class=\"built_in\">arguments</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    args[startIndex] = rest;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里涉及到两个知识点：</p>\n<ul>\n<li><code>function.length</code>指的是函数定义的参数个数</li>\n<li><code>function.call</code>和<code>function.apply</code>的区别：<code>call</code>需逐个传入参数，而<code>apply</code>则将参数放进一个数组传入</li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>从<code>_.each</code>函数入手，理解<code>underscore.js</code>的基础函数，<code>_.each</code>的调用盏可以参考如下思维导图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/each.jpg\" alt=\"image\"></p>\n<p><code>underscore.js</code>的很多方法都是基于函数的，因此对于用户传入的回调函数都是需要处理的，<code>_.each</code>也不例外。因此先来介绍内置的<code>cb</code>函数还有<code>optimizeCb</code>函数</p>","more":"<h3 id=\"cb\"><a href=\"#cb\" class=\"headerlink\" title=\"cb\"></a>cb</h3><p><code>cb</code>顾名思义，就是回调函数(CallBack的简称)的意思。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// An internal function to generate callbacks that can be applied to each</span></span><br><span class=\"line\"><span class=\"comment\">// element in a collection, returning the desired result — either `identity`,</span></span><br><span class=\"line\"><span class=\"comment\">// an arbitrary callback, a property matcher, or a property accessor.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.iteratee !== builtinIteratee) <span class=\"keyword\">return</span> _.iteratee(value, context); <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> _.identity; <span class=\"comment\">// 2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(value)) <span class=\"keyword\">return</span> optimizeCb(value, context, argCount); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isObject(value) &amp;&amp; !_.isArray(value)) <span class=\"keyword\">return</span> _.matcher(value); <span class=\"comment\">// 4</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.property(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对于迭代函数(iteratee)来说，我们是可以重写成自己的迭代函数的。因此如果我们重新了的话就直接调用我们重写的<code>_.iteratee</code></li>\n<li>如果没有传入<code>value</code>，就使用<code>_.identity = function(value) &#123; return value; &#125;</code></li>\n<li>如果传入了<code>function</code>，则使用<code>optimizeCb</code>格式化一下</li>\n<li>如果传入了<code>object</code>，就是返回一个匹配函数，用于判断后续传入对象是否和该对象一致</li>\n<li>否则就将传入的值当成一个属性，返回一个匹配该属性的函数</li>\n</ol>\n<h3 id=\"optimizeCb\"><a href=\"#optimizeCb\" class=\"headerlink\" title=\"optimizeCb\"></a>optimizeCb</h3><p>格式化传入的回调函数，以统一迭代函数，方便后续使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Internal function that returns an efficient (for current engines) version</span></span><br><span class=\"line\"><span class=\"comment\">// of the passed-in callback, to be repeatedly applied in other Underscore</span></span><br><span class=\"line\"><span class=\"comment\">// functions.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> optimizeCb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, context, argCount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有执行上下文，就直接返回该函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (context === <span class=\"keyword\">void</span> <span class=\"number\">0</span>) <span class=\"keyword\">return</span> func;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (argCount) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class=\"line\">    <span class=\"comment\">// made use of it.</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"literal\">null</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">accumulator, value, index, collection</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> func.call(context, accumulator, value, index, collection);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(context, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"collectNonEnumProps\"><a href=\"#collectNonEnumProps\" class=\"headerlink\" title=\"collectNonEnumProps\"></a>collectNonEnumProps</h3><p>在IE9以下版本，会有一个bug：如果重写了<code>原不可枚举的属性</code>，使用<code>for...in</code>是不会返回的。</p>\n<p>相关信息可参考：<a href=\"http://www.w3help.org/zh-cn/causes/SJ5003\">W3Help SJ5003</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Keys in IE &lt; 9 that won&#x27;t be iterated by `for key in ...` and thus missed.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hasEnumBug = !&#123;<span class=\"attr\">toString</span>: <span class=\"literal\">null</span>&#125;.propertyIsEnumerable(<span class=\"string\">&#x27;toString&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nonEnumerableProps = [<span class=\"string\">&#x27;valueOf&#x27;</span>, <span class=\"string\">&#x27;isPrototypeOf&#x27;</span>, <span class=\"string\">&#x27;toString&#x27;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;propertyIsEnumerable&#x27;</span>, <span class=\"string\">&#x27;hasOwnProperty&#x27;</span>, <span class=\"string\">&#x27;toLocaleString&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> collectNonEnumProps = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, keys</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nonEnumIdx = nonEnumerableProps.length;</span><br><span class=\"line\">  <span class=\"comment\">// 获取对象的构造函数，以获取对象的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> <span class=\"title\">constructor</span> = <span class=\"title\">obj</span>.<span class=\"title\">constructor</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> proto = _.isFunction(<span class=\"title\">constructor</span>) &amp;&amp; <span class=\"title\">constructor</span>.<span class=\"title\">prototype</span> || <span class=\"title\">ObjProto</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Constructor is a special case.</span></span><br><span class=\"line\">  <span class=\"comment\">// 将构造函数属性放入keys</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prop = <span class=\"string\">&#x27;constructor&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (nonEnumIdx--) &#123;</span><br><span class=\"line\">    prop = nonEnumerableProps[nonEnumIdx];</span><br><span class=\"line\">    <span class=\"comment\">// 如果obj有这个属性</span></span><br><span class=\"line\">    <span class=\"comment\">// obj[prop] !== proto[prop] 说明重写了该属性</span></span><br><span class=\"line\">    <span class=\"comment\">// keys不包含该属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123;</span><br><span class=\"line\">      keys.push(prop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里就涉及到JavaScript的对象相关知识，可以参考另一篇文章<a href=\"/\">待续</a></p>\n<h3 id=\"restArgs\"><a href=\"#restArgs\" class=\"headerlink\" title=\"restArgs\"></a>restArgs</h3><p><code>rest</code>是剩余的意思，顾名思义就是剩余参数，以方便灵活使用函数，灵活传入参数。这个是功能在ES6已经实现了，使用方式为：<code>function(value, ...rest)</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to ES6&#x27;s rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)</span></span><br><span class=\"line\"><span class=\"comment\">// This accumulates the arguments passed into an array, after a given index.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restArgs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, startIndex</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// func.length可获取函数定义的参数个数</span></span><br><span class=\"line\">  <span class=\"comment\">// eg: function (a, b) &#123;&#125;  =&gt; 2</span></span><br><span class=\"line\">  startIndex = startIndex == <span class=\"literal\">null</span> ? func.length - <span class=\"number\">1</span> : +startIndex;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> length = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">arguments</span>.length - startIndex, <span class=\"number\">0</span>),</span><br><span class=\"line\">        rest = <span class=\"built_in\">Array</span>(length),</span><br><span class=\"line\">        index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将定义的最后一个参数和超过定义的参数都放进rest数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; index &lt; length; index++) &#123;</span><br><span class=\"line\">      rest[index] = <span class=\"built_in\">arguments</span>[index + startIndex];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这部分逻辑和下部分是重叠的。因为这三种情况是常用的，就可避免执行下面的逻辑。</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (startIndex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], rest);</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>], <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>], rest);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将超出的部分(指rest)放在args数组的最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>(startIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class=\"line\">      args[index] = <span class=\"built_in\">arguments</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    args[startIndex] = rest;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里涉及到两个知识点：</p>\n<ul>\n<li><code>function.length</code>指的是函数定义的参数个数</li>\n<li><code>function.call</code>和<code>function.apply</code>的区别：<code>call</code>需逐个传入参数，而<code>apply</code>则将参数放进一个数组传入</li>\n</ul>"},{"title":"理解underscore.js系列——①分析外包装","date":"2017-09-04T12:26:40.000Z","desc":"理解underscore.js v1.8.3 源码解析","toc":true,"_content":"\n# 前言\n\n其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。\n\n另外提醒，此文对应的`underscore.js`版本是`v1.8.3`\n\n<!-- more -->\n\n## 正文\n\n下面将以源码+解析的形式，叙述我对`underscore.js`的理解，能力有限，如有错误请指正。\n\n### 立即执行函数\n\n源码的最外面是一个立即执行函数(`IIFE`)：\n\n```js\n(function() {\n  // ...其他内容\n}());\n```\n\n之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。\n\n### 全局变量\n\n以前刚接触前端开发的时候，不懂`Node.js`，认为全局变量就是`window`，因此看到下面的代码会很困惑：\n\n```js\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n             typeof global == 'object' && global.global === global && global ||\n             this ||\n             {};\n```\n\n这是一个很geek的做法，运用了逻辑运算中的[`短路运算`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators)，在`||`操作的时候，如果前面为`true`的话，就不会计算后面的了。\n\n印象当中，以前的js库都是用`window`的，现在改用`self`，是因为要兼容[webWorker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)的缘故。因此（如注释所言）\n\n- 在浏览器或者`webWorker`的话，`root = self`\n- 在服务器环境的话，`root = global`\n- 在其他的虚拟机的话，则指向`this`即`root = this`\n- 其他环境就设置为空对象`{}`\n\n### 变量冲突\n\n我们假设一个情况，如果`_`这个变量被别人使用了。如果我们直接给`_`赋值，不就丢失了前面的对于`_`的定义。\n\n因此`undersocre.js`就先保存起来了：\n\n```js\nvar previousUnderscore = root._;\n```\n\n这样的话，就不会丢失了前面对`_`的定义，如果要使用的话，就可以使用`underscore.js`提供的`noConflict`方法：\n\n```js\n_.noConflict = function() {\n  root._ = previousUnderscore;\n  return this;\n};\n```\n\n### 缓存引用\n\n这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：\n\n```js\n// Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n```\n\n### 实现继承\n\n众所周知的是，js是使用原型链来实现继承的。\n\n其实这个实现方法就是ES5的`Object.create`的Polyfill，这么做是为了向后兼容：\n\n```js\n  var Ctor = function(){};\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null; // 恢复CTor的原型，以备后续使用\n    return result;\n  };\n```\n\n### 初始化\n\n```js\n// Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n```\n\n一开始我对这个部分有些困惑的，因为我简单地认为`_`就应该是一个空对象`{}`。\n\n其实，`underscore.js`是支持面向对象的方式使用的，也就是把`_`当作一个构造函数。即`new _(obj)`这样的用法。\n\n但是由于js没用真正的构造函数，因此还可以这样使用：`_(obj)`。为了避免这种情况，因此有了第二行代码：`if (!(this instanceof _)) return new _(obj);`。因为直接调用函数的话，`this`是指向全局的。\n\n### 兼容Node.js环境\n\n```js\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n```\n\n由于`Node.js`的存在，因此在`Node.js`环境就将`_`赋值给`exports`\n\n另外如注释所说，之所以要检测`nodeType`，是为了确保`exports`和`module`不是`HTML`元素\n\n## 结尾\n\n这篇文章就是我阅读`udersocre.js`的第一篇源码分析文章，也是这个系列的第一篇。\n\n写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。\n","source":"_posts/underscore/underscore-wrapper.md","raw":"---\ntitle: 理解underscore.js系列——①分析外包装\ndate: 2017-09-04 20:26:40\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\ntoc: true\ncategories:\n- 源码解析\n- underscore\n---\n\n# 前言\n\n其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。\n\n另外提醒，此文对应的`underscore.js`版本是`v1.8.3`\n\n<!-- more -->\n\n## 正文\n\n下面将以源码+解析的形式，叙述我对`underscore.js`的理解，能力有限，如有错误请指正。\n\n### 立即执行函数\n\n源码的最外面是一个立即执行函数(`IIFE`)：\n\n```js\n(function() {\n  // ...其他内容\n}());\n```\n\n之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。\n\n### 全局变量\n\n以前刚接触前端开发的时候，不懂`Node.js`，认为全局变量就是`window`，因此看到下面的代码会很困惑：\n\n```js\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n             typeof global == 'object' && global.global === global && global ||\n             this ||\n             {};\n```\n\n这是一个很geek的做法，运用了逻辑运算中的[`短路运算`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators)，在`||`操作的时候，如果前面为`true`的话，就不会计算后面的了。\n\n印象当中，以前的js库都是用`window`的，现在改用`self`，是因为要兼容[webWorker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)的缘故。因此（如注释所言）\n\n- 在浏览器或者`webWorker`的话，`root = self`\n- 在服务器环境的话，`root = global`\n- 在其他的虚拟机的话，则指向`this`即`root = this`\n- 其他环境就设置为空对象`{}`\n\n### 变量冲突\n\n我们假设一个情况，如果`_`这个变量被别人使用了。如果我们直接给`_`赋值，不就丢失了前面的对于`_`的定义。\n\n因此`undersocre.js`就先保存起来了：\n\n```js\nvar previousUnderscore = root._;\n```\n\n这样的话，就不会丢失了前面对`_`的定义，如果要使用的话，就可以使用`underscore.js`提供的`noConflict`方法：\n\n```js\n_.noConflict = function() {\n  root._ = previousUnderscore;\n  return this;\n};\n```\n\n### 缓存引用\n\n这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：\n\n```js\n// Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n```\n\n### 实现继承\n\n众所周知的是，js是使用原型链来实现继承的。\n\n其实这个实现方法就是ES5的`Object.create`的Polyfill，这么做是为了向后兼容：\n\n```js\n  var Ctor = function(){};\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null; // 恢复CTor的原型，以备后续使用\n    return result;\n  };\n```\n\n### 初始化\n\n```js\n// Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n```\n\n一开始我对这个部分有些困惑的，因为我简单地认为`_`就应该是一个空对象`{}`。\n\n其实，`underscore.js`是支持面向对象的方式使用的，也就是把`_`当作一个构造函数。即`new _(obj)`这样的用法。\n\n但是由于js没用真正的构造函数，因此还可以这样使用：`_(obj)`。为了避免这种情况，因此有了第二行代码：`if (!(this instanceof _)) return new _(obj);`。因为直接调用函数的话，`this`是指向全局的。\n\n### 兼容Node.js环境\n\n```js\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n```\n\n由于`Node.js`的存在，因此在`Node.js`环境就将`_`赋值给`exports`\n\n另外如注释所说，之所以要检测`nodeType`，是为了确保`exports`和`module`不是`HTML`元素\n\n## 结尾\n\n这篇文章就是我阅读`udersocre.js`的第一篇源码分析文章，也是这个系列的第一篇。\n\n写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。\n","slug":"underscore/underscore-wrapper","published":1,"updated":"2022-01-08T08:34:41.682Z","_id":"cky5gyomk0003n669hjjtay8h","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。</p>\n<p>另外提醒，此文对应的<code>underscore.js</code>版本是<code>v1.8.3</code></p>\n<span id=\"more\"></span>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>下面将以源码+解析的形式，叙述我对<code>underscore.js</code>的理解，能力有限，如有错误请指正。</p>\n<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h3><p>源码的最外面是一个立即执行函数(<code>IIFE</code>)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他内容</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>以前刚接触前端开发的时候，不懂<code>Node.js</code>，认为全局变量就是<code>window</code>，因此看到下面的代码会很困惑：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Establish the root object, `window` (`self`) in the browser, `global`</span></span><br><span class=\"line\"><span class=\"comment\">// on the server, or `this` in some virtual machines. We use `self`</span></span><br><span class=\"line\"><span class=\"comment\">// instead of `window` for `WebWorker` support.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = <span class=\"keyword\">typeof</span> self == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class=\"line\">           <span class=\"keyword\">typeof</span> <span class=\"built_in\">global</span> == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"built_in\">global</span>.global === <span class=\"built_in\">global</span> &amp;&amp; <span class=\"built_in\">global</span> ||</span><br><span class=\"line\">           <span class=\"built_in\">this</span> ||</span><br><span class=\"line\">           &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很geek的做法，运用了逻辑运算中的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators\"><code>短路运算</code></a>，在<code>||</code>操作的时候，如果前面为<code>true</code>的话，就不会计算后面的了。</p>\n<p>印象当中，以前的js库都是用<code>window</code>的，现在改用<code>self</code>，是因为要兼容<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker\">webWorker</a>的缘故。因此（如注释所言）</p>\n<ul>\n<li>在浏览器或者<code>webWorker</code>的话，<code>root = self</code></li>\n<li>在服务器环境的话，<code>root = global</code></li>\n<li>在其他的虚拟机的话，则指向<code>this</code>即<code>root = this</code></li>\n<li>其他环境就设置为空对象<code>&#123;&#125;</code></li>\n</ul>\n<h3 id=\"变量冲突\"><a href=\"#变量冲突\" class=\"headerlink\" title=\"变量冲突\"></a>变量冲突</h3><p>我们假设一个情况，如果<code>_</code>这个变量被别人使用了。如果我们直接给<code>_</code>赋值，不就丢失了前面的对于<code>_</code>的定义。</p>\n<p>因此<code>undersocre.js</code>就先保存起来了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> previousUnderscore = root._;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，就不会丢失了前面对<code>_</code>的定义，如果要使用的话，就可以使用<code>underscore.js</code>提供的<code>noConflict</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  root._ = previousUnderscore;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存引用\"><a href=\"#缓存引用\" class=\"headerlink\" title=\"缓存引用\"></a>缓存引用</h3><p>这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Save bytes in the minified (but not gzipped) version:</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ArrayProto = <span class=\"built_in\">Array</span>.prototype, ObjProto = <span class=\"built_in\">Object</span>.prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> SymbolProto = <span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> ? <span class=\"built_in\">Symbol</span>.prototype : <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create quick reference variables for speed access to core prototypes.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> push = ArrayProto.push,</span><br><span class=\"line\">      slice = ArrayProto.slice,</span><br><span class=\"line\">      toString = ObjProto.toString,</span><br><span class=\"line\">      hasOwnProperty = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All **ECMAScript 5** native function implementations that we hope to use</span></span><br><span class=\"line\">  <span class=\"comment\">// are declared here.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> nativeIsArray = <span class=\"built_in\">Array</span>.isArray,</span><br><span class=\"line\">      nativeKeys = <span class=\"built_in\">Object</span>.keys,</span><br><span class=\"line\">      nativeCreate = <span class=\"built_in\">Object</span>.create;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h3><p>众所周知的是，js是使用原型链来实现继承的。</p>\n<p>其实这个实现方法就是ES5的<code>Object.create</code>的Polyfill，这么做是为了向后兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Ctor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An internal function for creating a new object that inherits from another.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baseCreate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prototype</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_.isObject(prototype)) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nativeCreate) <span class=\"keyword\">return</span> nativeCreate(prototype);</span><br><span class=\"line\">  Ctor.prototype = prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> Ctor;</span><br><span class=\"line\">  Ctor.prototype = <span class=\"literal\">null</span>; <span class=\"comment\">// 恢复CTor的原型，以备后续使用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a safe reference to the Underscore object for use below.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> _) <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> _)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _(obj);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一开始我对这个部分有些困惑的，因为我简单地认为<code>_</code>就应该是一个空对象<code>&#123;&#125;</code>。</p>\n<p>其实，<code>underscore.js</code>是支持面向对象的方式使用的，也就是把<code>_</code>当作一个构造函数。即<code>new _(obj)</code>这样的用法。</p>\n<p>但是由于js没用真正的构造函数，因此还可以这样使用：<code>_(obj)</code>。为了避免这种情况，因此有了第二行代码：<code>if (!(this instanceof _)) return new _(obj);</code>。因为直接调用函数的话，<code>this</code>是指向全局的。</p>\n<h3 id=\"兼容Node-js环境\"><a href=\"#兼容Node-js环境\" class=\"headerlink\" title=\"兼容Node.js环境\"></a>兼容Node.js环境</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Export the Underscore object for **Node.js**, with</span></span><br><span class=\"line\"><span class=\"comment\">// backwards-compatibility for their old module API. If we&#x27;re in</span></span><br><span class=\"line\"><span class=\"comment\">// the browser, add `_` as a global object.</span></span><br><span class=\"line\"><span class=\"comment\">// (`nodeType` is checked to ensure that `module`</span></span><br><span class=\"line\"><span class=\"comment\">// and `exports` are not HTML elements.)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">exports</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">exports</span>.nodeType) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">module</span>.nodeType &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">exports</span> = <span class=\"built_in\">module</span>.exports = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>._ = _;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  root._ = _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>Node.js</code>的存在，因此在<code>Node.js</code>环境就将<code>_</code>赋值给<code>exports</code></p>\n<p>另外如注释所说，之所以要检测<code>nodeType</code>，是为了确保<code>exports</code>和<code>module</code>不是<code>HTML</code>元素</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这篇文章就是我阅读<code>udersocre.js</code>的第一篇源码分析文章，也是这个系列的第一篇。</p>\n<p>写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实每个JavaScript库的外包装都大同小异，读懂一个就差不多能读懂其他的了。</p>\n<p>另外提醒，此文对应的<code>underscore.js</code>版本是<code>v1.8.3</code></p>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>下面将以源码+解析的形式，叙述我对<code>underscore.js</code>的理解，能力有限，如有错误请指正。</p>\n<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a>立即执行函数</h3><p>源码的最外面是一个立即执行函数(<code>IIFE</code>)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他内容</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>之所以这么做，在我的理解是，因为js只有函数作用域，只有这样做才不会污染全局变量。</p>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>以前刚接触前端开发的时候，不懂<code>Node.js</code>，认为全局变量就是<code>window</code>，因此看到下面的代码会很困惑：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Establish the root object, `window` (`self`) in the browser, `global`</span></span><br><span class=\"line\"><span class=\"comment\">// on the server, or `this` in some virtual machines. We use `self`</span></span><br><span class=\"line\"><span class=\"comment\">// instead of `window` for `WebWorker` support.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> root = <span class=\"keyword\">typeof</span> self == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class=\"line\">           <span class=\"keyword\">typeof</span> <span class=\"built_in\">global</span> == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"built_in\">global</span>.global === <span class=\"built_in\">global</span> &amp;&amp; <span class=\"built_in\">global</span> ||</span><br><span class=\"line\">           <span class=\"built_in\">this</span> ||</span><br><span class=\"line\">           &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这是一个很geek的做法，运用了逻辑运算中的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators\"><code>短路运算</code></a>，在<code>||</code>操作的时候，如果前面为<code>true</code>的话，就不会计算后面的了。</p>\n<p>印象当中，以前的js库都是用<code>window</code>的，现在改用<code>self</code>，是因为要兼容<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker\">webWorker</a>的缘故。因此（如注释所言）</p>\n<ul>\n<li>在浏览器或者<code>webWorker</code>的话，<code>root = self</code></li>\n<li>在服务器环境的话，<code>root = global</code></li>\n<li>在其他的虚拟机的话，则指向<code>this</code>即<code>root = this</code></li>\n<li>其他环境就设置为空对象<code>&#123;&#125;</code></li>\n</ul>\n<h3 id=\"变量冲突\"><a href=\"#变量冲突\" class=\"headerlink\" title=\"变量冲突\"></a>变量冲突</h3><p>我们假设一个情况，如果<code>_</code>这个变量被别人使用了。如果我们直接给<code>_</code>赋值，不就丢失了前面的对于<code>_</code>的定义。</p>\n<p>因此<code>undersocre.js</code>就先保存起来了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> previousUnderscore = root._;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，就不会丢失了前面对<code>_</code>的定义，如果要使用的话，就可以使用<code>underscore.js</code>提供的<code>noConflict</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.noConflict = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  root._ = previousUnderscore;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存引用\"><a href=\"#缓存引用\" class=\"headerlink\" title=\"缓存引用\"></a>缓存引用</h3><p>这个就属于代码优化的做法了（缓存常用的native方法，以便后面快速访问和使用），比较常规：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Save bytes in the minified (but not gzipped) version:</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ArrayProto = <span class=\"built_in\">Array</span>.prototype, ObjProto = <span class=\"built_in\">Object</span>.prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> SymbolProto = <span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">&#x27;undefined&#x27;</span> ? <span class=\"built_in\">Symbol</span>.prototype : <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Create quick reference variables for speed access to core prototypes.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> push = ArrayProto.push,</span><br><span class=\"line\">      slice = ArrayProto.slice,</span><br><span class=\"line\">      toString = ObjProto.toString,</span><br><span class=\"line\">      hasOwnProperty = ObjProto.hasOwnProperty;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All **ECMAScript 5** native function implementations that we hope to use</span></span><br><span class=\"line\">  <span class=\"comment\">// are declared here.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> nativeIsArray = <span class=\"built_in\">Array</span>.isArray,</span><br><span class=\"line\">      nativeKeys = <span class=\"built_in\">Object</span>.keys,</span><br><span class=\"line\">      nativeCreate = <span class=\"built_in\">Object</span>.create;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h3><p>众所周知的是，js是使用原型链来实现继承的。</p>\n<p>其实这个实现方法就是ES5的<code>Object.create</code>的Polyfill，这么做是为了向后兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Ctor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An internal function for creating a new object that inherits from another.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> baseCreate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prototype</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_.isObject(prototype)) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nativeCreate) <span class=\"keyword\">return</span> nativeCreate(prototype);</span><br><span class=\"line\">  Ctor.prototype = prototype;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> Ctor;</span><br><span class=\"line\">  Ctor.prototype = <span class=\"literal\">null</span>; <span class=\"comment\">// 恢复CTor的原型，以备后续使用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a safe reference to the Underscore object for use below.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _ = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> _) <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> _)) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _(obj);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._wrapped = obj;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一开始我对这个部分有些困惑的，因为我简单地认为<code>_</code>就应该是一个空对象<code>&#123;&#125;</code>。</p>\n<p>其实，<code>underscore.js</code>是支持面向对象的方式使用的，也就是把<code>_</code>当作一个构造函数。即<code>new _(obj)</code>这样的用法。</p>\n<p>但是由于js没用真正的构造函数，因此还可以这样使用：<code>_(obj)</code>。为了避免这种情况，因此有了第二行代码：<code>if (!(this instanceof _)) return new _(obj);</code>。因为直接调用函数的话，<code>this</code>是指向全局的。</p>\n<h3 id=\"兼容Node-js环境\"><a href=\"#兼容Node-js环境\" class=\"headerlink\" title=\"兼容Node.js环境\"></a>兼容Node.js环境</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Export the Underscore object for **Node.js**, with</span></span><br><span class=\"line\"><span class=\"comment\">// backwards-compatibility for their old module API. If we&#x27;re in</span></span><br><span class=\"line\"><span class=\"comment\">// the browser, add `_` as a global object.</span></span><br><span class=\"line\"><span class=\"comment\">// (`nodeType` is checked to ensure that `module`</span></span><br><span class=\"line\"><span class=\"comment\">// and `exports` are not HTML elements.)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">exports</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">exports</span>.nodeType) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> != <span class=\"string\">&#x27;undefined&#x27;</span> &amp;&amp; !<span class=\"built_in\">module</span>.nodeType &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">exports</span> = <span class=\"built_in\">module</span>.exports = _;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>._ = _;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  root._ = _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>Node.js</code>的存在，因此在<code>Node.js</code>环境就将<code>_</code>赋值给<code>exports</code></p>\n<p>另外如注释所说，之所以要检测<code>nodeType</code>，是为了确保<code>exports</code>和<code>module</code>不是<code>HTML</code>元素</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这篇文章就是我阅读<code>udersocre.js</code>的第一篇源码分析文章，也是这个系列的第一篇。</p>\n<p>写这篇文章是为了提升自己的写作能力，同时也可以让其他读者可以有一个好的思路（我所认为的）去尝试读懂其他的源码。</p>"},{"title":"理解underscore.js系列——④精选函数","date":"2017-09-23T10:43:11.000Z","desc":"理解underscore.js v1.8.3 源码解析","toc":true,"_content":"\n这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过`underscore`的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。\n\n<!-- more -->\n\n\n### _.sample\n\n随意取出数组中的N个元素。\n\n按我的思路，就是使用`_.random`得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。\n\n`underscore`则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。\n\n```js\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n```\n\n### _.throttle\n\n节流函数，频繁触发的函数可用`throttle`来实现一段时间(周期取决于`wait`)内只执行一次。\n\n常见的场景是：页面滚动时`scroll`、页面大小改变时`resize`\n\n可以看到，这个`throttle`函数是比较健壮的。\n\n有`leading`、`trailing`可选，意思为开始和结束这个临界点是否触发。\n\n```js\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n```\n\n实现`options.leading`（即开始时是否执行）相关：\n - 设置`var previous = 0;`\n - 默认不设置`options.leading`即默认开始时执行，故此时`if (!previous && options.leading === false) previous = now;`不会执行。\n - 此时，`previous = 0`。因此，`remaining = wait - (now - previous);`肯定小于0，故开始时必会执行。\n \n\n实现`options.trailing`（即最后是否执行一次）相关：\n - 考虑一个情况，只触发一次时，那么最终要在`wait`时间之后是否执行呢？\n - 此时`underscore`就是使用一个定时器来实现。\n\n### _.debounce\n\n防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于`wait`)才执行一次。\n\n常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。\n\n```js\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArgs(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n```\n\n可以看到，该版本的`debounce`函数增加了`immediate`选项：就是刚开始的时候执行一次，n秒之后再执行一次。\n\n在看`underscore`官网上，介绍说这个在防止意外的双击`submit`按钮时很有用。\n\n这我有一点困惑，那不就提交了两次表单吗？\n\n后来我发现，`later`函数里，执行`func`有一个前置条件:`if (args)`，而在`immediate = true`的情况下，`later`是这么调用的：`setTimeout(later, wait)`，这时没有传入任何参数，故`args = undefind`即`func`不会执行。\n\n因此，`immediate = true`时，就只提交了一次表单，没任何问题。\n\n### _.compose\n\n组成函数，类似`jQuery`的链式调用：将前一个函数的执行结果传入后一个函数。\n\n```js\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n```\n\n这里我觉得`var i = start`似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。\n\n### _.after\n\n执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。\n\n```js\n// Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n```\n\n在`javaScript`开发中，经常遇到异步调用的问题。\n\n拿开发小程序为例，上传图片的功能官方只提供`单张上传API`，当我们要批量上次的时候，执行循环调用`单张上传API`。此时要全部上传完执行回调就可以使用这个方法了。\n\n现在想想，我之前的做法是`setTimeout(uploadSuccess, 100)`，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。\n\n","source":"_posts/underscore/underscore-featured-function.md","raw":"---\ntitle: 理解underscore.js系列——④精选函数\ndate: 2017-09-23 18:43:11\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\ntoc: true\ncategories:\n- 源码解析\n- underscore\n---\n\n这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过`underscore`的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。\n\n<!-- more -->\n\n\n### _.sample\n\n随意取出数组中的N个元素。\n\n按我的思路，就是使用`_.random`得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。\n\n`underscore`则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。\n\n```js\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n```\n\n### _.throttle\n\n节流函数，频繁触发的函数可用`throttle`来实现一段时间(周期取决于`wait`)内只执行一次。\n\n常见的场景是：页面滚动时`scroll`、页面大小改变时`resize`\n\n可以看到，这个`throttle`函数是比较健壮的。\n\n有`leading`、`trailing`可选，意思为开始和结束这个临界点是否触发。\n\n```js\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n```\n\n实现`options.leading`（即开始时是否执行）相关：\n - 设置`var previous = 0;`\n - 默认不设置`options.leading`即默认开始时执行，故此时`if (!previous && options.leading === false) previous = now;`不会执行。\n - 此时，`previous = 0`。因此，`remaining = wait - (now - previous);`肯定小于0，故开始时必会执行。\n \n\n实现`options.trailing`（即最后是否执行一次）相关：\n - 考虑一个情况，只触发一次时，那么最终要在`wait`时间之后是否执行呢？\n - 此时`underscore`就是使用一个定时器来实现。\n\n### _.debounce\n\n防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于`wait`)才执行一次。\n\n常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。\n\n```js\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArgs(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n```\n\n可以看到，该版本的`debounce`函数增加了`immediate`选项：就是刚开始的时候执行一次，n秒之后再执行一次。\n\n在看`underscore`官网上，介绍说这个在防止意外的双击`submit`按钮时很有用。\n\n这我有一点困惑，那不就提交了两次表单吗？\n\n后来我发现，`later`函数里，执行`func`有一个前置条件:`if (args)`，而在`immediate = true`的情况下，`later`是这么调用的：`setTimeout(later, wait)`，这时没有传入任何参数，故`args = undefind`即`func`不会执行。\n\n因此，`immediate = true`时，就只提交了一次表单，没任何问题。\n\n### _.compose\n\n组成函数，类似`jQuery`的链式调用：将前一个函数的执行结果传入后一个函数。\n\n```js\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n```\n\n这里我觉得`var i = start`似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。\n\n### _.after\n\n执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。\n\n```js\n// Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n```\n\n在`javaScript`开发中，经常遇到异步调用的问题。\n\n拿开发小程序为例，上传图片的功能官方只提供`单张上传API`，当我们要批量上次的时候，执行循环调用`单张上传API`。此时要全部上传完执行回调就可以使用这个方法了。\n\n现在想想，我之前的做法是`setTimeout(uploadSuccess, 100)`，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。\n\n","slug":"underscore/underscore-featured-function","published":1,"updated":"2022-01-08T08:34:36.407Z","_id":"cky5gyu8l0006n66981ypaxvq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过<code>underscore</code>的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。</p>\n<span id=\"more\"></span>\n\n\n<h3 id=\"sample\"><a href=\"#sample\" class=\"headerlink\" title=\"_.sample\"></a>_.sample</h3><p>随意取出数组中的N个元素。</p>\n<p>按我的思路，就是使用<code>_.random</code>得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。</p>\n<p><code>underscore</code>则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sample **n** random values from a collection using the modern version of the</span></span><br><span class=\"line\"><span class=\"comment\">// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).</span></span><br><span class=\"line\"><span class=\"comment\">// If **n** is not specified, returns a single random element.</span></span><br><span class=\"line\"><span class=\"comment\">// The internal `guard` argument allows it to work with `map`.</span></span><br><span class=\"line\">_.sample = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, n, guard</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"literal\">null</span> || guard) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isArrayLike(obj)) obj = _.values(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[_.random(obj.length - <span class=\"number\">1</span>)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = getLength(sample);</span><br><span class=\"line\">  n = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">Math</span>.min(n, length), <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; n; index++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rand = _.random(index, last);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = sample[index];</span><br><span class=\"line\">    sample[index] = sample[rand];</span><br><span class=\"line\">    sample[rand] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sample.slice(<span class=\"number\">0</span>, n);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"_.throttle\"></a>_.throttle</h3><p>节流函数，频繁触发的函数可用<code>throttle</code>来实现一段时间(周期取决于<code>wait</code>)内只执行一次。</p>\n<p>常见的场景是：页面滚动时<code>scroll</code>、页面大小改变时<code>resize</code></p>\n<p>可以看到，这个<code>throttle</code>函数是比较健壮的。</p>\n<p>有<code>leading</code>、<code>trailing</code>可选，意思为开始和结束这个临界点是否触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class=\"line\"><span class=\"comment\">// during a given window of time. Normally, the throttled function will run</span></span><br><span class=\"line\"><span class=\"comment\">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class=\"line\"><span class=\"comment\">// but if you&#x27;d like to disable the execution on the leading edge, pass</span></span><br><span class=\"line\"><span class=\"comment\">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class=\"line\">_.throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, context, args, result;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.now();</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = _.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  throttled.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout = context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现<code>options.leading</code>（即开始时是否执行）相关：</p>\n<ul>\n<li>设置<code>var previous = 0;</code></li>\n<li>默认不设置<code>options.leading</code>即默认开始时执行，故此时<code>if (!previous &amp;&amp; options.leading === false) previous = now;</code>不会执行。</li>\n<li>此时，<code>previous = 0</code>。因此，<code>remaining = wait - (now - previous);</code>肯定小于0，故开始时必会执行。</li>\n</ul>\n<p>实现<code>options.trailing</code>（即最后是否执行一次）相关：</p>\n<ul>\n<li>考虑一个情况，只触发一次时，那么最终要在<code>wait</code>时间之后是否执行呢？</li>\n<li>此时<code>underscore</code>就是使用一个定时器来实现。</li>\n</ul>\n<h3 id=\"debounce\"><a href=\"#debounce\" class=\"headerlink\" title=\"_.debounce\"></a>_.debounce</h3><p>防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于<code>wait</code>)才执行一次。</p>\n<p>常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class=\"line\"><span class=\"comment\">// be triggered. The function will be called after it stops being called for</span></span><br><span class=\"line\"><span class=\"comment\">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class=\"line\"><span class=\"comment\">// leading edge, instead of the trailing.</span></span><br><span class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, args</span>) </span>&#123;</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args) result = func.apply(context, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounced = restArgs(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout) <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = !timeout;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) result = func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timeout = _.delay(later, wait, <span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  debounced.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounced;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，该版本的<code>debounce</code>函数增加了<code>immediate</code>选项：就是刚开始的时候执行一次，n秒之后再执行一次。</p>\n<p>在看<code>underscore</code>官网上，介绍说这个在防止意外的双击<code>submit</code>按钮时很有用。</p>\n<p>这我有一点困惑，那不就提交了两次表单吗？</p>\n<p>后来我发现，<code>later</code>函数里，执行<code>func</code>有一个前置条件:<code>if (args)</code>，而在<code>immediate = true</code>的情况下，<code>later</code>是这么调用的：<code>setTimeout(later, wait)</code>，这时没有传入任何参数，故<code>args = undefind</code>即<code>func</code>不会执行。</p>\n<p>因此，<code>immediate = true</code>时，就只提交了一次表单，没任何问题。</p>\n<h3 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"_.compose\"></a>_.compose</h3><p>组成函数，类似<code>jQuery</code>的链式调用：将前一个函数的执行结果传入后一个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that is the composition of a list of functions, each</span></span><br><span class=\"line\"><span class=\"comment\">// consuming the return value of the function that follows.</span></span><br><span class=\"line\">_.compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> start = args.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = start;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = args[start].apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) result = args[i].call(<span class=\"built_in\">this</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里我觉得<code>var i = start</code>似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。</p>\n<h3 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"_.after\"></a>_.after</h3><p>执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that will only be executed on and after the Nth call.</span></span><br><span class=\"line\">  _.after = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">times, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (--times &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>javaScript</code>开发中，经常遇到异步调用的问题。</p>\n<p>拿开发小程序为例，上传图片的功能官方只提供<code>单张上传API</code>，当我们要批量上次的时候，执行循环调用<code>单张上传API</code>。此时要全部上传完执行回调就可以使用这个方法了。</p>\n<p>现在想想，我之前的做法是<code>setTimeout(uploadSuccess, 100)</code>，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>这篇文章就分析一些我觉得很常用，也很有趣的一些函数。很早以前就听过<code>underscore</code>的大名，但是很少去用到。通过这次阅读源码，发来了不少有趣的函数，也学习到了许多技巧，真实收益匪浅。</p>","more":"<h3 id=\"sample\"><a href=\"#sample\" class=\"headerlink\" title=\"_.sample\"></a>_.sample</h3><p>随意取出数组中的N个元素。</p>\n<p>按我的思路，就是使用<code>_.random</code>得到索引然后取N个元素，但是这个方法有一个问题，就是有可能取到同个元素。</p>\n<p><code>underscore</code>则另辟蹊径，其算法是遍历前N个元素，每个元素和任意位置的元素替换，最后返回前N个元素即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sample **n** random values from a collection using the modern version of the</span></span><br><span class=\"line\"><span class=\"comment\">// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).</span></span><br><span class=\"line\"><span class=\"comment\">// If **n** is not specified, returns a single random element.</span></span><br><span class=\"line\"><span class=\"comment\">// The internal `guard` argument allows it to work with `map`.</span></span><br><span class=\"line\">_.sample = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, n, guard</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n == <span class=\"literal\">null</span> || guard) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isArrayLike(obj)) obj = _.values(obj);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[_.random(obj.length - <span class=\"number\">1</span>)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = getLength(sample);</span><br><span class=\"line\">  n = <span class=\"built_in\">Math</span>.max(<span class=\"built_in\">Math</span>.min(n, length), <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; n; index++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rand = _.random(index, last);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = sample[index];</span><br><span class=\"line\">    sample[index] = sample[rand];</span><br><span class=\"line\">    sample[rand] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sample.slice(<span class=\"number\">0</span>, n);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"_.throttle\"></a>_.throttle</h3><p>节流函数，频繁触发的函数可用<code>throttle</code>来实现一段时间(周期取决于<code>wait</code>)内只执行一次。</p>\n<p>常见的场景是：页面滚动时<code>scroll</code>、页面大小改变时<code>resize</code></p>\n<p>可以看到，这个<code>throttle</code>函数是比较健壮的。</p>\n<p>有<code>leading</code>、<code>trailing</code>可选，意思为开始和结束这个临界点是否触发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, when invoked, will only be triggered at most once</span></span><br><span class=\"line\"><span class=\"comment\">// during a given window of time. Normally, the throttled function will run</span></span><br><span class=\"line\"><span class=\"comment\">// as much as it can, without ever going more than once per `wait` duration;</span></span><br><span class=\"line\"><span class=\"comment\">// but if you&#x27;d like to disable the execution on the leading edge, pass</span></span><br><span class=\"line\"><span class=\"comment\">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span></span><br><span class=\"line\">_.throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, context, args, result;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    previous = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.now();</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    result = func.apply(context, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = _.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      previous = now;</span><br><span class=\"line\">      result = func.apply(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  throttled.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout = context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现<code>options.leading</code>（即开始时是否执行）相关：</p>\n<ul>\n<li>设置<code>var previous = 0;</code></li>\n<li>默认不设置<code>options.leading</code>即默认开始时执行，故此时<code>if (!previous &amp;&amp; options.leading === false) previous = now;</code>不会执行。</li>\n<li>此时，<code>previous = 0</code>。因此，<code>remaining = wait - (now - previous);</code>肯定小于0，故开始时必会执行。</li>\n</ul>\n<p>实现<code>options.trailing</code>（即最后是否执行一次）相关：</p>\n<ul>\n<li>考虑一个情况，只触发一次时，那么最终要在<code>wait</code>时间之后是否执行呢？</li>\n<li>此时<code>underscore</code>就是使用一个定时器来实现。</li>\n</ul>\n<h3 id=\"debounce\"><a href=\"#debounce\" class=\"headerlink\" title=\"_.debounce\"></a>_.debounce</h3><p>防抖动函数。频繁执行一个函数时，只有停止执行之后的若干时间(取决于<code>wait</code>)才执行一次。</p>\n<p>常见场景：输入框搜索的时候，停止输入n秒才发起搜索请求。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function, that, as long as it continues to be invoked, will not</span></span><br><span class=\"line\"><span class=\"comment\">// be triggered. The function will be called after it stops being called for</span></span><br><span class=\"line\"><span class=\"comment\">// N milliseconds. If `immediate` is passed, trigger the function on the</span></span><br><span class=\"line\"><span class=\"comment\">// leading edge, instead of the trailing.</span></span><br><span class=\"line\">_.debounce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timeout, result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">context, args</span>) </span>&#123;</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args) result = func.apply(context, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounced = restArgs(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout) <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = !timeout;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) result = func.apply(<span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timeout = _.delay(later, wait, <span class=\"built_in\">this</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  debounced.cancel = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounced;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，该版本的<code>debounce</code>函数增加了<code>immediate</code>选项：就是刚开始的时候执行一次，n秒之后再执行一次。</p>\n<p>在看<code>underscore</code>官网上，介绍说这个在防止意外的双击<code>submit</code>按钮时很有用。</p>\n<p>这我有一点困惑，那不就提交了两次表单吗？</p>\n<p>后来我发现，<code>later</code>函数里，执行<code>func</code>有一个前置条件:<code>if (args)</code>，而在<code>immediate = true</code>的情况下，<code>later</code>是这么调用的：<code>setTimeout(later, wait)</code>，这时没有传入任何参数，故<code>args = undefind</code>即<code>func</code>不会执行。</p>\n<p>因此，<code>immediate = true</code>时，就只提交了一次表单，没任何问题。</p>\n<h3 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"_.compose\"></a>_.compose</h3><p>组成函数，类似<code>jQuery</code>的链式调用：将前一个函数的执行结果传入后一个函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that is the composition of a list of functions, each</span></span><br><span class=\"line\"><span class=\"comment\">// consuming the return value of the function that follows.</span></span><br><span class=\"line\">_.compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> start = args.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = start;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = args[start].apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--) result = args[i].call(<span class=\"built_in\">this</span>, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里我觉得<code>var i = start</code>似乎有些多余，但是如果站在代码语义(可读性的考虑)的角度的话，好像又不应该删除。</p>\n<h3 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"_.after\"></a>_.after</h3><p>执行N次之后才执行一次。这个方法的实现很简单，但是给我展示了一种新的开发模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Returns a function that will only be executed on and after the Nth call.</span></span><br><span class=\"line\">  _.after = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">times, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (--times &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>javaScript</code>开发中，经常遇到异步调用的问题。</p>\n<p>拿开发小程序为例，上传图片的功能官方只提供<code>单张上传API</code>，当我们要批量上次的时候，执行循环调用<code>单张上传API</code>。此时要全部上传完执行回调就可以使用这个方法了。</p>\n<p>现在想想，我之前的做法是<code>setTimeout(uploadSuccess, 100)</code>，每隔0.1s去判断一下是否全部上传完毕，真是惭愧不如啊。</p>"},{"title":"理解underscore.js系列——②杂项","date":"2017-09-11T14:21:25.000Z","desc":"理解underscore.js v1.8.3 源码解析","toc":true,"_content":"\n这一篇文章，就写一些零散的（我所理解的）知识点，感觉`underscore.js`许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。\n\n<!-- more -->\n\n## typeof \n\n在`underscore.js`里，`typeof`后面都是跟着`==`而不是我们常用的`===`\n\n看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：\n\n> typeof typeof x，不管x是什么都是返回string的话，那么`==`就已经足够，并且与`===`相比还节省了一个字节。\n\n## void 0与undefined\n\n首先，`void`在C里是和常见的，但在js里就很少看到了。`void`在js里是一个操作符，它的作用在MDN里是这样描述的：\n\n> The `void` operator evaluates the given expression and then returns `undefined`.\n\n简而言之，`void`后面无论跟着什么表达式，都返回`undefined`。那使用`void 0`就是因为这样比较简洁。即\n\n```js\nvoid 0 === undefined\n```\n\n那么，为什么不直接用`undefined`而多此一举呢。\n\n那是因为\n\n- `undefined`有可能被重写(`undefined`不是保留字)\n\n```js\n// 在IE8及以下\nvar undefined = 10\nconsole.log(undefined) // 10\n\n// 主流浏览器\nfunction() {\n    var undefined = 10\n    console.log(undefined) // 10\n}\n```\n- `void 0`的长度为6个字符，而`undefined`则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。\n- 在iOS某版本下，`void 0`的速度比`undefind`快（这个是网上看到的，未验证）\n\n## val == null\n\n在`underscore.js`里，经常会看到`val == null`这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。\n\n在开发时，我要判断一个变量是否有传入，是这么做的：\n\n```js\nif (typeof val === 'undefined') {\n    // others\n}\n```\n\n这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：\n\n```js\nfunction someTest(val, otherVal) {\n    \n}\n\nsomeTest(null, 1)\n```\n\n此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：\n\n```js\nif (typeof val === 'undefined' || val === null) {\n    // others\n}\n```\n\n其实，此时完全可以用：`val == null`代替（**此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句**）。\n\n其中涉及的`==`（半等）知识，可以参考[Standard ECMA-262](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)","source":"_posts/underscore/underscore-mix.md","raw":"---\ntitle: 理解underscore.js系列——②杂项\ndate: 2017-09-11 22:21:25\ntags:\n- JavaScript\n- underscore.js\ndesc: 理解underscore.js v1.8.3 源码解析\ntoc: true\ncategories:\n- 源码解析\n- underscore\n---\n\n这一篇文章，就写一些零散的（我所理解的）知识点，感觉`underscore.js`许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。\n\n<!-- more -->\n\n## typeof \n\n在`underscore.js`里，`typeof`后面都是跟着`==`而不是我们常用的`===`\n\n看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：\n\n> typeof typeof x，不管x是什么都是返回string的话，那么`==`就已经足够，并且与`===`相比还节省了一个字节。\n\n## void 0与undefined\n\n首先，`void`在C里是和常见的，但在js里就很少看到了。`void`在js里是一个操作符，它的作用在MDN里是这样描述的：\n\n> The `void` operator evaluates the given expression and then returns `undefined`.\n\n简而言之，`void`后面无论跟着什么表达式，都返回`undefined`。那使用`void 0`就是因为这样比较简洁。即\n\n```js\nvoid 0 === undefined\n```\n\n那么，为什么不直接用`undefined`而多此一举呢。\n\n那是因为\n\n- `undefined`有可能被重写(`undefined`不是保留字)\n\n```js\n// 在IE8及以下\nvar undefined = 10\nconsole.log(undefined) // 10\n\n// 主流浏览器\nfunction() {\n    var undefined = 10\n    console.log(undefined) // 10\n}\n```\n- `void 0`的长度为6个字符，而`undefined`则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。\n- 在iOS某版本下，`void 0`的速度比`undefind`快（这个是网上看到的，未验证）\n\n## val == null\n\n在`underscore.js`里，经常会看到`val == null`这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。\n\n在开发时，我要判断一个变量是否有传入，是这么做的：\n\n```js\nif (typeof val === 'undefined') {\n    // others\n}\n```\n\n这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：\n\n```js\nfunction someTest(val, otherVal) {\n    \n}\n\nsomeTest(null, 1)\n```\n\n此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：\n\n```js\nif (typeof val === 'undefined' || val === null) {\n    // others\n}\n```\n\n其实，此时完全可以用：`val == null`代替（**此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句**）。\n\n其中涉及的`==`（半等）知识，可以参考[Standard ECMA-262](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3)","slug":"underscore/underscore-mix","published":1,"updated":"2022-01-08T08:34:38.927Z","_id":"cky5gz03r0009n669g47k01vi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这一篇文章，就写一些零散的（我所理解的）知识点，感觉<code>underscore.js</code>许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><p>在<code>underscore.js</code>里，<code>typeof</code>后面都是跟着<code>==</code>而不是我们常用的<code>===</code></p>\n<p>看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：</p>\n<blockquote>\n<p>typeof typeof x，不管x是什么都是返回string的话，那么<code>==</code>就已经足够，并且与<code>===</code>相比还节省了一个字节。</p>\n</blockquote>\n<h2 id=\"void-0与undefined\"><a href=\"#void-0与undefined\" class=\"headerlink\" title=\"void 0与undefined\"></a>void 0与undefined</h2><p>首先，<code>void</code>在C里是和常见的，但在js里就很少看到了。<code>void</code>在js里是一个操作符，它的作用在MDN里是这样描述的：</p>\n<blockquote>\n<p>The <code>void</code> operator evaluates the given expression and then returns <code>undefined</code>.</p>\n</blockquote>\n<p>简而言之，<code>void</code>后面无论跟着什么表达式，都返回<code>undefined</code>。那使用<code>void 0</code>就是因为这样比较简洁。即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"number\">0</span> === <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，为什么不直接用<code>undefined</code>而多此一举呢。</p>\n<p>那是因为</p>\n<ul>\n<li><code>undefined</code>有可能被重写(<code>undefined</code>不是保留字)</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在IE8及以下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主流浏览器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>void 0</code>的长度为6个字符，而<code>undefined</code>则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。</li>\n<li>在iOS某版本下，<code>void 0</code>的速度比<code>undefind</code>快（这个是网上看到的，未验证）</li>\n</ul>\n<h2 id=\"val-null\"><a href=\"#val-null\" class=\"headerlink\" title=\"val == null\"></a>val == null</h2><p>在<code>underscore.js</code>里，经常会看到<code>val == null</code>这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。</p>\n<p>在开发时，我要判断一个变量是否有传入，是这么做的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someTest</span>(<span class=\"params\">val, otherVal</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">someTest(<span class=\"literal\">null</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span> || val === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，此时完全可以用：<code>val == null</code>代替（<strong>此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句</strong>）。</p>\n<p>其中涉及的<code>==</code>（半等）知识，可以参考<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\">Standard ECMA-262</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>这一篇文章，就写一些零散的（我所理解的）知识点，感觉<code>underscore.js</code>许多细节值得好好深究一下。就像一篇好文章一样，经典的书籍值得重复地去品味，所谓书读百遍其义自现。</p>","more":"<h2 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h2><p>在<code>underscore.js</code>里，<code>typeof</code>后面都是跟着<code>==</code>而不是我们常用的<code>===</code></p>\n<p>看了一些其他人的解释都是笼统地归因于要隐式转换，却不给出任何例子。所以我不是很能理解。有一个理由我觉得是比较合理的：</p>\n<blockquote>\n<p>typeof typeof x，不管x是什么都是返回string的话，那么<code>==</code>就已经足够，并且与<code>===</code>相比还节省了一个字节。</p>\n</blockquote>\n<h2 id=\"void-0与undefined\"><a href=\"#void-0与undefined\" class=\"headerlink\" title=\"void 0与undefined\"></a>void 0与undefined</h2><p>首先，<code>void</code>在C里是和常见的，但在js里就很少看到了。<code>void</code>在js里是一个操作符，它的作用在MDN里是这样描述的：</p>\n<blockquote>\n<p>The <code>void</code> operator evaluates the given expression and then returns <code>undefined</code>.</p>\n</blockquote>\n<p>简而言之，<code>void</code>后面无论跟着什么表达式，都返回<code>undefined</code>。那使用<code>void 0</code>就是因为这样比较简洁。即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"number\">0</span> === <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，为什么不直接用<code>undefined</code>而多此一举呢。</p>\n<p>那是因为</p>\n<ul>\n<li><code>undefined</code>有可能被重写(<code>undefined</code>不是保留字)</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在IE8及以下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主流浏览器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>) <span class=\"comment\">// 10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>void 0</code>的长度为6个字符，而<code>undefined</code>则长达9个字符。减少3个字符传输，也减少了敲击键盘的次数，这个替换还是有必要的。</li>\n<li>在iOS某版本下，<code>void 0</code>的速度比<code>undefind</code>快（这个是网上看到的，未验证）</li>\n</ul>\n<h2 id=\"val-null\"><a href=\"#val-null\" class=\"headerlink\" title=\"val == null\"></a>val == null</h2><p>在<code>underscore.js</code>里，经常会看到<code>val == null</code>这样的做法。起初，不以为然，后来仔细琢磨一番。发现，这是一个很好的实践啊。</p>\n<p>在开发时，我要判断一个变量是否有传入，是这么做的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样做没什么问题，但是当有多个参数，而val又不需要传入的时候呢：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someTest</span>(<span class=\"params\">val, otherVal</span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">someTest(<span class=\"literal\">null</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>此时就要传入null了，而此时很容易补丁式将上面的判断改成如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val === <span class=\"string\">&#x27;undefined&#x27;</span> || val === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// others</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，此时完全可以用：<code>val == null</code>代替（<strong>此时val要么是undefined要么是null才会等于true，所以此语句完全等于上面那个语句</strong>）。</p>\n<p>其中涉及的<code>==</code>（半等）知识，可以参考<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3\">Standard ECMA-262</a></p>"},{"title":"Promise 原理 & 宏微任务","date":"2021-01-17T06:59:13.000Z","toc":true,"_content":"\n读完这篇文章，你的收获有：\n1. Promise简史\n2. Promise的关键概念\n3. 可以手写符合标准的Promise\n4. 可以解答任意宏任务/微任务的题目\n\n<!-- more -->\n\n# 前言\n\n为什么写这篇文章？\n\nJavaScript是异步语言，因此Promise的重要性不言而喻。\n\n而我看了一些文章，觉得质量参差不齐。\n\n于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。\n\n由于能力有限，文中可能存在错误，望广大网友指正。\n\n# Promise 简史\n\nPromise 并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。\n\n这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：[Promise/A+](https://promisesaplus.com)。\n\n在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。\n\n# Promise 的关键概念\n\n> “The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference\n\nPromise的基础认知，推荐看阮一峰的[《ES6 入门教程》](https://es6.ruanyifeng.com/#docs/promise)。\n\n本文的重点是讲解一些手写Promise需要关注的关键概念。\n\n## Promise 有三个状态：\n\n- pending\n- resolved\n- rejected\n\n只能从pending到resolved或rejected，之后状态就凝固了。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image)\n\n当状态流转成resolved时，需要选择一个值作为当前Promise的value：\n- `new Promise`时，则是通过`resolve(val)`\n- `promise.then`时，则是通过`return`（需要注意的是，没有显式`return`时是默认`return undefined`）\n\n这个值可以是任意的合法JavaScript值（包括`undefined`、`thenable对象`或者`promise`）\n\n> thenable对象是一个定义了then方法的对象或者函数\n\n状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。\n\n## Promise.prototype.then\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n- [Promise/A+](https://promisesaplus.com/) 是Promise的标准规范，**其中指出Promise实例只需要实现then一个方法**\n- then接收两个参数，而两个参数都是可选的，意味着可以什么都不传\n- then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的\n- 每次调用then均返回一个全新的Promise实例，这样就可以链式调用\n- then会在当前宏任务下形成一个微任务（具体介绍看下面）\n\n### Promise 的状态\n\nthen其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。\n\n它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：\n\n```js\nnew Promise((resolve, reject) => {\n\tresolve(1) // 将当前的状态流转成resolved\n})\n```\n\n而then返回的promise的状态判断需要分两步走：\n1. then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态\n2. 若满足条件1，则看当前回调函数能否正常处理\n\n说得有点绕口，看下面的实例代码即可理解：\n\n**理解条件1：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<rejected>: \"error1\"}\n\treject('error1')\n})\n\nlet p2 = p1.then(console.log) // Promise {<rejected>: \"error1\"}\n```\n\n由于`p1`的状态是`Rejected`的，而`p2`没有传入`onRejected`的回调函数，因此`p2`的状态完全复用`p1`的状态。\n\n**理解条件2：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<fulfilled>: 1}\n\tresolve(1)\n})\n\nlet p2 = p1.then(val => { // Promise {<rejected>: ReferenceError: x is not defined}\n\tconsole.log('p1 was resolved:', val)\n\treturn x; // Uncaught referenceError\n})\n\nlet p3 = p2.then(undefined, reason => 1) // Promise {<fulfilled>: 1}\n```\n\n`p1`的状态是`fulfilled`的，而`p2`有`onFulfilled`的回调函数，但是没有正确处理，抛异常了。因此`p2`的状态变成了`rejected`，其中的reason为则报错的原因。\n\n而此时`p3`刚好有`onRejected`的函数，也能正确处理，最后的返回值则是自己的value，因此`p3`的状态是`fulfilled`的。\n\n### Promise 的返回值\n\n前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了`promise`，这里重点讲下。\n\n由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。\n\n同样看看例子：\n\n```js\nlet p1 = new Promise(resolve => {\n\tsetTimeout(resolve, 1000, 1)\n}) \n\nlet p2 = new Promise(() => p1)\n```\n\n`p1`是一个简单的定时器promise，在1000ms之后，状态会变成`<fulfilled: 1>`。\n\n而`p2`的返回值是`p1`，因此`p2`在1000ms之内也是`<pending>`，同样会在1000ms之后，变成`<fulfilled: 1>`\n\n## Promise.prototype.catch\n\n虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。\n\n其实，catch可以理解成then的一种封装：\n\n```js\npromise.catch(function onRejected() {}) == promise.then(undefined, function onRejected() {})\n```\n\n## 微任务 microtask\n\n当前promise的状态变更之后，不是立即执行then方法的。此时引入了 **微任务(microtask)** 的概念。\n\n与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。\n\n也可以通过其他的方式生成宏任务：`setTimeout`、`setInterval`；而微任务则可以通过`promise.then`、`Object.observe(已废弃)`、`MutationObserver`生成。\n\n宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image)\n\n即一个宏任务下，是可以有多个微任务的。\n\n> 由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。\n\n### 解析任务\n\n分析代码的时候，可以这样分几步走：\n\n1. 理想情况下，如果没有任何`setTimeout`和`promise.then`的话，则全部在一个宏任务里执行\n2. 若出现`promise.then`，则在当前宏任务生成一个微任务，用于执行`promise.then`\n3. 若出现了`setTimeout`，则添加一个宏任务，重复条件1\n\n分析几个例子考验一下：\n\n**例子1：**\n```js\nsetTimeout(console.log, 0, 0)\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n**例子2：**\n```js\nconsole.log(8)\n\nsetTimeout(function() {\n    console.log(0)\n    Promise.resolve(4).then(console.log)\n}) // 省略参数，delay默认为0\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n\nsetTimeout(console.log, 0, 5)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n其实，还有`async/await`相关的题目，如果阅读足够多的话，我再完善吧。\n\n# 手写 Promise\n\n其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。\n\n我在[github](https://github.com/LeeJim/word)写了一份，代码逻辑都算挺清晰的，大家可以去看看。\n\n我建议大家在写之前，再仔细看一下`Promise/A+`的标准规范，可以结合我的代码一起看。\n\n清晰理解细节之后，再动手写一遍。\n\n如果觉得不错的话，记得给我点赞 + [star](https://github.com/LeeJim/word)。\n\n撒花，感谢阅读！","source":"_posts/ advance/promise.md","raw":"---\ntitle: Promise 原理 & 宏微任务\ndate: 2021-01-17 14:59:13\ntags: \n- promise\ntoc: true\ncategories:\n- [前端, 进阶]\n---\n\n读完这篇文章，你的收获有：\n1. Promise简史\n2. Promise的关键概念\n3. 可以手写符合标准的Promise\n4. 可以解答任意宏任务/微任务的题目\n\n<!-- more -->\n\n# 前言\n\n为什么写这篇文章？\n\nJavaScript是异步语言，因此Promise的重要性不言而喻。\n\n而我看了一些文章，觉得质量参差不齐。\n\n于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。\n\n由于能力有限，文中可能存在错误，望广大网友指正。\n\n# Promise 简史\n\nPromise 并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。\n\n这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：[Promise/A+](https://promisesaplus.com)。\n\n在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。\n\n# Promise 的关键概念\n\n> “The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference\n\nPromise的基础认知，推荐看阮一峰的[《ES6 入门教程》](https://es6.ruanyifeng.com/#docs/promise)。\n\n本文的重点是讲解一些手写Promise需要关注的关键概念。\n\n## Promise 有三个状态：\n\n- pending\n- resolved\n- rejected\n\n只能从pending到resolved或rejected，之后状态就凝固了。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image)\n\n当状态流转成resolved时，需要选择一个值作为当前Promise的value：\n- `new Promise`时，则是通过`resolve(val)`\n- `promise.then`时，则是通过`return`（需要注意的是，没有显式`return`时是默认`return undefined`）\n\n这个值可以是任意的合法JavaScript值（包括`undefined`、`thenable对象`或者`promise`）\n\n> thenable对象是一个定义了then方法的对象或者函数\n\n状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。\n\n## Promise.prototype.then\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n- [Promise/A+](https://promisesaplus.com/) 是Promise的标准规范，**其中指出Promise实例只需要实现then一个方法**\n- then接收两个参数，而两个参数都是可选的，意味着可以什么都不传\n- then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的\n- 每次调用then均返回一个全新的Promise实例，这样就可以链式调用\n- then会在当前宏任务下形成一个微任务（具体介绍看下面）\n\n### Promise 的状态\n\nthen其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。\n\n它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：\n\n```js\nnew Promise((resolve, reject) => {\n\tresolve(1) // 将当前的状态流转成resolved\n})\n```\n\n而then返回的promise的状态判断需要分两步走：\n1. then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态\n2. 若满足条件1，则看当前回调函数能否正常处理\n\n说得有点绕口，看下面的实例代码即可理解：\n\n**理解条件1：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<rejected>: \"error1\"}\n\treject('error1')\n})\n\nlet p2 = p1.then(console.log) // Promise {<rejected>: \"error1\"}\n```\n\n由于`p1`的状态是`Rejected`的，而`p2`没有传入`onRejected`的回调函数，因此`p2`的状态完全复用`p1`的状态。\n\n**理解条件2：**\n\n```js\nlet p1 = new Promise((resolve, reject) => { // Promise {<fulfilled>: 1}\n\tresolve(1)\n})\n\nlet p2 = p1.then(val => { // Promise {<rejected>: ReferenceError: x is not defined}\n\tconsole.log('p1 was resolved:', val)\n\treturn x; // Uncaught referenceError\n})\n\nlet p3 = p2.then(undefined, reason => 1) // Promise {<fulfilled>: 1}\n```\n\n`p1`的状态是`fulfilled`的，而`p2`有`onFulfilled`的回调函数，但是没有正确处理，抛异常了。因此`p2`的状态变成了`rejected`，其中的reason为则报错的原因。\n\n而此时`p3`刚好有`onRejected`的函数，也能正确处理，最后的返回值则是自己的value，因此`p3`的状态是`fulfilled`的。\n\n### Promise 的返回值\n\n前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了`promise`，这里重点讲下。\n\n由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。\n\n同样看看例子：\n\n```js\nlet p1 = new Promise(resolve => {\n\tsetTimeout(resolve, 1000, 1)\n}) \n\nlet p2 = new Promise(() => p1)\n```\n\n`p1`是一个简单的定时器promise，在1000ms之后，状态会变成`<fulfilled: 1>`。\n\n而`p2`的返回值是`p1`，因此`p2`在1000ms之内也是`<pending>`，同样会在1000ms之后，变成`<fulfilled: 1>`\n\n## Promise.prototype.catch\n\n虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。\n\n其实，catch可以理解成then的一种封装：\n\n```js\npromise.catch(function onRejected() {}) == promise.then(undefined, function onRejected() {})\n```\n\n## 微任务 microtask\n\n当前promise的状态变更之后，不是立即执行then方法的。此时引入了 **微任务(microtask)** 的概念。\n\n与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。\n\n也可以通过其他的方式生成宏任务：`setTimeout`、`setInterval`；而微任务则可以通过`promise.then`、`Object.observe(已废弃)`、`MutationObserver`生成。\n\n宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image)\n\n即一个宏任务下，是可以有多个微任务的。\n\n> 由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。\n\n### 解析任务\n\n分析代码的时候，可以这样分几步走：\n\n1. 理想情况下，如果没有任何`setTimeout`和`promise.then`的话，则全部在一个宏任务里执行\n2. 若出现`promise.then`，则在当前宏任务生成一个微任务，用于执行`promise.then`\n3. 若出现了`setTimeout`，则添加一个宏任务，重复条件1\n\n分析几个例子考验一下：\n\n**例子1：**\n```js\nsetTimeout(console.log, 0, 0)\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n**例子2：**\n```js\nconsole.log(8)\n\nsetTimeout(function() {\n    console.log(0)\n    Promise.resolve(4).then(console.log)\n}) // 省略参数，delay默认为0\n\nnew Promise((resolve) => {\n    console.log(1)\n    resolve(2)\n}).then(console.log)\n\nconsole.log(3)\n\nsetTimeout(console.log, 0, 5)\n```\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n其实，还有`async/await`相关的题目，如果阅读足够多的话，我再完善吧。\n\n# 手写 Promise\n\n其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。\n\n我在[github](https://github.com/LeeJim/word)写了一份，代码逻辑都算挺清晰的，大家可以去看看。\n\n我建议大家在写之前，再仔细看一下`Promise/A+`的标准规范，可以结合我的代码一起看。\n\n清晰理解细节之后，再动手写一遍。\n\n如果觉得不错的话，记得给我点赞 + [star](https://github.com/LeeJim/word)。\n\n撒花，感谢阅读！","slug":" advance/promise","published":1,"updated":"2022-01-08T09:20:26.247Z","_id":"cky5ieoi7000mn6694dbta4cd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>读完这篇文章，你的收获有：</p>\n<ol>\n<li>Promise简史</li>\n<li>Promise的关键概念</li>\n<li>可以手写符合标准的Promise</li>\n<li>可以解答任意宏任务/微任务的题目</li>\n</ol>\n<span id=\"more\"></span>\n\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>为什么写这篇文章？</p>\n<p>JavaScript是异步语言，因此Promise的重要性不言而喻。</p>\n<p>而我看了一些文章，觉得质量参差不齐。</p>\n<p>于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。</p>\n<p>由于能力有限，文中可能存在错误，望广大网友指正。</p>\n<h1 id=\"Promise-简史\"><a href=\"#Promise-简史\" class=\"headerlink\" title=\"Promise 简史\"></a>Promise 简史</h1><p>Promise 并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。</p>\n<p>这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：<a href=\"https://promisesaplus.com/\">Promise/A+</a>。</p>\n<p>在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。</p>\n<h1 id=\"Promise-的关键概念\"><a href=\"#Promise-的关键概念\" class=\"headerlink\" title=\"Promise 的关键概念\"></a>Promise 的关键概念</h1><blockquote>\n<p>“The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference</p>\n</blockquote>\n<p>Promise的基础认知，推荐看阮一峰的<a href=\"https://es6.ruanyifeng.com/#docs/promise\">《ES6 入门教程》</a>。</p>\n<p>本文的重点是讲解一些手写Promise需要关注的关键概念。</p>\n<h2 id=\"Promise-有三个状态：\"><a href=\"#Promise-有三个状态：\" class=\"headerlink\" title=\"Promise 有三个状态：\"></a>Promise 有三个状态：</h2><ul>\n<li>pending</li>\n<li>resolved</li>\n<li>rejected</li>\n</ul>\n<p>只能从pending到resolved或rejected，之后状态就凝固了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>当状态流转成resolved时，需要选择一个值作为当前Promise的value：</p>\n<ul>\n<li><code>new Promise</code>时，则是通过<code>resolve(val)</code></li>\n<li><code>promise.then</code>时，则是通过<code>return</code>（需要注意的是，没有显式<code>return</code>时是默认<code>return undefined</code>）</li>\n</ul>\n<p>这个值可以是任意的合法JavaScript值（包括<code>undefined</code>、<code>thenable对象</code>或者<code>promise</code>）</p>\n<blockquote>\n<p>thenable对象是一个定义了then方法的对象或者函数</p>\n</blockquote>\n<p>状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。</p>\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then\"></a>Promise.prototype.then</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://promisesaplus.com/\">Promise/A+</a> 是Promise的标准规范，<strong>其中指出Promise实例只需要实现then一个方法</strong></li>\n<li>then接收两个参数，而两个参数都是可选的，意味着可以什么都不传</li>\n<li>then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的</li>\n<li>每次调用then均返回一个全新的Promise实例，这样就可以链式调用</li>\n<li>then会在当前宏任务下形成一个微任务（具体介绍看下面）</li>\n</ul>\n<h3 id=\"Promise-的状态\"><a href=\"#Promise-的状态\" class=\"headerlink\" title=\"Promise 的状态\"></a>Promise 的状态</h3><p>then其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。</p>\n<p>它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>) <span class=\"comment\">// 将当前的状态流转成resolved</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>而then返回的promise的状态判断需要分两步走：</p>\n<ol>\n<li>then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态</li>\n<li>若满足条件1，则看当前回调函数能否正常处理</li>\n</ol>\n<p>说得有点绕口，看下面的实例代码即可理解：</p>\n<p><strong>理解条件1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br><span class=\"line\">\treject(<span class=\"string\">&#x27;error1&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>由于<code>p1</code>的状态是<code>Rejected</code>的，而<code>p2</code>没有传入<code>onRejected</code>的回调函数，因此<code>p2</code>的状态完全复用<code>p1</code>的状态。</p>\n<p><strong>理解条件2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: ReferenceError: x is not defined&#125;</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;p1 was resolved:&#x27;</span>, val)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x; <span class=\"comment\">// Uncaught referenceError</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = p2.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> <span class=\"number\">1</span>) <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>的状态是<code>fulfilled</code>的，而<code>p2</code>有<code>onFulfilled</code>的回调函数，但是没有正确处理，抛异常了。因此<code>p2</code>的状态变成了<code>rejected</code>，其中的reason为则报错的原因。</p>\n<p>而此时<code>p3</code>刚好有<code>onRejected</code>的函数，也能正确处理，最后的返回值则是自己的value，因此<code>p3</code>的状态是<code>fulfilled</code>的。</p>\n<h3 id=\"Promise-的返回值\"><a href=\"#Promise-的返回值\" class=\"headerlink\" title=\"Promise 的返回值\"></a>Promise 的返回值</h3><p>前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了<code>promise</code>，这里重点讲下。</p>\n<p>由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。</p>\n<p>同样看看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">1000</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">() =&gt;</span> p1)</span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>是一个简单的定时器promise，在1000ms之后，状态会变成<code>&lt;fulfilled: 1&gt;</code>。</p>\n<p>而<code>p2</code>的返回值是<code>p1</code>，因此<code>p2</code>在1000ms之内也是<code>&lt;pending&gt;</code>，同样会在1000ms之后，变成<code>&lt;fulfilled: 1&gt;</code></p>\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch\"></a>Promise.prototype.catch</h2><p>虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。</p>\n<p>其实，catch可以理解成then的一种封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;) == promise.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"微任务-microtask\"><a href=\"#微任务-microtask\" class=\"headerlink\" title=\"微任务 microtask\"></a>微任务 microtask</h2><p>当前promise的状态变更之后，不是立即执行then方法的。此时引入了 <strong>微任务(microtask)</strong> 的概念。</p>\n<p>与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。</p>\n<p>也可以通过其他的方式生成宏任务：<code>setTimeout</code>、<code>setInterval</code>；而微任务则可以通过<code>promise.then</code>、<code>Object.observe(已废弃)</code>、<code>MutationObserver</code>生成。</p>\n<p>宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>即一个宏任务下，是可以有多个微任务的。</p>\n<blockquote>\n<p>由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。</p>\n</blockquote>\n<h3 id=\"解析任务\"><a href=\"#解析任务\" class=\"headerlink\" title=\"解析任务\"></a>解析任务</h3><p>分析代码的时候，可以这样分几步走：</p>\n<ol>\n<li>理想情况下，如果没有任何<code>setTimeout</code>和<code>promise.then</code>的话，则全部在一个宏任务里执行</li>\n<li>若出现<code>promise.then</code>，则在当前宏任务生成一个微任务，用于执行<code>promise.then</code></li>\n<li>若出现了<code>setTimeout</code>，则添加一个宏任务，重复条件1</li>\n</ol>\n<p>分析几个例子考验一下：</p>\n<p><strong>例子1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n<p><strong>例子2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 省略参数，delay默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n<p>其实，还有<code>async/await</code>相关的题目，如果阅读足够多的话，我再完善吧。</p>\n<h1 id=\"手写-Promise\"><a href=\"#手写-Promise\" class=\"headerlink\" title=\"手写 Promise\"></a>手写 Promise</h1><p>其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。</p>\n<p>我在<a href=\"https://github.com/LeeJim/word\">github</a>写了一份，代码逻辑都算挺清晰的，大家可以去看看。</p>\n<p>我建议大家在写之前，再仔细看一下<code>Promise/A+</code>的标准规范，可以结合我的代码一起看。</p>\n<p>清晰理解细节之后，再动手写一遍。</p>\n<p>如果觉得不错的话，记得给我点赞 + <a href=\"https://github.com/LeeJim/word\">star</a>。</p>\n<p>撒花，感谢阅读！</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>读完这篇文章，你的收获有：</p>\n<ol>\n<li>Promise简史</li>\n<li>Promise的关键概念</li>\n<li>可以手写符合标准的Promise</li>\n<li>可以解答任意宏任务/微任务的题目</li>\n</ol>","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>为什么写这篇文章？</p>\n<p>JavaScript是异步语言，因此Promise的重要性不言而喻。</p>\n<p>而我看了一些文章，觉得质量参差不齐。</p>\n<p>于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。</p>\n<p>由于能力有限，文中可能存在错误，望广大网友指正。</p>\n<h1 id=\"Promise-简史\"><a href=\"#Promise-简史\" class=\"headerlink\" title=\"Promise 简史\"></a>Promise 简史</h1><p>Promise 并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。</p>\n<p>这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：<a href=\"https://promisesaplus.com/\">Promise/A+</a>。</p>\n<p>在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。</p>\n<h1 id=\"Promise-的关键概念\"><a href=\"#Promise-的关键概念\" class=\"headerlink\" title=\"Promise 的关键概念\"></a>Promise 的关键概念</h1><blockquote>\n<p>“The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference</p>\n</blockquote>\n<p>Promise的基础认知，推荐看阮一峰的<a href=\"https://es6.ruanyifeng.com/#docs/promise\">《ES6 入门教程》</a>。</p>\n<p>本文的重点是讲解一些手写Promise需要关注的关键概念。</p>\n<h2 id=\"Promise-有三个状态：\"><a href=\"#Promise-有三个状态：\" class=\"headerlink\" title=\"Promise 有三个状态：\"></a>Promise 有三个状态：</h2><ul>\n<li>pending</li>\n<li>resolved</li>\n<li>rejected</li>\n</ul>\n<p>只能从pending到resolved或rejected，之后状态就凝固了。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>当状态流转成resolved时，需要选择一个值作为当前Promise的value：</p>\n<ul>\n<li><code>new Promise</code>时，则是通过<code>resolve(val)</code></li>\n<li><code>promise.then</code>时，则是通过<code>return</code>（需要注意的是，没有显式<code>return</code>时是默认<code>return undefined</code>）</li>\n</ul>\n<p>这个值可以是任意的合法JavaScript值（包括<code>undefined</code>、<code>thenable对象</code>或者<code>promise</code>）</p>\n<blockquote>\n<p>thenable对象是一个定义了then方法的对象或者函数</p>\n</blockquote>\n<p>状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。</p>\n<h2 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then\"></a>Promise.prototype.then</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://promisesaplus.com/\">Promise/A+</a> 是Promise的标准规范，<strong>其中指出Promise实例只需要实现then一个方法</strong></li>\n<li>then接收两个参数，而两个参数都是可选的，意味着可以什么都不传</li>\n<li>then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的</li>\n<li>每次调用then均返回一个全新的Promise实例，这样就可以链式调用</li>\n<li>then会在当前宏任务下形成一个微任务（具体介绍看下面）</li>\n</ul>\n<h3 id=\"Promise-的状态\"><a href=\"#Promise-的状态\" class=\"headerlink\" title=\"Promise 的状态\"></a>Promise 的状态</h3><p>then其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。</p>\n<p>它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>) <span class=\"comment\">// 将当前的状态流转成resolved</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>而then返回的promise的状态判断需要分两步走：</p>\n<ol>\n<li>then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态</li>\n<li>若满足条件1，则看当前回调函数能否正常处理</li>\n</ol>\n<p>说得有点绕口，看下面的实例代码即可理解：</p>\n<p><strong>理解条件1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br><span class=\"line\">\treject(<span class=\"string\">&#x27;error1&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"built_in\">console</span>.log) <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: &quot;error1&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>由于<code>p1</code>的状态是<code>Rejected</code>的，而<code>p2</code>没有传入<code>onRejected</code>的回调函数，因此<code>p2</code>的状态完全复用<code>p1</code>的状态。</p>\n<p><strong>理解条件2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br><span class=\"line\">\tresolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = p1.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123; <span class=\"comment\">// Promise &#123;&lt;rejected&gt;: ReferenceError: x is not defined&#125;</span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;p1 was resolved:&#x27;</span>, val)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x; <span class=\"comment\">// Uncaught referenceError</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = p2.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> <span class=\"number\">1</span>) <span class=\"comment\">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>的状态是<code>fulfilled</code>的，而<code>p2</code>有<code>onFulfilled</code>的回调函数，但是没有正确处理，抛异常了。因此<code>p2</code>的状态变成了<code>rejected</code>，其中的reason为则报错的原因。</p>\n<p>而此时<code>p3</code>刚好有<code>onRejected</code>的函数，也能正确处理，最后的返回值则是自己的value，因此<code>p3</code>的状态是<code>fulfilled</code>的。</p>\n<h3 id=\"Promise-的返回值\"><a href=\"#Promise-的返回值\" class=\"headerlink\" title=\"Promise 的返回值\"></a>Promise 的返回值</h3><p>前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了<code>promise</code>，这里重点讲下。</p>\n<p>由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。</p>\n<p>同样看看例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(resolve, <span class=\"number\">1000</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">() =&gt;</span> p1)</span><br></pre></td></tr></table></figure>\n\n<p><code>p1</code>是一个简单的定时器promise，在1000ms之后，状态会变成<code>&lt;fulfilled: 1&gt;</code>。</p>\n<p>而<code>p2</code>的返回值是<code>p1</code>，因此<code>p2</code>在1000ms之内也是<code>&lt;pending&gt;</code>，同样会在1000ms之后，变成<code>&lt;fulfilled: 1&gt;</code></p>\n<h2 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch\"></a>Promise.prototype.catch</h2><p>虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。</p>\n<p>其实，catch可以理解成then的一种封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;) == promise.then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"微任务-microtask\"><a href=\"#微任务-microtask\" class=\"headerlink\" title=\"微任务 microtask\"></a>微任务 microtask</h2><p>当前promise的状态变更之后，不是立即执行then方法的。此时引入了 <strong>微任务(microtask)</strong> 的概念。</p>\n<p>与之对应的则是 **宏任务(macrotask)**，基本的JavaScript代码则是在一个宏任务里执行的。</p>\n<p>也可以通过其他的方式生成宏任务：<code>setTimeout</code>、<code>setInterval</code>；而微任务则可以通过<code>promise.then</code>、<code>Object.observe(已废弃)</code>、<code>MutationObserver</code>生成。</p>\n<p>宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>即一个宏任务下，是可以有多个微任务的。</p>\n<blockquote>\n<p>由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。</p>\n</blockquote>\n<h3 id=\"解析任务\"><a href=\"#解析任务\" class=\"headerlink\" title=\"解析任务\"></a>解析任务</h3><p>分析代码的时候，可以这样分几步走：</p>\n<ol>\n<li>理想情况下，如果没有任何<code>setTimeout</code>和<code>promise.then</code>的话，则全部在一个宏任务里执行</li>\n<li>若出现<code>promise.then</code>，则在当前宏任务生成一个微任务，用于执行<code>promise.then</code></li>\n<li>若出现了<code>setTimeout</code>，则添加一个宏任务，重复条件1</li>\n</ol>\n<p>分析几个例子考验一下：</p>\n<p><strong>例子1：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n1、3、2、0\n</p>\n</details>\n\n<p><strong>例子2：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">4</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 省略参数，delay默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    resolve(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<details><summary><b>正确的输出顺序：</b></summary>\n<p>\n8、1、3、2、0、4、5\n</p>\n</details>\n\n<p>其实，还有<code>async/await</code>相关的题目，如果阅读足够多的话，我再完善吧。</p>\n<h1 id=\"手写-Promise\"><a href=\"#手写-Promise\" class=\"headerlink\" title=\"手写 Promise\"></a>手写 Promise</h1><p>其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。</p>\n<p>我在<a href=\"https://github.com/LeeJim/word\">github</a>写了一份，代码逻辑都算挺清晰的，大家可以去看看。</p>\n<p>我建议大家在写之前，再仔细看一下<code>Promise/A+</code>的标准规范，可以结合我的代码一起看。</p>\n<p>清晰理解细节之后，再动手写一遍。</p>\n<p>如果觉得不错的话，记得给我点赞 + <a href=\"https://github.com/LeeJim/word\">star</a>。</p>\n<p>撒花，感谢阅读！</p>"},{"title":"如何将小程序的 API Promise 化","desc":"小程序如何将异步调用转成Promise调用","toc":true,"date":"2020-03-31T16:00:00.000Z","_content":"\n## 前言\n\n众所周知，前端一大坑就是回调函数。\n\n相信很多人是从`async/await`的温柔乡，掉到小程序重新写回调的大坑里的。\n\n<!-- more -->\n\n由于开发者工具新增了 [增强编译](https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html) 从而原生支持了`async\\await`，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 **异步调用** 方式改成 **Promise的方式** 即可。\n\n## 分析与实践\n\n大致上可以有两种思路，第一种就是，逐个函数封装：\n\n```js\nlet promisify = func => args => new Promise((resolve, reject) => {\n    func(Object.assign(args, {\n        success: resolve,\n        fail: reject,\n    }))\n})\n\nlet _login = promisify(wx.login) // 将wx.login转成Promise形式的方法\n\n_login().then(res => console.log)\n```\n\n这种方式比较麻烦，每次调用都需要手动转换。\n\n### 劫持WX\n\n第二种就类似`Page`封装那样，劫持`wx`对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：\n\n- 同步方法是以`Sync`结尾的\n- 通过`typeof`判断是否为函数\n\n```js\n// promisify.js\n\nlet originalWX = wx\nlet props = Object.keys(wx)\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        wx[name] = promisify(fn)\n    }\n}\n```\n\n尝试封装之后，发现报错了。因为`wx.drawCanvas`只有`getter`没有`setter`，无法给它赋值。相当于这个方法是`readonly`。\n\n![](/blog/images/promisify-error1.jpg)\n\n既然存在没有`setter`的方法，那么我看有多少方法是有`setter`的：\n\n```js\nObject.keys(wx).filter(name => {\n    let descriptor = Object.getOwnPropertyDescriptor(wx, name)\n    return typeof descriptor.set === 'function'\n})\n```\n\n结果是`[]`，相当于无法改变`wx`对象的每个属性值。\n\n![](/blog/images/promisify-console1.jpg)\n\n### 复制模式\n\n虽然`wx`的属性都是`readonly`，不能劫持`wx`，但我发现`wx`是`writable`的。\n\n那么可以采用复制模式，将它的所有异步方法拷贝一份并`promisify`之后赋值到新对象，最后再将整个对象赋值给`wx`即可：\n\n```js\nlet props = Object.keys(wx)\nlet jwx = {}\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        jwx[name] = promisify(fn)\n    } else {\n        jwx[name] = fn\n    }\n}\n\nwx = jwx\n```\n\n这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了`promisify`。\n\n### 代理模式\n\n熟悉ES新特性的读者应该知道`Proxy`。\n\n它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上`Proxy`之后，对这个属性的任何行为都可以被代理。\n\n那么我们就可以给`wx`挂上代理：\n\n```js\nlet originalWX = wx\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return promisify(fn)\n        }\n    }\n});\n```\n\n代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。\n\n在实践中，我发现并不是所有同步方法都是以`Sync`结尾的。比如：`wx.getMenuButtonBoundingClientRect`。\n\n因此打算手动维护一个同步方法列表，将这项方法过滤掉：\n\n```js\nlet syncFuncList = ['getMenuButtonBoundingClientRect']\n// name为函数名\nlet isSync = name.endsWith('Sync') || syncFuncList.includes(name)\n```\n\n\n## 优化\n\n考虑到要兼容已上线的小程序，若匆忙替换`wx`，必会导致全局报错，因此可以如下处理：\n\n当用户调用API时，如果传入了`success`、`fail`、`complete`等回调方法的话，则仍继续使用回调的方式继续执行。那么`promisify`可以如下优化：\n\n```js\nlet originalWX = wx\nlet hasCallback = obj => {\n    let cbs = ['success', 'fail', 'complete']\n    return Object.keys(obj).some(k => cbs.includes(k))\n}\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return (obj) => {\n                if (!obj) return fn()\n                if (hasCallback(obj)) return fn(obj)\n                return promisify(fn)(obj)\n            }\n        }\n    }\n});\n```\n\n> 由于本文的前提是开启 **增强编译**，而该模式下也新增支持`Array.prototype.includes`，因此可以放心使用该ES7的新特性。\n\n## 后续\n\n由于发现了微信官方也提供了一个 [API Promise化](https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html) 的工具类库，因此增加了本章节。\n\n通过阅读源代码，发现官方的工具类库提供两个方法：`promisify` 和 `promisifyAll`\n\n其中`promisify`与前文的同名方法是几乎一致的。而`promisifyAll`则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：\n\n```js\nimport { promisifyAll } from 'miniprogram-api-promise';\n\nlet jwx = {}\n\npromisifyAll(wx, jwx)\n\nwx = jwx\n```\n\n另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。\n\n相当于我的做法是黑名单机制，而官方采用了白名单机制。\n\n> 最后再提醒下，开发者工具记得打开 **增强编译**","source":"_posts/miniprogram/api-promisify.md","raw":"---\ntitle: 如何将小程序的 API Promise 化\ntags: \n- 小程序\ndesc: 小程序如何将异步调用转成Promise调用\ntoc: true\ncategories:\n- 小程序\ndate: 2020-4-1\n---\n\n## 前言\n\n众所周知，前端一大坑就是回调函数。\n\n相信很多人是从`async/await`的温柔乡，掉到小程序重新写回调的大坑里的。\n\n<!-- more -->\n\n由于开发者工具新增了 [增强编译](https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html) 从而原生支持了`async\\await`，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 **异步调用** 方式改成 **Promise的方式** 即可。\n\n## 分析与实践\n\n大致上可以有两种思路，第一种就是，逐个函数封装：\n\n```js\nlet promisify = func => args => new Promise((resolve, reject) => {\n    func(Object.assign(args, {\n        success: resolve,\n        fail: reject,\n    }))\n})\n\nlet _login = promisify(wx.login) // 将wx.login转成Promise形式的方法\n\n_login().then(res => console.log)\n```\n\n这种方式比较麻烦，每次调用都需要手动转换。\n\n### 劫持WX\n\n第二种就类似`Page`封装那样，劫持`wx`对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：\n\n- 同步方法是以`Sync`结尾的\n- 通过`typeof`判断是否为函数\n\n```js\n// promisify.js\n\nlet originalWX = wx\nlet props = Object.keys(wx)\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        wx[name] = promisify(fn)\n    }\n}\n```\n\n尝试封装之后，发现报错了。因为`wx.drawCanvas`只有`getter`没有`setter`，无法给它赋值。相当于这个方法是`readonly`。\n\n![](/blog/images/promisify-error1.jpg)\n\n既然存在没有`setter`的方法，那么我看有多少方法是有`setter`的：\n\n```js\nObject.keys(wx).filter(name => {\n    let descriptor = Object.getOwnPropertyDescriptor(wx, name)\n    return typeof descriptor.set === 'function'\n})\n```\n\n结果是`[]`，相当于无法改变`wx`对象的每个属性值。\n\n![](/blog/images/promisify-console1.jpg)\n\n### 复制模式\n\n虽然`wx`的属性都是`readonly`，不能劫持`wx`，但我发现`wx`是`writable`的。\n\n那么可以采用复制模式，将它的所有异步方法拷贝一份并`promisify`之后赋值到新对象，最后再将整个对象赋值给`wx`即可：\n\n```js\nlet props = Object.keys(wx)\nlet jwx = {}\n\nfor (let name of props) {\n    let fn = wx[name]\n\n    if (typeof fn === 'function' && !name.endsWith('Sync')) {\n        jwx[name] = promisify(fn)\n    } else {\n        jwx[name] = fn\n    }\n}\n\nwx = jwx\n```\n\n这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了`promisify`。\n\n### 代理模式\n\n熟悉ES新特性的读者应该知道`Proxy`。\n\n它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上`Proxy`之后，对这个属性的任何行为都可以被代理。\n\n那么我们就可以给`wx`挂上代理：\n\n```js\nlet originalWX = wx\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return promisify(fn)\n        }\n    }\n});\n```\n\n代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。\n\n在实践中，我发现并不是所有同步方法都是以`Sync`结尾的。比如：`wx.getMenuButtonBoundingClientRect`。\n\n因此打算手动维护一个同步方法列表，将这项方法过滤掉：\n\n```js\nlet syncFuncList = ['getMenuButtonBoundingClientRect']\n// name为函数名\nlet isSync = name.endsWith('Sync') || syncFuncList.includes(name)\n```\n\n\n## 优化\n\n考虑到要兼容已上线的小程序，若匆忙替换`wx`，必会导致全局报错，因此可以如下处理：\n\n当用户调用API时，如果传入了`success`、`fail`、`complete`等回调方法的话，则仍继续使用回调的方式继续执行。那么`promisify`可以如下优化：\n\n```js\nlet originalWX = wx\nlet hasCallback = obj => {\n    let cbs = ['success', 'fail', 'complete']\n    return Object.keys(obj).some(k => cbs.includes(k))\n}\nwx = new Proxy({}, {\n    get(target, name) {\n        if (name in originalWX ) {\n            let fn = originalWX[name]\n            let isSyncFunc = name.endsWith('Sync') // 同步函数 \n            let isNotFunc = typeof fn !== 'function' // 非函数\n\n            if (isSyncFunc || isNotFunc) return fn\n\n            return (obj) => {\n                if (!obj) return fn()\n                if (hasCallback(obj)) return fn(obj)\n                return promisify(fn)(obj)\n            }\n        }\n    }\n});\n```\n\n> 由于本文的前提是开启 **增强编译**，而该模式下也新增支持`Array.prototype.includes`，因此可以放心使用该ES7的新特性。\n\n## 后续\n\n由于发现了微信官方也提供了一个 [API Promise化](https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html) 的工具类库，因此增加了本章节。\n\n通过阅读源代码，发现官方的工具类库提供两个方法：`promisify` 和 `promisifyAll`\n\n其中`promisify`与前文的同名方法是几乎一致的。而`promisifyAll`则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：\n\n```js\nimport { promisifyAll } from 'miniprogram-api-promise';\n\nlet jwx = {}\n\npromisifyAll(wx, jwx)\n\nwx = jwx\n```\n\n另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。\n\n相当于我的做法是黑名单机制，而官方采用了白名单机制。\n\n> 最后再提醒下，开发者工具记得打开 **增强编译**","slug":"miniprogram/api-promisify","published":1,"updated":"2023-08-04T10:46:34.264Z","_id":"cky5ioqer0011n669acm951wc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>众所周知，前端一大坑就是回调函数。</p>\n<p>相信很多人是从<code>async/await</code>的温柔乡，掉到小程序重新写回调的大坑里的。</p>\n<span id=\"more\"></span>\n\n<p>由于开发者工具新增了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html\">增强编译</a> 从而原生支持了<code>async\\await</code>，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 <strong>异步调用</strong> 方式改成 <strong>Promise的方式</strong> 即可。</p>\n<h2 id=\"分析与实践\"><a href=\"#分析与实践\" class=\"headerlink\" title=\"分析与实践\"></a>分析与实践</h2><p>大致上可以有两种思路，第一种就是，逐个函数封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promisify = <span class=\"function\"><span class=\"params\">func</span> =&gt;</span> <span class=\"function\"><span class=\"params\">args</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    func(<span class=\"built_in\">Object</span>.assign(args, &#123;</span><br><span class=\"line\">        <span class=\"attr\">success</span>: resolve,</span><br><span class=\"line\">        <span class=\"attr\">fail</span>: reject,</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _login = promisify(wx.login) <span class=\"comment\">// 将wx.login转成Promise形式的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">_login().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n<p>这种方式比较麻烦，每次调用都需要手动转换。</p>\n<h3 id=\"劫持WX\"><a href=\"#劫持WX\" class=\"headerlink\" title=\"劫持WX\"></a>劫持WX</h3><p>第二种就类似<code>Page</code>封装那样，劫持<code>wx</code>对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：</p>\n<ul>\n<li>同步方法是以<code>Sync</code>结尾的</li>\n<li>通过<code>typeof</code>判断是否为函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promisify.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        wx[name] = promisify(fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试封装之后，发现报错了。因为<code>wx.drawCanvas</code>只有<code>getter</code>没有<code>setter</code>，无法给它赋值。相当于这个方法是<code>readonly</code>。</p>\n<p><img src=\"/blog/images/promisify-error1.jpg\"></p>\n<p>既然存在没有<code>setter</code>的方法，那么我看有多少方法是有<code>setter</code>的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(wx).filter(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(wx, name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> descriptor.set === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>结果是<code>[]</code>，相当于无法改变<code>wx</code>对象的每个属性值。</p>\n<p><img src=\"/blog/images/promisify-console1.jpg\"></p>\n<h3 id=\"复制模式\"><a href=\"#复制模式\" class=\"headerlink\" title=\"复制模式\"></a>复制模式</h3><p>虽然<code>wx</code>的属性都是<code>readonly</code>，不能劫持<code>wx</code>，但我发现<code>wx</code>是<code>writable</code>的。</p>\n<p>那么可以采用复制模式，将它的所有异步方法拷贝一份并<code>promisify</code>之后赋值到新对象，最后再将整个对象赋值给<code>wx</code>即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        jwx[name] = promisify(fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        jwx[name] = fn</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了<code>promisify</code>。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>熟悉ES新特性的读者应该知道<code>Proxy</code>。</p>\n<p>它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上<code>Proxy</code>之后，对这个属性的任何行为都可以被代理。</p>\n<p>那么我们就可以给<code>wx</code>挂上代理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> promisify(fn)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。</p>\n<p>在实践中，我发现并不是所有同步方法都是以<code>Sync</code>结尾的。比如：<code>wx.getMenuButtonBoundingClientRect</code>。</p>\n<p>因此打算手动维护一个同步方法列表，将这项方法过滤掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> syncFuncList = [<span class=\"string\">&#x27;getMenuButtonBoundingClientRect&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// name为函数名</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isSync = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) || syncFuncList.includes(name)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>考虑到要兼容已上线的小程序，若匆忙替换<code>wx</code>，必会导致全局报错，因此可以如下处理：</p>\n<p>当用户调用API时，如果传入了<code>success</code>、<code>fail</code>、<code>complete</code>等回调方法的话，则仍继续使用回调的方式继续执行。那么<code>promisify</code>可以如下优化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> hasCallback = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cbs = [<span class=\"string\">&#x27;success&#x27;</span>, <span class=\"string\">&#x27;fail&#x27;</span>, <span class=\"string\">&#x27;complete&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(obj).some(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> cbs.includes(k))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span> fn()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasCallback(obj)) <span class=\"keyword\">return</span> fn(obj)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> promisify(fn)(obj)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于本文的前提是开启 <strong>增强编译</strong>，而该模式下也新增支持<code>Array.prototype.includes</code>，因此可以放心使用该ES7的新特性。</p>\n</blockquote>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>由于发现了微信官方也提供了一个 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html\">API Promise化</a> 的工具类库，因此增加了本章节。</p>\n<p>通过阅读源代码，发现官方的工具类库提供两个方法：<code>promisify</code> 和 <code>promisifyAll</code></p>\n<p>其中<code>promisify</code>与前文的同名方法是几乎一致的。而<code>promisifyAll</code>则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; promisifyAll &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;miniprogram-api-promise&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promisifyAll(wx, jwx)</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。</p>\n<p>相当于我的做法是黑名单机制，而官方采用了白名单机制。</p>\n<blockquote>\n<p>最后再提醒下，开发者工具记得打开 <strong>增强编译</strong></p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>众所周知，前端一大坑就是回调函数。</p>\n<p>相信很多人是从<code>async/await</code>的温柔乡，掉到小程序重新写回调的大坑里的。</p>","more":"<p>由于开发者工具新增了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/codecompile.html\">增强编译</a> 从而原生支持了<code>async\\await</code>，避免了我们仍需通过webpack等第三方打包工具实现。因此我们需要做的就是将官方API的 <strong>异步调用</strong> 方式改成 <strong>Promise的方式</strong> 即可。</p>\n<h2 id=\"分析与实践\"><a href=\"#分析与实践\" class=\"headerlink\" title=\"分析与实践\"></a>分析与实践</h2><p>大致上可以有两种思路，第一种就是，逐个函数封装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promisify = <span class=\"function\"><span class=\"params\">func</span> =&gt;</span> <span class=\"function\"><span class=\"params\">args</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    func(<span class=\"built_in\">Object</span>.assign(args, &#123;</span><br><span class=\"line\">        <span class=\"attr\">success</span>: resolve,</span><br><span class=\"line\">        <span class=\"attr\">fail</span>: reject,</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _login = promisify(wx.login) <span class=\"comment\">// 将wx.login转成Promise形式的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">_login().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n<p>这种方式比较麻烦，每次调用都需要手动转换。</p>\n<h3 id=\"劫持WX\"><a href=\"#劫持WX\" class=\"headerlink\" title=\"劫持WX\"></a>劫持WX</h3><p>第二种就类似<code>Page</code>封装那样，劫持<code>wx</code>对象，进行全局统一封装。但有一点比较棘手的是，需要分析清楚哪些是函数，哪些函数是异步而不是同步的，一开始我的思路是这样的：</p>\n<ul>\n<li>同步方法是以<code>Sync</code>结尾的</li>\n<li>通过<code>typeof</code>判断是否为函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// promisify.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        wx[name] = promisify(fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尝试封装之后，发现报错了。因为<code>wx.drawCanvas</code>只有<code>getter</code>没有<code>setter</code>，无法给它赋值。相当于这个方法是<code>readonly</code>。</p>\n<p><img src=\"/blog/images/promisify-error1.jpg\"></p>\n<p>既然存在没有<code>setter</code>的方法，那么我看有多少方法是有<code>setter</code>的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(wx).filter(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(wx, name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> descriptor.set === <span class=\"string\">&#x27;function&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>结果是<code>[]</code>，相当于无法改变<code>wx</code>对象的每个属性值。</p>\n<p><img src=\"/blog/images/promisify-console1.jpg\"></p>\n<h3 id=\"复制模式\"><a href=\"#复制模式\" class=\"headerlink\" title=\"复制模式\"></a>复制模式</h3><p>虽然<code>wx</code>的属性都是<code>readonly</code>，不能劫持<code>wx</code>，但我发现<code>wx</code>是<code>writable</code>的。</p>\n<p>那么可以采用复制模式，将它的所有异步方法拷贝一份并<code>promisify</code>之后赋值到新对象，最后再将整个对象赋值给<code>wx</code>即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> props = <span class=\"built_in\">Object</span>.keys(wx)</span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = wx[name]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; !name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>)) &#123;</span><br><span class=\"line\">        jwx[name] = promisify(fn)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        jwx[name] = fn</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>这种方式虽可行，但是挺冗余的，因为将很多可能没用上的方法也进行了<code>promisify</code>。</p>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>熟悉ES新特性的读者应该知道<code>Proxy</code>。</p>\n<p>它可以用来定义对象的自定义行为，顾名思义，就是给对象挂上<code>Proxy</code>之后，对这个属性的任何行为都可以被代理。</p>\n<p>那么我们就可以给<code>wx</code>挂上代理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> promisify(fn)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代理的方式虽解决了复制模式的冗余问题，但是仍有一个问题待解决：异步方法的判断。</p>\n<p>在实践中，我发现并不是所有同步方法都是以<code>Sync</code>结尾的。比如：<code>wx.getMenuButtonBoundingClientRect</code>。</p>\n<p>因此打算手动维护一个同步方法列表，将这项方法过滤掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> syncFuncList = [<span class=\"string\">&#x27;getMenuButtonBoundingClientRect&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// name为函数名</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isSync = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) || syncFuncList.includes(name)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>考虑到要兼容已上线的小程序，若匆忙替换<code>wx</code>，必会导致全局报错，因此可以如下处理：</p>\n<p>当用户调用API时，如果传入了<code>success</code>、<code>fail</code>、<code>complete</code>等回调方法的话，则仍继续使用回调的方式继续执行。那么<code>promisify</code>可以如下优化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx</span><br><span class=\"line\"><span class=\"keyword\">let</span> hasCallback = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cbs = [<span class=\"string\">&#x27;success&#x27;</span>, <span class=\"string\">&#x27;fail&#x27;</span>, <span class=\"string\">&#x27;complete&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(obj).some(<span class=\"function\"><span class=\"params\">k</span> =&gt;</span> cbs.includes(k))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> fn = originalWX[name]</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunc = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>) <span class=\"comment\">// 同步函数 </span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunc = <span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span> <span class=\"comment\">// 非函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunc || isNotFunc) <span class=\"keyword\">return</span> fn</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span> fn()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasCallback(obj)) <span class=\"keyword\">return</span> fn(obj)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> promisify(fn)(obj)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于本文的前提是开启 <strong>增强编译</strong>，而该模式下也新增支持<code>Array.prototype.includes</code>，因此可以放心使用该ES7的新特性。</p>\n</blockquote>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>由于发现了微信官方也提供了一个 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/extended/utils/api-promise.html\">API Promise化</a> 的工具类库，因此增加了本章节。</p>\n<p>通过阅读源代码，发现官方的工具类库提供两个方法：<code>promisify</code> 和 <code>promisifyAll</code></p>\n<p>其中<code>promisify</code>与前文的同名方法是几乎一致的。而<code>promisifyAll</code>则是接收两个参数，第一个是被封装的对象，第二个则是封装之后的对象，如下使用将和前文我提到的封装方式类似：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; promisifyAll &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;miniprogram-api-promise&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jwx = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promisifyAll(wx, jwx)</span><br><span class=\"line\"></span><br><span class=\"line\">wx = jwx</span><br></pre></td></tr></table></figure>\n\n<p>另外还有一点需要提到的是，官方这个工具类库，判断是否为异步函数的方式是维护了一个异步方法列表，会存在遗漏新API的可能。</p>\n<p>相当于我的做法是黑名单机制，而官方采用了白名单机制。</p>\n<blockquote>\n<p>最后再提醒下，开发者工具记得打开 <strong>增强编译</strong></p>\n</blockquote>"},{"title":"小程序中实现自定义导航栏","desc":"小程序如何自定义导航栏","toc":true,"date":"2020-05-05T16:00:00.000Z","_content":"\n小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。\n\n<!-- more -->\n\n> 自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域\n\n![](/blog/images/custom-navigator/interface.jpg)\n\n## 作用\n\n最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。\n\n![](/blog/images/custom-navigator/full-screen.jpeg)\n\n其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。\n\n需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过`wx.getMenuButtonBoundingClientRect`获取胶囊按钮的布局位置信息。\n\n## 布局信息\n\n由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。\n\n![](/blog/images/custom-navigator/navigator.jpg)\n\n如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过`wx.getSystemInfo`获取系统信息，其中的`statusBarHeight`即是状态栏的高度。\n\n另外前文也提到了，胶囊按钮的信息可以通过`wx.getMenuButtonBoundingClientRect`获取。胶囊按钮与状态栏的距离可以这样计算：\n\n```js\nlet mb = wx.getMenuButtonBoundingClientRect();\nlet sh = wx.getSystemInfoSync().statusBarHeight // 为getSystemInfo的同步版本\n\nlet distance = mb.top - sh\n```\n\n基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的`distance`是一致的。所以，导航栏的高度是：\n\n```js\nlet nh = mb.height + distance * 2 // navigatorHeight\n```\n\n总计一下，导航栏的布局信息如下：\n\n```js\nlet navigator = {\n    top: sh\n    bottom: mb.bottom + distance\n    left: 0,\n    right: 0,\n    height: mb.height + distance * 2\n    width: wx.getSystemInfoSync().screenWidth\n}\n```\n\n## 兼容问题\n\n前文提到页面设置导航栏是要求`客户端7.0.0以上`；\n\n另外计算 **状态栏高度(statusBarHeight)** 需要`基础库版本1.9.0`以上；\n\n计算胶囊按钮的布局信息`wx.getMenuButtonBoundingClientRect`则要求`基础库2.1.0`；\n\n> 由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为`2.4.3`\n\n因此，只要判断当前用户的客户端是否为`7.0.0`或以上即可。\n\n## 注意事项\n\n由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意`position: fixed`的元素，此时应该将`top`对应的数值加上`statusBarHeight`和`navigator.height`，才能渲染正确。","source":"_posts/miniprogram/custom-navigator.md","raw":"---\ntitle: 小程序中实现自定义导航栏\ntags: \n- 小程序\n- 自定义组件\ndesc: 小程序如何自定义导航栏\ntoc: true\ncategories:\n- 小程序\ndate: 2020-5-6\n---\n\n小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。\n\n<!-- more -->\n\n> 自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域\n\n![](/blog/images/custom-navigator/interface.jpg)\n\n## 作用\n\n最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。\n\n![](/blog/images/custom-navigator/full-screen.jpeg)\n\n其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。\n\n需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过`wx.getMenuButtonBoundingClientRect`获取胶囊按钮的布局位置信息。\n\n## 布局信息\n\n由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。\n\n![](/blog/images/custom-navigator/navigator.jpg)\n\n如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过`wx.getSystemInfo`获取系统信息，其中的`statusBarHeight`即是状态栏的高度。\n\n另外前文也提到了，胶囊按钮的信息可以通过`wx.getMenuButtonBoundingClientRect`获取。胶囊按钮与状态栏的距离可以这样计算：\n\n```js\nlet mb = wx.getMenuButtonBoundingClientRect();\nlet sh = wx.getSystemInfoSync().statusBarHeight // 为getSystemInfo的同步版本\n\nlet distance = mb.top - sh\n```\n\n基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的`distance`是一致的。所以，导航栏的高度是：\n\n```js\nlet nh = mb.height + distance * 2 // navigatorHeight\n```\n\n总计一下，导航栏的布局信息如下：\n\n```js\nlet navigator = {\n    top: sh\n    bottom: mb.bottom + distance\n    left: 0,\n    right: 0,\n    height: mb.height + distance * 2\n    width: wx.getSystemInfoSync().screenWidth\n}\n```\n\n## 兼容问题\n\n前文提到页面设置导航栏是要求`客户端7.0.0以上`；\n\n另外计算 **状态栏高度(statusBarHeight)** 需要`基础库版本1.9.0`以上；\n\n计算胶囊按钮的布局信息`wx.getMenuButtonBoundingClientRect`则要求`基础库2.1.0`；\n\n> 由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为`2.4.3`\n\n因此，只要判断当前用户的客户端是否为`7.0.0`或以上即可。\n\n## 注意事项\n\n由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意`position: fixed`的元素，此时应该将`top`对应的数值加上`statusBarHeight`和`navigator.height`，才能渲染正确。","slug":"miniprogram/custom-navigator","published":1,"updated":"2023-08-04T10:48:56.919Z","_id":"cky5ioqes0012n669gor85mvz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域</p>\n</blockquote>\n<p><img src=\"/blog/images/custom-navigator/interface.jpg\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。</p>\n<p><img src=\"/blog/images/custom-navigator/full-screen.jpeg\"></p>\n<p>其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。</p>\n<p>需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取胶囊按钮的布局位置信息。</p>\n<h2 id=\"布局信息\"><a href=\"#布局信息\" class=\"headerlink\" title=\"布局信息\"></a>布局信息</h2><p>由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。</p>\n<p><img src=\"/blog/images/custom-navigator/navigator.jpg\"></p>\n<p>如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过<code>wx.getSystemInfo</code>获取系统信息，其中的<code>statusBarHeight</code>即是状态栏的高度。</p>\n<p>另外前文也提到了，胶囊按钮的信息可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取。胶囊按钮与状态栏的距离可以这样计算：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mb = wx.getMenuButtonBoundingClientRect();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sh = wx.getSystemInfoSync().statusBarHeight <span class=\"comment\">// 为getSystemInfo的同步版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> distance = mb.top - sh</span><br></pre></td></tr></table></figure>\n\n<p>基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的<code>distance</code>是一致的。所以，导航栏的高度是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nh = mb.height + distance * <span class=\"number\">2</span> <span class=\"comment\">// navigatorHeight</span></span><br></pre></td></tr></table></figure>\n\n<p>总计一下，导航栏的布局信息如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> navigator = &#123;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: sh</span><br><span class=\"line\">    <span class=\"attr\">bottom</span>: mb.bottom + distance</span><br><span class=\"line\">    <span class=\"attr\">left</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">right</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">height</span>: mb.height + distance * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attr\">width</span>: wx.getSystemInfoSync().screenWidth</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"兼容问题\"><a href=\"#兼容问题\" class=\"headerlink\" title=\"兼容问题\"></a>兼容问题</h2><p>前文提到页面设置导航栏是要求<code>客户端7.0.0以上</code>；</p>\n<p>另外计算 <strong>状态栏高度(statusBarHeight)</strong> 需要<code>基础库版本1.9.0</code>以上；</p>\n<p>计算胶囊按钮的布局信息<code>wx.getMenuButtonBoundingClientRect</code>则要求<code>基础库2.1.0</code>；</p>\n<blockquote>\n<p>由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为<code>2.4.3</code></p>\n</blockquote>\n<p>因此，只要判断当前用户的客户端是否为<code>7.0.0</code>或以上即可。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意<code>position: fixed</code>的元素，此时应该将<code>top</code>对应的数值加上<code>statusBarHeight</code>和<code>navigator.height</code>，才能渲染正确。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>小程序早期版本（微信客户端6.6.0）仅支持全局设置自定义导航栏。只能统一设置，不能页面单独设置。直到微信客户端7.0.0发布之后，开始支持页面设置自定义导航栏，这让许多大型的小程序逐渐改成自定义导航栏成为了可能。</p>","more":"<blockquote>\n<p>自定义导航栏：下图黑色部分导航栏不再默认显示，从而整个手机页面都成为小程序的渲染区域</p>\n</blockquote>\n<p><img src=\"/blog/images/custom-navigator/interface.jpg\"></p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>最大的作用就是可以全屏展示，如我的小程序可以展示壁纸的真实效果，不再受导航栏限制。</p>\n<p><img src=\"/blog/images/custom-navigator/full-screen.jpeg\"></p>\n<p>其次，可以客制化导航栏，如在后退按钮旁，新增别的按钮，也可以实现后退监听。</p>\n<p>需要注意的是，右上角胶囊按钮无法消除，是永久展示的。因此在自定义导航栏的时候，需要考虑与其对齐。可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取胶囊按钮的布局位置信息。</p>\n<h2 id=\"布局信息\"><a href=\"#布局信息\" class=\"headerlink\" title=\"布局信息\"></a>布局信息</h2><p>由于开启自定义导航栏之后，全屏界面可渲染，因此如果要客制化导航栏的话，需要知道导航栏的布局信息。</p>\n<p><img src=\"/blog/images/custom-navigator/navigator.jpg\"></p>\n<p>如上图所示，以Android为例。较深色部分为 **状态栏(statusBar)**，可以通过<code>wx.getSystemInfo</code>获取系统信息，其中的<code>statusBarHeight</code>即是状态栏的高度。</p>\n<p>另外前文也提到了，胶囊按钮的信息可以通过<code>wx.getMenuButtonBoundingClientRect</code>获取。胶囊按钮与状态栏的距离可以这样计算：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mb = wx.getMenuButtonBoundingClientRect();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sh = wx.getSystemInfoSync().statusBarHeight <span class=\"comment\">// 为getSystemInfo的同步版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> distance = mb.top - sh</span><br></pre></td></tr></table></figure>\n\n<p>基于胶囊按钮是在导航栏的中间，因此胶囊按钮距离导航栏的底部距离和上面的<code>distance</code>是一致的。所以，导航栏的高度是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> nh = mb.height + distance * <span class=\"number\">2</span> <span class=\"comment\">// navigatorHeight</span></span><br></pre></td></tr></table></figure>\n\n<p>总计一下，导航栏的布局信息如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> navigator = &#123;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: sh</span><br><span class=\"line\">    <span class=\"attr\">bottom</span>: mb.bottom + distance</span><br><span class=\"line\">    <span class=\"attr\">left</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">right</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">height</span>: mb.height + distance * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attr\">width</span>: wx.getSystemInfoSync().screenWidth</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"兼容问题\"><a href=\"#兼容问题\" class=\"headerlink\" title=\"兼容问题\"></a>兼容问题</h2><p>前文提到页面设置导航栏是要求<code>客户端7.0.0以上</code>；</p>\n<p>另外计算 <strong>状态栏高度(statusBarHeight)</strong> 需要<code>基础库版本1.9.0</code>以上；</p>\n<p>计算胶囊按钮的布局信息<code>wx.getMenuButtonBoundingClientRect</code>则要求<code>基础库2.1.0</code>；</p>\n<blockquote>\n<p>由于微信客户端7.0.0发布日期是2018.12.22，而此时的最新基础库版本为<code>2.4.3</code></p>\n</blockquote>\n<p>因此，只要判断当前用户的客户端是否为<code>7.0.0</code>或以上即可。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>由于设置了自定义导航栏，全屏成了渲染区域。因此需要注意<code>position: fixed</code>的元素，此时应该将<code>top</code>对应的数值加上<code>statusBarHeight</code>和<code>navigator.height</code>，才能渲染正确。</p>"},{"title":"小程序中实现自定义标签栏","desc":"小程序如何自定义tabbar","toc":true,"date":"2020-03-28T16:00:00.000Z","_content":"\n## 前言\n\n由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。\n\n<!-- more -->\n\n因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：\n\n![](/blog/images/compare.jpg)\n\n## 分析\n\n原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。\n\n从 [小程序的官网文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar) 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：\n\n```json\n\"tabbar\": {\n    \"custom\": true\n}\n```\n \n设置了`custom`之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。\n\n而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）\n\n## 实践\n\n按照官网文档的描述，在根目录上创建组件的文件夹，命名`custom-tab-bar`，里面的文件和正常的组件保持一致。\n\n此时就可以将组件的样式和逻辑稍作调整：\n\n- 当进入首页时，背景色改成透明\n- 进入其他页面，背景色改回白色\n\n这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的`WXML`里显式引用。\n\n### 选中态\n\n由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？\n\n根据官网的描述，即是提供了接口`getTabBar`，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）\n\n需要在tabbar包含的每个页面的onShow里这样设置：\n\n```js\nPage({\n    onShow() {\n        if (typeof this.getTabBar === 'function') {\n            this.getTabBar().setData({ selected: 0 }) // 0代表第一个\n        }\n    }\n})\n```\n\n> 此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router\n\n### 兼容性\n\n为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉`custom:true`才会恢复渲染tabbar。\n\n所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。\n\n> 如果你知道有什么兼容办法，欢迎和我联系。","source":"_posts/miniprogram/custom-tabbar.md","raw":"---\ntitle: 小程序中实现自定义标签栏\ntags: \n- 小程序\n- 自定义组件\ndesc: 小程序如何自定义tabbar\ntoc: true\ncategories:\n- 小程序\ndate: 2020-3-29\n---\n\n## 前言\n\n由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。\n\n<!-- more -->\n\n因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：\n\n![](/blog/images/compare.jpg)\n\n## 分析\n\n原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。\n\n从 [小程序的官网文档](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar) 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：\n\n```json\n\"tabbar\": {\n    \"custom\": true\n}\n```\n \n设置了`custom`之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。\n\n而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）\n\n## 实践\n\n按照官网文档的描述，在根目录上创建组件的文件夹，命名`custom-tab-bar`，里面的文件和正常的组件保持一致。\n\n此时就可以将组件的样式和逻辑稍作调整：\n\n- 当进入首页时，背景色改成透明\n- 进入其他页面，背景色改回白色\n\n这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的`WXML`里显式引用。\n\n### 选中态\n\n由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？\n\n根据官网的描述，即是提供了接口`getTabBar`，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）\n\n需要在tabbar包含的每个页面的onShow里这样设置：\n\n```js\nPage({\n    onShow() {\n        if (typeof this.getTabBar === 'function') {\n            this.getTabBar().setData({ selected: 0 }) // 0代表第一个\n        }\n    }\n})\n```\n\n> 此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router\n\n### 兼容性\n\n为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉`custom:true`才会恢复渲染tabbar。\n\n所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。\n\n> 如果你知道有什么兼容办法，欢迎和我联系。","slug":"miniprogram/custom-tabbar","published":1,"updated":"2023-08-04T10:45:54.869Z","_id":"cky5ioqet0014n6694fi2336q","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。</p>\n<span id=\"more\"></span>\n\n<p>因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：</p>\n<p><img src=\"/blog/images/compare.jpg\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。</p>\n<p>从 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar\">小程序的官网文档</a> 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;tabbar&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;custom&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置了<code>custom</code>之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。</p>\n<p>而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>按照官网文档的描述，在根目录上创建组件的文件夹，命名<code>custom-tab-bar</code>，里面的文件和正常的组件保持一致。</p>\n<p>此时就可以将组件的样式和逻辑稍作调整：</p>\n<ul>\n<li>当进入首页时，背景色改成透明</li>\n<li>进入其他页面，背景色改回白色</li>\n</ul>\n<p>这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的<code>WXML</code>里显式引用。</p>\n<h3 id=\"选中态\"><a href=\"#选中态\" class=\"headerlink\" title=\"选中态\"></a>选中态</h3><p>由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？</p>\n<p>根据官网的描述，即是提供了接口<code>getTabBar</code>，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）</p>\n<p>需要在tabbar包含的每个页面的onShow里这样设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span>.getTabBar === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.getTabBar().setData(&#123; <span class=\"attr\">selected</span>: <span class=\"number\">0</span> &#125;) <span class=\"comment\">// 0代表第一个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router</p>\n</blockquote>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉<code>custom:true</code>才会恢复渲染tabbar。</p>\n<p>所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。</p>\n<blockquote>\n<p>如果你知道有什么兼容办法，欢迎和我联系。</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。</p>","more":"<p>因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：</p>\n<p><img src=\"/blog/images/compare.jpg\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。</p>\n<p>从 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar\">小程序的官网文档</a> 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;tabbar&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;custom&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置了<code>custom</code>之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。</p>\n<p>而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>按照官网文档的描述，在根目录上创建组件的文件夹，命名<code>custom-tab-bar</code>，里面的文件和正常的组件保持一致。</p>\n<p>此时就可以将组件的样式和逻辑稍作调整：</p>\n<ul>\n<li>当进入首页时，背景色改成透明</li>\n<li>进入其他页面，背景色改回白色</li>\n</ul>\n<p>这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的<code>WXML</code>里显式引用。</p>\n<h3 id=\"选中态\"><a href=\"#选中态\" class=\"headerlink\" title=\"选中态\"></a>选中态</h3><p>由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？</p>\n<p>根据官网的描述，即是提供了接口<code>getTabBar</code>，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）</p>\n<p>需要在tabbar包含的每个页面的onShow里这样设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">this</span>.getTabBar === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.getTabBar().setData(&#123; <span class=\"attr\">selected</span>: <span class=\"number\">0</span> &#125;) <span class=\"comment\">// 0代表第一个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router</p>\n</blockquote>\n<h3 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h3><p>为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉<code>custom:true</code>才会恢复渲染tabbar。</p>\n<p>所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。</p>\n<blockquote>\n<p>如果你知道有什么兼容办法，欢迎和我联系。</p>\n</blockquote>"},{"title":"编码规范的一些思考","desc":"如何制定前端的编码规范，以及前端工程化","toc":true,"date":"2020-04-11T16:00:00.000Z","_content":"\n## 引言\n\n古人常说，无规矩不成方圆。在编程的世界里也同样如此。\n\n从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。\n\n然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。\n\n<!-- more -->\n\n## 现实\n\n在笔者呆过的团队，似乎都在重蹈覆辙：\n- 一开始不重视文档、规范，快速启动，敏捷开发\n- 等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码\n- 由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码\n\n如此往复，无形中浪费了许多因修复历史代码而产生的工作量。\n\n笔者认为，有可能是以下几种原因导致这种现象：\n\n- 团队早期人员少，项目急，人力不足\n- 前端开发仍不够成熟，没可落地的完整方案\n- 经验不足，无法意识到规范的重要性\n\n## 范围\n\n我们常说的代码规范属于编码规范的子集。\n\n笔者理解的编码规范包括一下几种：\n- 代码规范\n- 文件规范\n- 项目结构规范\n\n其中，**代码规范** 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。\n\n代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。\n\n**文件规范** 则包含：文件的命名规范，以及文件的类型规范（如图片）。\n\n**项目结构规范** 是规范化项目的结构，有利于项目的可读性。\n\n由于篇幅有限，文本将主要阐述 **代码规范** 的制定与落地实施。\n\n## 前端的特殊性\n\n若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。\n\n但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：\n\n- 编程语言：JavaScript、CSS、HTML\n- 框架：Vue、React、Angular\n- runtime：Node.js、小程序、浏览器\n- 语法糖：CoffeeScript、TypeScript\n\n其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。\n\n上述的runtime和语法糖都是针对于`JavaScript`而言，因此确定`JavsScript`的代码规范是首要任务。\n\n> 最好的结果就是每个人写得代码都是一样的。\n\n## 快速开始\n\n导致团队的代码规范难以指定的一个很大原因就是无法快速开始。\n\n因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)\n\n通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。\n\n对于`JavaScript`来说，最强力的代码分析检测工具非`ESLint`莫属，其涵盖了代码质量和编码风格的检测。\n\n### ESLint\n\n![](/blog/images/code-guide/eslint.png)\n\nESLint官方有提供一个推荐方案，通过配置文件`.eslintrc`：\n\n```json\n{\n    \"extends\": \"eslint:recommended\"\n}\n```\n\n或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。\n\n使用`ESlint --init`即可开启交互式初始化ESLint配置。\n\n对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架`Vue`举例说明：\n\n`Vue`官方提供了ESLint的插件：[eslint-plugin-vue](https://eslint.vuejs.org/)\n\n通过此插件，可以利用ESLint检测`.vue`文件的`<template>`和`<script>`模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：\n\n```json\n{\n    \"extends\": \"plugin:vue/vue3-recommended\",\n    \"rules\": {\n\n    }\n}\n```\n\n> 另外，可以在`rules`里覆盖推荐的规范\n\n执行检测：\n\n```bash\nnpx eslint **/*.{js,vue}\n```\n\n### HTMLHint\n\n![](/blog/images/code-guide/htmlhint.png)\n\n因为`HTML`不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：[HTMLHint Rules](https://github.com/htmlhint/HTMLHint/wiki/Rules)\n\n通过配置文件`.htmlhintrc`配置，默认配置如下：\n\n```json\n{\n   \"tagname-lowercase\": true,\n    \"attr-lowercase\": true,\n    \"attr-value-double-quotes\": true,\n    \"doctype-first\": true,\n    \"tag-pair\": true,\n    \"spec-char-escape\": true,\n    \"id-unique\": true,\n    \"src-not-empty\": true,\n    \"attr-no-duplication\": true,\n    \"title-require\": true\n}\n```\n\n执行检测：\n\n```bash\nnpx htmlhint **/*.html\n```\n\n### stylelint\n\n![](/blog/images/code-guide/stylelint.png)\n\n`stylelint`是`CSS`的代码分析工具，类似于`ESLint`，`stylelint`也提供了 **标准配置(standard configuration)**，安装方式：\n\n```bash\nnpm install --save-dev stylelint stylelint-config-standard\n```\n\n在项目根目录创建配置文件`.stylelintrc.json`：\n\n```json\n{\n  \"extends\": \"stylelint-config-standard\"\n}\n```\n\n执行检测：\n\n```bash\nnpx stylelint \"**/*.css\"\n```\n\n## 实施方案\n\n如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以`GitLab`举例：\n\n每个仓库均可设置多个分支，在`GitLab`上对关键分支（比如`master`）的权限做严格把控，比如：\n\n- 不允许任何人直接push到关键分支（Allowed to push: No one)\n\n![](/blog/images/code-guide/protect-branch.png)\n\n- 仅允许通过pipeline的 **合并请求(merge requests)** 进行合并\n\n![](/blog/images/code-guide/merge-request.png)\n\n最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。\n\n## 总结\n\n编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。\n\n另外，需要切记的是，规范文档的落地不一定需要正式的`word`格式，`markdown`、`html`乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。","source":"_posts/miniprogram/code-style-guide.md","raw":"---\ntitle: 编码规范的一些思考\ntags: 编码规范\ndesc: 如何制定前端的编码规范，以及前端工程化\ntoc: true\ncategories:\n- JavaScript\ndate: 2020-4-12\n---\n\n## 引言\n\n古人常说，无规矩不成方圆。在编程的世界里也同样如此。\n\n从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。\n\n然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。\n\n<!-- more -->\n\n## 现实\n\n在笔者呆过的团队，似乎都在重蹈覆辙：\n- 一开始不重视文档、规范，快速启动，敏捷开发\n- 等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码\n- 由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码\n\n如此往复，无形中浪费了许多因修复历史代码而产生的工作量。\n\n笔者认为，有可能是以下几种原因导致这种现象：\n\n- 团队早期人员少，项目急，人力不足\n- 前端开发仍不够成熟，没可落地的完整方案\n- 经验不足，无法意识到规范的重要性\n\n## 范围\n\n我们常说的代码规范属于编码规范的子集。\n\n笔者理解的编码规范包括一下几种：\n- 代码规范\n- 文件规范\n- 项目结构规范\n\n其中，**代码规范** 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。\n\n代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。\n\n**文件规范** 则包含：文件的命名规范，以及文件的类型规范（如图片）。\n\n**项目结构规范** 是规范化项目的结构，有利于项目的可读性。\n\n由于篇幅有限，文本将主要阐述 **代码规范** 的制定与落地实施。\n\n## 前端的特殊性\n\n若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。\n\n但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：\n\n- 编程语言：JavaScript、CSS、HTML\n- 框架：Vue、React、Angular\n- runtime：Node.js、小程序、浏览器\n- 语法糖：CoffeeScript、TypeScript\n\n其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。\n\n上述的runtime和语法糖都是针对于`JavaScript`而言，因此确定`JavsScript`的代码规范是首要任务。\n\n> 最好的结果就是每个人写得代码都是一样的。\n\n## 快速开始\n\n导致团队的代码规范难以指定的一个很大原因就是无法快速开始。\n\n因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)\n\n通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。\n\n对于`JavaScript`来说，最强力的代码分析检测工具非`ESLint`莫属，其涵盖了代码质量和编码风格的检测。\n\n### ESLint\n\n![](/blog/images/code-guide/eslint.png)\n\nESLint官方有提供一个推荐方案，通过配置文件`.eslintrc`：\n\n```json\n{\n    \"extends\": \"eslint:recommended\"\n}\n```\n\n或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。\n\n使用`ESlint --init`即可开启交互式初始化ESLint配置。\n\n对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架`Vue`举例说明：\n\n`Vue`官方提供了ESLint的插件：[eslint-plugin-vue](https://eslint.vuejs.org/)\n\n通过此插件，可以利用ESLint检测`.vue`文件的`<template>`和`<script>`模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：\n\n```json\n{\n    \"extends\": \"plugin:vue/vue3-recommended\",\n    \"rules\": {\n\n    }\n}\n```\n\n> 另外，可以在`rules`里覆盖推荐的规范\n\n执行检测：\n\n```bash\nnpx eslint **/*.{js,vue}\n```\n\n### HTMLHint\n\n![](/blog/images/code-guide/htmlhint.png)\n\n因为`HTML`不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：[HTMLHint Rules](https://github.com/htmlhint/HTMLHint/wiki/Rules)\n\n通过配置文件`.htmlhintrc`配置，默认配置如下：\n\n```json\n{\n   \"tagname-lowercase\": true,\n    \"attr-lowercase\": true,\n    \"attr-value-double-quotes\": true,\n    \"doctype-first\": true,\n    \"tag-pair\": true,\n    \"spec-char-escape\": true,\n    \"id-unique\": true,\n    \"src-not-empty\": true,\n    \"attr-no-duplication\": true,\n    \"title-require\": true\n}\n```\n\n执行检测：\n\n```bash\nnpx htmlhint **/*.html\n```\n\n### stylelint\n\n![](/blog/images/code-guide/stylelint.png)\n\n`stylelint`是`CSS`的代码分析工具，类似于`ESLint`，`stylelint`也提供了 **标准配置(standard configuration)**，安装方式：\n\n```bash\nnpm install --save-dev stylelint stylelint-config-standard\n```\n\n在项目根目录创建配置文件`.stylelintrc.json`：\n\n```json\n{\n  \"extends\": \"stylelint-config-standard\"\n}\n```\n\n执行检测：\n\n```bash\nnpx stylelint \"**/*.css\"\n```\n\n## 实施方案\n\n如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以`GitLab`举例：\n\n每个仓库均可设置多个分支，在`GitLab`上对关键分支（比如`master`）的权限做严格把控，比如：\n\n- 不允许任何人直接push到关键分支（Allowed to push: No one)\n\n![](/blog/images/code-guide/protect-branch.png)\n\n- 仅允许通过pipeline的 **合并请求(merge requests)** 进行合并\n\n![](/blog/images/code-guide/merge-request.png)\n\n最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。\n\n## 总结\n\n编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。\n\n另外，需要切记的是，规范文档的落地不一定需要正式的`word`格式，`markdown`、`html`乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。","slug":"miniprogram/code-style-guide","published":1,"updated":"2023-08-04T10:48:11.088Z","_id":"cky5ioqet0016n66963gx6id4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>古人常说，无规矩不成方圆。在编程的世界里也同样如此。</p>\n<p>从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。</p>\n<p>然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"现实\"><a href=\"#现实\" class=\"headerlink\" title=\"现实\"></a>现实</h2><p>在笔者呆过的团队，似乎都在重蹈覆辙：</p>\n<ul>\n<li>一开始不重视文档、规范，快速启动，敏捷开发</li>\n<li>等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码</li>\n<li>由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码</li>\n</ul>\n<p>如此往复，无形中浪费了许多因修复历史代码而产生的工作量。</p>\n<p>笔者认为，有可能是以下几种原因导致这种现象：</p>\n<ul>\n<li>团队早期人员少，项目急，人力不足</li>\n<li>前端开发仍不够成熟，没可落地的完整方案</li>\n<li>经验不足，无法意识到规范的重要性</li>\n</ul>\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><p>我们常说的代码规范属于编码规范的子集。</p>\n<p>笔者理解的编码规范包括一下几种：</p>\n<ul>\n<li>代码规范</li>\n<li>文件规范</li>\n<li>项目结构规范</li>\n</ul>\n<p>其中，<strong>代码规范</strong> 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。</p>\n<p>代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。</p>\n<p><strong>文件规范</strong> 则包含：文件的命名规范，以及文件的类型规范（如图片）。</p>\n<p><strong>项目结构规范</strong> 是规范化项目的结构，有利于项目的可读性。</p>\n<p>由于篇幅有限，文本将主要阐述 <strong>代码规范</strong> 的制定与落地实施。</p>\n<h2 id=\"前端的特殊性\"><a href=\"#前端的特殊性\" class=\"headerlink\" title=\"前端的特殊性\"></a>前端的特殊性</h2><p>若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。</p>\n<p>但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：</p>\n<ul>\n<li>编程语言：JavaScript、CSS、HTML</li>\n<li>框架：Vue、React、Angular</li>\n<li>runtime：Node.js、小程序、浏览器</li>\n<li>语法糖：CoffeeScript、TypeScript</li>\n</ul>\n<p>其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。</p>\n<p>上述的runtime和语法糖都是针对于<code>JavaScript</code>而言，因此确定<code>JavsScript</code>的代码规范是首要任务。</p>\n<blockquote>\n<p>最好的结果就是每个人写得代码都是一样的。</p>\n</blockquote>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>导致团队的代码规范难以指定的一个很大原因就是无法快速开始。</p>\n<p>因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)</p>\n<p>通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。</p>\n<p>对于<code>JavaScript</code>来说，最强力的代码分析检测工具非<code>ESLint</code>莫属，其涵盖了代码质量和编码风格的检测。</p>\n<h3 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p><img src=\"/blog/images/code-guide/eslint.png\"></p>\n<p>ESLint官方有提供一个推荐方案，通过配置文件<code>.eslintrc</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;eslint:recommended&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。</p>\n<p>使用<code>ESlint --init</code>即可开启交互式初始化ESLint配置。</p>\n<p>对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架<code>Vue</code>举例说明：</p>\n<p><code>Vue</code>官方提供了ESLint的插件：<a href=\"https://eslint.vuejs.org/\">eslint-plugin-vue</a></p>\n<p>通过此插件，可以利用ESLint检测<code>.vue</code>文件的<code>&lt;template&gt;</code>和<code>&lt;script&gt;</code>模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;plugin:vue/vue3-recommended&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;rules&quot;</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外，可以在<code>rules</code>里覆盖推荐的规范</p>\n</blockquote>\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx eslint **/*.&#123;js,vue&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMLHint\"><a href=\"#HTMLHint\" class=\"headerlink\" title=\"HTMLHint\"></a>HTMLHint</h3><p><img src=\"/blog/images/code-guide/htmlhint.png\"></p>\n<p>因为<code>HTML</code>不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：<a href=\"https://github.com/htmlhint/HTMLHint/wiki/Rules\">HTMLHint Rules</a></p>\n<p>通过配置文件<code>.htmlhintrc</code>配置，默认配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">&quot;tagname-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-value-double-quotes&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;doctype-first&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;tag-pair&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;spec-char-escape&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;id-unique&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;src-not-empty&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-no-duplication&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;title-require&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx htmlhint **/*.html</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"stylelint\"><a href=\"#stylelint\" class=\"headerlink\" title=\"stylelint\"></a>stylelint</h3><p><img src=\"/blog/images/code-guide/stylelint.png\"></p>\n<p><code>stylelint</code>是<code>CSS</code>的代码分析工具，类似于<code>ESLint</code>，<code>stylelint</code>也提供了 **标准配置(standard configuration)**，安装方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev stylelint stylelint-config-standard</span><br></pre></td></tr></table></figure>\n\n<p>在项目根目录创建配置文件<code>.stylelintrc.json</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;stylelint-config-standard&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx stylelint <span class=\"string\">&quot;**/*.css&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h2><p>如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以<code>GitLab</code>举例：</p>\n<p>每个仓库均可设置多个分支，在<code>GitLab</code>上对关键分支（比如<code>master</code>）的权限做严格把控，比如：</p>\n<ul>\n<li>不允许任何人直接push到关键分支（Allowed to push: No one)</li>\n</ul>\n<p><img src=\"/blog/images/code-guide/protect-branch.png\"></p>\n<ul>\n<li>仅允许通过pipeline的 <strong>合并请求(merge requests)</strong> 进行合并</li>\n</ul>\n<p><img src=\"/blog/images/code-guide/merge-request.png\"></p>\n<p>最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。</p>\n<p>另外，需要切记的是，规范文档的落地不一定需要正式的<code>word</code>格式，<code>markdown</code>、<code>html</code>乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>古人常说，无规矩不成方圆。在编程的世界里也同样如此。</p>\n<p>从编程语言，到文件的命名，再上升到项目结构都可以提供相关的规范。</p>\n<p>然而，规范的落地往往都会晚于项目的启动，因此每个团队都会有历史代码需要处理，这是工程师无法逾越，也是心中无法抹去的痛苦。</p>","more":"<h2 id=\"现实\"><a href=\"#现实\" class=\"headerlink\" title=\"现实\"></a>现实</h2><p>在笔者呆过的团队，似乎都在重蹈覆辙：</p>\n<ul>\n<li>一开始不重视文档、规范，快速启动，敏捷开发</li>\n<li>等团队日益壮大，开始制定规范，而此时已经存在大量的历史遗留的问题代码</li>\n<li>由于团队会有些人员变动，因此会出现一些无人认领的孤儿代码</li>\n</ul>\n<p>如此往复，无形中浪费了许多因修复历史代码而产生的工作量。</p>\n<p>笔者认为，有可能是以下几种原因导致这种现象：</p>\n<ul>\n<li>团队早期人员少，项目急，人力不足</li>\n<li>前端开发仍不够成熟，没可落地的完整方案</li>\n<li>经验不足，无法意识到规范的重要性</li>\n</ul>\n<h2 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h2><p>我们常说的代码规范属于编码规范的子集。</p>\n<p>笔者理解的编码规范包括一下几种：</p>\n<ul>\n<li>代码规范</li>\n<li>文件规范</li>\n<li>项目结构规范</li>\n</ul>\n<p>其中，<strong>代码规范</strong> 并不是编写有效的代码硬性规定，而是统一代码风格、避免出错的最佳实践。</p>\n<p>代码规范往往含有主观性（比如在JavaScript是否需要分号），孰是孰非可以讨论很久，因此建议小范围投票，快速决定，坚决执行即可。</p>\n<p><strong>文件规范</strong> 则包含：文件的命名规范，以及文件的类型规范（如图片）。</p>\n<p><strong>项目结构规范</strong> 是规范化项目的结构，有利于项目的可读性。</p>\n<p>由于篇幅有限，文本将主要阐述 <strong>代码规范</strong> 的制定与落地实施。</p>\n<h2 id=\"前端的特殊性\"><a href=\"#前端的特殊性\" class=\"headerlink\" title=\"前端的特殊性\"></a>前端的特殊性</h2><p>若是其他岗位，可能就涉及一种编程语言，因此确定一种代码规范即可。</p>\n<p>但是前端，涉及到编程语言相对较多，并且不同框架或者runtime也可能导致不同的语法风格，因此需要覆盖的规范也比较多：</p>\n<ul>\n<li>编程语言：JavaScript、CSS、HTML</li>\n<li>框架：Vue、React、Angular</li>\n<li>runtime：Node.js、小程序、浏览器</li>\n<li>语法糖：CoffeeScript、TypeScript</li>\n</ul>\n<p>其中JavaScript是一种极度灵活，约束较少，弱类型的动态编程语言，也是前端开发的主要语言。如果不对编码的风格做一定的约束，必然出现千差万别的风格，虽然都是正确可执行的代码，但这会让代码的可阅读性非常差。</p>\n<p>上述的runtime和语法糖都是针对于<code>JavaScript</code>而言，因此确定<code>JavsScript</code>的代码规范是首要任务。</p>\n<blockquote>\n<p>最好的结果就是每个人写得代码都是一样的。</p>\n</blockquote>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>导致团队的代码规范难以指定的一个很大原因就是无法快速开始。</p>\n<p>因此笔者提供一种思路：工具驱动规范(Tool Drive Specification)</p>\n<p>通过现有的代码检测工具，反向推到出代码的规范，即有可实施的检测工具，又有了现成的文档，一举两得。</p>\n<p>对于<code>JavaScript</code>来说，最强力的代码分析检测工具非<code>ESLint</code>莫属，其涵盖了代码质量和编码风格的检测。</p>\n<h3 id=\"ESLint\"><a href=\"#ESLint\" class=\"headerlink\" title=\"ESLint\"></a>ESLint</h3><p><img src=\"/blog/images/code-guide/eslint.png\"></p>\n<p>ESLint官方有提供一个推荐方案，通过配置文件<code>.eslintrc</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;eslint:recommended&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者采用业界比较出名的公司规范也可以，比如：Google、Airbnb。</p>\n<p>使用<code>ESlint --init</code>即可开启交互式初始化ESLint配置。</p>\n<p>对于不同的runtime、语法糖和框架而言，都可以使用ESLint作为检测工具，其中的差异则是需要依赖不同的第三方插件来扩展检测能力。以下以团队的首选框架<code>Vue</code>举例说明：</p>\n<p><code>Vue</code>官方提供了ESLint的插件：<a href=\"https://eslint.vuejs.org/\">eslint-plugin-vue</a></p>\n<p>通过此插件，可以利用ESLint检测<code>.vue</code>文件的<code>&lt;template&gt;</code>和<code>&lt;script&gt;</code>模块，检测语法错误，以及编码风格。同样地，插件也有推荐的配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;plugin:vue/vue3-recommended&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;rules&quot;</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外，可以在<code>rules</code>里覆盖推荐的规范</p>\n</blockquote>\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx eslint **/*.&#123;js,vue&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMLHint\"><a href=\"#HTMLHint\" class=\"headerlink\" title=\"HTMLHint\"></a>HTMLHint</h3><p><img src=\"/blog/images/code-guide/htmlhint.png\"></p>\n<p>因为<code>HTML</code>不算真正的编程语言，而是标记语言，因此可以检测的规范不会太多，因此可以手动梳理一便，同时也支持自定义规则。全部的规则：<a href=\"https://github.com/htmlhint/HTMLHint/wiki/Rules\">HTMLHint Rules</a></p>\n<p>通过配置文件<code>.htmlhintrc</code>配置，默认配置如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">&quot;tagname-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-lowercase&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-value-double-quotes&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;doctype-first&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;tag-pair&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;spec-char-escape&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;id-unique&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;src-not-empty&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;attr-no-duplication&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;title-require&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx htmlhint **/*.html</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"stylelint\"><a href=\"#stylelint\" class=\"headerlink\" title=\"stylelint\"></a>stylelint</h3><p><img src=\"/blog/images/code-guide/stylelint.png\"></p>\n<p><code>stylelint</code>是<code>CSS</code>的代码分析工具，类似于<code>ESLint</code>，<code>stylelint</code>也提供了 **标准配置(standard configuration)**，安装方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev stylelint stylelint-config-standard</span><br></pre></td></tr></table></figure>\n\n<p>在项目根目录创建配置文件<code>.stylelintrc.json</code>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;extends&quot;</span>: <span class=\"string\">&quot;stylelint-config-standard&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行检测：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx stylelint <span class=\"string\">&quot;**/*.css&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h2><p>如果只是制定的代码规范文档，但是没有可实施方案，依靠人为的自觉，必然出现不遵守规则的漏网之鱼。因此，必须落地实施方案，拒绝不符合规范的代码合入代码仓库。以<code>GitLab</code>举例：</p>\n<p>每个仓库均可设置多个分支，在<code>GitLab</code>上对关键分支（比如<code>master</code>）的权限做严格把控，比如：</p>\n<ul>\n<li>不允许任何人直接push到关键分支（Allowed to push: No one)</li>\n</ul>\n<p><img src=\"/blog/images/code-guide/protect-branch.png\"></p>\n<ul>\n<li>仅允许通过pipeline的 <strong>合并请求(merge requests)</strong> 进行合并</li>\n</ul>\n<p><img src=\"/blog/images/code-guide/merge-request.png\"></p>\n<p>最后在pipeline中添加一个Job：执行以上检测脚本。如果代码有不符合规范，则会直接报错从而终止代码继续合并。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编码规范的重要性在团队建设的前期，往往容易被忽略，带来的后果是需要消耗更多的时间去掩埋一开始挖的坑。并且在无规范的混沌时期，不同的代码风格导致的代码可读性下降，会无形中加重了开发的负担，降低了开发效率。</p>\n<p>另外，需要切记的是，规范文档的落地不一定需要正式的<code>word</code>格式，<code>markdown</code>、<code>html</code>乃至于配置文件的格式都是可以接受的。重要的是代码规范有落地的检测工具。</p>"},{"title":"浅谈小程序的框架设计","desc":"小程序如何设计框架","toc":true,"date":"2020-03-27T16:00:00.000Z","_content":"\n## 前言\n\n其实说是框架设计，有点“夸大其词”。\n\n实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。\n\n<!-- more -->\n\n## 封装Page\n\n对小程序的`Page`进行封装，是一个框架的基础，也是解决许多通用问题的利刃。\n\n如每个页面都需要设置分享`onShareAppMessage`，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装`Page`。\n\n一种方案是，通过`Page`来定义一个新的`Page`，如：`JPage`，然后每个页面不再使用`Page`注册页面，而是使用`JPage`。\n\n还有一种更好的方案，也是我所采取的方案：**劫持Page**。以至于不用改变每个页面的注册方式：\n\n```js\n// app.js\n\nlet realPage = Page\nPage = function Page(obj) {\n    let defaultPageConfig = {\n        onShareAppMessage() {\n            return {\n                title: '这里有很多有趣的壁纸',\n                path: `/pages/index/index`,\n                imageUrl: 'http://resoure.africans.cn/1.jpg',\n            }\n        }\n    }\n    return realPage({ ...defaultPageConfig, ...obj })\n}\n```\n\n这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：\n\n如果使用过 **云开发** 的读者，应该知道 **获取集合** 的步骤是这样的：\n\n```js\nlet db = wx.cloud.database()\nlet table = db.collection('wallpapers')\n```\n\n可以将这个 获取集合 的方法抽象成这样:\n\n```js\nlet getTable = (tableName) => {\n    let db = wx.cloud.database()\n    return db.collection(tableName)\n}\n```\n\n将这个方法放在`defaultPageConfig`里，以后每个页面都可以这样获取集合：\n\n```js\nthis.getTable('wallpapers')\n```\n\n## 环境\n\n每个小程序都有三种版本：开发版、体验版、正式版。\n\n往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？\n\n微信官网提供了 [wx.getAccountInfoSync](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html)，为了避免在`Page`对象里冗余太多信息，因此`env`添加至`App`：\n\n```js\nApp({\n    env: (function() {\n        let { miniProgram } = wx.getAccountInfoSync()\n        return miniProgram.envVersion\n    }())\n})\n```\n\n> 需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案\n\n\n后续可以这样使用：\n\n```js\nlet app = getApp()\nconsole.log(app.env) // develop\n```\n## 设备信息\n\n由于每个用户进入小程序之后，设备信息不可能发生变更。\n\n但在每个`Page`都封装这个信息会有点冗余，因此可以放进`App`里：\n\n```js\nApp({\n    getSystemInfo() {\n        let info = wx.getSystemInfoSync()\n\n        this.getSystemInfo = () => info\n        return info\n    }\n})\n```\n\n> 采用了缓存的机制，第一次调用时，调用`getSystemInfoSync`获取，第二次就直接返回缓存的设备信息了","source":"_posts/miniprogram/frame-design.md","raw":"---\ntitle: 浅谈小程序的框架设计\ntags: \n- 小程序\ndesc: 小程序如何设计框架\ntoc: true\ncategories:\n- 小程序\ndate: 2020-3-28\n---\n\n## 前言\n\n其实说是框架设计，有点“夸大其词”。\n\n实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。\n\n<!-- more -->\n\n## 封装Page\n\n对小程序的`Page`进行封装，是一个框架的基础，也是解决许多通用问题的利刃。\n\n如每个页面都需要设置分享`onShareAppMessage`，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装`Page`。\n\n一种方案是，通过`Page`来定义一个新的`Page`，如：`JPage`，然后每个页面不再使用`Page`注册页面，而是使用`JPage`。\n\n还有一种更好的方案，也是我所采取的方案：**劫持Page**。以至于不用改变每个页面的注册方式：\n\n```js\n// app.js\n\nlet realPage = Page\nPage = function Page(obj) {\n    let defaultPageConfig = {\n        onShareAppMessage() {\n            return {\n                title: '这里有很多有趣的壁纸',\n                path: `/pages/index/index`,\n                imageUrl: 'http://resoure.africans.cn/1.jpg',\n            }\n        }\n    }\n    return realPage({ ...defaultPageConfig, ...obj })\n}\n```\n\n这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：\n\n如果使用过 **云开发** 的读者，应该知道 **获取集合** 的步骤是这样的：\n\n```js\nlet db = wx.cloud.database()\nlet table = db.collection('wallpapers')\n```\n\n可以将这个 获取集合 的方法抽象成这样:\n\n```js\nlet getTable = (tableName) => {\n    let db = wx.cloud.database()\n    return db.collection(tableName)\n}\n```\n\n将这个方法放在`defaultPageConfig`里，以后每个页面都可以这样获取集合：\n\n```js\nthis.getTable('wallpapers')\n```\n\n## 环境\n\n每个小程序都有三种版本：开发版、体验版、正式版。\n\n往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？\n\n微信官网提供了 [wx.getAccountInfoSync](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html)，为了避免在`Page`对象里冗余太多信息，因此`env`添加至`App`：\n\n```js\nApp({\n    env: (function() {\n        let { miniProgram } = wx.getAccountInfoSync()\n        return miniProgram.envVersion\n    }())\n})\n```\n\n> 需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案\n\n\n后续可以这样使用：\n\n```js\nlet app = getApp()\nconsole.log(app.env) // develop\n```\n## 设备信息\n\n由于每个用户进入小程序之后，设备信息不可能发生变更。\n\n但在每个`Page`都封装这个信息会有点冗余，因此可以放进`App`里：\n\n```js\nApp({\n    getSystemInfo() {\n        let info = wx.getSystemInfoSync()\n\n        this.getSystemInfo = () => info\n        return info\n    }\n})\n```\n\n> 采用了缓存的机制，第一次调用时，调用`getSystemInfoSync`获取，第二次就直接返回缓存的设备信息了","slug":"miniprogram/frame-design","published":1,"updated":"2023-08-04T10:45:18.563Z","_id":"cky5ioqeu0019n669gy528ksl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实说是框架设计，有点“夸大其词”。</p>\n<p>实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"封装Page\"><a href=\"#封装Page\" class=\"headerlink\" title=\"封装Page\"></a>封装Page</h2><p>对小程序的<code>Page</code>进行封装，是一个框架的基础，也是解决许多通用问题的利刃。</p>\n<p>如每个页面都需要设置分享<code>onShareAppMessage</code>，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装<code>Page</code>。</p>\n<p>一种方案是，通过<code>Page</code>来定义一个新的<code>Page</code>，如：<code>JPage</code>，然后每个页面不再使用<code>Page</code>注册页面，而是使用<code>JPage</code>。</p>\n<p>还有一种更好的方案，也是我所采取的方案：<strong>劫持Page</strong>。以至于不用改变每个页面的注册方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> realPage = Page</span><br><span class=\"line\">Page = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Page</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultPageConfig = &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShareAppMessage</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;这里有很多有趣的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">`/pages/index/index`</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;http://resoure.africans.cn/1.jpg&#x27;</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> realPage(&#123; ...defaultPageConfig, ...obj &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：</p>\n<p>如果使用过 <strong>云开发</strong> 的读者，应该知道 <strong>获取集合</strong> 的步骤是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\"><span class=\"keyword\">let</span> table = db.collection(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以将这个 获取集合 的方法抽象成这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getTable = <span class=\"function\">(<span class=\"params\">tableName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db.collection(tableName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将这个方法放在<code>defaultPageConfig</code>里，以后每个页面都可以这样获取集合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.getTable(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>每个小程序都有三种版本：开发版、体验版、正式版。</p>\n<p>往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？</p>\n<p>微信官网提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html\">wx.getAccountInfoSync</a>，为了避免在<code>Page</code>对象里冗余太多信息，因此<code>env</code>添加至<code>App</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"attr\">env</span>: (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; miniProgram &#125; = wx.getAccountInfoSync()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> miniProgram.envVersion</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案</p>\n</blockquote>\n<p>后续可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> app = getApp()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(app.env) <span class=\"comment\">// develop</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"设备信息\"><a href=\"#设备信息\" class=\"headerlink\" title=\"设备信息\"></a>设备信息</h2><p>由于每个用户进入小程序之后，设备信息不可能发生变更。</p>\n<p>但在每个<code>Page</code>都封装这个信息会有点冗余，因此可以放进<code>App</code>里：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getSystemInfo</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> info = wx.getSystemInfoSync()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.getSystemInfo = <span class=\"function\">() =&gt;</span> info</span><br><span class=\"line\">        <span class=\"keyword\">return</span> info</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>采用了缓存的机制，第一次调用时，调用<code>getSystemInfoSync</code>获取，第二次就直接返回缓存的设备信息了</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实说是框架设计，有点“夸大其词”。</p>\n<p>实际上是，将在开发当中遇到的问题，统一抽象，通过全局封装的方式解决。而这样封装处理，就称为了我所称的“框架”。</p>","more":"<h2 id=\"封装Page\"><a href=\"#封装Page\" class=\"headerlink\" title=\"封装Page\"></a>封装Page</h2><p>对小程序的<code>Page</code>进行封装，是一个框架的基础，也是解决许多通用问题的利刃。</p>\n<p>如每个页面都需要设置分享<code>onShareAppMessage</code>，而分享信息大概率是一致的，那么应该如果有效地处理呢？我想到的最佳实践就是封装<code>Page</code>。</p>\n<p>一种方案是，通过<code>Page</code>来定义一个新的<code>Page</code>，如：<code>JPage</code>，然后每个页面不再使用<code>Page</code>注册页面，而是使用<code>JPage</code>。</p>\n<p>还有一种更好的方案，也是我所采取的方案：<strong>劫持Page</strong>。以至于不用改变每个页面的注册方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> realPage = Page</span><br><span class=\"line\">Page = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Page</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultPageConfig = &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShareAppMessage</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;这里有很多有趣的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">`/pages/index/index`</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;http://resoure.africans.cn/1.jpg&#x27;</span>,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> realPage(&#123; ...defaultPageConfig, ...obj &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样封装，我们后续可以做很多优化，如抽象通用的方法，举个例子：</p>\n<p>如果使用过 <strong>云开发</strong> 的读者，应该知道 <strong>获取集合</strong> 的步骤是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\"><span class=\"keyword\">let</span> table = db.collection(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以将这个 获取集合 的方法抽象成这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getTable = <span class=\"function\">(<span class=\"params\">tableName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> db = wx.cloud.database()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db.collection(tableName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将这个方法放在<code>defaultPageConfig</code>里，以后每个页面都可以这样获取集合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.getTable(<span class=\"string\">&#x27;wallpapers&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>每个小程序都有三种版本：开发版、体验版、正式版。</p>\n<p>往往我们会有这样的需要，如不同环境请求不同的服务器。那我们要如何区分这些环境呢？</p>\n<p>微信官网提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html\">wx.getAccountInfoSync</a>，为了避免在<code>Page</code>对象里冗余太多信息，因此<code>env</code>添加至<code>App</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"attr\">env</span>: (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; miniProgram &#125; = wx.getAccountInfoSync()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> miniProgram.envVersion</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，该API仅支持基础库2.2.2以上版本，以下版本目前没有解决方案</p>\n</blockquote>\n<p>后续可以这样使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> app = getApp()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(app.env) <span class=\"comment\">// develop</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"设备信息\"><a href=\"#设备信息\" class=\"headerlink\" title=\"设备信息\"></a>设备信息</h2><p>由于每个用户进入小程序之后，设备信息不可能发生变更。</p>\n<p>但在每个<code>Page</code>都封装这个信息会有点冗余，因此可以放进<code>App</code>里：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getSystemInfo</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> info = wx.getSystemInfoSync()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.getSystemInfo = <span class=\"function\">() =&gt;</span> info</span><br><span class=\"line\">        <span class=\"keyword\">return</span> info</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>采用了缓存的机制，第一次调用时，调用<code>getSystemInfoSync</code>获取，第二次就直接返回缓存的设备信息了</p>\n</blockquote>"},{"title":"小程序如何管理全局变量","desc":"小程序的全局变量要如何管理","date":"2020-04-06T16:00:00.000Z","toc":true,"_content":"\n## 前言\n\n> 在浏览器的环境下有一个全局变量：`window`。\n若定义变量时，遗漏了`var`，此时声明的变量就变成了全局变量，自动挂载到`window`下，可当做`window`的属性来访问，也可以直接访问。\n\n小程序的底层也是通过Web实现的，因此同样存在`window`对象，但是微信团队做了些处理：\n\n![](/blog/images/global-window.png)\n\n微信团队将`window`设置成了`writable:false`，且值也为`undefined`。\n\n即我们无法像在`web`那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的`wx`、`global`。\n\n<!-- more -->\n\n## 问题\n\n虽然`window`是只读的，但是`global`是可写的:\n\n![](/blog/images/global-global.png)\n\n因此常见的做法，就是将需要全局访问的变量都保存到`global`下，间接声明了全局变量。\n\n全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。\n\n另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。\n\n> 同理，setStorage也存在同样的问题。\n\n## 思考\n\n简单地将这些变量改成`readonly`肯定是不可取的，这影响了日常的开发。\n\n在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：\n\n- 命名空间\n- 模块化\n\n其中 **模块化** 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。\n\n因此 **命名空间** 是可以深入探索的思路。\n\n## 实践\n\n### 命名空间\n\n命名空间是一种常用的代码组织形式。\n\n大致做法是，先通过命名分配空间，再使用空间。\n\n> 我的习惯是，用业务或者功能来命名空间\n\n```js\nglobal.localStorage = {\n    doSet() {},\n    doGet() {},\n    doClear() {}\n}\n\nglobal.util = {\n    format() {},\n    valide() {}\n}\n```\n\n命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。\n\n### Symbol\n\n`Symbol`是ES2015中新增的基本数据类型。这个类型有个特别之处，每个`Symbol()`返回的值都是独一无二的，举个例子：\n\n```js\nSymbol('foo') === Symbol('foo') // false\n```\n\n因此通过`Symbol`的方式，可以完美避免变量被覆盖：\n\n```js\n// car.js\nlet car = Symbol()\nglobal[car] = {}\n\n// health.js\nlet health = Symbol()\nglobal[health] = {}\n```\n\n由于每个`Symbol`返回的值是唯一的，因此这个`Symbol`可以单独保存，以便各个文件引用。\n\n> 由于 `Symbol` 属于新特性，因此需要关注下兼容性\n\n![](/blog/images/compatibility-symbol.jpg)\n\n### 管理声明\n\n通过`Symbol`的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。\n\n我想到的办法就是给 `global` 增加个代理，对 `global` 的任何操作，都先经过代理检测，这样就有了强力的保障。\n\n因此，可以使用新特性：`Proxy` 来监听 `global` 的变更，举例说明：\n\n```js\nglobal = new Proxy(global, {\n    set(obj, prop, val) {\n        if (prop in obj) {\n            throw new TypeError(`${prop}: 该属性已定义！`)\n        }\n\n        // 可以做其他策略\n        // 或者上报数据，让你知道有哪些人偷偷定义了全局对象\n        obj[prop] = val\n        return true\n    },\n})\n```\n\n> 由于 `Proxy` 属于新特性，因此需要关注下兼容性\n\n![](/blog/images/compatibility-proxy.jpg)\n\n## 总结\n\n使用 `Proxy` 之后，能对 `global` 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。","source":"_posts/miniprogram/global-data-manage.md","raw":"---\ntitle: 小程序如何管理全局变量\ntags: 小程序\ndesc: 小程序的全局变量要如何管理\ndate: 2020-4-7\ntoc: true\ncategories:\n- 小程序\n---\n\n## 前言\n\n> 在浏览器的环境下有一个全局变量：`window`。\n若定义变量时，遗漏了`var`，此时声明的变量就变成了全局变量，自动挂载到`window`下，可当做`window`的属性来访问，也可以直接访问。\n\n小程序的底层也是通过Web实现的，因此同样存在`window`对象，但是微信团队做了些处理：\n\n![](/blog/images/global-window.png)\n\n微信团队将`window`设置成了`writable:false`，且值也为`undefined`。\n\n即我们无法像在`web`那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的`wx`、`global`。\n\n<!-- more -->\n\n## 问题\n\n虽然`window`是只读的，但是`global`是可写的:\n\n![](/blog/images/global-global.png)\n\n因此常见的做法，就是将需要全局访问的变量都保存到`global`下，间接声明了全局变量。\n\n全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。\n\n另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。\n\n> 同理，setStorage也存在同样的问题。\n\n## 思考\n\n简单地将这些变量改成`readonly`肯定是不可取的，这影响了日常的开发。\n\n在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：\n\n- 命名空间\n- 模块化\n\n其中 **模块化** 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。\n\n因此 **命名空间** 是可以深入探索的思路。\n\n## 实践\n\n### 命名空间\n\n命名空间是一种常用的代码组织形式。\n\n大致做法是，先通过命名分配空间，再使用空间。\n\n> 我的习惯是，用业务或者功能来命名空间\n\n```js\nglobal.localStorage = {\n    doSet() {},\n    doGet() {},\n    doClear() {}\n}\n\nglobal.util = {\n    format() {},\n    valide() {}\n}\n```\n\n命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。\n\n### Symbol\n\n`Symbol`是ES2015中新增的基本数据类型。这个类型有个特别之处，每个`Symbol()`返回的值都是独一无二的，举个例子：\n\n```js\nSymbol('foo') === Symbol('foo') // false\n```\n\n因此通过`Symbol`的方式，可以完美避免变量被覆盖：\n\n```js\n// car.js\nlet car = Symbol()\nglobal[car] = {}\n\n// health.js\nlet health = Symbol()\nglobal[health] = {}\n```\n\n由于每个`Symbol`返回的值是唯一的，因此这个`Symbol`可以单独保存，以便各个文件引用。\n\n> 由于 `Symbol` 属于新特性，因此需要关注下兼容性\n\n![](/blog/images/compatibility-symbol.jpg)\n\n### 管理声明\n\n通过`Symbol`的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。\n\n我想到的办法就是给 `global` 增加个代理，对 `global` 的任何操作，都先经过代理检测，这样就有了强力的保障。\n\n因此，可以使用新特性：`Proxy` 来监听 `global` 的变更，举例说明：\n\n```js\nglobal = new Proxy(global, {\n    set(obj, prop, val) {\n        if (prop in obj) {\n            throw new TypeError(`${prop}: 该属性已定义！`)\n        }\n\n        // 可以做其他策略\n        // 或者上报数据，让你知道有哪些人偷偷定义了全局对象\n        obj[prop] = val\n        return true\n    },\n})\n```\n\n> 由于 `Proxy` 属于新特性，因此需要关注下兼容性\n\n![](/blog/images/compatibility-proxy.jpg)\n\n## 总结\n\n使用 `Proxy` 之后，能对 `global` 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。","slug":"miniprogram/global-data-manage","published":1,"updated":"2023-08-04T10:46:54.613Z","_id":"cky5ioqev001cn669bv0z1rc6","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>在浏览器的环境下有一个全局变量：<code>window</code>。<br>若定义变量时，遗漏了<code>var</code>，此时声明的变量就变成了全局变量，自动挂载到<code>window</code>下，可当做<code>window</code>的属性来访问，也可以直接访问。</p>\n</blockquote>\n<p>小程序的底层也是通过Web实现的，因此同样存在<code>window</code>对象，但是微信团队做了些处理：</p>\n<p><img src=\"/blog/images/global-window.png\"></p>\n<p>微信团队将<code>window</code>设置成了<code>writable:false</code>，且值也为<code>undefined</code>。</p>\n<p>即我们无法像在<code>web</code>那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的<code>wx</code>、<code>global</code>。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>虽然<code>window</code>是只读的，但是<code>global</code>是可写的:</p>\n<p><img src=\"/blog/images/global-global.png\"></p>\n<p>因此常见的做法，就是将需要全局访问的变量都保存到<code>global</code>下，间接声明了全局变量。</p>\n<p>全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。</p>\n<p>另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。</p>\n<blockquote>\n<p>同理，setStorage也存在同样的问题。</p>\n</blockquote>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>简单地将这些变量改成<code>readonly</code>肯定是不可取的，这影响了日常的开发。</p>\n<p>在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：</p>\n<ul>\n<li>命名空间</li>\n<li>模块化</li>\n</ul>\n<p>其中 <strong>模块化</strong> 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。</p>\n<p>因此 <strong>命名空间</strong> 是可以深入探索的思路。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>命名空间是一种常用的代码组织形式。</p>\n<p>大致做法是，先通过命名分配空间，再使用空间。</p>\n<blockquote>\n<p>我的习惯是，用业务或者功能来命名空间</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span>.localStorage = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doSet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doGet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doClear</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.util = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">format</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">valide</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。</p>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p><code>Symbol</code>是ES2015中新增的基本数据类型。这个类型有个特别之处，每个<code>Symbol()</code>返回的值都是独一无二的，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>因此通过<code>Symbol</code>的方式，可以完美避免变量被覆盖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// car.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[car] = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// health.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> health = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[health] = &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于每个<code>Symbol</code>返回的值是唯一的，因此这个<code>Symbol</code>可以单独保存，以便各个文件引用。</p>\n<blockquote>\n<p>由于 <code>Symbol</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/blog/images/compatibility-symbol.jpg\"></p>\n<h3 id=\"管理声明\"><a href=\"#管理声明\" class=\"headerlink\" title=\"管理声明\"></a>管理声明</h3><p>通过<code>Symbol</code>的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。</p>\n<p>我想到的办法就是给 <code>global</code> 增加个代理，对 <code>global</code> 的任何操作，都先经过代理检测，这样就有了强力的保障。</p>\n<p>因此，可以使用新特性：<code>Proxy</code> 来监听 <code>global</code> 的变更，举例说明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(<span class=\"built_in\">global</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">obj, prop, val</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">`<span class=\"subst\">$&#123;prop&#125;</span>: 该属性已定义！`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可以做其他策略</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者上报数据，让你知道有哪些人偷偷定义了全局对象</span></span><br><span class=\"line\">        obj[prop] = val</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于 <code>Proxy</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/blog/images/compatibility-proxy.jpg\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用 <code>Proxy</code> 之后，能对 <code>global</code> 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>在浏览器的环境下有一个全局变量：<code>window</code>。<br>若定义变量时，遗漏了<code>var</code>，此时声明的变量就变成了全局变量，自动挂载到<code>window</code>下，可当做<code>window</code>的属性来访问，也可以直接访问。</p>\n</blockquote>\n<p>小程序的底层也是通过Web实现的，因此同样存在<code>window</code>对象，但是微信团队做了些处理：</p>\n<p><img src=\"/blog/images/global-window.png\"></p>\n<p>微信团队将<code>window</code>设置成了<code>writable:false</code>，且值也为<code>undefined</code>。</p>\n<p>即我们无法像在<code>web</code>那样任意声明全局变量。但微信团队提供了其他的全局变量，比如常用的<code>wx</code>、<code>global</code>。</p>","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>虽然<code>window</code>是只读的，但是<code>global</code>是可写的:</p>\n<p><img src=\"/blog/images/global-global.png\"></p>\n<p>因此常见的做法，就是将需要全局访问的变量都保存到<code>global</code>下，间接声明了全局变量。</p>\n<p>全局变量的污染，在小团队的项目里可能没什么感知。但是在一个大型的项目里，是非常常见的，一不小心就将别人声明的变量覆盖了。</p>\n<p>另外如果可以随意注册全局变量，又不加以管理的话，有可能会导致内存泄漏，最终导致应用闪退。</p>\n<blockquote>\n<p>同理，setStorage也存在同样的问题。</p>\n</blockquote>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>简单地将这些变量改成<code>readonly</code>肯定是不可取的，这影响了日常的开发。</p>\n<p>在早期的前端开发中，也有同样类似的全局变量污染的问题，我依稀记得两种解决方案：</p>\n<ul>\n<li>命名空间</li>\n<li>模块化</li>\n</ul>\n<p>其中 <strong>模块化</strong> 明显不是这个问题的解决方案。因为目前的确是需要全局变量的，问题只是如何避免污染和管理全局变量而已。</p>\n<p>因此 <strong>命名空间</strong> 是可以深入探索的思路。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>命名空间是一种常用的代码组织形式。</p>\n<p>大致做法是，先通过命名分配空间，再使用空间。</p>\n<blockquote>\n<p>我的习惯是，用业务或者功能来命名空间</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span>.localStorage = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doSet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doGet</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">doClear</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">global</span>.util = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">format</span>(<span class=\"params\"></span>)</span> &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">valide</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>命名空间是通过互相约定的方式来工作的，因此仍然会存在覆盖的问题。</p>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p><code>Symbol</code>是ES2015中新增的基本数据类型。这个类型有个特别之处，每个<code>Symbol()</code>返回的值都是独一无二的，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>因此通过<code>Symbol</code>的方式，可以完美避免变量被覆盖：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// car.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[car] = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// health.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> health = <span class=\"built_in\">Symbol</span>()</span><br><span class=\"line\"><span class=\"built_in\">global</span>[health] = &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于每个<code>Symbol</code>返回的值是唯一的，因此这个<code>Symbol</code>可以单独保存，以便各个文件引用。</p>\n<blockquote>\n<p>由于 <code>Symbol</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/blog/images/compatibility-symbol.jpg\"></p>\n<h3 id=\"管理声明\"><a href=\"#管理声明\" class=\"headerlink\" title=\"管理声明\"></a>管理声明</h3><p>通过<code>Symbol</code>的方式解决了变量的污染问题，但仍然无法对全局变量的声明进行管理。</p>\n<p>我想到的办法就是给 <code>global</code> 增加个代理，对 <code>global</code> 的任何操作，都先经过代理检测，这样就有了强力的保障。</p>\n<p>因此，可以使用新特性：<code>Proxy</code> 来监听 <code>global</code> 的变更，举例说明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">global</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(<span class=\"built_in\">global</span>, &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">obj, prop, val</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">`<span class=\"subst\">$&#123;prop&#125;</span>: 该属性已定义！`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可以做其他策略</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者上报数据，让你知道有哪些人偷偷定义了全局对象</span></span><br><span class=\"line\">        obj[prop] = val</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于 <code>Proxy</code> 属于新特性，因此需要关注下兼容性</p>\n</blockquote>\n<p><img src=\"/blog/images/compatibility-proxy.jpg\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用 <code>Proxy</code> 之后，能对 <code>global</code> 的各种操作（设置属性，设置原型等13种操作）进行监控，即能避免重复定义变量，也可以很好的管理全局变量，两全其美。</p>"},{"title":"关于订阅消息的思考","desc":"小程序订阅消息的思考","toc":true,"date":"2020-05-15T16:00:00.000Z","_content":"\n## 前言\n\n小程序的早期定位是“即用即走”或者说是“用完即走”。\n但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。\n让用户回流的关键手段就是 **订阅消息**，通过点击订阅消息，可直接回到小程序。\n\n<!-- more -->\n\n## 背景\n\n早期小程序提供的是 **模板消息**，用户每次点击或者完成支付，都会生成一个`formId`或者`paypay_id`，开发者可以通过这个`formId`给用户发送一次模板消息。\n\n因此，开发者的常规做法：尽可能地在每个按钮上都封装`form`，用以收集`formId`；收集的`formId`并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些`formId`发送模板消息。\n\n这样会存在几个问题：\n- 用户会被莫名的骚扰（因为`formId`有7天的有效期）\n- 用户收到的模板消息是无预期的（因为`formId`可以发任意的模板消息）\n- 开发者在每个页面每个可点击区域都封装了`form`，导致代码混乱\n\n为了解决以上问题，小程序团队就采用了 **订阅消息** 来替换 **模板消息**。\n\n> 小程序模板消息接口于2020年1月10日下线\n\n## 订阅消息的优势\n\n**订阅消息** 与 **模板消息** 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：\n\n![](/blog/images/subscribe/request-subscribe-message.jpg)\n\n另外，**对订阅消息的发送时限不做限制**，即可以在任意时间给用户发送一条模板消息，而不像以前的`formId`有7天的有效期。\n\n从开发者的角度看：订阅消息是使用接口调用([wx.requestSubscribeMessage](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html))，不再是以前那样，一定要用`Button`。**对于代码维护和开发效率来说，都是利好的**。\n\n从代码维护上讲，开发者不用再层层嵌套`form`了，简化了许多代码；另外，以前模板消息是通过`Button`封装的，拜托了这层束缚之后，就不用再重置`Button`的样式了，对于开发效率也是有一定的帮助。\n\n### 模板消息\n```html\n<form bindsubmit=\"addFormId\" report-submit>\n    <button class=\"invite-btn\" form-type=\"submit\">\n        邀请好友\n    </button>\n</form>\n```\n\n```js\nPage({\n    data: {},\n    addFormId(e) {\n        let { formId } = e.detail;\n        // save formId\n    }\n})\n```\n\n### 订阅消息\n\n```html\n<view class=\"invite-btn\" bindtap=\"handleInvite\">邀请好友</view>\n```\n\n```js\nPage({\n    handleInvite() {\n        wx.requestSubscribeMessage({\n            tmplIds: [''] // 订阅的模板ID\n        })\n    }\n})\n```\n\n\n\n> 但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。\n\n## 订阅消息的类型\n\n以往的模板消息，每次发送消息需要消耗一个`formId`，而`formId`有7天的有效期，因此小程序无法召回7天以前的活跃用户。\n\n而订阅消息则提供了两种类型：\n- 一次性订阅\n- 长期订阅\n\n其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。\n\n不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。\n\n## 开发的差异\n\n### 小程序端\n\n以往的模板消息方式，需要前端将每次收集到的`formId`，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。\n\n另外每次发起消息订阅，都会有弹窗出现：\n\n![](/blog/images/subscribe/WechatIMG198.jpg)\n\n用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。\n\n若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：\n\n![](/blog/images/subscribe/WechatIMG199.jpg)\n\n其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。\n\n如果用户关闭接收所有订阅消息，那么调用`wx.requestSubscribeMessage`时，会触发`fail`，并返回如下信息：\n\n```js\n{\n    errCode: 20004,\n    errMsg: 'The main switch is switched off',\n    // 用户关闭了主开关，无法进行订阅\n}\n```\n\n## 总结\n\n订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往`formId`的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。\n\n因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。","source":"_posts/miniprogram/think-about-subscribe.md","raw":"---\ntitle: 关于订阅消息的思考\ntags: \n- 小程序\ndesc: 小程序订阅消息的思考\ntoc: true\ncategories:\n- 小程序\ndate: 2020-5-16\n---\n\n## 前言\n\n小程序的早期定位是“即用即走”或者说是“用完即走”。\n但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。\n让用户回流的关键手段就是 **订阅消息**，通过点击订阅消息，可直接回到小程序。\n\n<!-- more -->\n\n## 背景\n\n早期小程序提供的是 **模板消息**，用户每次点击或者完成支付，都会生成一个`formId`或者`paypay_id`，开发者可以通过这个`formId`给用户发送一次模板消息。\n\n因此，开发者的常规做法：尽可能地在每个按钮上都封装`form`，用以收集`formId`；收集的`formId`并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些`formId`发送模板消息。\n\n这样会存在几个问题：\n- 用户会被莫名的骚扰（因为`formId`有7天的有效期）\n- 用户收到的模板消息是无预期的（因为`formId`可以发任意的模板消息）\n- 开发者在每个页面每个可点击区域都封装了`form`，导致代码混乱\n\n为了解决以上问题，小程序团队就采用了 **订阅消息** 来替换 **模板消息**。\n\n> 小程序模板消息接口于2020年1月10日下线\n\n## 订阅消息的优势\n\n**订阅消息** 与 **模板消息** 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：\n\n![](/blog/images/subscribe/request-subscribe-message.jpg)\n\n另外，**对订阅消息的发送时限不做限制**，即可以在任意时间给用户发送一条模板消息，而不像以前的`formId`有7天的有效期。\n\n从开发者的角度看：订阅消息是使用接口调用([wx.requestSubscribeMessage](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html))，不再是以前那样，一定要用`Button`。**对于代码维护和开发效率来说，都是利好的**。\n\n从代码维护上讲，开发者不用再层层嵌套`form`了，简化了许多代码；另外，以前模板消息是通过`Button`封装的，拜托了这层束缚之后，就不用再重置`Button`的样式了，对于开发效率也是有一定的帮助。\n\n### 模板消息\n```html\n<form bindsubmit=\"addFormId\" report-submit>\n    <button class=\"invite-btn\" form-type=\"submit\">\n        邀请好友\n    </button>\n</form>\n```\n\n```js\nPage({\n    data: {},\n    addFormId(e) {\n        let { formId } = e.detail;\n        // save formId\n    }\n})\n```\n\n### 订阅消息\n\n```html\n<view class=\"invite-btn\" bindtap=\"handleInvite\">邀请好友</view>\n```\n\n```js\nPage({\n    handleInvite() {\n        wx.requestSubscribeMessage({\n            tmplIds: [''] // 订阅的模板ID\n        })\n    }\n})\n```\n\n\n\n> 但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。\n\n## 订阅消息的类型\n\n以往的模板消息，每次发送消息需要消耗一个`formId`，而`formId`有7天的有效期，因此小程序无法召回7天以前的活跃用户。\n\n而订阅消息则提供了两种类型：\n- 一次性订阅\n- 长期订阅\n\n其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。\n\n不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。\n\n## 开发的差异\n\n### 小程序端\n\n以往的模板消息方式，需要前端将每次收集到的`formId`，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。\n\n另外每次发起消息订阅，都会有弹窗出现：\n\n![](/blog/images/subscribe/WechatIMG198.jpg)\n\n用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。\n\n若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：\n\n![](/blog/images/subscribe/WechatIMG199.jpg)\n\n其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。\n\n如果用户关闭接收所有订阅消息，那么调用`wx.requestSubscribeMessage`时，会触发`fail`，并返回如下信息：\n\n```js\n{\n    errCode: 20004,\n    errMsg: 'The main switch is switched off',\n    // 用户关闭了主开关，无法进行订阅\n}\n```\n\n## 总结\n\n订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往`formId`的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。\n\n因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。","slug":"miniprogram/think-about-subscribe","published":1,"updated":"2023-08-04T10:49:25.419Z","_id":"cky5ioqew001fn6694aok78z9","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的早期定位是“即用即走”或者说是“用完即走”。<br>但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。<br>让用户回流的关键手段就是 <strong>订阅消息</strong>，通过点击订阅消息，可直接回到小程序。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>早期小程序提供的是 <strong>模板消息</strong>，用户每次点击或者完成支付，都会生成一个<code>formId</code>或者<code>paypay_id</code>，开发者可以通过这个<code>formId</code>给用户发送一次模板消息。</p>\n<p>因此，开发者的常规做法：尽可能地在每个按钮上都封装<code>form</code>，用以收集<code>formId</code>；收集的<code>formId</code>并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些<code>formId</code>发送模板消息。</p>\n<p>这样会存在几个问题：</p>\n<ul>\n<li>用户会被莫名的骚扰（因为<code>formId</code>有7天的有效期）</li>\n<li>用户收到的模板消息是无预期的（因为<code>formId</code>可以发任意的模板消息）</li>\n<li>开发者在每个页面每个可点击区域都封装了<code>form</code>，导致代码混乱</li>\n</ul>\n<p>为了解决以上问题，小程序团队就采用了 <strong>订阅消息</strong> 来替换 <strong>模板消息</strong>。</p>\n<blockquote>\n<p>小程序模板消息接口于2020年1月10日下线</p>\n</blockquote>\n<h2 id=\"订阅消息的优势\"><a href=\"#订阅消息的优势\" class=\"headerlink\" title=\"订阅消息的优势\"></a>订阅消息的优势</h2><p><strong>订阅消息</strong> 与 <strong>模板消息</strong> 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：</p>\n<p><img src=\"/blog/images/subscribe/request-subscribe-message.jpg\"></p>\n<p>另外，<strong>对订阅消息的发送时限不做限制</strong>，即可以在任意时间给用户发送一条模板消息，而不像以前的<code>formId</code>有7天的有效期。</p>\n<p>从开发者的角度看：订阅消息是使用接口调用(<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html\">wx.requestSubscribeMessage</a>)，不再是以前那样，一定要用<code>Button</code>。<strong>对于代码维护和开发效率来说，都是利好的</strong>。</p>\n<p>从代码维护上讲，开发者不用再层层嵌套<code>form</code>了，简化了许多代码；另外，以前模板消息是通过<code>Button</code>封装的，拜托了这层束缚之后，就不用再重置<code>Button</code>的样式了，对于开发效率也是有一定的帮助。</p>\n<h3 id=\"模板消息\"><a href=\"#模板消息\" class=\"headerlink\" title=\"模板消息\"></a>模板消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">bindsubmit</span>=<span class=\"string\">&quot;addFormId&quot;</span> <span class=\"attr\">report-submit</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">form-type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span></span><br><span class=\"line\">        邀请好友</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addFormId</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; formId &#125; = e.detail;</span><br><span class=\"line\">        <span class=\"comment\">// save formId</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"订阅消息\"><a href=\"#订阅消息\" class=\"headerlink\" title=\"订阅消息\"></a>订阅消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleInvite&quot;</span>&gt;</span>邀请好友<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleInvite</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        wx.requestSubscribeMessage(&#123;</span><br><span class=\"line\">            <span class=\"attr\">tmplIds</span>: [<span class=\"string\">&#x27;&#x27;</span>] <span class=\"comment\">// 订阅的模板ID</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。</p>\n</blockquote>\n<h2 id=\"订阅消息的类型\"><a href=\"#订阅消息的类型\" class=\"headerlink\" title=\"订阅消息的类型\"></a>订阅消息的类型</h2><p>以往的模板消息，每次发送消息需要消耗一个<code>formId</code>，而<code>formId</code>有7天的有效期，因此小程序无法召回7天以前的活跃用户。</p>\n<p>而订阅消息则提供了两种类型：</p>\n<ul>\n<li>一次性订阅</li>\n<li>长期订阅</li>\n</ul>\n<p>其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。</p>\n<p>不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。</p>\n<h2 id=\"开发的差异\"><a href=\"#开发的差异\" class=\"headerlink\" title=\"开发的差异\"></a>开发的差异</h2><h3 id=\"小程序端\"><a href=\"#小程序端\" class=\"headerlink\" title=\"小程序端\"></a>小程序端</h3><p>以往的模板消息方式，需要前端将每次收集到的<code>formId</code>，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。</p>\n<p>另外每次发起消息订阅，都会有弹窗出现：</p>\n<p><img src=\"/blog/images/subscribe/WechatIMG198.jpg\"></p>\n<p>用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。</p>\n<p>若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：</p>\n<p><img src=\"/blog/images/subscribe/WechatIMG199.jpg\"></p>\n<p>其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。</p>\n<p>如果用户关闭接收所有订阅消息，那么调用<code>wx.requestSubscribeMessage</code>时，会触发<code>fail</code>，并返回如下信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">errCode</span>: <span class=\"number\">20004</span>,</span><br><span class=\"line\">    <span class=\"attr\">errMsg</span>: <span class=\"string\">&#x27;The main switch is switched off&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 用户关闭了主开关，无法进行订阅</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往<code>formId</code>的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。</p>\n<p>因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的早期定位是“即用即走”或者说是“用完即走”。<br>但小程序的运营者却不是这么想的，希望用户尽可能的停留在小程序上，或者“多回来看看”，俗称“拉回流”。<br>让用户回流的关键手段就是 <strong>订阅消息</strong>，通过点击订阅消息，可直接回到小程序。</p>","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>早期小程序提供的是 <strong>模板消息</strong>，用户每次点击或者完成支付，都会生成一个<code>formId</code>或者<code>paypay_id</code>，开发者可以通过这个<code>formId</code>给用户发送一次模板消息。</p>\n<p>因此，开发者的常规做法：尽可能地在每个按钮上都封装<code>form</code>，用以收集<code>formId</code>；收集的<code>formId</code>并不会使用，而是将它们存到数据库里，在需要拉回流的时候，通过这些<code>formId</code>发送模板消息。</p>\n<p>这样会存在几个问题：</p>\n<ul>\n<li>用户会被莫名的骚扰（因为<code>formId</code>有7天的有效期）</li>\n<li>用户收到的模板消息是无预期的（因为<code>formId</code>可以发任意的模板消息）</li>\n<li>开发者在每个页面每个可点击区域都封装了<code>form</code>，导致代码混乱</li>\n</ul>\n<p>为了解决以上问题，小程序团队就采用了 <strong>订阅消息</strong> 来替换 <strong>模板消息</strong>。</p>\n<blockquote>\n<p>小程序模板消息接口于2020年1月10日下线</p>\n</blockquote>\n<h2 id=\"订阅消息的优势\"><a href=\"#订阅消息的优势\" class=\"headerlink\" title=\"订阅消息的优势\"></a>订阅消息的优势</h2><p><strong>订阅消息</strong> 与 <strong>模板消息</strong> 相比较，明显的优势：用户对自己将收到的模板消息类型有一定的预期，如：</p>\n<p><img src=\"/blog/images/subscribe/request-subscribe-message.jpg\"></p>\n<p>另外，<strong>对订阅消息的发送时限不做限制</strong>，即可以在任意时间给用户发送一条模板消息，而不像以前的<code>formId</code>有7天的有效期。</p>\n<p>从开发者的角度看：订阅消息是使用接口调用(<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html\">wx.requestSubscribeMessage</a>)，不再是以前那样，一定要用<code>Button</code>。<strong>对于代码维护和开发效率来说，都是利好的</strong>。</p>\n<p>从代码维护上讲，开发者不用再层层嵌套<code>form</code>了，简化了许多代码；另外，以前模板消息是通过<code>Button</code>封装的，拜托了这层束缚之后，就不用再重置<code>Button</code>的样式了，对于开发效率也是有一定的帮助。</p>\n<h3 id=\"模板消息\"><a href=\"#模板消息\" class=\"headerlink\" title=\"模板消息\"></a>模板消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">bindsubmit</span>=<span class=\"string\">&quot;addFormId&quot;</span> <span class=\"attr\">report-submit</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">form-type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span></span><br><span class=\"line\">        邀请好友</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addFormId</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; formId &#125; = e.detail;</span><br><span class=\"line\">        <span class=\"comment\">// save formId</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"订阅消息\"><a href=\"#订阅消息\" class=\"headerlink\" title=\"订阅消息\"></a>订阅消息</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;invite-btn&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleInvite&quot;</span>&gt;</span>邀请好友<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleInvite</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        wx.requestSubscribeMessage(&#123;</span><br><span class=\"line\">            <span class=\"attr\">tmplIds</span>: [<span class=\"string\">&#x27;&#x27;</span>] <span class=\"comment\">// 订阅的模板ID</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>但是，订阅消息仍有个小程序通病，有一定的兼容性，需要基础库2.4.4以上才能使用。这也就意味着，2020年1月10日模板消息下线之后，你没法招回停留在基础库2.4.4以下的用户了。</p>\n</blockquote>\n<h2 id=\"订阅消息的类型\"><a href=\"#订阅消息的类型\" class=\"headerlink\" title=\"订阅消息的类型\"></a>订阅消息的类型</h2><p>以往的模板消息，每次发送消息需要消耗一个<code>formId</code>，而<code>formId</code>有7天的有效期，因此小程序无法召回7天以前的活跃用户。</p>\n<p>而订阅消息则提供了两种类型：</p>\n<ul>\n<li>一次性订阅</li>\n<li>长期订阅</li>\n</ul>\n<p>其中，一次性订阅与以往的模板消息类似，是一次性的，唯一的差异是订阅消息没有限时；而长期订阅则是召回的利器，用户只要订阅过一次，小程序将获得给该用户发送多次消息的能力。</p>\n<p>不过，目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放。而且个人主体的小程序没有权限申请。</p>\n<h2 id=\"开发的差异\"><a href=\"#开发的差异\" class=\"headerlink\" title=\"开发的差异\"></a>开发的差异</h2><h3 id=\"小程序端\"><a href=\"#小程序端\" class=\"headerlink\" title=\"小程序端\"></a>小程序端</h3><p>以往的模板消息方式，需要前端将每次收集到的<code>formId</code>，上传至后端保存起来。现在，需要做的是，记录一下哪个用户订阅了哪些模板即可，至于订阅的次数，也是需要开发者自行保存的。</p>\n<p>另外每次发起消息订阅，都会有弹窗出现：</p>\n<p><img src=\"/blog/images/subscribe/WechatIMG198.jpg\"></p>\n<p>用户可以勾选“总是保持以上选择，不再询问”，这样下次点击时，就直接授权订阅。</p>\n<p>若此后希望小程序重新出现弹框，则是没有办法的。只能在设置页里取消单个订阅消息，或者关闭接收所有订阅消息：</p>\n<p><img src=\"/blog/images/subscribe/WechatIMG199.jpg\"></p>\n<p>其实就等于将这些设置转移到更深的路径上，但还是保留了用户取消订阅的权利。</p>\n<p>如果用户关闭接收所有订阅消息，那么调用<code>wx.requestSubscribeMessage</code>时，会触发<code>fail</code>，并返回如下信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">errCode</span>: <span class=\"number\">20004</span>,</span><br><span class=\"line\">    <span class=\"attr\">errMsg</span>: <span class=\"string\">&#x27;The main switch is switched off&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 用户关闭了主开关，无法进行订阅</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>订阅消息是模板消息的进阶产品，对于用户、开发者更友好，但对于小程序的运营者来说，反而并没有更大的帮助。毕竟以往<code>formId</code>的方式，可以用来发送任意模板消息，现在只能“特定订阅特定使用”。</p>\n<p>因此，更多的小程序运营者会讲小程序的用户引导到公众号，这样才能更大可能地接触到用户，毕竟公众号的消息推送更不受限制。</p>"},{"title":"关于小程序组件透传函数的实践","date":"2022-01-06T12:21:28.000Z","toc":true,"_content":"\n> 开发小程序组件库 TDesign 有感\n\n微信小程序，从基础库 `2.0.9` 开始，自定义组件的 `type: Object` 属性（properties）支持函数类型的值了，但仍不支持函数类型的属性，即：\n\n<!-- more -->\n\n```js\n// dialog.js\nComponent({\n  properties: {\n    confirmBtn: {\n      type: Object, // ok\n    },\n    cancelBtn: {\n      type: Function // wrong\n    }\n  },\n\n  observer: {\n    confirmBtn(obj) {\n      console.log(obj.bindgetuserinfo) // function\n    }\n  }\n})\n```\n\n这种能力，在实现 Dialog 组件的时候，非常有用。这样在 Dialog 组件的 `cancel` 和 `confirm` 按钮可以方便地支持 Button 的各种开放能力。\n\n于是，就会想当然地这样实现：\n\n```html\n<view class=\"t-dialog\">\n  <!-- ... -->\n  <button\n    class=\"cancel-btn\" \n    size=\"{{cancelBtn.size}}\"\n    type=\"{{cancelBtn.type}}\"\n    plain=\"{{cancelBtn.plain}}\"\n    disabled=\"{{cancelBtn.disabled}}\"\n    open-type=\"{{cancelBtn.openType}}\" \n    bindgetuserinfo=\"{{cancelBtn.bindgetuserinfo}}\"\n  >\n    取消\n  </button>\n\n  <button\n    class=\"confirm-btn\" \n    size=\"{{confirmBtn.size}}\"\n    type=\"{{confirmBtn.type}}\"\n    plain=\"{{confirmBtn.plain}}\"\n    disabled=\"{{confirmBtn.disabled}}\"\n    open-type=\"{{confirmBtn.openType}}\" \n    bindgetuserinfo=\"{{confirmBtn.bindgetuserinfo}}\"\n  >\n    确认\n  </button>\n</view>\n```\n\n这样就会出现几个问题：\n- 属性透传写法太冗余\n- 事件不会触发\n- 按钮内容没法传入\n\n## 属性透传\n\nDialog 组件存在两个按钮，所以两个按钮都需要透传 button 属性，直观的想法就是采用 template 来处理:\n\n```html\n<!-- button.wxml -->\n<template name=\"button\">\n  <button\n      class=\"{{class}}\" \n      size=\"{{size}}\"\n      type=\"{{type}}\"\n      plain=\"{{plain}}\"\n      disabled=\"{{disabled}}\"\n      open-type=\"{{openType}}\" \n      bindgetuserinfo=\"{{bindgetuserinfo}}\"\n    >\n    确认\n  </button>\n</template>\n```\n\n于是 Dialog 的代码就可以省略成这样：\n\n```html\n<import src=\"./button.wxml\" /> \n\n<view class=\"t-dialog\">\n  <!-- ... -->\n  <template is=\"button\" data={{...cancelBtn, class: 'cancel-btn'}}>\n  <template is=\"button\" data={{...confirmBtn, class: 'confirm-btn'}}>\n</view>\n```\n\n这里确实挺奇怪的，可以直接传入了一个解构后的值。\n\n> 这里可以直接合并对象\n\n## 事件不会触发\n\n一开始以为是 template 的值传递过程，不支持 function 类型的值，因此丢失了。\n\n比如在 template 里面使用 wxs 打印类型，居然是空的。\n\n后来经过各种测试，最后在官网文档找到答案：[小程序框架/事件系统](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)\n\n在小程序的事件绑定，只需要传入的是字符串: \n\n```html\n<view bindtap=\"handletap\">Tap me!</view>\n```\n\n也可以是一个数据绑定:\n\n```html\n<view bindtap=\"{{ handlerName }}\">Tap me!</view>\n```\n\n但，这个数据的返回值类型应该是 string 而不是 function。\n\n通过这点，恍然大悟，想起了小程序的双线程模型：\n\n![](https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png)\n\n为了减轻线程之间的传输负担，是不需要将 function 传到渲染层的，只需要给一个函数名，然后在逻辑层执行对应的函数即可。\n\n因此没有办法在 wxml 里面执行对象属性的函数，需要找一个代理函数（Proxy function）处理。\n\n为了区分对应的按钮，因此 template 做了小改动，增加了一个 `data-token` 的属性：\n\n```html\n<template name=\"button\">\n  <button data-token=\"{{token}}\" bindtap=\"onTplButtonTap\">\n</template>\n```\n\n对应的 Dialog 的 wxml 的改动是这样的：\n\n```html\n<import src=\"button.wxml\" /> \n\n<view class=\"t-dialog\">\n  <!-- ... -->\n  <template is=\"button\" data={{...cancelBtn, token: 'cancel', class: 'cancel-btn'}}>\n  <template is=\"button\" data={{...confirmBtn, token: 'confirm', class: 'confirm-btn'}}>\n</view>\n```\n\n对应的 JS 是这样的：\n\n```js\nComponent({\n  methods: {\n    onTplButtonTap(e) {\n      const { token } = e.target.dataset // cancel or confirm\n      const evtType = e.type // 对应的事件名，如 getuserinfo/getphonenumber 等\n      const evtName = `bind${evtType}`\n      const targetBtn = this.data[`${type}Btn`]\n\n      if (typeof targetBtn[evtName] == 'function') {\n        targetBtn[evtName](e.detail)\n      }\n    }\n  }\n})\n```\n\n这样就能完美透传并触发各种 button 事件了。\n\n## 按钮内容传入\n\n其事这个倒是个小问题，因为 TDesign 组件在规划的时候，就已经充分地考虑了多框架之间的差异。为了弥补框架之间的差异，都可以通过 content 的属性来传入插槽的内容，起初我还不理解，直到遇到了这个问题。\n\n以前总觉得，可以通过 slot 的方式传入，又支持一个 content 有点多此一举。直到我遇到了需要透传 button 属性的 dialog 组件。\n\n# 总结\n\n小程序的黑盒子运行时，在遇到问题的时候真的很容易陷入盲调的困境，此时应该去看看官方文档的资料，或者网上搜一下是否其他人也遇到类似的问题，这样才可能破局。\n\n毕竟只有他们才知道代码是怎么跑的。","source":"_posts/miniprogram/miniprogram-function-property.md","raw":"---\ntitle: 关于小程序组件透传函数的实践\ndate: 2022-01-06 20:21:28\ntags: \n- 小程序\n- 自定义组件\ntoc: true\ncategories:\n- 小程序\n---\n\n> 开发小程序组件库 TDesign 有感\n\n微信小程序，从基础库 `2.0.9` 开始，自定义组件的 `type: Object` 属性（properties）支持函数类型的值了，但仍不支持函数类型的属性，即：\n\n<!-- more -->\n\n```js\n// dialog.js\nComponent({\n  properties: {\n    confirmBtn: {\n      type: Object, // ok\n    },\n    cancelBtn: {\n      type: Function // wrong\n    }\n  },\n\n  observer: {\n    confirmBtn(obj) {\n      console.log(obj.bindgetuserinfo) // function\n    }\n  }\n})\n```\n\n这种能力，在实现 Dialog 组件的时候，非常有用。这样在 Dialog 组件的 `cancel` 和 `confirm` 按钮可以方便地支持 Button 的各种开放能力。\n\n于是，就会想当然地这样实现：\n\n```html\n<view class=\"t-dialog\">\n  <!-- ... -->\n  <button\n    class=\"cancel-btn\" \n    size=\"{{cancelBtn.size}}\"\n    type=\"{{cancelBtn.type}}\"\n    plain=\"{{cancelBtn.plain}}\"\n    disabled=\"{{cancelBtn.disabled}}\"\n    open-type=\"{{cancelBtn.openType}}\" \n    bindgetuserinfo=\"{{cancelBtn.bindgetuserinfo}}\"\n  >\n    取消\n  </button>\n\n  <button\n    class=\"confirm-btn\" \n    size=\"{{confirmBtn.size}}\"\n    type=\"{{confirmBtn.type}}\"\n    plain=\"{{confirmBtn.plain}}\"\n    disabled=\"{{confirmBtn.disabled}}\"\n    open-type=\"{{confirmBtn.openType}}\" \n    bindgetuserinfo=\"{{confirmBtn.bindgetuserinfo}}\"\n  >\n    确认\n  </button>\n</view>\n```\n\n这样就会出现几个问题：\n- 属性透传写法太冗余\n- 事件不会触发\n- 按钮内容没法传入\n\n## 属性透传\n\nDialog 组件存在两个按钮，所以两个按钮都需要透传 button 属性，直观的想法就是采用 template 来处理:\n\n```html\n<!-- button.wxml -->\n<template name=\"button\">\n  <button\n      class=\"{{class}}\" \n      size=\"{{size}}\"\n      type=\"{{type}}\"\n      plain=\"{{plain}}\"\n      disabled=\"{{disabled}}\"\n      open-type=\"{{openType}}\" \n      bindgetuserinfo=\"{{bindgetuserinfo}}\"\n    >\n    确认\n  </button>\n</template>\n```\n\n于是 Dialog 的代码就可以省略成这样：\n\n```html\n<import src=\"./button.wxml\" /> \n\n<view class=\"t-dialog\">\n  <!-- ... -->\n  <template is=\"button\" data={{...cancelBtn, class: 'cancel-btn'}}>\n  <template is=\"button\" data={{...confirmBtn, class: 'confirm-btn'}}>\n</view>\n```\n\n这里确实挺奇怪的，可以直接传入了一个解构后的值。\n\n> 这里可以直接合并对象\n\n## 事件不会触发\n\n一开始以为是 template 的值传递过程，不支持 function 类型的值，因此丢失了。\n\n比如在 template 里面使用 wxs 打印类型，居然是空的。\n\n后来经过各种测试，最后在官网文档找到答案：[小程序框架/事件系统](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)\n\n在小程序的事件绑定，只需要传入的是字符串: \n\n```html\n<view bindtap=\"handletap\">Tap me!</view>\n```\n\n也可以是一个数据绑定:\n\n```html\n<view bindtap=\"{{ handlerName }}\">Tap me!</view>\n```\n\n但，这个数据的返回值类型应该是 string 而不是 function。\n\n通过这点，恍然大悟，想起了小程序的双线程模型：\n\n![](https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png)\n\n为了减轻线程之间的传输负担，是不需要将 function 传到渲染层的，只需要给一个函数名，然后在逻辑层执行对应的函数即可。\n\n因此没有办法在 wxml 里面执行对象属性的函数，需要找一个代理函数（Proxy function）处理。\n\n为了区分对应的按钮，因此 template 做了小改动，增加了一个 `data-token` 的属性：\n\n```html\n<template name=\"button\">\n  <button data-token=\"{{token}}\" bindtap=\"onTplButtonTap\">\n</template>\n```\n\n对应的 Dialog 的 wxml 的改动是这样的：\n\n```html\n<import src=\"button.wxml\" /> \n\n<view class=\"t-dialog\">\n  <!-- ... -->\n  <template is=\"button\" data={{...cancelBtn, token: 'cancel', class: 'cancel-btn'}}>\n  <template is=\"button\" data={{...confirmBtn, token: 'confirm', class: 'confirm-btn'}}>\n</view>\n```\n\n对应的 JS 是这样的：\n\n```js\nComponent({\n  methods: {\n    onTplButtonTap(e) {\n      const { token } = e.target.dataset // cancel or confirm\n      const evtType = e.type // 对应的事件名，如 getuserinfo/getphonenumber 等\n      const evtName = `bind${evtType}`\n      const targetBtn = this.data[`${type}Btn`]\n\n      if (typeof targetBtn[evtName] == 'function') {\n        targetBtn[evtName](e.detail)\n      }\n    }\n  }\n})\n```\n\n这样就能完美透传并触发各种 button 事件了。\n\n## 按钮内容传入\n\n其事这个倒是个小问题，因为 TDesign 组件在规划的时候，就已经充分地考虑了多框架之间的差异。为了弥补框架之间的差异，都可以通过 content 的属性来传入插槽的内容，起初我还不理解，直到遇到了这个问题。\n\n以前总觉得，可以通过 slot 的方式传入，又支持一个 content 有点多此一举。直到我遇到了需要透传 button 属性的 dialog 组件。\n\n# 总结\n\n小程序的黑盒子运行时，在遇到问题的时候真的很容易陷入盲调的困境，此时应该去看看官方文档的资料，或者网上搜一下是否其他人也遇到类似的问题，这样才可能破局。\n\n毕竟只有他们才知道代码是怎么跑的。","slug":"miniprogram/miniprogram-function-property","published":1,"updated":"2023-08-04T11:25:16.575Z","_id":"cky5ioqex001in66993vkbz4v","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>开发小程序组件库 TDesign 有感</p>\n</blockquote>\n<p>微信小程序，从基础库 <code>2.0.9</code> 开始，自定义组件的 <code>type: Object</code> 属性（properties）支持函数类型的值了，但仍不支持函数类型的属性，即：</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dialog.js</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">confirmBtn</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>, <span class=\"comment\">// ok</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">cancelBtn</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Function</span> <span class=\"comment\">// wrong</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">observer</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">confirmBtn</span>(<span class=\"params\">obj</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(obj.bindgetuserinfo) <span class=\"comment\">// function</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这种能力，在实现 Dialog 组件的时候，非常有用。这样在 Dialog 组件的 <code>cancel</code> 和 <code>confirm</code> 按钮可以方便地支持 Button 的各种开放能力。</p>\n<p>于是，就会想当然地这样实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t-dialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;cancel-btn&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.size&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.type&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">plain</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.plain&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">disabled</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.disabled&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">open-type</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.openType&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">bindgetuserinfo</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.bindgetuserinfo&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    取消</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;confirm-btn&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.size&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.type&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">plain</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.plain&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">disabled</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.disabled&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">open-type</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.openType&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">bindgetuserinfo</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.bindgetuserinfo&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    确认</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就会出现几个问题：</p>\n<ul>\n<li>属性透传写法太冗余</li>\n<li>事件不会触发</li>\n<li>按钮内容没法传入</li>\n</ul>\n<h2 id=\"属性透传\"><a href=\"#属性透传\" class=\"headerlink\" title=\"属性透传\"></a>属性透传</h2><p>Dialog 组件存在两个按钮，所以两个按钮都需要透传 button 属性，直观的想法就是采用 template 来处理:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- button.wxml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;&#123;&#123;class&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">size</span>=<span class=\"string\">&quot;&#123;&#123;size&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">type</span>=<span class=\"string\">&quot;&#123;&#123;type&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">plain</span>=<span class=\"string\">&quot;&#123;&#123;plain&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">disabled</span>=<span class=\"string\">&quot;&#123;&#123;disabled&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">open-type</span>=<span class=\"string\">&quot;&#123;&#123;openType&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">bindgetuserinfo</span>=<span class=\"string\">&quot;&#123;&#123;bindgetuserinfo&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">    确认</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>于是 Dialog 的代码就可以省略成这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">import</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./button.wxml&quot;</span> /&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t-dialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...cancelBtn,</span> <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">cancel-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...confirmBtn,</span> <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">confirm-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里确实挺奇怪的，可以直接传入了一个解构后的值。</p>\n<blockquote>\n<p>这里可以直接合并对象</p>\n</blockquote>\n<h2 id=\"事件不会触发\"><a href=\"#事件不会触发\" class=\"headerlink\" title=\"事件不会触发\"></a>事件不会触发</h2><p>一开始以为是 template 的值传递过程，不支持 function 类型的值，因此丢失了。</p>\n<p>比如在 template 里面使用 wxs 打印类型，居然是空的。</p>\n<p>后来经过各种测试，最后在官网文档找到答案：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html\">小程序框架/事件系统</a></p>\n<p>在小程序的事件绑定，只需要传入的是字符串: </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handletap&quot;</span>&gt;</span>Tap me!<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以是一个数据绑定:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;&#123;&#123; handlerName &#125;&#125;&quot;</span>&gt;</span>Tap me!<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但，这个数据的返回值类型应该是 string 而不是 function。</p>\n<p>通过这点，恍然大悟，想起了小程序的双线程模型：</p>\n<p><img src=\"https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png\"></p>\n<p>为了减轻线程之间的传输负担，是不需要将 function 传到渲染层的，只需要给一个函数名，然后在逻辑层执行对应的函数即可。</p>\n<p>因此没有办法在 wxml 里面执行对象属性的函数，需要找一个代理函数（Proxy function）处理。</p>\n<p>为了区分对应的按钮，因此 template 做了小改动，增加了一个 <code>data-token</code> 的属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-token</span>=<span class=\"string\">&quot;&#123;&#123;token&#125;&#125;&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;onTplButtonTap&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对应的 Dialog 的 wxml 的改动是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">import</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;button.wxml&quot;</span> /&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t-dialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...cancelBtn,</span> <span class=\"attr\">token:</span> &#x27;<span class=\"attr\">cancel</span>&#x27;, <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">cancel-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...confirmBtn,</span> <span class=\"attr\">token:</span> &#x27;<span class=\"attr\">confirm</span>&#x27;, <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">confirm-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对应的 JS 是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onTplButtonTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; token &#125; = e.target.dataset <span class=\"comment\">// cancel or confirm</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> evtType = e.type <span class=\"comment\">// 对应的事件名，如 getuserinfo/getphonenumber 等</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> evtName = <span class=\"string\">`bind<span class=\"subst\">$&#123;evtType&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> targetBtn = <span class=\"built_in\">this</span>.data[<span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>Btn`</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> targetBtn[evtName] == <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        targetBtn[evtName](e.detail)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样就能完美透传并触发各种 button 事件了。</p>\n<h2 id=\"按钮内容传入\"><a href=\"#按钮内容传入\" class=\"headerlink\" title=\"按钮内容传入\"></a>按钮内容传入</h2><p>其事这个倒是个小问题，因为 TDesign 组件在规划的时候，就已经充分地考虑了多框架之间的差异。为了弥补框架之间的差异，都可以通过 content 的属性来传入插槽的内容，起初我还不理解，直到遇到了这个问题。</p>\n<p>以前总觉得，可以通过 slot 的方式传入，又支持一个 content 有点多此一举。直到我遇到了需要透传 button 属性的 dialog 组件。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>小程序的黑盒子运行时，在遇到问题的时候真的很容易陷入盲调的困境，此时应该去看看官方文档的资料，或者网上搜一下是否其他人也遇到类似的问题，这样才可能破局。</p>\n<p>毕竟只有他们才知道代码是怎么跑的。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<blockquote>\n<p>开发小程序组件库 TDesign 有感</p>\n</blockquote>\n<p>微信小程序，从基础库 <code>2.0.9</code> 开始，自定义组件的 <code>type: Object</code> 属性（properties）支持函数类型的值了，但仍不支持函数类型的属性，即：</p>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dialog.js</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">confirmBtn</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Object</span>, <span class=\"comment\">// ok</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">cancelBtn</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Function</span> <span class=\"comment\">// wrong</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">observer</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">confirmBtn</span>(<span class=\"params\">obj</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(obj.bindgetuserinfo) <span class=\"comment\">// function</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这种能力，在实现 Dialog 组件的时候，非常有用。这样在 Dialog 组件的 <code>cancel</code> 和 <code>confirm</code> 按钮可以方便地支持 Button 的各种开放能力。</p>\n<p>于是，就会想当然地这样实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t-dialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;cancel-btn&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.size&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.type&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">plain</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.plain&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">disabled</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.disabled&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">open-type</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.openType&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">bindgetuserinfo</span>=<span class=\"string\">&quot;&#123;&#123;cancelBtn.bindgetuserinfo&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    取消</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;confirm-btn&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.size&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.type&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">plain</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.plain&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">disabled</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.disabled&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">open-type</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.openType&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">bindgetuserinfo</span>=<span class=\"string\">&quot;&#123;&#123;confirmBtn.bindgetuserinfo&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    确认</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就会出现几个问题：</p>\n<ul>\n<li>属性透传写法太冗余</li>\n<li>事件不会触发</li>\n<li>按钮内容没法传入</li>\n</ul>\n<h2 id=\"属性透传\"><a href=\"#属性透传\" class=\"headerlink\" title=\"属性透传\"></a>属性透传</h2><p>Dialog 组件存在两个按钮，所以两个按钮都需要透传 button 属性，直观的想法就是采用 template 来处理:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- button.wxml --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;&#123;&#123;class&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">size</span>=<span class=\"string\">&quot;&#123;&#123;size&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">type</span>=<span class=\"string\">&quot;&#123;&#123;type&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">plain</span>=<span class=\"string\">&quot;&#123;&#123;plain&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">disabled</span>=<span class=\"string\">&quot;&#123;&#123;disabled&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">open-type</span>=<span class=\"string\">&quot;&#123;&#123;openType&#125;&#125;&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">bindgetuserinfo</span>=<span class=\"string\">&quot;&#123;&#123;bindgetuserinfo&#125;&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">    确认</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>于是 Dialog 的代码就可以省略成这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">import</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./button.wxml&quot;</span> /&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t-dialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...cancelBtn,</span> <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">cancel-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...confirmBtn,</span> <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">confirm-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里确实挺奇怪的，可以直接传入了一个解构后的值。</p>\n<blockquote>\n<p>这里可以直接合并对象</p>\n</blockquote>\n<h2 id=\"事件不会触发\"><a href=\"#事件不会触发\" class=\"headerlink\" title=\"事件不会触发\"></a>事件不会触发</h2><p>一开始以为是 template 的值传递过程，不支持 function 类型的值，因此丢失了。</p>\n<p>比如在 template 里面使用 wxs 打印类型，居然是空的。</p>\n<p>后来经过各种测试，最后在官网文档找到答案：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html\">小程序框架/事件系统</a></p>\n<p>在小程序的事件绑定，只需要传入的是字符串: </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handletap&quot;</span>&gt;</span>Tap me!<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以是一个数据绑定:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;&#123;&#123; handlerName &#125;&#125;&quot;</span>&gt;</span>Tap me!<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但，这个数据的返回值类型应该是 string 而不是 function。</p>\n<p>通过这点，恍然大悟，想起了小程序的双线程模型：</p>\n<p><img src=\"https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png\"></p>\n<p>为了减轻线程之间的传输负担，是不需要将 function 传到渲染层的，只需要给一个函数名，然后在逻辑层执行对应的函数即可。</p>\n<p>因此没有办法在 wxml 里面执行对象属性的函数，需要找一个代理函数（Proxy function）处理。</p>\n<p>为了区分对应的按钮，因此 template 做了小改动，增加了一个 <code>data-token</code> 的属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;button&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-token</span>=<span class=\"string\">&quot;&#123;&#123;token&#125;&#125;&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;onTplButtonTap&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对应的 Dialog 的 wxml 的改动是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">import</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;button.wxml&quot;</span> /&gt;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;t-dialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ... --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...cancelBtn,</span> <span class=\"attr\">token:</span> &#x27;<span class=\"attr\">cancel</span>&#x27;, <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">cancel-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;&#123;...confirmBtn,</span> <span class=\"attr\">token:</span> &#x27;<span class=\"attr\">confirm</span>&#x27;, <span class=\"attr\">class:</span> &#x27;<span class=\"attr\">confirm-btn</span>&#x27;&#125;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对应的 JS 是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">  <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onTplButtonTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; token &#125; = e.target.dataset <span class=\"comment\">// cancel or confirm</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> evtType = e.type <span class=\"comment\">// 对应的事件名，如 getuserinfo/getphonenumber 等</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> evtName = <span class=\"string\">`bind<span class=\"subst\">$&#123;evtType&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> targetBtn = <span class=\"built_in\">this</span>.data[<span class=\"string\">`<span class=\"subst\">$&#123;type&#125;</span>Btn`</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> targetBtn[evtName] == <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        targetBtn[evtName](e.detail)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样就能完美透传并触发各种 button 事件了。</p>\n<h2 id=\"按钮内容传入\"><a href=\"#按钮内容传入\" class=\"headerlink\" title=\"按钮内容传入\"></a>按钮内容传入</h2><p>其事这个倒是个小问题，因为 TDesign 组件在规划的时候，就已经充分地考虑了多框架之间的差异。为了弥补框架之间的差异，都可以通过 content 的属性来传入插槽的内容，起初我还不理解，直到遇到了这个问题。</p>\n<p>以前总觉得，可以通过 slot 的方式传入，又支持一个 content 有点多此一举。直到我遇到了需要透传 button 属性的 dialog 组件。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>小程序的黑盒子运行时，在遇到问题的时候真的很容易陷入盲调的困境，此时应该去看看官方文档的资料，或者网上搜一下是否其他人也遇到类似的问题，这样才可能破局。</p>\n<p>毕竟只有他们才知道代码是怎么跑的。</p>"},{"title":"小程序的自动更新机制","desc":"小程序自动更新机制","date":"2020-04-26T16:00:00.000Z","toc":true,"_content":"\n## 前言\n\n小程序的更新机制与它的运行机制有关。\n\n为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。\n\n<!-- more -->\n\n## 运行机制\n\n首先，先看下小程序的运行机制：\n\n![](/blog/images/update/work-flow.png)\n\n与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。\n\n## 更新机制\n\n小程序的更新机制分为：\n\n- 未启动时更新\n- 启动时更新\n\n**未启动时更新**：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。\n\n**启动时更新**：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：\n\n```js\nconst updateManager = wx.getUpdateManager()\n\nupdateManager.onCheckForUpdate(function (res) {\n  // 请求完新版本信息的回调\n  console.log(res.hasUpdate)\n})\n\nupdateManager.onUpdateReady(function () {\n  wx.showModal({\n    title: '更新提示',\n    content: '新版本已经准备好，是否重启应用？',\n    success(res) {\n      if (res.confirm) {\n        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\n        updateManager.applyUpdate()\n      }\n    }\n  })\n})\n\nupdateManager.onUpdateFailed(function () {\n  // 新版本下载失败\n})\n```\n\n> 如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。\n\n根据微信提供的能力，小程序的更新流程大致如下：\n\n![](/blog/images/update/update-logic.jpg)\n\n由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。\n\n下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。\n\n由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。\n\n## 测试\n\n更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。\n\n笔者尝试在体验版上做测试：先打开`v0.0.1`版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是`v0.0.2`，根本没有还原小程序的更新机制。\n\n因此可以得出结论：**体验版无法测试更新机制**。\n\n### 模拟更新\n\n另外，开发者工具的编译模式提供模拟更新：\n\n![](/blog/images/update/mock-update.jpg)\n\n## 兼容处理\n\n由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。\n\n最简单的方式：每次升级接口时，均采用新接口。","source":"_posts/miniprogram/update.md","raw":"---\ntitle: 小程序的自动更新机制\ndesc: 小程序自动更新机制\ntags: \n- 小程序\ndate: 2020-4-27\ntoc: true\ncategories:\n- 小程序\n---\n\n## 前言\n\n小程序的更新机制与它的运行机制有关。\n\n为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。\n\n<!-- more -->\n\n## 运行机制\n\n首先，先看下小程序的运行机制：\n\n![](/blog/images/update/work-flow.png)\n\n与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。\n\n## 更新机制\n\n小程序的更新机制分为：\n\n- 未启动时更新\n- 启动时更新\n\n**未启动时更新**：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。\n\n**启动时更新**：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：\n\n```js\nconst updateManager = wx.getUpdateManager()\n\nupdateManager.onCheckForUpdate(function (res) {\n  // 请求完新版本信息的回调\n  console.log(res.hasUpdate)\n})\n\nupdateManager.onUpdateReady(function () {\n  wx.showModal({\n    title: '更新提示',\n    content: '新版本已经准备好，是否重启应用？',\n    success(res) {\n      if (res.confirm) {\n        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\n        updateManager.applyUpdate()\n      }\n    }\n  })\n})\n\nupdateManager.onUpdateFailed(function () {\n  // 新版本下载失败\n})\n```\n\n> 如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。\n\n根据微信提供的能力，小程序的更新流程大致如下：\n\n![](/blog/images/update/update-logic.jpg)\n\n由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。\n\n下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。\n\n由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。\n\n## 测试\n\n更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。\n\n笔者尝试在体验版上做测试：先打开`v0.0.1`版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是`v0.0.2`，根本没有还原小程序的更新机制。\n\n因此可以得出结论：**体验版无法测试更新机制**。\n\n### 模拟更新\n\n另外，开发者工具的编译模式提供模拟更新：\n\n![](/blog/images/update/mock-update.jpg)\n\n## 兼容处理\n\n由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。\n\n最简单的方式：每次升级接口时，均采用新接口。","slug":"miniprogram/update","published":1,"updated":"2023-08-04T10:48:34.750Z","_id":"cky5ioqey001ln6691r2db44c","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的更新机制与它的运行机制有关。</p>\n<p>为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"运行机制\"><a href=\"#运行机制\" class=\"headerlink\" title=\"运行机制\"></a>运行机制</h2><p>首先，先看下小程序的运行机制：</p>\n<p><img src=\"/blog/images/update/work-flow.png\"></p>\n<p>与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。</p>\n<h2 id=\"更新机制\"><a href=\"#更新机制\" class=\"headerlink\" title=\"更新机制\"></a>更新机制</h2><p>小程序的更新机制分为：</p>\n<ul>\n<li>未启动时更新</li>\n<li>启动时更新</li>\n</ul>\n<p><strong>未启动时更新</strong>：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。</p>\n<p><strong>启动时更新</strong>：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> updateManager = wx.getUpdateManager()</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onCheckForUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求完新版本信息的回调</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.hasUpdate)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateReady(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;更新提示&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">content</span>: <span class=\"string\">&#x27;新版本已经准备好，是否重启应用？&#x27;</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">success</span>(<span class=\"params\">res</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.confirm) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span></span><br><span class=\"line\">        updateManager.applyUpdate()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateFailed(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新版本下载失败</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。</p>\n</blockquote>\n<p>根据微信提供的能力，小程序的更新流程大致如下：</p>\n<p><img src=\"/blog/images/update/update-logic.jpg\"></p>\n<p>由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。</p>\n<p>下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。</p>\n<p>由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。</p>\n<p>笔者尝试在体验版上做测试：先打开<code>v0.0.1</code>版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是<code>v0.0.2</code>，根本没有还原小程序的更新机制。</p>\n<p>因此可以得出结论：<strong>体验版无法测试更新机制</strong>。</p>\n<h3 id=\"模拟更新\"><a href=\"#模拟更新\" class=\"headerlink\" title=\"模拟更新\"></a>模拟更新</h3><p>另外，开发者工具的编译模式提供模拟更新：</p>\n<p><img src=\"/blog/images/update/mock-update.jpg\"></p>\n<h2 id=\"兼容处理\"><a href=\"#兼容处理\" class=\"headerlink\" title=\"兼容处理\"></a>兼容处理</h2><p>由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。</p>\n<p>最简单的方式：每次升级接口时，均采用新接口。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>小程序的更新机制与它的运行机制有关。</p>\n<p>为了保证用户能尽可能快得打开小程序，只会在后台更新，不会主动等待更新完毕才进入最新版小程序。</p>","more":"<h2 id=\"运行机制\"><a href=\"#运行机制\" class=\"headerlink\" title=\"运行机制\"></a>运行机制</h2><p>首先，先看下小程序的运行机制：</p>\n<p><img src=\"/blog/images/update/work-flow.png\"></p>\n<p>与APP的概念有些类似，初次打开即为冷启动，若启动之后，在被系统回收之前再次打开，则称之为热启动。</p>\n<h2 id=\"更新机制\"><a href=\"#更新机制\" class=\"headerlink\" title=\"更新机制\"></a>更新机制</h2><p>小程序的更新机制分为：</p>\n<ul>\n<li>未启动时更新</li>\n<li>启动时更新</li>\n</ul>\n<p><strong>未启动时更新</strong>：意味着微信客户端会在用户不在访问小程序期间，主动触发更新，最慢24小时内覆盖所有用户。如果用户在未覆盖期间进入小程序，则触发了启动时更新。</p>\n<p><strong>启动时更新</strong>：用户冷启动进入小程序时，均会检测小程序是否有更新版本，若有则后台默默更新，准备为下次冷启动时使用。需要注意的是，此时访问的仍是旧版本的小程序。如果此时想手动使用新版小程序，则可以使用官方API：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> updateManager = wx.getUpdateManager()</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onCheckForUpdate(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求完新版本信息的回调</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.hasUpdate)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateReady(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  wx.showModal(&#123;</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">&#x27;更新提示&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">content</span>: <span class=\"string\">&#x27;新版本已经准备好，是否重启应用？&#x27;</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">success</span>(<span class=\"params\">res</span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (res.confirm) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span></span><br><span class=\"line\">        updateManager.applyUpdate()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">updateManager.onUpdateFailed(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 新版本下载失败</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如若用户是第一次打开小程序（即新用户），则会直接打开最新版本的小程序。此时不需要考虑更新机制。</p>\n</blockquote>\n<p>根据微信提供的能力，小程序的更新流程大致如下：</p>\n<p><img src=\"/blog/images/update/update-logic.jpg\"></p>\n<p>由于官方API没有提供主动下载新版本小程序的能力，仅提供了检测的能力。因此，当新版本下载失败时，没法主动触发重试，只能让用户继续访问旧版本的小程序。</p>\n<p>下载失败之后，小程序的重试机制不得而知。可能需要等待小程序被销毁之后，再次冷启动时才会再次主动更新；又或者等待24小时之后。</p>\n<p>由于可能存在下载新版本失败的用户，因此小程序的后端服务需要考虑向后兼容。另外，可以在下载失败的回调函数里加入数据统计，用于计算更新失败的概率。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更新机制的测试工作比较麻烦，因为可能要上生产环境测试，风险极大。</p>\n<p>笔者尝试在体验版上做测试：先打开<code>v0.0.1</code>版本的小程序，然后在开发者工具上传新的版本，再通过最近访问的列表里再次打开小程序，结果发现直接打开的就是<code>v0.0.2</code>，根本没有还原小程序的更新机制。</p>\n<p>因此可以得出结论：<strong>体验版无法测试更新机制</strong>。</p>\n<h3 id=\"模拟更新\"><a href=\"#模拟更新\" class=\"headerlink\" title=\"模拟更新\"></a>模拟更新</h3><p>另外，开发者工具的编译模式提供模拟更新：</p>\n<p><img src=\"/blog/images/update/mock-update.jpg\"></p>\n<h2 id=\"兼容处理\"><a href=\"#兼容处理\" class=\"headerlink\" title=\"兼容处理\"></a>兼容处理</h2><p>由于存在用户访问旧版小程序的可能，因此与后端的接口设计需要特别关注，尤其是在更新接口时，如果没有做到向后兼容，则会出现旧前端访问新后端的现象，从而产生不可预期的后果。</p>\n<p>最简单的方式：每次升级接口时，均采用新接口。</p>"},{"title":"小程序的组件封装思考","desc":"小程序组件封装的思考","date":"2020-04-07T16:00:00.000Z","toc":true,"_content":"\n## 前言\n\n在小程序开发的早期，是没有 **自定义组件(component)** ，仅有 **自定义模板(template)** 的。最早接触到组件开发还是在使用 `React`、`Vue` 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多\n\n<!-- more -->\n\n## 为什么要有组件？\n\n对于这个问题，很多人的第一反应也许是：代码复用\n\n的确，代码复用是组件的核心职责，但它还有更大的使命：性能\n\n因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果\n\n![](/blog/images/components/components-graph.png)\n\n## 生命周期\n\n在 `Vue` 中，每个页面是一个 `Vue` 实例，而组件又是可复用的 `Vue` 实例，因此可以理解成，页面和组件是相同的生命周期\n\n而小程序就将页面和组件拆分成两个类：`Page` 和 `Component`，因此接收的生命周期函数也是不一样的。比如，`Page` 接收的是：`onLoad`、`onShow`、`onReady`等函数，而 `Component` 则接收 `created`、`attached`、`ready` 等函数\n\n> 命名风格都不一致，真是让人头大\n\n![](/blog/images/components/miniprogram-lifecycle.png)\n\n## 数据传递\n\n### Vue\n\n`Vue` 的组件间数据传递的机制是这样的：父组件通过`property`传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件\n\n在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境\n\n为了解决这个问题，`Vue` 推出了 `Vuex` 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：\n\n![](/blog/images/components/vuex.png)\n\n### 小程序\n\n小程序同样有类似的机制，`property`和事件。此外还提供了获取 **子组件实例** 的方法：`selectComponent()` 和  定义组件间关系的字段 `relations`\n\n其中常用的就是获取子组件实例，比如:\n\n```html\n<parent-component>\n    <child-component id=\"child\"></child-component>\n</parent-component>\n```\n\n此时，在`parent-component`组件中可以直接获取`child-component`的实例：\n\n```js\nComponent({\n    attached() {\n        let $child = this.selectComponent('#child')\n\n        // $child.doSomeThing()\n    }\n})\n```\n\n## 实战\n\n### 背景\n\n> 制作一个 **对话框(modal)** 组件\n\n也许有的读者会感到困惑，官方不是有提供 `wx.showModal` 可以直接用吗，为什么要重复造轮子\n\n其实，当你的产品想要结合 `Modal` 和 `Button` 的 `open-type` 能力时，你就会明白重复造轮子的必要性以及`wx.showModal`的局限性\n\n### 属性定义\n\n对话框的常见属性可以参考`wx.showModal`\n\n除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：`visible`\n\n此时，有两种选择，第一种是将这个变量存在页面上，通过`property`传递给`Modal`组件；另外一种，就是作为`Modal`组件`data`中的一员\n\n### property传递\n\n通过`property`传递的话，就相当于将 `Modal` 的控制权交到对应的页面，举例：\n\n```html\n<!-- home.wxml -->\n\n<modal visible=\"{{visible}}\" />\n```\n\n```js\n// home.js\n\nPage({\n    data: {\n        visible: false\n    },\n    toggleModal() {\n        this.setData({ visible: !this.data.visible })\n    }\n})\n```\n\n此时对应的 `Modal`：\n\n```js\n// modal.js\n\nComponent({\n    properties: {\n        visible: {\n            type: Boolean,\n            value: false,\n            observer(newVal, oldVal) {\n                this.setData({ visible: newVal })\n            }\n        }\n    }\n})\n```\n\n> 这里和`Vue`框架有个差异，`Vue`对于传进来的property会自动赋值，而小程序则需要自己手动赋值\n\n#### 问题与办法\n\n当 `visible` 这个变量被 `Modal` 和 `Page` 同时使用时，会出现不显示的问题。\n\n为了便于描述，我通过描述真实场景来讲解：\n\n1. 当页面需要显示对话框时，`Page` 传递 `visible=true` 给 `Modal`\n2. 经过一段时间之后，用户关闭了对话框，此时 `Modal` 将自身的 `visible` 设置为 `false`\n3. 当页面需要再次出现对话框时，`Page` 继续传递`visible=true` 给 `Modal`，**此时发现对话框不会显示**\n\n通过分析可以发现，由于 `Page` 两次传递相同的 `visible=true` 给 `Modal` ，因此第二次传递的时候，被 `Modal` 直接忽略掉了。\n\n这个问题也很好解决，大致思路就是保证每次传递的值不同即可：\n\n- 传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）\n- 利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如`{ visible: true } !== { visible: true }`)\n\n### 组件自身属性\n\n这种是我推荐的方案。将 `visible` 属性交由组件 `Modal` 自行管理：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    },\n    methods: {\n        show() {\n            this.setData({ visible: true })\n        }\n    }\n})\n```\n\n由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的`setData`，如：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.setData({ visible: true })\n```\n\n但是不建议这样使用，而是组件暴露方法让外部调用：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.show()\n```\n\n### 组件的事件\n\n通常，对话框都会有按钮，一个或两个。\n\n因此 `Modal` 需要与父组件通过 **事件(event)** 的方式传递信息：当前点击了取消还是确定按钮：\n\n```html\n<!-- home.wxml -->\n\n<modal id=\"modal\" bind:btntap=\"handleModalTap\" />\n```\n\n```js\n// home.js\n\nPage({\n    showModal() {\n        let $modal = this.selectComponent('#modal')\n\n        $modal.show()\n    },\n\n    // 其他方法\n\n    handleModalTap(e) {\n        let { type } = e.detail\n\n        // type = cancel or confirm\n    }\n})\n```\n\n在 `Modal` 的构造函数则是这样的：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    }\n    methods: {\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n```html\n<!-- modal.wxml -->\n\n<view class=\"wrapper\">\n    <!-- 省略其他结构 -->\n    <view class=\"foot\" bindtap=\"handleBtnTap\">\n        <button data-type=\"cancel\">取消</button>\n        <button data-type=\"confirm\">确定</button>\n    </view>\n</view>\n```\n\n这样设计 `Modal` 组件，的确可以满足使用，但是不够好用\n\n因为展示对话框时使用的是 `showModal` 而用户操作之后又是通过另外一个方法 `handleModalTap` 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护\n\n所以，我建议结合 `Promise` 来封装 `Modal`\n\n### 省略事件\n\n由于展示对话框之后，用户必然要操作，因此可以在 `showModal` 的时候，通过 `Promise` 返回对应的操作信息即可\n\n另外，需要引入发布订阅机制（以下使用 `Node.js` 的 `Events` 举例）：\n\n```js\n// modal.js\n\nconst EventEmitter = require('events');\nconst ee = new EventEmitter();\n\nComponent({\n    data: {\n        visible: false\n    },\n\n    methods: {\n        show() {\n            this.setData({ visible: true })\n\n            return new Promise((resolve, reject) => {\n                ee.on('cancel', () => {\n                    reject()\n                })\n                ee.on('confirm', () => {\n                    resolve()\n                })\n            })\n        },\n\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            ee.emit(type)\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n此时，在 `Page` 即可这样展示对话框：\n\n```js\n// home.js\n\nPage({\n    onLoad() {\n        let $modal = this.selectComponent('#modal')\n\n        $moda.show().then(() => {\n            // 当点击确认时\n        }).catch(() => {\n            // 当点击取消时\n        })\n    }\n})\n```\n\n## 总结\n\n组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！","source":"_posts/miniprogram/thinking-about-components.md","raw":"---\ntitle: 小程序的组件封装思考\ndesc: 小程序组件封装的思考\ntags: \n- 小程序\ndate: 2020-4-8\ntoc: true\ncategories:\n- 小程序\n---\n\n## 前言\n\n在小程序开发的早期，是没有 **自定义组件(component)** ，仅有 **自定义模板(template)** 的。最早接触到组件开发还是在使用 `React`、`Vue` 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多\n\n<!-- more -->\n\n## 为什么要有组件？\n\n对于这个问题，很多人的第一反应也许是：代码复用\n\n的确，代码复用是组件的核心职责，但它还有更大的使命：性能\n\n因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果\n\n![](/blog/images/components/components-graph.png)\n\n## 生命周期\n\n在 `Vue` 中，每个页面是一个 `Vue` 实例，而组件又是可复用的 `Vue` 实例，因此可以理解成，页面和组件是相同的生命周期\n\n而小程序就将页面和组件拆分成两个类：`Page` 和 `Component`，因此接收的生命周期函数也是不一样的。比如，`Page` 接收的是：`onLoad`、`onShow`、`onReady`等函数，而 `Component` 则接收 `created`、`attached`、`ready` 等函数\n\n> 命名风格都不一致，真是让人头大\n\n![](/blog/images/components/miniprogram-lifecycle.png)\n\n## 数据传递\n\n### Vue\n\n`Vue` 的组件间数据传递的机制是这样的：父组件通过`property`传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件\n\n在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境\n\n为了解决这个问题，`Vue` 推出了 `Vuex` 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：\n\n![](/blog/images/components/vuex.png)\n\n### 小程序\n\n小程序同样有类似的机制，`property`和事件。此外还提供了获取 **子组件实例** 的方法：`selectComponent()` 和  定义组件间关系的字段 `relations`\n\n其中常用的就是获取子组件实例，比如:\n\n```html\n<parent-component>\n    <child-component id=\"child\"></child-component>\n</parent-component>\n```\n\n此时，在`parent-component`组件中可以直接获取`child-component`的实例：\n\n```js\nComponent({\n    attached() {\n        let $child = this.selectComponent('#child')\n\n        // $child.doSomeThing()\n    }\n})\n```\n\n## 实战\n\n### 背景\n\n> 制作一个 **对话框(modal)** 组件\n\n也许有的读者会感到困惑，官方不是有提供 `wx.showModal` 可以直接用吗，为什么要重复造轮子\n\n其实，当你的产品想要结合 `Modal` 和 `Button` 的 `open-type` 能力时，你就会明白重复造轮子的必要性以及`wx.showModal`的局限性\n\n### 属性定义\n\n对话框的常见属性可以参考`wx.showModal`\n\n除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：`visible`\n\n此时，有两种选择，第一种是将这个变量存在页面上，通过`property`传递给`Modal`组件；另外一种，就是作为`Modal`组件`data`中的一员\n\n### property传递\n\n通过`property`传递的话，就相当于将 `Modal` 的控制权交到对应的页面，举例：\n\n```html\n<!-- home.wxml -->\n\n<modal visible=\"{{visible}}\" />\n```\n\n```js\n// home.js\n\nPage({\n    data: {\n        visible: false\n    },\n    toggleModal() {\n        this.setData({ visible: !this.data.visible })\n    }\n})\n```\n\n此时对应的 `Modal`：\n\n```js\n// modal.js\n\nComponent({\n    properties: {\n        visible: {\n            type: Boolean,\n            value: false,\n            observer(newVal, oldVal) {\n                this.setData({ visible: newVal })\n            }\n        }\n    }\n})\n```\n\n> 这里和`Vue`框架有个差异，`Vue`对于传进来的property会自动赋值，而小程序则需要自己手动赋值\n\n#### 问题与办法\n\n当 `visible` 这个变量被 `Modal` 和 `Page` 同时使用时，会出现不显示的问题。\n\n为了便于描述，我通过描述真实场景来讲解：\n\n1. 当页面需要显示对话框时，`Page` 传递 `visible=true` 给 `Modal`\n2. 经过一段时间之后，用户关闭了对话框，此时 `Modal` 将自身的 `visible` 设置为 `false`\n3. 当页面需要再次出现对话框时，`Page` 继续传递`visible=true` 给 `Modal`，**此时发现对话框不会显示**\n\n通过分析可以发现，由于 `Page` 两次传递相同的 `visible=true` 给 `Modal` ，因此第二次传递的时候，被 `Modal` 直接忽略掉了。\n\n这个问题也很好解决，大致思路就是保证每次传递的值不同即可：\n\n- 传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）\n- 利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如`{ visible: true } !== { visible: true }`)\n\n### 组件自身属性\n\n这种是我推荐的方案。将 `visible` 属性交由组件 `Modal` 自行管理：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    },\n    methods: {\n        show() {\n            this.setData({ visible: true })\n        }\n    }\n})\n```\n\n由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的`setData`，如：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.setData({ visible: true })\n```\n\n但是不建议这样使用，而是组件暴露方法让外部调用：\n\n```js\nlet $modal = this.selectComponent('#modal')\n\n$modal.show()\n```\n\n### 组件的事件\n\n通常，对话框都会有按钮，一个或两个。\n\n因此 `Modal` 需要与父组件通过 **事件(event)** 的方式传递信息：当前点击了取消还是确定按钮：\n\n```html\n<!-- home.wxml -->\n\n<modal id=\"modal\" bind:btntap=\"handleModalTap\" />\n```\n\n```js\n// home.js\n\nPage({\n    showModal() {\n        let $modal = this.selectComponent('#modal')\n\n        $modal.show()\n    },\n\n    // 其他方法\n\n    handleModalTap(e) {\n        let { type } = e.detail\n\n        // type = cancel or confirm\n    }\n})\n```\n\n在 `Modal` 的构造函数则是这样的：\n\n```js\n// modal.js\n\nComponent({\n    data: {\n        visible: false\n    }\n    methods: {\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n```html\n<!-- modal.wxml -->\n\n<view class=\"wrapper\">\n    <!-- 省略其他结构 -->\n    <view class=\"foot\" bindtap=\"handleBtnTap\">\n        <button data-type=\"cancel\">取消</button>\n        <button data-type=\"confirm\">确定</button>\n    </view>\n</view>\n```\n\n这样设计 `Modal` 组件，的确可以满足使用，但是不够好用\n\n因为展示对话框时使用的是 `showModal` 而用户操作之后又是通过另外一个方法 `handleModalTap` 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护\n\n所以，我建议结合 `Promise` 来封装 `Modal`\n\n### 省略事件\n\n由于展示对话框之后，用户必然要操作，因此可以在 `showModal` 的时候，通过 `Promise` 返回对应的操作信息即可\n\n另外，需要引入发布订阅机制（以下使用 `Node.js` 的 `Events` 举例）：\n\n```js\n// modal.js\n\nconst EventEmitter = require('events');\nconst ee = new EventEmitter();\n\nComponent({\n    data: {\n        visible: false\n    },\n\n    methods: {\n        show() {\n            this.setData({ visible: true })\n\n            return new Promise((resolve, reject) => {\n                ee.on('cancel', () => {\n                    reject()\n                })\n                ee.on('confirm', () => {\n                    resolve()\n                })\n            })\n        },\n\n        handleBtnTap(e) {\n            let { type } = e.target.dataset\n\n            ee.emit(type)\n            this.triggerEvent('btntap', { type })\n        }\n    }\n})\n```\n\n此时，在 `Page` 即可这样展示对话框：\n\n```js\n// home.js\n\nPage({\n    onLoad() {\n        let $modal = this.selectComponent('#modal')\n\n        $moda.show().then(() => {\n            // 当点击确认时\n        }).catch(() => {\n            // 当点击取消时\n        })\n    }\n})\n```\n\n## 总结\n\n组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！","slug":"miniprogram/thinking-about-components","published":1,"updated":"2023-08-04T10:47:26.145Z","_id":"cky5ioqf0001yn669cm8s1rzq","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在小程序开发的早期，是没有 <strong>自定义组件(component)</strong> ，仅有 <strong>自定义模板(template)</strong> 的。最早接触到组件开发还是在使用 <code>React</code>、<code>Vue</code> 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多</p>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么要有组件？\"><a href=\"#为什么要有组件？\" class=\"headerlink\" title=\"为什么要有组件？\"></a>为什么要有组件？</h2><p>对于这个问题，很多人的第一反应也许是：代码复用</p>\n<p>的确，代码复用是组件的核心职责，但它还有更大的使命：性能</p>\n<p>因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果</p>\n<p><img src=\"/blog/images/components/components-graph.png\"></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>在 <code>Vue</code> 中，每个页面是一个 <code>Vue</code> 实例，而组件又是可复用的 <code>Vue</code> 实例，因此可以理解成，页面和组件是相同的生命周期</p>\n<p>而小程序就将页面和组件拆分成两个类：<code>Page</code> 和 <code>Component</code>，因此接收的生命周期函数也是不一样的。比如，<code>Page</code> 接收的是：<code>onLoad</code>、<code>onShow</code>、<code>onReady</code>等函数，而 <code>Component</code> 则接收 <code>created</code>、<code>attached</code>、<code>ready</code> 等函数</p>\n<blockquote>\n<p>命名风格都不一致，真是让人头大</p>\n</blockquote>\n<p><img src=\"/blog/images/components/miniprogram-lifecycle.png\"></p>\n<h2 id=\"数据传递\"><a href=\"#数据传递\" class=\"headerlink\" title=\"数据传递\"></a>数据传递</h2><h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p><code>Vue</code> 的组件间数据传递的机制是这样的：父组件通过<code>property</code>传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件</p>\n<p>在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境</p>\n<p>为了解决这个问题，<code>Vue</code> 推出了 <code>Vuex</code> 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：</p>\n<p><img src=\"/blog/images/components/vuex.png\"></p>\n<h3 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h3><p>小程序同样有类似的机制，<code>property</code>和事件。此外还提供了获取 <strong>子组件实例</strong> 的方法：<code>selectComponent()</code> 和  定义组件间关系的字段 <code>relations</code></p>\n<p>其中常用的就是获取子组件实例，比如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child-component</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;child&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，在<code>parent-component</code>组件中可以直接获取<code>child-component</code>的实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">attached</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $child = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#child&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// $child.doSomeThing()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>制作一个 <strong>对话框(modal)</strong> 组件</p>\n</blockquote>\n<p>也许有的读者会感到困惑，官方不是有提供 <code>wx.showModal</code> 可以直接用吗，为什么要重复造轮子</p>\n<p>其实，当你的产品想要结合 <code>Modal</code> 和 <code>Button</code> 的 <code>open-type</code> 能力时，你就会明白重复造轮子的必要性以及<code>wx.showModal</code>的局限性</p>\n<h3 id=\"属性定义\"><a href=\"#属性定义\" class=\"headerlink\" title=\"属性定义\"></a>属性定义</h3><p>对话框的常见属性可以参考<code>wx.showModal</code></p>\n<p>除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：<code>visible</code></p>\n<p>此时，有两种选择，第一种是将这个变量存在页面上，通过<code>property</code>传递给<code>Modal</code>组件；另外一种，就是作为<code>Modal</code>组件<code>data</code>中的一员</p>\n<h3 id=\"property传递\"><a href=\"#property传递\" class=\"headerlink\" title=\"property传递\"></a>property传递</h3><p>通过<code>property</code>传递的话，就相当于将 <code>Modal</code> 的控制权交到对应的页面，举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">visible</span>=<span class=\"string\">&quot;&#123;&#123;visible&#125;&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">toggleModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: !<span class=\"built_in\">this</span>.data.visible &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时对应的 <code>Modal</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">observer</span>(<span class=\"params\">newVal, oldVal</span>)</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: newVal &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里和<code>Vue</code>框架有个差异，<code>Vue</code>对于传进来的property会自动赋值，而小程序则需要自己手动赋值</p>\n</blockquote>\n<h4 id=\"问题与办法\"><a href=\"#问题与办法\" class=\"headerlink\" title=\"问题与办法\"></a>问题与办法</h4><p>当 <code>visible</code> 这个变量被 <code>Modal</code> 和 <code>Page</code> 同时使用时，会出现不显示的问题。</p>\n<p>为了便于描述，我通过描述真实场景来讲解：</p>\n<ol>\n<li>当页面需要显示对话框时，<code>Page</code> 传递 <code>visible=true</code> 给 <code>Modal</code></li>\n<li>经过一段时间之后，用户关闭了对话框，此时 <code>Modal</code> 将自身的 <code>visible</code> 设置为 <code>false</code></li>\n<li>当页面需要再次出现对话框时，<code>Page</code> 继续传递<code>visible=true</code> 给 <code>Modal</code>，<strong>此时发现对话框不会显示</strong></li>\n</ol>\n<p>通过分析可以发现，由于 <code>Page</code> 两次传递相同的 <code>visible=true</code> 给 <code>Modal</code> ，因此第二次传递的时候，被 <code>Modal</code> 直接忽略掉了。</p>\n<p>这个问题也很好解决，大致思路就是保证每次传递的值不同即可：</p>\n<ul>\n<li>传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）</li>\n<li>利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如<code>&#123; visible: true &#125; !== &#123; visible: true &#125;</code>)</li>\n</ul>\n<h3 id=\"组件自身属性\"><a href=\"#组件自身属性\" class=\"headerlink\" title=\"组件自身属性\"></a>组件自身属性</h3><p>这种是我推荐的方案。将 <code>visible</code> 属性交由组件 <code>Modal</code> 自行管理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的<code>setData</code>，如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>但是不建议这样使用，而是组件暴露方法让外部调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.show()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件的事件\"><a href=\"#组件的事件\" class=\"headerlink\" title=\"组件的事件\"></a>组件的事件</h3><p>通常，对话框都会有按钮，一个或两个。</p>\n<p>因此 <code>Modal</code> 需要与父组件通过 <strong>事件(event)</strong> 的方式传递信息：当前点击了取消还是确定按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;modal&quot;</span> <span class=\"attr\">bind:btntap</span>=<span class=\"string\">&quot;handleModalTap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">showModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $modal.show()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleModalTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; type &#125; = e.detail</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// type = cancel or confirm</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Modal</code> 的构造函数则是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- modal.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 省略其他结构 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;foot&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleBtnTap&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;cancel&quot;</span>&gt;</span>取消<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;confirm&quot;</span>&gt;</span>确定<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样设计 <code>Modal</code> 组件，的确可以满足使用，但是不够好用</p>\n<p>因为展示对话框时使用的是 <code>showModal</code> 而用户操作之后又是通过另外一个方法 <code>handleModalTap</code> 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护</p>\n<p>所以，我建议结合 <code>Promise</code> 来封装 <code>Modal</code></p>\n<h3 id=\"省略事件\"><a href=\"#省略事件\" class=\"headerlink\" title=\"省略事件\"></a>省略事件</h3><p>由于展示对话框之后，用户必然要操作，因此可以在 <code>showModal</code> 的时候，通过 <code>Promise</code> 返回对应的操作信息即可</p>\n<p>另外，需要引入发布订阅机制（以下使用 <code>Node.js</code> 的 <code>Events</code> 举例）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ee = <span class=\"keyword\">new</span> EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;cancel&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    reject()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;confirm&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    resolve()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            ee.emit(type)</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时，在 <code>Page</code> 即可这样展示对话框：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $moda.show().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击确认时</span></span><br><span class=\"line\">        &#125;).catch(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击取消时</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在小程序开发的早期，是没有 <strong>自定义组件(component)</strong> ，仅有 <strong>自定义模板(template)</strong> 的。最早接触到组件开发还是在使用 <code>React</code>、<code>Vue</code> 框架的时候，熟悉以上两个框架的读者，对小程序的组件应该会有熟悉的感觉，机制和写法差不多</p>","more":"<h2 id=\"为什么要有组件？\"><a href=\"#为什么要有组件？\" class=\"headerlink\" title=\"为什么要有组件？\"></a>为什么要有组件？</h2><p>对于这个问题，很多人的第一反应也许是：代码复用</p>\n<p>的确，代码复用是组件的核心职责，但它还有更大的使命：性能</p>\n<p>因为通过组件封装，可以将页面拆分成多个组件，因此较大粒度的页面就被拆分成粒度较小的组件。当一些数据发生变更导致页面变化时，就只需要重新渲染包含该数据的组件即可，而不用渲染整个页面，从而达到了提高渲染性能的效果</p>\n<p><img src=\"/blog/images/components/components-graph.png\"></p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>在 <code>Vue</code> 中，每个页面是一个 <code>Vue</code> 实例，而组件又是可复用的 <code>Vue</code> 实例，因此可以理解成，页面和组件是相同的生命周期</p>\n<p>而小程序就将页面和组件拆分成两个类：<code>Page</code> 和 <code>Component</code>，因此接收的生命周期函数也是不一样的。比如，<code>Page</code> 接收的是：<code>onLoad</code>、<code>onShow</code>、<code>onReady</code>等函数，而 <code>Component</code> 则接收 <code>created</code>、<code>attached</code>、<code>ready</code> 等函数</p>\n<blockquote>\n<p>命名风格都不一致，真是让人头大</p>\n</blockquote>\n<p><img src=\"/blog/images/components/miniprogram-lifecycle.png\"></p>\n<h2 id=\"数据传递\"><a href=\"#数据传递\" class=\"headerlink\" title=\"数据传递\"></a>数据传递</h2><h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p><code>Vue</code> 的组件间数据传递的机制是这样的：父组件通过<code>property</code>传递数据给子组件，而子组件通过事件通知的形式传递数据给父组件</p>\n<p>在页面包含的组件结构还比较简单的时候，这样的机制还是比较好用的。但是，随着业务的复杂度逐渐上升，组件嵌套的层数递增，会出现数据层层传递的困境</p>\n<p>为了解决这个问题，<code>Vue</code> 推出了 <code>Vuex</code> 这样的状态管理工具，集中式存储、管理应用的所有组件的状态。并提出了“单向数据流”的理念：</p>\n<p><img src=\"/blog/images/components/vuex.png\"></p>\n<h3 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h3><p>小程序同样有类似的机制，<code>property</code>和事件。此外还提供了获取 <strong>子组件实例</strong> 的方法：<code>selectComponent()</code> 和  定义组件间关系的字段 <code>relations</code></p>\n<p>其中常用的就是获取子组件实例，比如:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child-component</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;child&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">child-component</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时，在<code>parent-component</code>组件中可以直接获取<code>child-component</code>的实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">attached</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $child = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#child&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// $child.doSomeThing()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>制作一个 <strong>对话框(modal)</strong> 组件</p>\n</blockquote>\n<p>也许有的读者会感到困惑，官方不是有提供 <code>wx.showModal</code> 可以直接用吗，为什么要重复造轮子</p>\n<p>其实，当你的产品想要结合 <code>Modal</code> 和 <code>Button</code> 的 <code>open-type</code> 能力时，你就会明白重复造轮子的必要性以及<code>wx.showModal</code>的局限性</p>\n<h3 id=\"属性定义\"><a href=\"#属性定义\" class=\"headerlink\" title=\"属性定义\"></a>属性定义</h3><p>对话框的常见属性可以参考<code>wx.showModal</code></p>\n<p>除此以外，其中关键的一个属性就是 表示对话框当前的显示状态：<code>visible</code></p>\n<p>此时，有两种选择，第一种是将这个变量存在页面上，通过<code>property</code>传递给<code>Modal</code>组件；另外一种，就是作为<code>Modal</code>组件<code>data</code>中的一员</p>\n<h3 id=\"property传递\"><a href=\"#property传递\" class=\"headerlink\" title=\"property传递\"></a>property传递</h3><p>通过<code>property</code>传递的话，就相当于将 <code>Modal</code> 的控制权交到对应的页面，举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">visible</span>=<span class=\"string\">&quot;&#123;&#123;visible&#125;&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">toggleModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: !<span class=\"built_in\">this</span>.data.visible &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时对应的 <code>Modal</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">properties</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"built_in\">Boolean</span>,</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"title\">observer</span>(<span class=\"params\">newVal, oldVal</span>)</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: newVal &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里和<code>Vue</code>框架有个差异，<code>Vue</code>对于传进来的property会自动赋值，而小程序则需要自己手动赋值</p>\n</blockquote>\n<h4 id=\"问题与办法\"><a href=\"#问题与办法\" class=\"headerlink\" title=\"问题与办法\"></a>问题与办法</h4><p>当 <code>visible</code> 这个变量被 <code>Modal</code> 和 <code>Page</code> 同时使用时，会出现不显示的问题。</p>\n<p>为了便于描述，我通过描述真实场景来讲解：</p>\n<ol>\n<li>当页面需要显示对话框时，<code>Page</code> 传递 <code>visible=true</code> 给 <code>Modal</code></li>\n<li>经过一段时间之后，用户关闭了对话框，此时 <code>Modal</code> 将自身的 <code>visible</code> 设置为 <code>false</code></li>\n<li>当页面需要再次出现对话框时，<code>Page</code> 继续传递<code>visible=true</code> 给 <code>Modal</code>，<strong>此时发现对话框不会显示</strong></li>\n</ol>\n<p>通过分析可以发现，由于 <code>Page</code> 两次传递相同的 <code>visible=true</code> 给 <code>Modal</code> ，因此第二次传递的时候，被 <code>Modal</code> 直接忽略掉了。</p>\n<p>这个问题也很好解决，大致思路就是保证每次传递的值不同即可：</p>\n<ul>\n<li>传递的值前面加上时间戳，组件再将时间戳移除（比较直观，但是不方便）</li>\n<li>利用对象不相等的机制，数据传递只传对象，不传基础数据类型（比如<code>&#123; visible: true &#125; !== &#123; visible: true &#125;</code>)</li>\n</ul>\n<h3 id=\"组件自身属性\"><a href=\"#组件自身属性\" class=\"headerlink\" title=\"组件自身属性\"></a>组件自身属性</h3><p>这种是我推荐的方案。将 <code>visible</code> 属性交由组件 <code>Modal</code> 自行管理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>由于父组件或者当前页面可以直接获取组件的实例，因此可以直接调用组件的<code>setData</code>，如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>但是不建议这样使用，而是组件暴露方法让外部调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">$modal.show()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件的事件\"><a href=\"#组件的事件\" class=\"headerlink\" title=\"组件的事件\"></a>组件的事件</h3><p>通常，对话框都会有按钮，一个或两个。</p>\n<p>因此 <code>Modal</code> 需要与父组件通过 <strong>事件(event)</strong> 的方式传递信息：当前点击了取消还是确定按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- home.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">modal</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;modal&quot;</span> <span class=\"attr\">bind:btntap</span>=<span class=\"string\">&quot;handleModalTap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">showModal</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $modal.show()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">handleModalTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> &#123; type &#125; = e.detail</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// type = cancel or confirm</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Modal</code> 的构造函数则是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- modal.wxml --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrapper&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 省略其他结构 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;foot&quot;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&quot;handleBtnTap&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;cancel&quot;</span>&gt;</span>取消<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-type</span>=<span class=\"string\">&quot;confirm&quot;</span>&gt;</span>确定<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样设计 <code>Modal</code> 组件，的确可以满足使用，但是不够好用</p>\n<p>因为展示对话框时使用的是 <code>showModal</code> 而用户操作之后又是通过另外一个方法 <code>handleModalTap</code> 反馈的。当一段时间之后回看这样的代码，会发现这种写法存在思维的中断，不利于代码维护</p>\n<p>所以，我建议结合 <code>Promise</code> 来封装 <code>Modal</code></p>\n<h3 id=\"省略事件\"><a href=\"#省略事件\" class=\"headerlink\" title=\"省略事件\"></a>省略事件</h3><p>由于展示对话框之后，用户必然要操作，因此可以在 <code>showModal</code> 的时候，通过 <code>Promise</code> 返回对应的操作信息即可</p>\n<p>另外，需要引入发布订阅机制（以下使用 <code>Node.js</code> 的 <code>Events</code> 举例）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modal.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ee = <span class=\"keyword\">new</span> EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">visible</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">show</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.setData(&#123; <span class=\"attr\">visible</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;cancel&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    reject()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                ee.on(<span class=\"string\">&#x27;confirm&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                    resolve()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">handleBtnTap</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> &#123; type &#125; = e.target.dataset</span><br><span class=\"line\"></span><br><span class=\"line\">            ee.emit(type)</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;btntap&#x27;</span>, &#123; type &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时，在 <code>Page</code> 即可这样展示对话框：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// home.js</span></span><br><span class=\"line\"></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> $modal = <span class=\"built_in\">this</span>.selectComponent(<span class=\"string\">&#x27;#modal&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        $moda.show().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击确认时</span></span><br><span class=\"line\">        &#125;).catch(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当点击取消时</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>组件是很好用的机制，也是最常用到的能力。因此日常开发中，应该会遇到各种各样组件封装的问题，平时遇到应该多思考总结一下，对团队和自己都很有帮助！</p>"},{"title":"小程序实战汇总一","date":"2018-01-07T14:54:42.000Z","toc":true,"desc":"小程序 授权处理","_content":"\n随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。\n\n那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。\n\n<!-- more -->\n\n# 授权处理\n\n在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。\n\n因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。\n\n## 解决方案\n\n在基础库**1.2**版本，新增了`wx.getSetting`接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。\n\n具体实现可参考一下代码：\n\n```js\nwx.getUserInfo({\n  success: function (res) {\n    // 成功获取用户信息，继续操作\n  },\n  fail: (res) => {\n    wx.showModal({\n      title: '用户未授权',\n      content: '如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？',\n      success: (action) => {\n        if (action.confirm) {\n          \n        }\n      }\n    })\n  }\n})\n\n// 检查状态\nwx.openSetting({\n  success: (res) => {\n    // 二次授权成功\n    if (res.authSetting[\"scope.userInfo\"]) {\n      // 成功获取用户信息\n    }\n  },\n  fail: function () {\n    fail()\n  }\n})\n```\n\n# 页面数据传递\n\n页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？\n\n## URL传递\n\n类似Web的链接跳转，使用类似query串的形式。\n\n```js\nwx.navigateTo('../user/user?name=leejim')\n```\n\n在目的页的`onload`函数，可以这么获取：\n\n```js\nonLoad(options) {\n  console.log(options.name) // leejim\n}\n```\n\n## 使用客户端缓存\n\n小程序提供了本地存储的方式：`wx.setStorage`和`wx.getStorage`。\n\n可以在页面跳转前，先用`wx.setStorage`缓存数据，然后在目的页使用`wx.getStorage`获取数据。\n\n## 使用全局变量\n\n在小程序里，有一个全局函数`getApp`用来获取全局变量`app`。\n\n比如这样：\n\n```js\nvar app = getApp()\napp.index = 1 // 设置变量\n```\n\n## 往栈内的页面传递数据\n\n使用全局函数`getCurrentPages`函数可以获取栈内的所有页面。\n\n然后就可以直接设置那个页面的数据：\n\n```js\nvar pages = getCurrentPages()\npages[pages.length -1].setData({ // 往前一个页面设置数据\n  data: 123\n})\n```\n\n# 修改Input组件的值\n\n因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。\n\n但是我们能通过data绑定的方式来实现：\n\n```html\n<input value='{{inputValue}}' />\n```\n\njs部分：\n\n```js\nthis.setData({\n  inputValue: ''\n})\n```","source":"_posts/miniprogram/practice-of-wxapp-1.md","raw":"---\ntitle: 小程序实战汇总一\ndate: 2018-01-07 22:54:42\ntags: \n- 小程序\ncategories:\n- 小程序\ntoc: true\ndesc: 小程序 授权处理\n---\n\n随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。\n\n那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。\n\n<!-- more -->\n\n# 授权处理\n\n在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。\n\n因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。\n\n## 解决方案\n\n在基础库**1.2**版本，新增了`wx.getSetting`接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。\n\n具体实现可参考一下代码：\n\n```js\nwx.getUserInfo({\n  success: function (res) {\n    // 成功获取用户信息，继续操作\n  },\n  fail: (res) => {\n    wx.showModal({\n      title: '用户未授权',\n      content: '如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？',\n      success: (action) => {\n        if (action.confirm) {\n          \n        }\n      }\n    })\n  }\n})\n\n// 检查状态\nwx.openSetting({\n  success: (res) => {\n    // 二次授权成功\n    if (res.authSetting[\"scope.userInfo\"]) {\n      // 成功获取用户信息\n    }\n  },\n  fail: function () {\n    fail()\n  }\n})\n```\n\n# 页面数据传递\n\n页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？\n\n## URL传递\n\n类似Web的链接跳转，使用类似query串的形式。\n\n```js\nwx.navigateTo('../user/user?name=leejim')\n```\n\n在目的页的`onload`函数，可以这么获取：\n\n```js\nonLoad(options) {\n  console.log(options.name) // leejim\n}\n```\n\n## 使用客户端缓存\n\n小程序提供了本地存储的方式：`wx.setStorage`和`wx.getStorage`。\n\n可以在页面跳转前，先用`wx.setStorage`缓存数据，然后在目的页使用`wx.getStorage`获取数据。\n\n## 使用全局变量\n\n在小程序里，有一个全局函数`getApp`用来获取全局变量`app`。\n\n比如这样：\n\n```js\nvar app = getApp()\napp.index = 1 // 设置变量\n```\n\n## 往栈内的页面传递数据\n\n使用全局函数`getCurrentPages`函数可以获取栈内的所有页面。\n\n然后就可以直接设置那个页面的数据：\n\n```js\nvar pages = getCurrentPages()\npages[pages.length -1].setData({ // 往前一个页面设置数据\n  data: 123\n})\n```\n\n# 修改Input组件的值\n\n因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。\n\n但是我们能通过data绑定的方式来实现：\n\n```html\n<input value='{{inputValue}}' />\n```\n\njs部分：\n\n```js\nthis.setData({\n  inputValue: ''\n})\n```","slug":"miniprogram/practice-of-wxapp-1","published":1,"updated":"2022-01-08T08:36:14.003Z","_id":"cky5iqlwf0022n669b4hvh6aq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。</p>\n<p>那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"授权处理\"><a href=\"#授权处理\" class=\"headerlink\" title=\"授权处理\"></a>授权处理</h1><p>在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。</p>\n<p>因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>在基础库<strong>1.2</strong>版本，新增了<code>wx.getSetting</code>接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。</p>\n<p>具体实现可参考一下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.getUserInfo(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成功获取用户信息，继续操作</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    wx.showModal(&#123;</span><br><span class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">&#x27;用户未授权&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">content</span>: <span class=\"string\">&#x27;如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action.confirm) &#123;</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查状态</span></span><br><span class=\"line\">wx.openSetting(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 二次授权成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.authSetting[<span class=\"string\">&quot;scope.userInfo&quot;</span>]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 成功获取用户信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    fail()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"页面数据传递\"><a href=\"#页面数据传递\" class=\"headerlink\" title=\"页面数据传递\"></a>页面数据传递</h1><p>页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？</p>\n<h2 id=\"URL传递\"><a href=\"#URL传递\" class=\"headerlink\" title=\"URL传递\"></a>URL传递</h2><p>类似Web的链接跳转，使用类似query串的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.navigateTo(<span class=\"string\">&#x27;../user/user?name=leejim&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在目的页的<code>onload</code>函数，可以这么获取：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\">options</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(options.name) <span class=\"comment\">// leejim</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用客户端缓存\"><a href=\"#使用客户端缓存\" class=\"headerlink\" title=\"使用客户端缓存\"></a>使用客户端缓存</h2><p>小程序提供了本地存储的方式：<code>wx.setStorage</code>和<code>wx.getStorage</code>。</p>\n<p>可以在页面跳转前，先用<code>wx.setStorage</code>缓存数据，然后在目的页使用<code>wx.getStorage</code>获取数据。</p>\n<h2 id=\"使用全局变量\"><a href=\"#使用全局变量\" class=\"headerlink\" title=\"使用全局变量\"></a>使用全局变量</h2><p>在小程序里，有一个全局函数<code>getApp</code>用来获取全局变量<code>app</code>。</p>\n<p>比如这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = getApp()</span><br><span class=\"line\">app.index = <span class=\"number\">1</span> <span class=\"comment\">// 设置变量</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"往栈内的页面传递数据\"><a href=\"#往栈内的页面传递数据\" class=\"headerlink\" title=\"往栈内的页面传递数据\"></a>往栈内的页面传递数据</h2><p>使用全局函数<code>getCurrentPages</code>函数可以获取栈内的所有页面。</p>\n<p>然后就可以直接设置那个页面的数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pages = getCurrentPages()</span><br><span class=\"line\">pages[pages.length -<span class=\"number\">1</span>].setData(&#123; <span class=\"comment\">// 往前一个页面设置数据</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"number\">123</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改Input组件的值\"><a href=\"#修改Input组件的值\" class=\"headerlink\" title=\"修改Input组件的值\"></a>修改Input组件的值</h1><p>因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。</p>\n<p>但是我们能通过data绑定的方式来实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;&#123;&#123;inputValue&#125;&#125;&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>js部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">  <span class=\"attr\">inputValue</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>随着小程序的能力越来越强，逐渐得到越来越多用户的认可，因此对小程序的需要也越来越大。</p>\n<p>那么总结一下小程序的开发实践还是蛮有意义的一件事，希望能帮助大家，可以让大家避免走弯路。</p>","more":"<h1 id=\"授权处理\"><a href=\"#授权处理\" class=\"headerlink\" title=\"授权处理\"></a>授权处理</h1><p>在小程序中，最常见的场景就是授权处理。在小程序刚推出的时候，这个流程也还不完善，对于拒绝授权的用户将无法正常使用小程序。</p>\n<p>因为拒绝授权的用户，几分钟内是默认拒绝的，尽管你一再地调用授权的接口。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>在基础库<strong>1.2</strong>版本，新增了<code>wx.getSetting</code>接口，可以获取到用户的当前设置，利用这个接口可以实现二次授权。</p>\n<p>具体实现可参考一下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.getUserInfo(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成功获取用户信息，继续操作</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    wx.showModal(&#123;</span><br><span class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">&#x27;用户未授权&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">content</span>: <span class=\"string\">&#x27;如需正常使用清单同步功能，请按确认并在授权管理中选中“用户信息”，是否重新授权登录？&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (action.confirm) &#123;</span><br><span class=\"line\">          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查状态</span></span><br><span class=\"line\">wx.openSetting(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 二次授权成功</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.authSetting[<span class=\"string\">&quot;scope.userInfo&quot;</span>]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 成功获取用户信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">fail</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    fail()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"页面数据传递\"><a href=\"#页面数据传递\" class=\"headerlink\" title=\"页面数据传递\"></a>页面数据传递</h1><p>页面之间的数据传递是很常见的，那么在小程序中能如何传递数据呢？</p>\n<h2 id=\"URL传递\"><a href=\"#URL传递\" class=\"headerlink\" title=\"URL传递\"></a>URL传递</h2><p>类似Web的链接跳转，使用类似query串的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.navigateTo(<span class=\"string\">&#x27;../user/user?name=leejim&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在目的页的<code>onload</code>函数，可以这么获取：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">onLoad</span>(<span class=\"params\">options</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(options.name) <span class=\"comment\">// leejim</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用客户端缓存\"><a href=\"#使用客户端缓存\" class=\"headerlink\" title=\"使用客户端缓存\"></a>使用客户端缓存</h2><p>小程序提供了本地存储的方式：<code>wx.setStorage</code>和<code>wx.getStorage</code>。</p>\n<p>可以在页面跳转前，先用<code>wx.setStorage</code>缓存数据，然后在目的页使用<code>wx.getStorage</code>获取数据。</p>\n<h2 id=\"使用全局变量\"><a href=\"#使用全局变量\" class=\"headerlink\" title=\"使用全局变量\"></a>使用全局变量</h2><p>在小程序里，有一个全局函数<code>getApp</code>用来获取全局变量<code>app</code>。</p>\n<p>比如这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = getApp()</span><br><span class=\"line\">app.index = <span class=\"number\">1</span> <span class=\"comment\">// 设置变量</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"往栈内的页面传递数据\"><a href=\"#往栈内的页面传递数据\" class=\"headerlink\" title=\"往栈内的页面传递数据\"></a>往栈内的页面传递数据</h2><p>使用全局函数<code>getCurrentPages</code>函数可以获取栈内的所有页面。</p>\n<p>然后就可以直接设置那个页面的数据：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pages = getCurrentPages()</span><br><span class=\"line\">pages[pages.length -<span class=\"number\">1</span>].setData(&#123; <span class=\"comment\">// 往前一个页面设置数据</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"number\">123</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改Input组件的值\"><a href=\"#修改Input组件的值\" class=\"headerlink\" title=\"修改Input组件的值\"></a>修改Input组件的值</h1><p>因为小程序实现的是单向绑定，而且去除了原有DOM的操作，导致我们无法用常规的方式去操作input的值。</p>\n<p>但是我们能通过data绑定的方式来实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;&#123;&#123;inputValue&#125;&#125;&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>js部分：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">  <span class=\"attr\">inputValue</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"我所理解的BFC","date":"2017-11-11T02:53:38.000Z","desc":"bfc, clear float","toc":true,"_content":"\nBFC (Block Formatting Context) **块级格式化上下文**，在W3C上是这么定义的：\n\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.  \nIn a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.  \nIn a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).  \nFor information about page breaks in paged media, please consult the section on allowed page breaks.\n\n<!-- more -->\n\n## BFC效果\n\n先来说说BFC有什么效果，从效果看本质。\n\n逐个翻译W3c的定义如下：\n\n- `boxes`按顺序，从上到下，垂直排列\n\n> boxes are laid out one after the other, vertically, beginning at the top of a containing block\n\n- 相邻`boxes`的垂直距离由margin决定，但是在同一个BFC容器的话，`margin`会合并\n\n> The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.\n\n- 每个`boxes`的左边会和BFC容器的左边重叠，`float`元素也是如此\n\n> each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), \n\n- 可以解决因`float`元素导致的高度收缩问题（也就是常说的消除浮动）\n\n>  This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).\n\n## 如何触发BFC\n\n- `float`元素和 absolutely元素 (例如`position: absolute||fixed`) \n- `display`等于`inline-blocks`, `table-cells`, and `table-captions`的块级容器元素\n- `overflow`不等于`visible`的元素\n\n## BFC作用\n\n- 相邻margin合并的问题\n\n- 消除浮动\n\n## 参考\n\n- [CSS之BFC详解](http://www.html-js.com/article/1866)\n- [W3C block-formatting](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)","source":"_posts/css/what-is-bfc.md","raw":"---\ntitle: 我所理解的BFC\ndate: 2017-11-11 10:53:38\ntags:\n- CSS\n- BFC\ndesc: bfc, clear float\ntoc: true\ncategories:\n- CSS\n---\n\nBFC (Block Formatting Context) **块级格式化上下文**，在W3C上是这么定义的：\n\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.  \nIn a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.  \nIn a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).  \nFor information about page breaks in paged media, please consult the section on allowed page breaks.\n\n<!-- more -->\n\n## BFC效果\n\n先来说说BFC有什么效果，从效果看本质。\n\n逐个翻译W3c的定义如下：\n\n- `boxes`按顺序，从上到下，垂直排列\n\n> boxes are laid out one after the other, vertically, beginning at the top of a containing block\n\n- 相邻`boxes`的垂直距离由margin决定，但是在同一个BFC容器的话，`margin`会合并\n\n> The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.\n\n- 每个`boxes`的左边会和BFC容器的左边重叠，`float`元素也是如此\n\n> each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), \n\n- 可以解决因`float`元素导致的高度收缩问题（也就是常说的消除浮动）\n\n>  This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).\n\n## 如何触发BFC\n\n- `float`元素和 absolutely元素 (例如`position: absolute||fixed`) \n- `display`等于`inline-blocks`, `table-cells`, and `table-captions`的块级容器元素\n- `overflow`不等于`visible`的元素\n\n## BFC作用\n\n- 相邻margin合并的问题\n\n- 消除浮动\n\n## 参考\n\n- [CSS之BFC详解](http://www.html-js.com/article/1866)\n- [W3C block-formatting](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)","slug":"css/what-is-bfc","published":1,"updated":"2022-01-08T08:32:31.724Z","_id":"cky5j2nxc0025n669gj912itz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>BFC (Block Formatting Context) <strong>块级格式化上下文</strong>，在W3C上是这么定义的：</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.<br>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.<br>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).<br>For information about page breaks in paged media, please consult the section on allowed page breaks.</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"BFC效果\"><a href=\"#BFC效果\" class=\"headerlink\" title=\"BFC效果\"></a>BFC效果</h2><p>先来说说BFC有什么效果，从效果看本质。</p>\n<p>逐个翻译W3c的定义如下：</p>\n<ul>\n<li><code>boxes</code>按顺序，从上到下，垂直排列</li>\n</ul>\n<blockquote>\n<p>boxes are laid out one after the other, vertically, beginning at the top of a containing block</p>\n</blockquote>\n<ul>\n<li>相邻<code>boxes</code>的垂直距离由margin决定，但是在同一个BFC容器的话，<code>margin</code>会合并</li>\n</ul>\n<blockquote>\n<p>The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p>\n</blockquote>\n<ul>\n<li>每个<code>boxes</code>的左边会和BFC容器的左边重叠，<code>float</code>元素也是如此</li>\n</ul>\n<blockquote>\n<p>each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), </p>\n</blockquote>\n<ul>\n<li>可以解决因<code>float</code>元素导致的高度收缩问题（也就是常说的消除浮动）</li>\n</ul>\n<blockquote>\n<p> This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>\n</blockquote>\n<h2 id=\"如何触发BFC\"><a href=\"#如何触发BFC\" class=\"headerlink\" title=\"如何触发BFC\"></a>如何触发BFC</h2><ul>\n<li><code>float</code>元素和 absolutely元素 (例如<code>position: absolute||fixed</code>) </li>\n<li><code>display</code>等于<code>inline-blocks</code>, <code>table-cells</code>, and <code>table-captions</code>的块级容器元素</li>\n<li><code>overflow</code>不等于<code>visible</code>的元素</li>\n</ul>\n<h2 id=\"BFC作用\"><a href=\"#BFC作用\" class=\"headerlink\" title=\"BFC作用\"></a>BFC作用</h2><ul>\n<li><p>相邻margin合并的问题</p>\n</li>\n<li><p>消除浮动</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.html-js.com/article/1866\">CSS之BFC详解</a></li>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\">W3C block-formatting</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>BFC (Block Formatting Context) <strong>块级格式化上下文</strong>，在W3C上是这么定义的：</p>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.<br>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.<br>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).<br>For information about page breaks in paged media, please consult the section on allowed page breaks.</p>\n</blockquote>","more":"<h2 id=\"BFC效果\"><a href=\"#BFC效果\" class=\"headerlink\" title=\"BFC效果\"></a>BFC效果</h2><p>先来说说BFC有什么效果，从效果看本质。</p>\n<p>逐个翻译W3c的定义如下：</p>\n<ul>\n<li><code>boxes</code>按顺序，从上到下，垂直排列</li>\n</ul>\n<blockquote>\n<p>boxes are laid out one after the other, vertically, beginning at the top of a containing block</p>\n</blockquote>\n<ul>\n<li>相邻<code>boxes</code>的垂直距离由margin决定，但是在同一个BFC容器的话，<code>margin</code>会合并</li>\n</ul>\n<blockquote>\n<p>The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p>\n</blockquote>\n<ul>\n<li>每个<code>boxes</code>的左边会和BFC容器的左边重叠，<code>float</code>元素也是如此</li>\n</ul>\n<blockquote>\n<p>each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), </p>\n</blockquote>\n<ul>\n<li>可以解决因<code>float</code>元素导致的高度收缩问题（也就是常说的消除浮动）</li>\n</ul>\n<blockquote>\n<p> This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>\n</blockquote>\n<h2 id=\"如何触发BFC\"><a href=\"#如何触发BFC\" class=\"headerlink\" title=\"如何触发BFC\"></a>如何触发BFC</h2><ul>\n<li><code>float</code>元素和 absolutely元素 (例如<code>position: absolute||fixed</code>) </li>\n<li><code>display</code>等于<code>inline-blocks</code>, <code>table-cells</code>, and <code>table-captions</code>的块级容器元素</li>\n<li><code>overflow</code>不等于<code>visible</code>的元素</li>\n</ul>\n<h2 id=\"BFC作用\"><a href=\"#BFC作用\" class=\"headerlink\" title=\"BFC作用\"></a>BFC作用</h2><ul>\n<li><p>相邻margin合并的问题</p>\n</li>\n<li><p>消除浮动</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.html-js.com/article/1866\">CSS之BFC详解</a></li>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\">W3C block-formatting</a></li>\n</ul>"},{"title":"探索CSS盒模型","date":"2017-08-15T16:17:32.000Z","desc":"css model，css盒模型，margin，padding，widht，height","toc":true,"_content":"\n从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。\n\n现在开发基本遇到的基本样式(`CSS`)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。\n\n<!-- more -->\n\n# 块级元素\n\n毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png)\n\n## 水平格式化\n\n水平方向的大小也是有些复杂，主要一个原因是`width`影响的是内容(`content`)区域的宽度，而不是整个可见的元素框。\n\n大多数开发者以为，`widht`指的就是可见元素框的宽度，其实不是这样的(不过`CSS3`的`box-sizing`可以修改盒模型，这里暂不讨论)。\n\n\n> **可见元素框的宽 = `margin-left` + `border-left` + `padding-left` + `width` + `padding-right` + `border-right` + `margin-right`**\n\n知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。\n\n> 以上7个属性中，只有`margin-left`、`margin-right`和`width`这三个属性可以设置为auto，其他必须设置特定的值或0\n\n### 使用auto\n\n首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的`width`。\n\n#### 设置一个auto\n\n假定父元素`width: 400px`\n\n```css\np {\n    magrin-left: auto; /* 等于200px */\n    margin-right: 100px;\n    width: 100px;\n}\n```\n\n此时`margin-left`就是弥补剩余的宽度即400-100-100=200\n\n#### 不设置auto\n\n如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的`width`:\n\n```css\np {\n  magrin-left: 100px;\n  margin-right: 100px; /* 等于200px */\n  width: 100px;  \n}\n```\n\n其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(`overconstrained`)，因此此时的`margin-right`会被强制设置成`auto`，即`margin-right=200px`而不是我们想当然的那样等于`100px`。\n\n(ps:在英语这种从左向右读的语言是强制设置`marin-right`，而在从右向左的语言则是强制设置`margin-left`为`auto`了)\n\n#### 设置两个auto\n\n首先先考虑常用的，设置两个`margin`为`auto`，此时就可以实现水平居中的效果。\n\n如果设置其中一个`margin`和`width`为`auto`的话，`margin`的值则会减为0，而`widht`会水平延伸直至充满父元素。\n\n#### 设置三个auto\n\n即`margin-left`、`margin-right`和`widht`都为`auto`。此时和上面那个例子比较类似，就是`margin`都减为0，`width`则填满父元素。\n\n### 负的margin值\n\n前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：\n\n```css\n.parent {\n    widht: 400px;\n    border: 2px solid black;\n}\n\n.child {\n    margin-left: 10px;\n    width: auto;\n    margin-right: -50px;\n}\n```\n\n这个时候child这个子元素的`widht`是多少呢？\n\n根据前面提到的算法可以得到：**10px + 0 + 0 + width + -50px = 400px**，此时可以得到`width=440px`\n\n另外需要注意的是：`padding`、`border`和`width`都不能设置为负值。\n\n## 垂直格式化\n\n垂直方向和水平的大部分都比较类似，比如：\n\n> 可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom\n\n如果此时子元素的`height`大于父元素的`height`时，具体效果就要取决于`overflow`属性的值了，这里暂不讨论。\n\n有一点不一样的是：`margin-top`和`margin-bottom`设置为`auto`的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。\n\n### 设置margin-top、margin-bottom\n\n经常会有这么一个情况：子元素设置了`margin-top`或者`margin-bottom`，但是父元素不会撑开这部分的`margin`高度，这部分出现在父元素以外:\n\n```html\n<div class=\"parent\" style=\"background-color: silver\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n此时效果是这样的：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg)\n\n因为块级元素只有块级子元素的话，其高度是子元素的`border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom`的总和。\n\n但是如果该块级元素有padding或者border的话，则其高度等于子元素的`margin-top` + `border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom` + `margin-bottom`总和。比如：\n\n```html\n<div class=\"parent\" style=\"background-color: silver; border: 1px solid black\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n#### 合并margin-top和margin-bottom\n\n众所周知的是，如果有上下两个元素，上元素的`margin-bottom`和下元素的`margin-top`是会合并的，大小等于这两个的最大值。\n\n这时又有一个例外，就是如果元素含有`padding`或者`border`的话，则不会合并。","source":"_posts/css/css-box-model.md","raw":"---\ntitle: 探索CSS盒模型\ndate: 2017-08-16 00:17:32\ntags: \n- CSS\n- 盒模型\ndesc: css model，css盒模型，margin，padding，widht，height\ntoc: true\ncategories:\n- CSS\n---\n\n从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。\n\n现在开发基本遇到的基本样式(`CSS`)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。\n\n<!-- more -->\n\n# 块级元素\n\n毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png)\n\n## 水平格式化\n\n水平方向的大小也是有些复杂，主要一个原因是`width`影响的是内容(`content`)区域的宽度，而不是整个可见的元素框。\n\n大多数开发者以为，`widht`指的就是可见元素框的宽度，其实不是这样的(不过`CSS3`的`box-sizing`可以修改盒模型，这里暂不讨论)。\n\n\n> **可见元素框的宽 = `margin-left` + `border-left` + `padding-left` + `width` + `padding-right` + `border-right` + `margin-right`**\n\n知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。\n\n> 以上7个属性中，只有`margin-left`、`margin-right`和`width`这三个属性可以设置为auto，其他必须设置特定的值或0\n\n### 使用auto\n\n首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的`width`。\n\n#### 设置一个auto\n\n假定父元素`width: 400px`\n\n```css\np {\n    magrin-left: auto; /* 等于200px */\n    margin-right: 100px;\n    width: 100px;\n}\n```\n\n此时`margin-left`就是弥补剩余的宽度即400-100-100=200\n\n#### 不设置auto\n\n如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的`width`:\n\n```css\np {\n  magrin-left: 100px;\n  margin-right: 100px; /* 等于200px */\n  width: 100px;  \n}\n```\n\n其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(`overconstrained`)，因此此时的`margin-right`会被强制设置成`auto`，即`margin-right=200px`而不是我们想当然的那样等于`100px`。\n\n(ps:在英语这种从左向右读的语言是强制设置`marin-right`，而在从右向左的语言则是强制设置`margin-left`为`auto`了)\n\n#### 设置两个auto\n\n首先先考虑常用的，设置两个`margin`为`auto`，此时就可以实现水平居中的效果。\n\n如果设置其中一个`margin`和`width`为`auto`的话，`margin`的值则会减为0，而`widht`会水平延伸直至充满父元素。\n\n#### 设置三个auto\n\n即`margin-left`、`margin-right`和`widht`都为`auto`。此时和上面那个例子比较类似，就是`margin`都减为0，`width`则填满父元素。\n\n### 负的margin值\n\n前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：\n\n```css\n.parent {\n    widht: 400px;\n    border: 2px solid black;\n}\n\n.child {\n    margin-left: 10px;\n    width: auto;\n    margin-right: -50px;\n}\n```\n\n这个时候child这个子元素的`widht`是多少呢？\n\n根据前面提到的算法可以得到：**10px + 0 + 0 + width + -50px = 400px**，此时可以得到`width=440px`\n\n另外需要注意的是：`padding`、`border`和`width`都不能设置为负值。\n\n## 垂直格式化\n\n垂直方向和水平的大部分都比较类似，比如：\n\n> 可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom\n\n如果此时子元素的`height`大于父元素的`height`时，具体效果就要取决于`overflow`属性的值了，这里暂不讨论。\n\n有一点不一样的是：`margin-top`和`margin-bottom`设置为`auto`的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。\n\n### 设置margin-top、margin-bottom\n\n经常会有这么一个情况：子元素设置了`margin-top`或者`margin-bottom`，但是父元素不会撑开这部分的`margin`高度，这部分出现在父元素以外:\n\n```html\n<div class=\"parent\" style=\"background-color: silver\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n此时效果是这样的：\n\n![](http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg)\n\n因为块级元素只有块级子元素的话，其高度是子元素的`border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom`的总和。\n\n但是如果该块级元素有padding或者border的话，则其高度等于子元素的`margin-top` + `border-top` + `padding-top` + `height` + `padding-bottom` + `border-bottom` + `margin-bottom`总和。比如：\n\n```html\n<div class=\"parent\" style=\"background-color: silver; border: 1px solid black\">\n    <p class=\"child\" style=\"margin-top: 100px; margin-bottom: 100px\">test</p>\n</div>\n```\n\n#### 合并margin-top和margin-bottom\n\n众所周知的是，如果有上下两个元素，上元素的`margin-bottom`和下元素的`margin-top`是会合并的，大小等于这两个的最大值。\n\n这时又有一个例外，就是如果元素含有`padding`或者`border`的话，则不会合并。","slug":"css/css-box-model","published":1,"updated":"2022-01-08T08:35:21.537Z","_id":"cky5jbq26002kn6698ycq45wq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。</p>\n<p>现在开发基本遇到的基本样式(<code>CSS</code>)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h1><p>毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png\"></p>\n<h2 id=\"水平格式化\"><a href=\"#水平格式化\" class=\"headerlink\" title=\"水平格式化\"></a>水平格式化</h2><p>水平方向的大小也是有些复杂，主要一个原因是<code>width</code>影响的是内容(<code>content</code>)区域的宽度，而不是整个可见的元素框。</p>\n<p>大多数开发者以为，<code>widht</code>指的就是可见元素框的宽度，其实不是这样的(不过<code>CSS3</code>的<code>box-sizing</code>可以修改盒模型，这里暂不讨论)。</p>\n<blockquote>\n<p><strong>可见元素框的宽 = <code>margin-left</code> + <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code> + <code>margin-right</code></strong></p>\n</blockquote>\n<p>知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。</p>\n<blockquote>\n<p>以上7个属性中，只有<code>margin-left</code>、<code>margin-right</code>和<code>width</code>这三个属性可以设置为auto，其他必须设置特定的值或0</p>\n</blockquote>\n<h3 id=\"使用auto\"><a href=\"#使用auto\" class=\"headerlink\" title=\"使用auto\"></a>使用auto</h3><p>首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的<code>width</code>。</p>\n<h4 id=\"设置一个auto\"><a href=\"#设置一个auto\" class=\"headerlink\" title=\"设置一个auto\"></a>设置一个auto</h4><p>假定父元素<code>width: 400px</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    magrin-<span class=\"attribute\">left</span>: auto; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时<code>margin-left</code>就是弥补剩余的宽度即400-100-100=200</p>\n<h4 id=\"不设置auto\"><a href=\"#不设置auto\" class=\"headerlink\" title=\"不设置auto\"></a>不设置auto</h4><p>如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的<code>width</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  magrin-<span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(<code>overconstrained</code>)，因此此时的<code>margin-right</code>会被强制设置成<code>auto</code>，即<code>margin-right=200px</code>而不是我们想当然的那样等于<code>100px</code>。</p>\n<p>(ps:在英语这种从左向右读的语言是强制设置<code>marin-right</code>，而在从右向左的语言则是强制设置<code>margin-left</code>为<code>auto</code>了)</p>\n<h4 id=\"设置两个auto\"><a href=\"#设置两个auto\" class=\"headerlink\" title=\"设置两个auto\"></a>设置两个auto</h4><p>首先先考虑常用的，设置两个<code>margin</code>为<code>auto</code>，此时就可以实现水平居中的效果。</p>\n<p>如果设置其中一个<code>margin</code>和<code>width</code>为<code>auto</code>的话，<code>margin</code>的值则会减为0，而<code>widht</code>会水平延伸直至充满父元素。</p>\n<h4 id=\"设置三个auto\"><a href=\"#设置三个auto\" class=\"headerlink\" title=\"设置三个auto\"></a>设置三个auto</h4><p>即<code>margin-left</code>、<code>margin-right</code>和<code>widht</code>都为<code>auto</code>。此时和上面那个例子比较类似，就是<code>margin</code>都减为0，<code>width</code>则填满父元素。</p>\n<h3 id=\"负的margin值\"><a href=\"#负的margin值\" class=\"headerlink\" title=\"负的margin值\"></a>负的margin值</h3><p>前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">    widht: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候child这个子元素的<code>widht</code>是多少呢？</p>\n<p>根据前面提到的算法可以得到：<strong>10px + 0 + 0 + width + -50px = 400px</strong>，此时可以得到<code>width=440px</code></p>\n<p>另外需要注意的是：<code>padding</code>、<code>border</code>和<code>width</code>都不能设置为负值。</p>\n<h2 id=\"垂直格式化\"><a href=\"#垂直格式化\" class=\"headerlink\" title=\"垂直格式化\"></a>垂直格式化</h2><p>垂直方向和水平的大部分都比较类似，比如：</p>\n<blockquote>\n<p>可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom</p>\n</blockquote>\n<p>如果此时子元素的<code>height</code>大于父元素的<code>height</code>时，具体效果就要取决于<code>overflow</code>属性的值了，这里暂不讨论。</p>\n<p>有一点不一样的是：<code>margin-top</code>和<code>margin-bottom</code>设置为<code>auto</code>的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。</p>\n<h3 id=\"设置margin-top、margin-bottom\"><a href=\"#设置margin-top、margin-bottom\" class=\"headerlink\" title=\"设置margin-top、margin-bottom\"></a>设置margin-top、margin-bottom</h3><p>经常会有这么一个情况：子元素设置了<code>margin-top</code>或者<code>margin-bottom</code>，但是父元素不会撑开这部分的<code>margin</code>高度，这部分出现在父元素以外:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时效果是这样的：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg\"></p>\n<p>因为块级元素只有块级子元素的话，其高度是子元素的<code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code>的总和。</p>\n<p>但是如果该块级元素有padding或者border的话，则其高度等于子元素的<code>margin-top</code> + <code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code> + <code>margin-bottom</code>总和。比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver; border: 1px solid black&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并margin-top和margin-bottom\"><a href=\"#合并margin-top和margin-bottom\" class=\"headerlink\" title=\"合并margin-top和margin-bottom\"></a>合并margin-top和margin-bottom</h4><p>众所周知的是，如果有上下两个元素，上元素的<code>margin-bottom</code>和下元素的<code>margin-top</code>是会合并的，大小等于这两个的最大值。</p>\n<p>这时又有一个例外，就是如果元素含有<code>padding</code>或者<code>border</code>的话，则不会合并。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>从w3cschool入门前端开发，到实际开发遇到问题逐个网上搜索解决。</p>\n<p>现在开发基本遇到的基本样式(<code>CSS</code>)问题都能解决，但是发现知识是零散的，不成体系，一遇到没遇过的问题，不能很好地思考只能依靠google，这就是知识体系的不完善导致的。因此我现在从《CSS权威指南》开始逐渐构建自己的CSS知识体系，并总结一下心得。</p>","more":"<h1 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h1><p>毫无疑问的，每个元素的HTML里渲染都是基于盒模型的，因此理解这个很重要。抛出一个MDN制作的盒模型的图：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/box-model-standard-small.png\"></p>\n<h2 id=\"水平格式化\"><a href=\"#水平格式化\" class=\"headerlink\" title=\"水平格式化\"></a>水平格式化</h2><p>水平方向的大小也是有些复杂，主要一个原因是<code>width</code>影响的是内容(<code>content</code>)区域的宽度，而不是整个可见的元素框。</p>\n<p>大多数开发者以为，<code>widht</code>指的就是可见元素框的宽度，其实不是这样的(不过<code>CSS3</code>的<code>box-sizing</code>可以修改盒模型，这里暂不讨论)。</p>\n<blockquote>\n<p><strong>可见元素框的宽 = <code>margin-left</code> + <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code> + <code>margin-right</code></strong></p>\n</blockquote>\n<p>知道这个知识点很重要，后面的内容都是以这个为基础进行延伸的。</p>\n<blockquote>\n<p>以上7个属性中，只有<code>margin-left</code>、<code>margin-right</code>和<code>width</code>这三个属性可以设置为auto，其他必须设置特定的值或0</p>\n</blockquote>\n<h3 id=\"使用auto\"><a href=\"#使用auto\" class=\"headerlink\" title=\"使用auto\"></a>使用auto</h3><p>首先，大家都知道的一点是，块级元素的大小是横向填充的，即自己的宽度等于父元素的<code>width</code>。</p>\n<h4 id=\"设置一个auto\"><a href=\"#设置一个auto\" class=\"headerlink\" title=\"设置一个auto\"></a>设置一个auto</h4><p>假定父元素<code>width: 400px</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    magrin-<span class=\"attribute\">left</span>: auto; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时<code>margin-left</code>就是弥补剩余的宽度即400-100-100=200</p>\n<h4 id=\"不设置auto\"><a href=\"#不设置auto\" class=\"headerlink\" title=\"不设置auto\"></a>不设置auto</h4><p>如果三个属性都设置指定的值，那么不就有这样的可能：本元素框的可见宽度不等于父元素的<code>width</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">  magrin-<span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">100px</span>; <span class=\"comment\">/* 等于200px */</span></span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实情况不是这样的，因为在CSS中，这些格式化属性过分受限(<code>overconstrained</code>)，因此此时的<code>margin-right</code>会被强制设置成<code>auto</code>，即<code>margin-right=200px</code>而不是我们想当然的那样等于<code>100px</code>。</p>\n<p>(ps:在英语这种从左向右读的语言是强制设置<code>marin-right</code>，而在从右向左的语言则是强制设置<code>margin-left</code>为<code>auto</code>了)</p>\n<h4 id=\"设置两个auto\"><a href=\"#设置两个auto\" class=\"headerlink\" title=\"设置两个auto\"></a>设置两个auto</h4><p>首先先考虑常用的，设置两个<code>margin</code>为<code>auto</code>，此时就可以实现水平居中的效果。</p>\n<p>如果设置其中一个<code>margin</code>和<code>width</code>为<code>auto</code>的话，<code>margin</code>的值则会减为0，而<code>widht</code>会水平延伸直至充满父元素。</p>\n<h4 id=\"设置三个auto\"><a href=\"#设置三个auto\" class=\"headerlink\" title=\"设置三个auto\"></a>设置三个auto</h4><p>即<code>margin-left</code>、<code>margin-right</code>和<code>widht</code>都为<code>auto</code>。此时和上面那个例子比较类似，就是<code>margin</code>都减为0，<code>width</code>则填满父元素。</p>\n<h3 id=\"负的margin值\"><a href=\"#负的margin值\" class=\"headerlink\" title=\"负的margin值\"></a>负的margin值</h3><p>前面的情况都还算简单明了，但是遇到这个负的margin值，情况就渐渐复杂起来了。看下下面这个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</span><br><span class=\"line\">    widht: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候child这个子元素的<code>widht</code>是多少呢？</p>\n<p>根据前面提到的算法可以得到：<strong>10px + 0 + 0 + width + -50px = 400px</strong>，此时可以得到<code>width=440px</code></p>\n<p>另外需要注意的是：<code>padding</code>、<code>border</code>和<code>width</code>都不能设置为负值。</p>\n<h2 id=\"垂直格式化\"><a href=\"#垂直格式化\" class=\"headerlink\" title=\"垂直格式化\"></a>垂直格式化</h2><p>垂直方向和水平的大部分都比较类似，比如：</p>\n<blockquote>\n<p>可见元素的高 = margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom</p>\n</blockquote>\n<p>如果此时子元素的<code>height</code>大于父元素的<code>height</code>时，具体效果就要取决于<code>overflow</code>属性的值了，这里暂不讨论。</p>\n<p>有一点不一样的是：<code>margin-top</code>和<code>margin-bottom</code>设置为<code>auto</code>的话，都会自动计算为0，因此垂直居中的效果不能这么轻易实现。</p>\n<h3 id=\"设置margin-top、margin-bottom\"><a href=\"#设置margin-top、margin-bottom\" class=\"headerlink\" title=\"设置margin-top、margin-bottom\"></a>设置margin-top、margin-bottom</h3><p>经常会有这么一个情况：子元素设置了<code>margin-top</code>或者<code>margin-bottom</code>，但是父元素不会撑开这部分的<code>margin</code>高度，这部分出现在父元素以外:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此时效果是这样的：</p>\n<p><img src=\"http://7xnh42.com1.z0.glb.clouddn.com/1502812757152.jpg\"></p>\n<p>因为块级元素只有块级子元素的话，其高度是子元素的<code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code>的总和。</p>\n<p>但是如果该块级元素有padding或者border的话，则其高度等于子元素的<code>margin-top</code> + <code>border-top</code> + <code>padding-top</code> + <code>height</code> + <code>padding-bottom</code> + <code>border-bottom</code> + <code>margin-bottom</code>总和。比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;parent&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;background-color: silver; border: 1px solid black&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;child&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;margin-top: 100px; margin-bottom: 100px&quot;</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并margin-top和margin-bottom\"><a href=\"#合并margin-top和margin-bottom\" class=\"headerlink\" title=\"合并margin-top和margin-bottom\"></a>合并margin-top和margin-bottom</h4><p>众所周知的是，如果有上下两个元素，上元素的<code>margin-bottom</code>和下元素的<code>margin-top</code>是会合并的，大小等于这两个的最大值。</p>\n<p>这时又有一个例外，就是如果元素含有<code>padding</code>或者<code>border</code>的话，则不会合并。</p>"},{"title":"小程序 Session","date":"2017-07-18T15:26:51.000Z","desc":null,"toc":true,"_content":"\n最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。\n\n<!-- more -->\n\n## 登录态维护\n\n每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。\n\n### 无cookie\n\n首先，第一个需要踩的坑就是无`cookie`的登录态要如何维护。\n\n微信官方提供了一个流程图，我们可以先看看：\n\n![微信官方登录时序图](https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712)\n\n简而言之：\n1. 在小程序上通过`wx.login()`获取`code`\n2. 将`code`传到自己的服务器，然后将小程序的`secret`和`appid`与微信服务器交换`openid`和`session_key`\n3. 将`session_key`加上随机数生成`sessionId`，然后`openid`和`session_key`存在`session`里\n4. 小程序将`sessionId`存起来，每次访问都带上这个`sessionId`\n\n### 小程序获取code\n\n在小程序的`app.js`文件里，`onLaunch`函数调用我们写好的`login`函数：\n\n```js\nwx.login({\n  success: function (loginResult) {\n    wx.getUserInfo({\n      withCredentials: true,\n      success: function (userResult) {\n        // doLogin 就是将这些数据发送到服务器\n        doLogin(null, {\n            code: loginResult.code,\n            encryptedData: userResult.encryptedData,\n            iv: userResult.iv\n        })\n      }\n    })\n  }\n})\n```\n\n服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是`openid`和`session_key`。\n\n### 解密用户信息\n\n通过小程序传过来的和`encryptedData`和`iv`，然后还有刚才获取的`session_key`，我们就能解密用户的信息，通过对比解密出来的`openid`和微信交换来的`openid`对比，即可知道用户信息的正确性。\n\n### sessionId生成：\n\n```js\nfunction generateSessionId() {\n  return crypto.randomBytes(32).toString('hex')\n}\n```\n\n按理说，我们生成了`sessionId`，然后将对应的用户信息存在`session`里就大功告成了。\n\n但是这样的话，很容易被伪造的暴力的伪造`sessionId`攻击。因此，需要再进一步，生成另外一个校验数据称为`sessionkey`简称`sKey`，这时就使用到刚获取到的`session_key`：\n\n```js\nfunction generateSkey(sessionKey) {\n  const sha1 = (message) => {\n      return crypto.createHash('sha1').update(message, 'utf8').digest('hex')\n  }\n\n  return sha1(appid + secret + sessionKey)\n}\n```\n\n此时我们的`session`的`key`就是一个前面随机生成的`sessionId`。`value`则为：\n\n```js\n{\n  userinfo,\n  session_key,\n  sKey\n}\n```\n\n然后每次`sessionId`传递过来的时候，我们获取对应的`session_key`，然后调用`generateSkey`生成`sKey`，然后和`session`里面的`sKey`对比即可。\n\n此时，`session`的生成大功告成了！\n\n### 两个登录态的问题\n\n首先，调用微信生成的code的`login()`函数是有时效的，大概5分钟。\n\n我们生成的`session`也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。\n\n#### 小程序登录态\n\n官方提供了`wx.checkSession()`方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的`login`函数\n\n#### session失效\n\n这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现`session`失效了。\n\n因此我们可以在`app.js`的`onShow()`里发送请求到服务器测试`session`是否过期。过期的话就重新调用`login`函数。\n","source":"_posts/miniprogram/wechat-miniapp-session.md","raw":"---\ntitle: 小程序 Session\ndate: 2017-07-18 23:26:51\ntags:\n- 小程序\n- Session\ndesc:\ntoc: true\ncategories:\n- 小程序\n---\n\n最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。\n\n<!-- more -->\n\n## 登录态维护\n\n每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。\n\n### 无cookie\n\n首先，第一个需要踩的坑就是无`cookie`的登录态要如何维护。\n\n微信官方提供了一个流程图，我们可以先看看：\n\n![微信官方登录时序图](https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712)\n\n简而言之：\n1. 在小程序上通过`wx.login()`获取`code`\n2. 将`code`传到自己的服务器，然后将小程序的`secret`和`appid`与微信服务器交换`openid`和`session_key`\n3. 将`session_key`加上随机数生成`sessionId`，然后`openid`和`session_key`存在`session`里\n4. 小程序将`sessionId`存起来，每次访问都带上这个`sessionId`\n\n### 小程序获取code\n\n在小程序的`app.js`文件里，`onLaunch`函数调用我们写好的`login`函数：\n\n```js\nwx.login({\n  success: function (loginResult) {\n    wx.getUserInfo({\n      withCredentials: true,\n      success: function (userResult) {\n        // doLogin 就是将这些数据发送到服务器\n        doLogin(null, {\n            code: loginResult.code,\n            encryptedData: userResult.encryptedData,\n            iv: userResult.iv\n        })\n      }\n    })\n  }\n})\n```\n\n服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是`openid`和`session_key`。\n\n### 解密用户信息\n\n通过小程序传过来的和`encryptedData`和`iv`，然后还有刚才获取的`session_key`，我们就能解密用户的信息，通过对比解密出来的`openid`和微信交换来的`openid`对比，即可知道用户信息的正确性。\n\n### sessionId生成：\n\n```js\nfunction generateSessionId() {\n  return crypto.randomBytes(32).toString('hex')\n}\n```\n\n按理说，我们生成了`sessionId`，然后将对应的用户信息存在`session`里就大功告成了。\n\n但是这样的话，很容易被伪造的暴力的伪造`sessionId`攻击。因此，需要再进一步，生成另外一个校验数据称为`sessionkey`简称`sKey`，这时就使用到刚获取到的`session_key`：\n\n```js\nfunction generateSkey(sessionKey) {\n  const sha1 = (message) => {\n      return crypto.createHash('sha1').update(message, 'utf8').digest('hex')\n  }\n\n  return sha1(appid + secret + sessionKey)\n}\n```\n\n此时我们的`session`的`key`就是一个前面随机生成的`sessionId`。`value`则为：\n\n```js\n{\n  userinfo,\n  session_key,\n  sKey\n}\n```\n\n然后每次`sessionId`传递过来的时候，我们获取对应的`session_key`，然后调用`generateSkey`生成`sKey`，然后和`session`里面的`sKey`对比即可。\n\n此时，`session`的生成大功告成了！\n\n### 两个登录态的问题\n\n首先，调用微信生成的code的`login()`函数是有时效的，大概5分钟。\n\n我们生成的`session`也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。\n\n#### 小程序登录态\n\n官方提供了`wx.checkSession()`方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的`login`函数\n\n#### session失效\n\n这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现`session`失效了。\n\n因此我们可以在`app.js`的`onShow()`里发送请求到服务器测试`session`是否过期。过期的话就重新调用`login`函数。\n","slug":"miniprogram/wechat-miniapp-session","published":1,"updated":"2022-01-08T08:36:22.954Z","_id":"cky5jh6iq000b1h69497sevdg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"登录态维护\"><a href=\"#登录态维护\" class=\"headerlink\" title=\"登录态维护\"></a>登录态维护</h2><p>每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。</p>\n<h3 id=\"无cookie\"><a href=\"#无cookie\" class=\"headerlink\" title=\"无cookie\"></a>无cookie</h3><p>首先，第一个需要踩的坑就是无<code>cookie</code>的登录态要如何维护。</p>\n<p>微信官方提供了一个流程图，我们可以先看看：</p>\n<p><img src=\"https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712\" alt=\"微信官方登录时序图\"></p>\n<p>简而言之：</p>\n<ol>\n<li>在小程序上通过<code>wx.login()</code>获取<code>code</code></li>\n<li>将<code>code</code>传到自己的服务器，然后将小程序的<code>secret</code>和<code>appid</code>与微信服务器交换<code>openid</code>和<code>session_key</code></li>\n<li>将<code>session_key</code>加上随机数生成<code>sessionId</code>，然后<code>openid</code>和<code>session_key</code>存在<code>session</code>里</li>\n<li>小程序将<code>sessionId</code>存起来，每次访问都带上这个<code>sessionId</code></li>\n</ol>\n<h3 id=\"小程序获取code\"><a href=\"#小程序获取code\" class=\"headerlink\" title=\"小程序获取code\"></a>小程序获取code</h3><p>在小程序的<code>app.js</code>文件里，<code>onLaunch</code>函数调用我们写好的<code>login</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.login(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">loginResult</span>) </span>&#123;</span><br><span class=\"line\">    wx.getUserInfo(&#123;</span><br><span class=\"line\">      <span class=\"attr\">withCredentials</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userResult</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// doLogin 就是将这些数据发送到服务器</span></span><br><span class=\"line\">        doLogin(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">            <span class=\"attr\">code</span>: loginResult.code,</span><br><span class=\"line\">            <span class=\"attr\">encryptedData</span>: userResult.encryptedData,</span><br><span class=\"line\">            <span class=\"attr\">iv</span>: userResult.iv</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是<code>openid</code>和<code>session_key</code>。</p>\n<h3 id=\"解密用户信息\"><a href=\"#解密用户信息\" class=\"headerlink\" title=\"解密用户信息\"></a>解密用户信息</h3><p>通过小程序传过来的和<code>encryptedData</code>和<code>iv</code>，然后还有刚才获取的<code>session_key</code>，我们就能解密用户的信息，通过对比解密出来的<code>openid</code>和微信交换来的<code>openid</code>对比，即可知道用户信息的正确性。</p>\n<h3 id=\"sessionId生成：\"><a href=\"#sessionId生成：\" class=\"headerlink\" title=\"sessionId生成：\"></a>sessionId生成：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSessionId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> crypto.randomBytes(<span class=\"number\">32</span>).toString(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按理说，我们生成了<code>sessionId</code>，然后将对应的用户信息存在<code>session</code>里就大功告成了。</p>\n<p>但是这样的话，很容易被伪造的暴力的伪造<code>sessionId</code>攻击。因此，需要再进一步，生成另外一个校验数据称为<code>sessionkey</code>简称<code>sKey</code>，这时就使用到刚获取到的<code>session_key</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSkey</span>(<span class=\"params\">sessionKey</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sha1 = <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> crypto.createHash(<span class=\"string\">&#x27;sha1&#x27;</span>).update(message, <span class=\"string\">&#x27;utf8&#x27;</span>).digest(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sha1(appid + secret + sessionKey)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们的<code>session</code>的<code>key</code>就是一个前面随机生成的<code>sessionId</code>。<code>value</code>则为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  userinfo,</span><br><span class=\"line\">  session_key,</span><br><span class=\"line\">  sKey</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后每次<code>sessionId</code>传递过来的时候，我们获取对应的<code>session_key</code>，然后调用<code>generateSkey</code>生成<code>sKey</code>，然后和<code>session</code>里面的<code>sKey</code>对比即可。</p>\n<p>此时，<code>session</code>的生成大功告成了！</p>\n<h3 id=\"两个登录态的问题\"><a href=\"#两个登录态的问题\" class=\"headerlink\" title=\"两个登录态的问题\"></a>两个登录态的问题</h3><p>首先，调用微信生成的code的<code>login()</code>函数是有时效的，大概5分钟。</p>\n<p>我们生成的<code>session</code>也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。</p>\n<h4 id=\"小程序登录态\"><a href=\"#小程序登录态\" class=\"headerlink\" title=\"小程序登录态\"></a>小程序登录态</h4><p>官方提供了<code>wx.checkSession()</code>方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的<code>login</code>函数</p>\n<h4 id=\"session失效\"><a href=\"#session失效\" class=\"headerlink\" title=\"session失效\"></a>session失效</h4><p>这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现<code>session</code>失效了。</p>\n<p>因此我们可以在<code>app.js</code>的<code>onShow()</code>里发送请求到服务器测试<code>session</code>是否过期。过期的话就重新调用<code>login</code>函数。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>最近刚完成了一项小程序的开发任务。彻彻底底地从零开始，其中遇到了不少坑要填，因此来总结一下，希望能帮助到其他人，避免重复踩坑。</p>","more":"<h2 id=\"登录态维护\"><a href=\"#登录态维护\" class=\"headerlink\" title=\"登录态维护\"></a>登录态维护</h2><p>每个人开发小程序，都希望用户能持续使用自己开发的小程序，那么维护用户的登录态就是首要的任务。</p>\n<h3 id=\"无cookie\"><a href=\"#无cookie\" class=\"headerlink\" title=\"无cookie\"></a>无cookie</h3><p>首先，第一个需要踩的坑就是无<code>cookie</code>的登录态要如何维护。</p>\n<p>微信官方提供了一个流程图，我们可以先看看：</p>\n<p><img src=\"https://mp.weixin.qq.com/debug/wxadoc/dev/image/login.png?t=2017712\" alt=\"微信官方登录时序图\"></p>\n<p>简而言之：</p>\n<ol>\n<li>在小程序上通过<code>wx.login()</code>获取<code>code</code></li>\n<li>将<code>code</code>传到自己的服务器，然后将小程序的<code>secret</code>和<code>appid</code>与微信服务器交换<code>openid</code>和<code>session_key</code></li>\n<li>将<code>session_key</code>加上随机数生成<code>sessionId</code>，然后<code>openid</code>和<code>session_key</code>存在<code>session</code>里</li>\n<li>小程序将<code>sessionId</code>存起来，每次访问都带上这个<code>sessionId</code></li>\n</ol>\n<h3 id=\"小程序获取code\"><a href=\"#小程序获取code\" class=\"headerlink\" title=\"小程序获取code\"></a>小程序获取code</h3><p>在小程序的<code>app.js</code>文件里，<code>onLaunch</code>函数调用我们写好的<code>login</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.login(&#123;</span><br><span class=\"line\">  <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">loginResult</span>) </span>&#123;</span><br><span class=\"line\">    wx.getUserInfo(&#123;</span><br><span class=\"line\">      <span class=\"attr\">withCredentials</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">success</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userResult</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// doLogin 就是将这些数据发送到服务器</span></span><br><span class=\"line\">        doLogin(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">            <span class=\"attr\">code</span>: loginResult.code,</span><br><span class=\"line\">            <span class=\"attr\">encryptedData</span>: userResult.encryptedData,</span><br><span class=\"line\">            <span class=\"attr\">iv</span>: userResult.iv</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>服务器接受到这些数据，就可以和微信服务器交换数据了，这时我们拥有的数据就是<code>openid</code>和<code>session_key</code>。</p>\n<h3 id=\"解密用户信息\"><a href=\"#解密用户信息\" class=\"headerlink\" title=\"解密用户信息\"></a>解密用户信息</h3><p>通过小程序传过来的和<code>encryptedData</code>和<code>iv</code>，然后还有刚才获取的<code>session_key</code>，我们就能解密用户的信息，通过对比解密出来的<code>openid</code>和微信交换来的<code>openid</code>对比，即可知道用户信息的正确性。</p>\n<h3 id=\"sessionId生成：\"><a href=\"#sessionId生成：\" class=\"headerlink\" title=\"sessionId生成：\"></a>sessionId生成：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSessionId</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> crypto.randomBytes(<span class=\"number\">32</span>).toString(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按理说，我们生成了<code>sessionId</code>，然后将对应的用户信息存在<code>session</code>里就大功告成了。</p>\n<p>但是这样的话，很容易被伪造的暴力的伪造<code>sessionId</code>攻击。因此，需要再进一步，生成另外一个校验数据称为<code>sessionkey</code>简称<code>sKey</code>，这时就使用到刚获取到的<code>session_key</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateSkey</span>(<span class=\"params\">sessionKey</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sha1 = <span class=\"function\">(<span class=\"params\">message</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> crypto.createHash(<span class=\"string\">&#x27;sha1&#x27;</span>).update(message, <span class=\"string\">&#x27;utf8&#x27;</span>).digest(<span class=\"string\">&#x27;hex&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sha1(appid + secret + sessionKey)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们的<code>session</code>的<code>key</code>就是一个前面随机生成的<code>sessionId</code>。<code>value</code>则为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  userinfo,</span><br><span class=\"line\">  session_key,</span><br><span class=\"line\">  sKey</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后每次<code>sessionId</code>传递过来的时候，我们获取对应的<code>session_key</code>，然后调用<code>generateSkey</code>生成<code>sKey</code>，然后和<code>session</code>里面的<code>sKey</code>对比即可。</p>\n<p>此时，<code>session</code>的生成大功告成了！</p>\n<h3 id=\"两个登录态的问题\"><a href=\"#两个登录态的问题\" class=\"headerlink\" title=\"两个登录态的问题\"></a>两个登录态的问题</h3><p>首先，调用微信生成的code的<code>login()</code>函数是有时效的，大概5分钟。</p>\n<p>我们生成的<code>session</code>也是有时效的。这样就有两个登录态任一出现失效的情况。因此我们需要处理两个的失效问题。</p>\n<h4 id=\"小程序登录态\"><a href=\"#小程序登录态\" class=\"headerlink\" title=\"小程序登录态\"></a>小程序登录态</h4><p>官方提供了<code>wx.checkSession()</code>方法给我们验证登录态是否失效。因此这个失效的话，我们就重新调用之前写好的<code>login</code>函数</p>\n<h4 id=\"session失效\"><a href=\"#session失效\" class=\"headerlink\" title=\"session失效\"></a>session失效</h4><p>这个失效的问题就比较麻烦。很有可能就是发送某一个请求的时候发现<code>session</code>失效了。</p>\n<p>因此我们可以在<code>app.js</code>的<code>onShow()</code>里发送请求到服务器测试<code>session</code>是否过期。过期的话就重新调用<code>login</code>函数。</p>"},{"title":"总结 JavaScript 的检测方式","date":"2016-11-15T12:32:12.000Z","desc":["JavaScript","detect"],"toc":true,"_content":"\n在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。\n\n<!-- more -->\n\n我们都知道，JavaScript是有5种原始类型的：\n- number\n- string\n- boolean\n- undefined\n- null\n\n## 检测原始类型\n检测原始类型的最佳选择是使用`typeof`\n\n```js\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof undefined // undefined\n```\n\n`typeof`有一个好处就是：未声明的变量也不会报错\n```js\ntypeof someVariable //此时someVariable是未定义，返回undefined\n```\n\n## 检测复合类型\n复合类型内置有（不只以下几种，只是举例说明）：\n- Object\n- Array\n- Date\n- Error\n\n当我们使用`typeof`检测的时候，就会看到都是返回object\n\n```js\ntypeof {} //object\ntypeof [] //object\ntypeof new Date() //object\ntypeof new Error() //object\n```\n\n此时的最佳选择是使用`instanceof`\n\n```js\nvar today = new Date()\n\ntoday instanceof Date // true\n```\n\n到这里好像全部的检测类型都搞定了。\n\n但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。\n\n### 检测函数\n当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：\n\n```js\n// 在frame A定义的函数test\nfunction test(){}\n\n// 在frame B检测\ntest instanceof Function //false\n\n// 而使用typeof则可以正确返回\ntypeof test // function\n```\n\n故检测函数的时候，最佳选择是使用`typeof`\n\n### 检测数组\n数组的问题和函数是一样的，因为不同的构造函数。而此时`typeof`也不灵了，因为只返回object。\n\nDouglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：\n\n```js\nfunction isArray(value){\n  return typeof value.sort === 'function';\n}\n```\n\n其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。\n\n最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：\n\n```js\nfunction isArray(value){\n  return Object.prototype.toString.call(value) === '[object Array]' ;\n}\n```\n\n这个方法能完美地辨别是否为数组。\n\n在ECMAScript 5则可以使用Array的内置方法：\n\n```js\nArray.isArray([]) // true\n```\n\n## 检测属性\n我发现，在检测一个对象的属性是否存在的时候，常常是这样的：\n\n```js\nif(object.someProps){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != null){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != undefined){\n  //一些逻辑\n}\n```\n其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用`in`运算符：\n\n```js\nif(someProps in object){\n  //一些逻辑\n}\n```\n\n以上检测数据类型的所有方式。\n\n参考：\n《Maintainable JavaScript》\n\n\n","source":"_posts/javascript-detect.md","raw":"---\ntitle: 总结 JavaScript 的检测方式\ndate: 2016-11-15 20:32:12\ntags:\ndesc:\n- JavaScript\n- detect\ntoc: true\ncategories:\n- [前端, 基础]\n---\n\n在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。\n\n<!-- more -->\n\n我们都知道，JavaScript是有5种原始类型的：\n- number\n- string\n- boolean\n- undefined\n- null\n\n## 检测原始类型\n检测原始类型的最佳选择是使用`typeof`\n\n```js\ntypeof 'abc' // string\ntypeof 123 // number\ntypeof true // boolean\ntypeof undefined // undefined\n```\n\n`typeof`有一个好处就是：未声明的变量也不会报错\n```js\ntypeof someVariable //此时someVariable是未定义，返回undefined\n```\n\n## 检测复合类型\n复合类型内置有（不只以下几种，只是举例说明）：\n- Object\n- Array\n- Date\n- Error\n\n当我们使用`typeof`检测的时候，就会看到都是返回object\n\n```js\ntypeof {} //object\ntypeof [] //object\ntypeof new Date() //object\ntypeof new Error() //object\n```\n\n此时的最佳选择是使用`instanceof`\n\n```js\nvar today = new Date()\n\ntoday instanceof Date // true\n```\n\n到这里好像全部的检测类型都搞定了。\n\n但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。\n\n### 检测函数\n当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：\n\n```js\n// 在frame A定义的函数test\nfunction test(){}\n\n// 在frame B检测\ntest instanceof Function //false\n\n// 而使用typeof则可以正确返回\ntypeof test // function\n```\n\n故检测函数的时候，最佳选择是使用`typeof`\n\n### 检测数组\n数组的问题和函数是一样的，因为不同的构造函数。而此时`typeof`也不灵了，因为只返回object。\n\nDouglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：\n\n```js\nfunction isArray(value){\n  return typeof value.sort === 'function';\n}\n```\n\n其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。\n\n最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：\n\n```js\nfunction isArray(value){\n  return Object.prototype.toString.call(value) === '[object Array]' ;\n}\n```\n\n这个方法能完美地辨别是否为数组。\n\n在ECMAScript 5则可以使用Array的内置方法：\n\n```js\nArray.isArray([]) // true\n```\n\n## 检测属性\n我发现，在检测一个对象的属性是否存在的时候，常常是这样的：\n\n```js\nif(object.someProps){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != null){\n  //一些逻辑\n}\n```\n或者是这样的：\n\n```js\nif(object.someProps != undefined){\n  //一些逻辑\n}\n```\n其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用`in`运算符：\n\n```js\nif(someProps in object){\n  //一些逻辑\n}\n```\n\n以上检测数据类型的所有方式。\n\n参考：\n《Maintainable JavaScript》\n\n\n","slug":"javascript-detect","published":1,"updated":"2022-01-08T08:38:53.398Z","_id":"cky5jpv1a000x1h69gnob9gx2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。</p>\n<span id=\"more\"></span>\n\n<p>我们都知道，JavaScript是有5种原始类型的：</p>\n<ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>null</li>\n</ul>\n<h2 id=\"检测原始类型\"><a href=\"#检测原始类型\" class=\"headerlink\" title=\"检测原始类型\"></a>检测原始类型</h2><p>检测原始类型的最佳选择是使用<code>typeof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p><code>typeof</code>有一个好处就是：未声明的变量也不会报错</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> someVariable <span class=\"comment\">//此时someVariable是未定义，返回undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测复合类型\"><a href=\"#检测复合类型\" class=\"headerlink\" title=\"检测复合类型\"></a>检测复合类型</h2><p>复合类型内置有（不只以下几种，只是举例说明）：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>Error</li>\n</ul>\n<p>当我们使用<code>typeof</code>检测的时候，就会看到都是返回object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>() <span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>\n\n<p>此时的最佳选择是使用<code>instanceof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">today <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里好像全部的检测类型都搞定了。</p>\n<p>但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。</p>\n<h3 id=\"检测函数\"><a href=\"#检测函数\" class=\"headerlink\" title=\"检测函数\"></a>检测函数</h3><p>当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在frame A定义的函数test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在frame B检测</span></span><br><span class=\"line\">test <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而使用typeof则可以正确返回</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<p>故检测函数的时候，最佳选择是使用<code>typeof</code></p>\n<h3 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h3><p>数组的问题和函数是一样的，因为不同的构造函数。而此时<code>typeof</code>也不灵了，因为只返回object。</p>\n<p>Douglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value.sort === <span class=\"string\">&#x27;function&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。</p>\n<p>最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) === <span class=\"string\">&#x27;[object Array]&#x27;</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法能完美地辨别是否为数组。</p>\n<p>在ECMAScript 5则可以使用Array的内置方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.isArray([]) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测属性\"><a href=\"#检测属性\" class=\"headerlink\" title=\"检测属性\"></a>检测属性</h2><p>我发现，在检测一个对象的属性是否存在的时候，常常是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用<code>in</code>运算符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(someProps <span class=\"keyword\">in</span> object)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上检测数据类型的所有方式。</p>\n<p>参考：<br>《Maintainable JavaScript》</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在JavaScript开发当中，因为涉及到跨平台的兼容性问题，我们常常需要去检测一些方法或者属性是否存在，如果不存在而我们贸然使用的话，就是报错导致程序无法继续运行，而用户则会不知所措。</p>","more":"<p>我们都知道，JavaScript是有5种原始类型的：</p>\n<ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>null</li>\n</ul>\n<h2 id=\"检测原始类型\"><a href=\"#检测原始类型\" class=\"headerlink\" title=\"检测原始类型\"></a>检测原始类型</h2><p>检测原始类型的最佳选择是使用<code>typeof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">123</span> <span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p><code>typeof</code>有一个好处就是：未声明的变量也不会报错</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> someVariable <span class=\"comment\">//此时someVariable是未定义，返回undefined</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测复合类型\"><a href=\"#检测复合类型\" class=\"headerlink\" title=\"检测复合类型\"></a>检测复合类型</h2><p>复合类型内置有（不只以下几种，只是举例说明）：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>Error</li>\n</ul>\n<p>当我们使用<code>typeof</code>检测的时候，就会看到都是返回object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() <span class=\"comment\">//object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>() <span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>\n\n<p>此时的最佳选择是使用<code>instanceof</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> today = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">today <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Date</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里好像全部的检测类型都搞定了。</p>\n<p>但是，检测类型并不能这么简单地分为原始类型和复合类型，因为复合类型会涉及到构造函数的问题。</p>\n<h3 id=\"检测函数\"><a href=\"#检测函数\" class=\"headerlink\" title=\"检测函数\"></a>检测函数</h3><p>当我们的页面内嵌了其他的frame时，问题就来了。因为不同的frame的构造函数是独立的，即会发生以下问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在frame A定义的函数test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在frame B检测</span></span><br><span class=\"line\">test <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 而使用typeof则可以正确返回</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> test <span class=\"comment\">// function</span></span><br></pre></td></tr></table></figure>\n\n<p>故检测函数的时候，最佳选择是使用<code>typeof</code></p>\n<h3 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h3><p>数组的问题和函数是一样的，因为不同的构造函数。而此时<code>typeof</code>也不灵了，因为只返回object。</p>\n<p>Douglas Crockford则提供了一种叫duck typing(鸭式辩型)的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value.sort === <span class=\"string\">&#x27;function&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实，这种方式是默认的认为只有数组才有sort方法。其实传入任何有sort方法的对象也是返回true的。因此这个方法并不完美。</p>\n<p>最终的解决方案也是ECMAScript 5的实现方案，就是来自Kangax大神的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(value) === <span class=\"string\">&#x27;[object Array]&#x27;</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法能完美地辨别是否为数组。</p>\n<p>在ECMAScript 5则可以使用Array的内置方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.isArray([]) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"检测属性\"><a href=\"#检测属性\" class=\"headerlink\" title=\"检测属性\"></a>检测属性</h2><p>我发现，在检测一个对象的属性是否存在的时候，常常是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(object.someProps != <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实以上都是有问题的！因为以上方式都忽略了object可能存在假值的情况（即是属性存在，但是等于null或者undefined或者0或者false或者空字符串等等）。因此最佳的方式是使用<code>in</code>运算符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(someProps <span class=\"keyword\">in</span> object)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一些逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上检测数据类型的所有方式。</p>\n<p>参考：<br>《Maintainable JavaScript》</p>"},{"title":"HTTP 常用安全头","date":"2016-05-09T13:02:49.000Z","desc":"web safe,web安全,网络安全,http,http安全头部","toc":true,"_content":"\nSecurity - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容`web`安全，不能更生动形象。最近项目涉及到一些`web`安全的东西，就来总结一下相关的HTTP安全头部。\n\n<!--more-->\n\n## [Content-Security-Policy](http://content-security-policy.com/)\n\n**作用**：防止的内容注入（减缓了`XSS`攻击，恶意`iframe`注入）\n\n**不足**：目前只支持现代浏览器，对浏览器有要求，要求如下：\n\nheader | Chrome | FireFox | Safari |  Internet Explorer\n---|---|---|---|---|\nContent-Security-Policy `CSP Level 2` | 40+ Full January 2015 | 31+ PartialJuly 2014 | - | -\nContent-Security-Policy `CSP 1.0` | 25+ | 23+ | 7+ | Edge 12 build 10240+\n\n**分析**：\n1. 由于HTML的`img`、`script`、`css`是可以跨域的，这就导致了XSS缺陷。CSP可以设置`default-src`、`script-src`、`img-src`等等来限制HTML资源的加载\n\n2. `script-src`可以设置两个特殊的值（`unsafe-inline`、`unsafe-eval`）。`unsafe-inline`代表不能执行内`script`，这就对`XSS`增添了一次防御，不过这样对开发人员有一定的规范。`unsafe-eval`则是代表不能执行`eval`方法(这是一个比较BUG级的函数，它会把传入的参数全部当做`JS`代码解释并且执行)\n3. `sandbox`沙盒则适用于同源策略的`webapp`，可以限制新标签页面打开等等。\n4. `report-uri`这个属性可以设置一个`URL`，然后会把`CSP`的失败信息`POST`到这个`URL`。我们则可以记录这个有用的信息用来安全性分析。\n\n\n## [Strict Transport Security](https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security)\n\n```\nStrict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]\n```\n**作用**：告诉浏览器接下来的一定时间内（自己设置）只能用`HTTPS`访问。这个只会让用`HTTPS`访问的用户继续使用`HTTPS`。而HTTP访问的则无效。\n\n**分析**：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入`HTTPS`。所以第一次访问的时候，都是以`HTTP`访问，这时负载服务器就应该返回一个`301`跳转给客户端，让客户端跳转到`HTTPS`的服务下。由于有了`HSTS`的头部，下次用户再次以`HTTP`访问的时候，浏览器会自己做`307`跳转到`HTTPS`请求。\n\n**实际开发遇到的问题**：\n\n由于公司使用阿里云的`SLB`负载均衡，无法实现`301`跳转，于是使用了`node`再开启一个服务，用于接受来自`SLB`80端口的请求，然后返回一个`301`状态码并在`Location`头部加上`HTTPS`的地址。真正的`node`服务只接受`SLB`443接口的请求。\n\n## [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/gg622941.aspx)\n```\nX-Content-Type-Options: nosniff\n```\n**作用**：互联网上的资源有各种类型，通常浏览器会根据响应头的`Content-Type`字段来分辨它们的类型。例如：`text/html`代表html文档，`image/png`是PNG图片，`text/css`是CSS样式文档。然而，有些资源的`Content-Type`是错的或者未定义。这时，某些浏览器会启用`MIME-sniffing`来猜测该资源的类型，解析内容并执行。\n\n例如，我们即使给一个`html`文档指定`Content-Type`为`text/plain`，在`IE8`中这个文档依然会被当做`html`来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为`JavaScript`。\n\n**实际开发遇到的问题**：\n\n在IE下图片验证码不能显示。  \n分析后得出，是因为图片验证码返回的时候没有返回`content-type`这个文件类型的头部。所以`IE`不能识别文件类型。  \n解决办法是修改图片验证码插件在返回图片是增加头部`content-type`：`image/jpg`\n\n## 参考：\n\n- [Node.js Security Checklist](https://blog.risingstack.com/node-js-security-checklist/)\n\n- [Express.js官方的安全性最佳实践指导](http://expressjs.com/en/advanced/best-practice-security.html)\n\n- [xss攻击入门](http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html)\n","source":"_posts/http/web-safe-http-header.md","raw":"---\ntitle: HTTP 常用安全头\ndate: 2016-05-9 21:02:49\ntags:\n- 网络安全\n- HTTP\ndesc: web safe,web安全,网络安全,http,http安全头部\ntoc: true\ncategories:\n- 计算机网络\n---\n\nSecurity - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容`web`安全，不能更生动形象。最近项目涉及到一些`web`安全的东西，就来总结一下相关的HTTP安全头部。\n\n<!--more-->\n\n## [Content-Security-Policy](http://content-security-policy.com/)\n\n**作用**：防止的内容注入（减缓了`XSS`攻击，恶意`iframe`注入）\n\n**不足**：目前只支持现代浏览器，对浏览器有要求，要求如下：\n\nheader | Chrome | FireFox | Safari |  Internet Explorer\n---|---|---|---|---|\nContent-Security-Policy `CSP Level 2` | 40+ Full January 2015 | 31+ PartialJuly 2014 | - | -\nContent-Security-Policy `CSP 1.0` | 25+ | 23+ | 7+ | Edge 12 build 10240+\n\n**分析**：\n1. 由于HTML的`img`、`script`、`css`是可以跨域的，这就导致了XSS缺陷。CSP可以设置`default-src`、`script-src`、`img-src`等等来限制HTML资源的加载\n\n2. `script-src`可以设置两个特殊的值（`unsafe-inline`、`unsafe-eval`）。`unsafe-inline`代表不能执行内`script`，这就对`XSS`增添了一次防御，不过这样对开发人员有一定的规范。`unsafe-eval`则是代表不能执行`eval`方法(这是一个比较BUG级的函数，它会把传入的参数全部当做`JS`代码解释并且执行)\n3. `sandbox`沙盒则适用于同源策略的`webapp`，可以限制新标签页面打开等等。\n4. `report-uri`这个属性可以设置一个`URL`，然后会把`CSP`的失败信息`POST`到这个`URL`。我们则可以记录这个有用的信息用来安全性分析。\n\n\n## [Strict Transport Security](https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security)\n\n```\nStrict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]\n```\n**作用**：告诉浏览器接下来的一定时间内（自己设置）只能用`HTTPS`访问。这个只会让用`HTTPS`访问的用户继续使用`HTTPS`。而HTTP访问的则无效。\n\n**分析**：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入`HTTPS`。所以第一次访问的时候，都是以`HTTP`访问，这时负载服务器就应该返回一个`301`跳转给客户端，让客户端跳转到`HTTPS`的服务下。由于有了`HSTS`的头部，下次用户再次以`HTTP`访问的时候，浏览器会自己做`307`跳转到`HTTPS`请求。\n\n**实际开发遇到的问题**：\n\n由于公司使用阿里云的`SLB`负载均衡，无法实现`301`跳转，于是使用了`node`再开启一个服务，用于接受来自`SLB`80端口的请求，然后返回一个`301`状态码并在`Location`头部加上`HTTPS`的地址。真正的`node`服务只接受`SLB`443接口的请求。\n\n## [X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/gg622941.aspx)\n```\nX-Content-Type-Options: nosniff\n```\n**作用**：互联网上的资源有各种类型，通常浏览器会根据响应头的`Content-Type`字段来分辨它们的类型。例如：`text/html`代表html文档，`image/png`是PNG图片，`text/css`是CSS样式文档。然而，有些资源的`Content-Type`是错的或者未定义。这时，某些浏览器会启用`MIME-sniffing`来猜测该资源的类型，解析内容并执行。\n\n例如，我们即使给一个`html`文档指定`Content-Type`为`text/plain`，在`IE8`中这个文档依然会被当做`html`来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为`JavaScript`。\n\n**实际开发遇到的问题**：\n\n在IE下图片验证码不能显示。  \n分析后得出，是因为图片验证码返回的时候没有返回`content-type`这个文件类型的头部。所以`IE`不能识别文件类型。  \n解决办法是修改图片验证码插件在返回图片是增加头部`content-type`：`image/jpg`\n\n## 参考：\n\n- [Node.js Security Checklist](https://blog.risingstack.com/node-js-security-checklist/)\n\n- [Express.js官方的安全性最佳实践指导](http://expressjs.com/en/advanced/best-practice-security.html)\n\n- [xss攻击入门](http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html)\n","slug":"http/web-safe-http-header","published":1,"updated":"2022-01-08T08:23:53.944Z","_id":"cky5k7fkc000lda698dm8f586","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Security - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容<code>web</code>安全，不能更生动形象。最近项目涉及到一些<code>web</code>安全的东西，就来总结一下相关的HTTP安全头部。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Content-Security-Policy\"><a href=\"#Content-Security-Policy\" class=\"headerlink\" title=\"Content-Security-Policy\"></a><a href=\"http://content-security-policy.com/\">Content-Security-Policy</a></h2><p><strong>作用</strong>：防止的内容注入（减缓了<code>XSS</code>攻击，恶意<code>iframe</code>注入）</p>\n<p><strong>不足</strong>：目前只支持现代浏览器，对浏览器有要求，要求如下：</p>\n<table>\n<thead>\n<tr>\n<th>header</th>\n<th>Chrome</th>\n<th>FireFox</th>\n<th>Safari</th>\n<th>Internet Explorer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content-Security-Policy <code>CSP Level 2</code></td>\n<td>40+ Full January 2015</td>\n<td>31+ PartialJuly 2014</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Content-Security-Policy <code>CSP 1.0</code></td>\n<td>25+</td>\n<td>23+</td>\n<td>7+</td>\n<td>Edge 12 build 10240+</td>\n</tr>\n</tbody></table>\n<p><strong>分析</strong>：</p>\n<ol>\n<li><p>由于HTML的<code>img</code>、<code>script</code>、<code>css</code>是可以跨域的，这就导致了XSS缺陷。CSP可以设置<code>default-src</code>、<code>script-src</code>、<code>img-src</code>等等来限制HTML资源的加载</p>\n</li>\n<li><p><code>script-src</code>可以设置两个特殊的值（<code>unsafe-inline</code>、<code>unsafe-eval</code>）。<code>unsafe-inline</code>代表不能执行内<code>script</code>，这就对<code>XSS</code>增添了一次防御，不过这样对开发人员有一定的规范。<code>unsafe-eval</code>则是代表不能执行<code>eval</code>方法(这是一个比较BUG级的函数，它会把传入的参数全部当做<code>JS</code>代码解释并且执行)</p>\n</li>\n<li><p><code>sandbox</code>沙盒则适用于同源策略的<code>webapp</code>，可以限制新标签页面打开等等。</p>\n</li>\n<li><p><code>report-uri</code>这个属性可以设置一个<code>URL</code>，然后会把<code>CSP</code>的失败信息<code>POST</code>到这个<code>URL</code>。我们则可以记录这个有用的信息用来安全性分析。</p>\n</li>\n</ol>\n<h2 id=\"Strict-Transport-Security\"><a href=\"#Strict-Transport-Security\" class=\"headerlink\" title=\"Strict Transport Security\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security\">Strict Transport Security</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：告诉浏览器接下来的一定时间内（自己设置）只能用<code>HTTPS</code>访问。这个只会让用<code>HTTPS</code>访问的用户继续使用<code>HTTPS</code>。而HTTP访问的则无效。</p>\n<p><strong>分析</strong>：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入<code>HTTPS</code>。所以第一次访问的时候，都是以<code>HTTP</code>访问，这时负载服务器就应该返回一个<code>301</code>跳转给客户端，让客户端跳转到<code>HTTPS</code>的服务下。由于有了<code>HSTS</code>的头部，下次用户再次以<code>HTTP</code>访问的时候，浏览器会自己做<code>307</code>跳转到<code>HTTPS</code>请求。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>由于公司使用阿里云的<code>SLB</code>负载均衡，无法实现<code>301</code>跳转，于是使用了<code>node</code>再开启一个服务，用于接受来自<code>SLB</code>80端口的请求，然后返回一个<code>301</code>状态码并在<code>Location</code>头部加上<code>HTTPS</code>的地址。真正的<code>node</code>服务只接受<code>SLB</code>443接口的请求。</p>\n<h2 id=\"X-Content-Type-Options\"><a href=\"#X-Content-Type-Options\" class=\"headerlink\" title=\"X-Content-Type-Options\"></a><a href=\"https://msdn.microsoft.com/en-us/library/gg622941.aspx\">X-Content-Type-Options</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：互联网上的资源有各种类型，通常浏览器会根据响应头的<code>Content-Type</code>字段来分辨它们的类型。例如：<code>text/html</code>代表html文档，<code>image/png</code>是PNG图片，<code>text/css</code>是CSS样式文档。然而，有些资源的<code>Content-Type</code>是错的或者未定义。这时，某些浏览器会启用<code>MIME-sniffing</code>来猜测该资源的类型，解析内容并执行。</p>\n<p>例如，我们即使给一个<code>html</code>文档指定<code>Content-Type</code>为<code>text/plain</code>，在<code>IE8</code>中这个文档依然会被当做<code>html</code>来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为<code>JavaScript</code>。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>在IE下图片验证码不能显示。<br>分析后得出，是因为图片验证码返回的时候没有返回<code>content-type</code>这个文件类型的头部。所以<code>IE</code>不能识别文件类型。<br>解决办法是修改图片验证码插件在返回图片是增加头部<code>content-type</code>：<code>image/jpg</code></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><p><a href=\"https://blog.risingstack.com/node-js-security-checklist/\">Node.js Security Checklist</a></p>\n</li>\n<li><p><a href=\"http://expressjs.com/en/advanced/best-practice-security.html\">Express.js官方的安全性最佳实践指导</a></p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html\">xss攻击入门</a></p>\n</li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>Security - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容<code>web</code>安全，不能更生动形象。最近项目涉及到一些<code>web</code>安全的东西，就来总结一下相关的HTTP安全头部。</p>","more":"<h2 id=\"Content-Security-Policy\"><a href=\"#Content-Security-Policy\" class=\"headerlink\" title=\"Content-Security-Policy\"></a><a href=\"http://content-security-policy.com/\">Content-Security-Policy</a></h2><p><strong>作用</strong>：防止的内容注入（减缓了<code>XSS</code>攻击，恶意<code>iframe</code>注入）</p>\n<p><strong>不足</strong>：目前只支持现代浏览器，对浏览器有要求，要求如下：</p>\n<table>\n<thead>\n<tr>\n<th>header</th>\n<th>Chrome</th>\n<th>FireFox</th>\n<th>Safari</th>\n<th>Internet Explorer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content-Security-Policy <code>CSP Level 2</code></td>\n<td>40+ Full January 2015</td>\n<td>31+ PartialJuly 2014</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Content-Security-Policy <code>CSP 1.0</code></td>\n<td>25+</td>\n<td>23+</td>\n<td>7+</td>\n<td>Edge 12 build 10240+</td>\n</tr>\n</tbody></table>\n<p><strong>分析</strong>：</p>\n<ol>\n<li><p>由于HTML的<code>img</code>、<code>script</code>、<code>css</code>是可以跨域的，这就导致了XSS缺陷。CSP可以设置<code>default-src</code>、<code>script-src</code>、<code>img-src</code>等等来限制HTML资源的加载</p>\n</li>\n<li><p><code>script-src</code>可以设置两个特殊的值（<code>unsafe-inline</code>、<code>unsafe-eval</code>）。<code>unsafe-inline</code>代表不能执行内<code>script</code>，这就对<code>XSS</code>增添了一次防御，不过这样对开发人员有一定的规范。<code>unsafe-eval</code>则是代表不能执行<code>eval</code>方法(这是一个比较BUG级的函数，它会把传入的参数全部当做<code>JS</code>代码解释并且执行)</p>\n</li>\n<li><p><code>sandbox</code>沙盒则适用于同源策略的<code>webapp</code>，可以限制新标签页面打开等等。</p>\n</li>\n<li><p><code>report-uri</code>这个属性可以设置一个<code>URL</code>，然后会把<code>CSP</code>的失败信息<code>POST</code>到这个<code>URL</code>。我们则可以记录这个有用的信息用来安全性分析。</p>\n</li>\n</ol>\n<h2 id=\"Strict-Transport-Security\"><a href=\"#Strict-Transport-Security\" class=\"headerlink\" title=\"Strict Transport Security\"></a><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security\">Strict Transport Security</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：告诉浏览器接下来的一定时间内（自己设置）只能用<code>HTTPS</code>访问。这个只会让用<code>HTTPS</code>访问的用户继续使用<code>HTTPS</code>。而HTTP访问的则无效。</p>\n<p><strong>分析</strong>：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入<code>HTTPS</code>。所以第一次访问的时候，都是以<code>HTTP</code>访问，这时负载服务器就应该返回一个<code>301</code>跳转给客户端，让客户端跳转到<code>HTTPS</code>的服务下。由于有了<code>HSTS</code>的头部，下次用户再次以<code>HTTP</code>访问的时候，浏览器会自己做<code>307</code>跳转到<code>HTTPS</code>请求。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>由于公司使用阿里云的<code>SLB</code>负载均衡，无法实现<code>301</code>跳转，于是使用了<code>node</code>再开启一个服务，用于接受来自<code>SLB</code>80端口的请求，然后返回一个<code>301</code>状态码并在<code>Location</code>头部加上<code>HTTPS</code>的地址。真正的<code>node</code>服务只接受<code>SLB</code>443接口的请求。</p>\n<h2 id=\"X-Content-Type-Options\"><a href=\"#X-Content-Type-Options\" class=\"headerlink\" title=\"X-Content-Type-Options\"></a><a href=\"https://msdn.microsoft.com/en-us/library/gg622941.aspx\">X-Content-Type-Options</a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure>\n<p><strong>作用</strong>：互联网上的资源有各种类型，通常浏览器会根据响应头的<code>Content-Type</code>字段来分辨它们的类型。例如：<code>text/html</code>代表html文档，<code>image/png</code>是PNG图片，<code>text/css</code>是CSS样式文档。然而，有些资源的<code>Content-Type</code>是错的或者未定义。这时，某些浏览器会启用<code>MIME-sniffing</code>来猜测该资源的类型，解析内容并执行。</p>\n<p>例如，我们即使给一个<code>html</code>文档指定<code>Content-Type</code>为<code>text/plain</code>，在<code>IE8</code>中这个文档依然会被当做<code>html</code>来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为<code>JavaScript</code>。</p>\n<p><strong>实际开发遇到的问题</strong>：</p>\n<p>在IE下图片验证码不能显示。<br>分析后得出，是因为图片验证码返回的时候没有返回<code>content-type</code>这个文件类型的头部。所以<code>IE</code>不能识别文件类型。<br>解决办法是修改图片验证码插件在返回图片是增加头部<code>content-type</code>：<code>image/jpg</code></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><p><a href=\"https://blog.risingstack.com/node-js-security-checklist/\">Node.js Security Checklist</a></p>\n</li>\n<li><p><a href=\"http://expressjs.com/en/advanced/best-practice-security.html\">Express.js官方的安全性最佳实践指导</a></p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html\">xss攻击入门</a></p>\n</li>\n</ul>"},{"title":"CSS Background 基础知识","date":"2015-10-17T08:05:26.000Z","desc":"CSS,background,background-size,background-clip,background-origin,background-position,background-attachment","toc":true,"_content":"\nWEB开发常用到`background`但是没有去深究，仔细看了之后，发现`background`里面的知识点还是挺多不懂的。\n\n<!--more-->\n\n### background-size\n\n设置背景图大小[`初始值auto auto`-`非继承`-`适用所有元素`]\n\n```\nbackgrount-size: (<length> | <percentage> | auto){1,2} | contain | cover\n```\n- `length`：直接指定背景图大小\n- `percentage`：指定背景图片相对背景区的百分比\n- `auto`：以背景图片的比例缩放背景图片\n- `contain`：缩放背景图片以完全装入背景区，可能背景区部分空白。\n- `cover`：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。\n\n补充：\n- `<length>`/`<percentage>`/`auto` 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成`auto`\n- 逗号分隔的多个值：设置多重背景\n- `contain`/`cover` 会保留图片的原来比例\n\n### background-origin\n\n规定了指定背景图片`background-image`属性的原点位置的背景相对区域[`初始值padding-box`-`非继承`-`适用所有元素`]\n\n\n```\nbackgrount-origin: border-box | padding-box | content-box\n```\n\n- `border-box`: 背景图将显示在`border`上，设置`border-style:dashed`即可以看到效果\n- `padding-box`: 背景图将显示到`padding`上。\n- `content-box`: 背景图只显示在内容区域\n\n如果还不明白，可以看[这个例子](https://jsfiddle.net/vk3v9sez/)\n\n补充：\n\n- 当使用 `background-attachment` 为`fixed`时，该属性将被忽略不起作用。\n\n### background-clip\n\n效果同上面的`background-origin`，差别在于指定的是背景色不是图片\n\n[例子才此](https://jsfiddle.net/vk3v9sez/1/)，可以和上面对比一下\n\n### background-attachment\n\n如果指定了 `background-image` ，那么 `background-attachment` 决定背景是在视口中固定的还是随包含它的区块滚动的[`初始值scroll`-`非继承`-`适用所有元素`]\n\n\n```\nbackground-attachment: scroll | fixed | local\n```\n\n- `scroll`： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。\n- `fixed`：表示背景相对于视口固定\n- `local`：表示背景相对于元素的内容固定。\n\n解释：\n- `fixed`和其他两个的差别在于：`fixed`是相对于视窗（可以理解成屏幕）固定的。\n- `scroll`和`local`的差别在于：`scroll`在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而`local`则是跟着滚动的。可以看下[根据MDN改编的例子](https://jsfiddle.net/bcLs7uxk/)\n\n### background-position\n\n指定背景图片的初始位置[`初始值0% 0%`-`非继承`-`适用所有元素`]\n\n```\nbackground-position: (top, bottom, left, right){1,2} | <percentage> | <length>\n\n```\n\n- `top`: 等于垂直方向的0%\n- `bottom`：等于垂直方向的100%\n- `left`：等于水平方向的0%\n- `right`：等于水平方向的100%","source":"_posts/css/css-background.md","raw":"---\ntitle: CSS Background 基础知识\ndate: 2015-10-17 16:05:26\ntags: \n- CSS\ndesc: CSS,background,background-size,background-clip,background-origin,background-position,background-attachment\ntoc: true\ncategories:\n- CSS\n---\n\nWEB开发常用到`background`但是没有去深究，仔细看了之后，发现`background`里面的知识点还是挺多不懂的。\n\n<!--more-->\n\n### background-size\n\n设置背景图大小[`初始值auto auto`-`非继承`-`适用所有元素`]\n\n```\nbackgrount-size: (<length> | <percentage> | auto){1,2} | contain | cover\n```\n- `length`：直接指定背景图大小\n- `percentage`：指定背景图片相对背景区的百分比\n- `auto`：以背景图片的比例缩放背景图片\n- `contain`：缩放背景图片以完全装入背景区，可能背景区部分空白。\n- `cover`：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。\n\n补充：\n- `<length>`/`<percentage>`/`auto` 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成`auto`\n- 逗号分隔的多个值：设置多重背景\n- `contain`/`cover` 会保留图片的原来比例\n\n### background-origin\n\n规定了指定背景图片`background-image`属性的原点位置的背景相对区域[`初始值padding-box`-`非继承`-`适用所有元素`]\n\n\n```\nbackgrount-origin: border-box | padding-box | content-box\n```\n\n- `border-box`: 背景图将显示在`border`上，设置`border-style:dashed`即可以看到效果\n- `padding-box`: 背景图将显示到`padding`上。\n- `content-box`: 背景图只显示在内容区域\n\n如果还不明白，可以看[这个例子](https://jsfiddle.net/vk3v9sez/)\n\n补充：\n\n- 当使用 `background-attachment` 为`fixed`时，该属性将被忽略不起作用。\n\n### background-clip\n\n效果同上面的`background-origin`，差别在于指定的是背景色不是图片\n\n[例子才此](https://jsfiddle.net/vk3v9sez/1/)，可以和上面对比一下\n\n### background-attachment\n\n如果指定了 `background-image` ，那么 `background-attachment` 决定背景是在视口中固定的还是随包含它的区块滚动的[`初始值scroll`-`非继承`-`适用所有元素`]\n\n\n```\nbackground-attachment: scroll | fixed | local\n```\n\n- `scroll`： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。\n- `fixed`：表示背景相对于视口固定\n- `local`：表示背景相对于元素的内容固定。\n\n解释：\n- `fixed`和其他两个的差别在于：`fixed`是相对于视窗（可以理解成屏幕）固定的。\n- `scroll`和`local`的差别在于：`scroll`在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而`local`则是跟着滚动的。可以看下[根据MDN改编的例子](https://jsfiddle.net/bcLs7uxk/)\n\n### background-position\n\n指定背景图片的初始位置[`初始值0% 0%`-`非继承`-`适用所有元素`]\n\n```\nbackground-position: (top, bottom, left, right){1,2} | <percentage> | <length>\n\n```\n\n- `top`: 等于垂直方向的0%\n- `bottom`：等于垂直方向的100%\n- `left`：等于水平方向的0%\n- `right`：等于水平方向的100%","slug":"css/css-background","published":1,"updated":"2022-01-08T08:24:55.800Z","_id":"cky5kb73k000qda692wechm5u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>WEB开发常用到<code>background</code>但是没有去深究，仔细看了之后，发现<code>background</code>里面的知识点还是挺多不懂的。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h3><p>设置背景图大小[<code>初始值auto auto</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-size: (&lt;length&gt; | &lt;percentage&gt; | auto)&#123;1,2&#125; | contain | cover</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>length</code>：直接指定背景图大小</li>\n<li><code>percentage</code>：指定背景图片相对背景区的百分比</li>\n<li><code>auto</code>：以背景图片的比例缩放背景图片</li>\n<li><code>contain</code>：缩放背景图片以完全装入背景区，可能背景区部分空白。</li>\n<li><code>cover</code>：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。</li>\n</ul>\n<p>补充：</p>\n<ul>\n<li><code>&lt;length&gt;</code>/<code>&lt;percentage&gt;</code>/<code>auto</code> 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成<code>auto</code></li>\n<li>逗号分隔的多个值：设置多重背景</li>\n<li><code>contain</code>/<code>cover</code> 会保留图片的原来比例</li>\n</ul>\n<h3 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h3><p>规定了指定背景图片<code>background-image</code>属性的原点位置的背景相对区域[<code>初始值padding-box</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-origin: border-box | padding-box | content-box</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>border-box</code>: 背景图将显示在<code>border</code>上，设置<code>border-style:dashed</code>即可以看到效果</li>\n<li><code>padding-box</code>: 背景图将显示到<code>padding</code>上。</li>\n<li><code>content-box</code>: 背景图只显示在内容区域</li>\n</ul>\n<p>如果还不明白，可以看<a href=\"https://jsfiddle.net/vk3v9sez/\">这个例子</a></p>\n<p>补充：</p>\n<ul>\n<li>当使用 <code>background-attachment</code> 为<code>fixed</code>时，该属性将被忽略不起作用。</li>\n</ul>\n<h3 id=\"background-clip\"><a href=\"#background-clip\" class=\"headerlink\" title=\"background-clip\"></a>background-clip</h3><p>效果同上面的<code>background-origin</code>，差别在于指定的是背景色不是图片</p>\n<p><a href=\"https://jsfiddle.net/vk3v9sez/1/\">例子才此</a>，可以和上面对比一下</p>\n<h3 id=\"background-attachment\"><a href=\"#background-attachment\" class=\"headerlink\" title=\"background-attachment\"></a>background-attachment</h3><p>如果指定了 <code>background-image</code> ，那么 <code>background-attachment</code> 决定背景是在视口中固定的还是随包含它的区块滚动的[<code>初始值scroll</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-attachment: scroll | fixed | local</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>scroll</code>： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。</li>\n<li><code>fixed</code>：表示背景相对于视口固定</li>\n<li><code>local</code>：表示背景相对于元素的内容固定。</li>\n</ul>\n<p>解释：</p>\n<ul>\n<li><code>fixed</code>和其他两个的差别在于：<code>fixed</code>是相对于视窗（可以理解成屏幕）固定的。</li>\n<li><code>scroll</code>和<code>local</code>的差别在于：<code>scroll</code>在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而<code>local</code>则是跟着滚动的。可以看下<a href=\"https://jsfiddle.net/bcLs7uxk/\">根据MDN改编的例子</a></li>\n</ul>\n<h3 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h3><p>指定背景图片的初始位置[<code>初始值0% 0%</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-position: (top, bottom, left, right)&#123;1,2&#125; | &lt;percentage&gt; | &lt;length&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>top</code>: 等于垂直方向的0%</li>\n<li><code>bottom</code>：等于垂直方向的100%</li>\n<li><code>left</code>：等于水平方向的0%</li>\n<li><code>right</code>：等于水平方向的100%</li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>WEB开发常用到<code>background</code>但是没有去深究，仔细看了之后，发现<code>background</code>里面的知识点还是挺多不懂的。</p>","more":"<h3 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h3><p>设置背景图大小[<code>初始值auto auto</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-size: (&lt;length&gt; | &lt;percentage&gt; | auto)&#123;1,2&#125; | contain | cover</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>length</code>：直接指定背景图大小</li>\n<li><code>percentage</code>：指定背景图片相对背景区的百分比</li>\n<li><code>auto</code>：以背景图片的比例缩放背景图片</li>\n<li><code>contain</code>：缩放背景图片以完全装入背景区，可能背景区部分空白。</li>\n<li><code>cover</code>：缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。</li>\n</ul>\n<p>补充：</p>\n<ul>\n<li><code>&lt;length&gt;</code>/<code>&lt;percentage&gt;</code>/<code>auto</code> 可设置两个，第一个对应宽度，第二个对应高度；如果只指定一个，高度则隐式设置成<code>auto</code></li>\n<li>逗号分隔的多个值：设置多重背景</li>\n<li><code>contain</code>/<code>cover</code> 会保留图片的原来比例</li>\n</ul>\n<h3 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h3><p>规定了指定背景图片<code>background-image</code>属性的原点位置的背景相对区域[<code>初始值padding-box</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">backgrount-origin: border-box | padding-box | content-box</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>border-box</code>: 背景图将显示在<code>border</code>上，设置<code>border-style:dashed</code>即可以看到效果</li>\n<li><code>padding-box</code>: 背景图将显示到<code>padding</code>上。</li>\n<li><code>content-box</code>: 背景图只显示在内容区域</li>\n</ul>\n<p>如果还不明白，可以看<a href=\"https://jsfiddle.net/vk3v9sez/\">这个例子</a></p>\n<p>补充：</p>\n<ul>\n<li>当使用 <code>background-attachment</code> 为<code>fixed</code>时，该属性将被忽略不起作用。</li>\n</ul>\n<h3 id=\"background-clip\"><a href=\"#background-clip\" class=\"headerlink\" title=\"background-clip\"></a>background-clip</h3><p>效果同上面的<code>background-origin</code>，差别在于指定的是背景色不是图片</p>\n<p><a href=\"https://jsfiddle.net/vk3v9sez/1/\">例子才此</a>，可以和上面对比一下</p>\n<h3 id=\"background-attachment\"><a href=\"#background-attachment\" class=\"headerlink\" title=\"background-attachment\"></a>background-attachment</h3><p>如果指定了 <code>background-image</code> ，那么 <code>background-attachment</code> 决定背景是在视口中固定的还是随包含它的区块滚动的[<code>初始值scroll</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-attachment: scroll | fixed | local</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>scroll</code>： 表示背景相对于元素本身固定，而不是随着它的内容滚动（对元素边框是有效的）。</li>\n<li><code>fixed</code>：表示背景相对于视口固定</li>\n<li><code>local</code>：表示背景相对于元素的内容固定。</li>\n</ul>\n<p>解释：</p>\n<ul>\n<li><code>fixed</code>和其他两个的差别在于：<code>fixed</code>是相对于视窗（可以理解成屏幕）固定的。</li>\n<li><code>scroll</code>和<code>local</code>的差别在于：<code>scroll</code>在本元素有滚动条的情况下，背景图相对于本元素的滚动条不动，而<code>local</code>则是跟着滚动的。可以看下<a href=\"https://jsfiddle.net/bcLs7uxk/\">根据MDN改编的例子</a></li>\n</ul>\n<h3 id=\"background-position\"><a href=\"#background-position\" class=\"headerlink\" title=\"background-position\"></a>background-position</h3><p>指定背景图片的初始位置[<code>初始值0% 0%</code>-<code>非继承</code>-<code>适用所有元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">background-position: (top, bottom, left, right)&#123;1,2&#125; | &lt;percentage&gt; | &lt;length&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>top</code>: 等于垂直方向的0%</li>\n<li><code>bottom</code>：等于垂直方向的100%</li>\n<li><code>left</code>：等于水平方向的0%</li>\n<li><code>right</code>：等于水平方向的100%</li>\n</ul>"},{"title":"CSS 空格和换行","date":"2015-10-14T06:25:19.000Z","desc":"CSS空格和换行,word-break,overflow-wrap,word-wrap,white-space","toc":true,"_content":"\n在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。\n\n<!--more-->\n\n### break-all\n\n指定怎么在单词内断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwork-break: normal | break-all | keep-all;\n```\n\n`normal`: 使用默认的换行\n\n`break-all`: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。\n\n`keep-all`: CJK文本不断行，non-CJK文本的行为则和`normal`保持一致。\n\n具体效果可以看这个[参考例子](https://jsfiddle.net/5psou6y5/)\n\n### overflow-wrap(别名：word-wrap)\n\n指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\noverflow-wrap: normal | break-word;\n```\n\n`normal`: 表示在正常的单词结束处换行。\n\n`break-word`: 如果一行内无法容下某个单词的话，那就断开这个单词。\n\n**补充**：\n\n如果不明白`break-all`和`overflow-wrap`的差别的话，查看[这个例子](https://jsfiddle.net/ar6nha8e/)就可以明白了。\n\n---\n\n### white-space\n用来描述要如何处理元素内的空格。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwhite-space: normal | pre | nowrap | pre-wrap | pre-line;\n```\n\n`normal`: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。\n\n`nowrap`: 和 `normal` 一样，连续的空白符会被合并。但文本内的换行无效。\n\n`pre`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素时才会换行。\n\n`pre-wrap`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时才会换行。\n\n`pre-line`: 连续的空白符会被合并。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时会换行。\n\n**各种white-space的值对应的行为如下**：\n\n||换行符|空白符和制表符|文字换行|\n|--|--|--|--|\n|normal|合并|合并|转行|\n|nowrap|合并|合并|不转行|\n|pre|保留|保留|不转行|\n|pre-wrap|保留|保留|转行|\n|pre-line|保留|合并|转行|\n\n效果请看这个[MDN的例子](https://jsfiddle.net/hzywLx6u/)","source":"_posts/css/white-space-and-wrap.md","raw":"---\ntitle: CSS 空格和换行\ndate: 2015-10-14 14:25:19\ntags:\n- CSS\ndesc: CSS空格和换行,word-break,overflow-wrap,word-wrap,white-space\ntoc: true\ncategories:\n- CSS\n---\n\n在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。\n\n<!--more-->\n\n### break-all\n\n指定怎么在单词内断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwork-break: normal | break-all | keep-all;\n```\n\n`normal`: 使用默认的换行\n\n`break-all`: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。\n\n`keep-all`: CJK文本不断行，non-CJK文本的行为则和`normal`保持一致。\n\n具体效果可以看这个[参考例子](https://jsfiddle.net/5psou6y5/)\n\n### overflow-wrap(别名：word-wrap)\n\n指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\noverflow-wrap: normal | break-word;\n```\n\n`normal`: 表示在正常的单词结束处换行。\n\n`break-word`: 如果一行内无法容下某个单词的话，那就断开这个单词。\n\n**补充**：\n\n如果不明白`break-all`和`overflow-wrap`的差别的话，查看[这个例子](https://jsfiddle.net/ar6nha8e/)就可以明白了。\n\n---\n\n### white-space\n用来描述要如何处理元素内的空格。[`初始值normal`-`继承属性`-`适用全部元素`]\n\n```\nwhite-space: normal | pre | nowrap | pre-wrap | pre-line;\n```\n\n`normal`: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。\n\n`nowrap`: 和 `normal` 一样，连续的空白符会被合并。但文本内的换行无效。\n\n`pre`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素时才会换行。\n\n`pre-wrap`: 连续的空白符会被保留。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时才会换行。\n\n`pre-line`: 连续的空白符会被合并。在遇到换行符或者`<br>`元素，或者需要为了填充line盒子时会换行。\n\n**各种white-space的值对应的行为如下**：\n\n||换行符|空白符和制表符|文字换行|\n|--|--|--|--|\n|normal|合并|合并|转行|\n|nowrap|合并|合并|不转行|\n|pre|保留|保留|不转行|\n|pre-wrap|保留|保留|转行|\n|pre-line|保留|合并|转行|\n\n效果请看这个[MDN的例子](https://jsfiddle.net/hzywLx6u/)","slug":"css/white-space-and-wrap","published":1,"updated":"2022-01-08T08:25:50.211Z","_id":"cky5kbjen000tda69fwlpb5r6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"break-all\"><a href=\"#break-all\" class=\"headerlink\" title=\"break-all\"></a>break-all</h3><p>指定怎么在单词内断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">work-break: normal | break-all | keep-all;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 使用默认的换行</p>\n<p><code>break-all</code>: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。</p>\n<p><code>keep-all</code>: CJK文本不断行，non-CJK文本的行为则和<code>normal</code>保持一致。</p>\n<p>具体效果可以看这个<a href=\"https://jsfiddle.net/5psou6y5/\">参考例子</a></p>\n<h3 id=\"overflow-wrap-别名：word-wrap\"><a href=\"#overflow-wrap-别名：word-wrap\" class=\"headerlink\" title=\"overflow-wrap(别名：word-wrap)\"></a>overflow-wrap(别名：word-wrap)</h3><p>指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow-wrap: normal | break-word;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 表示在正常的单词结束处换行。</p>\n<p><code>break-word</code>: 如果一行内无法容下某个单词的话，那就断开这个单词。</p>\n<p><strong>补充</strong>：</p>\n<p>如果不明白<code>break-all</code>和<code>overflow-wrap</code>的差别的话，查看<a href=\"https://jsfiddle.net/ar6nha8e/\">这个例子</a>就可以明白了。</p>\n<hr>\n<h3 id=\"white-space\"><a href=\"#white-space\" class=\"headerlink\" title=\"white-space\"></a>white-space</h3><p>用来描述要如何处理元素内的空格。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">white-space: normal | pre | nowrap | pre-wrap | pre-line;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。</p>\n<p><code>nowrap</code>: 和 <code>normal</code> 一样，连续的空白符会被合并。但文本内的换行无效。</p>\n<p><code>pre</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素时才会换行。</p>\n<p><code>pre-wrap</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行。</p>\n<p><code>pre-line</code>: 连续的空白符会被合并。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时会换行。</p>\n<p><strong>各种white-space的值对应的行为如下</strong>：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>换行符</th>\n<th>空白符和制表符</th>\n<th>文字换行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>normal</td>\n<td>合并</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>nowrap</td>\n<td>合并</td>\n<td>合并</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre</td>\n<td>保留</td>\n<td>保留</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre-wrap</td>\n<td>保留</td>\n<td>保留</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>pre-line</td>\n<td>保留</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n</tbody></table>\n<p>效果请看这个<a href=\"https://jsfiddle.net/hzywLx6u/\">MDN的例子</a></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在WEB开发当中，往往容易忽略文本样式的控制，关注点常常停留在元素上。最近开发涉及到文本的样式，发现对应的属性的值都挺多的，因此来总结记录一下，以后给自己做参考。</p>","more":"<h3 id=\"break-all\"><a href=\"#break-all\" class=\"headerlink\" title=\"break-all\"></a>break-all</h3><p>指定怎么在单词内断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">work-break: normal | break-all | keep-all;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 使用默认的换行</p>\n<p><code>break-all</code>: 对于non-CJK(中文/日文/韩文)文本，可在任意字符间断行。</p>\n<p><code>keep-all</code>: CJK文本不断行，non-CJK文本的行为则和<code>normal</code>保持一致。</p>\n<p>具体效果可以看这个<a href=\"https://jsfiddle.net/5psou6y5/\">参考例子</a></p>\n<h3 id=\"overflow-wrap-别名：word-wrap\"><a href=\"#overflow-wrap-别名：word-wrap\" class=\"headerlink\" title=\"overflow-wrap(别名：word-wrap)\"></a>overflow-wrap(别名：word-wrap)</h3><p>指定一个不可断句的字符串太长溢出盒子模型时，是否要断行。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow-wrap: normal | break-word;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 表示在正常的单词结束处换行。</p>\n<p><code>break-word</code>: 如果一行内无法容下某个单词的话，那就断开这个单词。</p>\n<p><strong>补充</strong>：</p>\n<p>如果不明白<code>break-all</code>和<code>overflow-wrap</code>的差别的话，查看<a href=\"https://jsfiddle.net/ar6nha8e/\">这个例子</a>就可以明白了。</p>\n<hr>\n<h3 id=\"white-space\"><a href=\"#white-space\" class=\"headerlink\" title=\"white-space\"></a>white-space</h3><p>用来描述要如何处理元素内的空格。[<code>初始值normal</code>-<code>继承属性</code>-<code>适用全部元素</code>]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">white-space: normal | pre | nowrap | pre-wrap | pre-line;</span><br></pre></td></tr></table></figure>\n\n<p><code>normal</code>: 连续的空白符会被合并，换行符(Newline characters )会被当作空白符来处理。填充line盒子时，必要的话会换行。</p>\n<p><code>nowrap</code>: 和 <code>normal</code> 一样，连续的空白符会被合并。但文本内的换行无效。</p>\n<p><code>pre</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素时才会换行。</p>\n<p><code>pre-wrap</code>: 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行。</p>\n<p><code>pre-line</code>: 连续的空白符会被合并。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时会换行。</p>\n<p><strong>各种white-space的值对应的行为如下</strong>：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>换行符</th>\n<th>空白符和制表符</th>\n<th>文字换行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>normal</td>\n<td>合并</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>nowrap</td>\n<td>合并</td>\n<td>合并</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre</td>\n<td>保留</td>\n<td>保留</td>\n<td>不转行</td>\n</tr>\n<tr>\n<td>pre-wrap</td>\n<td>保留</td>\n<td>保留</td>\n<td>转行</td>\n</tr>\n<tr>\n<td>pre-line</td>\n<td>保留</td>\n<td>合并</td>\n<td>转行</td>\n</tr>\n</tbody></table>\n<p>效果请看这个<a href=\"https://jsfiddle.net/hzywLx6u/\">MDN的例子</a></p>"},{"title":"小程序按钮组件的亿点细节","date":"2022-01-25T14:40:19.000Z","_content":"\n# 前言\n\nTDesign 的 button 是之前的同事开发的，我接手过来只是做了样式的调整，因此对组件的实现没有很清楚。最近有用户反馈传了 disabled 之后仍然会触发 tap 事件。我的第一反应以为是个小问题，就是漏掉了透传 disabled 而已，但我发现问题没这么简单，于是便有了这篇小文章。\n\n<!-- more -->\n\n## 透传 disabled 属性\n\n将 disabled 透传至 button 之后，就发现 user agent 的样式权重很高：\n\n![小程序最终样式](/blog/images/miniprogram/user-agent.png)\n\n这其实是小程序的坑。按理说 user agent stylesheet 的优先级肯定比 user stylesheet 低才合理的:\n\n![CSS 层叠样式优先级](/blog/images/miniprogram/css-cascade.png)\n\n这明显是不讲武德了，但问题还是要解决。为了样式的正确还原，有两个解决方案：\n\n- 增加封装样式的特异性（specity）\n- 不透传disabled\n\n第一种方案，就是为了弥补小程序埋的坑而因此更多的问题，比如用户如果想要自定义主题的话，要想覆盖 TDesign 的样式就需要将 specity 提得更高，因此否定了这个方案。\n\n第二种方案，就是不将 disabled 属性透传到原生 Button，手动实现 disabled 的效果。\n\n## 重新实现 disabled\n\n这种方案很直观，就是监听 tap 事件，然后在 disabled 的时候不触发 tap 事件即可：\n\n```jsx\n<button class=\"t-button\" bind:tap=\"handleTap\">\n```\n\n```jsx\n// t-button\nComponent({\n\thandleTap() {\n\t\tif (this.data.disabled) return\n\t\tthis.triggerEvent('tap')\n\t}\n}\n```\n\n但此时需要考虑一种情况，就是有 open-type 的时候，会没法阻止。\n\n此时直观的想法是在每个开发能力对应的事件里，对 disabled 做特殊处理，但其实也是不合理的。因为这样没法阻止 open-type 的事件发生，用户仍然会看到对应的授权弹窗。\n\n另外一种方案，反而会合理许多，但也 hack 许多。就是在 disabled 的时候，不透传 open-type：\n\n```jsx\n<button open-type=\"{{ disabled ? '' : openType }}\" />\n```\n\n## 事件问题\n\n在使用 t-button 组件的时候，就发现问题了，tap 事件触发了两次：\n\n```jsx\n<t-button bind:tap=\"handler\">\n```\n\n```jsx\nPage({\n\thandler() {\n\t\tconsole.log(1) // 触发两次\n\t}\n})\n```\n\n这个问题也是比较典型的事件模型问题：\n\n![事件模型图](/blog/images/miniprogram/eventflow.svg)\n\n因此，需要通过 catch 事件来捕获 tap 事件，避免冒泡：\n\n```jsx\n<button class=\"t-button\" capture-catch:tap=\"handleTap\">\n```\n\n这样解决了上面的问题，但此时会导致 open-type 的事件不会触发。因此不能使用 capture-catch 而是使用 catch：\n\n```jsx\n<button class=\"t-button\" catch:tap=\"handleTap\">\n```\n\n## 总结\n\n最后 button 的组件完成了，我就好奇业界其他组件库是如何实现的。\n\n于是我去看了下 vant 和 lin-ui，这两个算是微信小程序组件库的两个明星仓库。\n\n结果发现，这两个库都选择了不透传 disabled，自行实现disabled。但在事件问题上，三个组件库走在了不同的路上：\n\n- vant 的 tap 事件是不受 disabled 影响的，新增了一个 disabled 时不触发的 click 事件。\n- lin-ui 则是会在有 open-type 的时候，disabled 失效。\n- TDesign 的 tap 的事件保持了和原生一致。","source":"_posts/miniprogram/component-button.md","raw":"---\ntitle: 小程序按钮组件的亿点细节\ndate: 2022-01-25 22:40:19\ntags:\ncategories:\n- 小程序\n---\n\n# 前言\n\nTDesign 的 button 是之前的同事开发的，我接手过来只是做了样式的调整，因此对组件的实现没有很清楚。最近有用户反馈传了 disabled 之后仍然会触发 tap 事件。我的第一反应以为是个小问题，就是漏掉了透传 disabled 而已，但我发现问题没这么简单，于是便有了这篇小文章。\n\n<!-- more -->\n\n## 透传 disabled 属性\n\n将 disabled 透传至 button 之后，就发现 user agent 的样式权重很高：\n\n![小程序最终样式](/blog/images/miniprogram/user-agent.png)\n\n这其实是小程序的坑。按理说 user agent stylesheet 的优先级肯定比 user stylesheet 低才合理的:\n\n![CSS 层叠样式优先级](/blog/images/miniprogram/css-cascade.png)\n\n这明显是不讲武德了，但问题还是要解决。为了样式的正确还原，有两个解决方案：\n\n- 增加封装样式的特异性（specity）\n- 不透传disabled\n\n第一种方案，就是为了弥补小程序埋的坑而因此更多的问题，比如用户如果想要自定义主题的话，要想覆盖 TDesign 的样式就需要将 specity 提得更高，因此否定了这个方案。\n\n第二种方案，就是不将 disabled 属性透传到原生 Button，手动实现 disabled 的效果。\n\n## 重新实现 disabled\n\n这种方案很直观，就是监听 tap 事件，然后在 disabled 的时候不触发 tap 事件即可：\n\n```jsx\n<button class=\"t-button\" bind:tap=\"handleTap\">\n```\n\n```jsx\n// t-button\nComponent({\n\thandleTap() {\n\t\tif (this.data.disabled) return\n\t\tthis.triggerEvent('tap')\n\t}\n}\n```\n\n但此时需要考虑一种情况，就是有 open-type 的时候，会没法阻止。\n\n此时直观的想法是在每个开发能力对应的事件里，对 disabled 做特殊处理，但其实也是不合理的。因为这样没法阻止 open-type 的事件发生，用户仍然会看到对应的授权弹窗。\n\n另外一种方案，反而会合理许多，但也 hack 许多。就是在 disabled 的时候，不透传 open-type：\n\n```jsx\n<button open-type=\"{{ disabled ? '' : openType }}\" />\n```\n\n## 事件问题\n\n在使用 t-button 组件的时候，就发现问题了，tap 事件触发了两次：\n\n```jsx\n<t-button bind:tap=\"handler\">\n```\n\n```jsx\nPage({\n\thandler() {\n\t\tconsole.log(1) // 触发两次\n\t}\n})\n```\n\n这个问题也是比较典型的事件模型问题：\n\n![事件模型图](/blog/images/miniprogram/eventflow.svg)\n\n因此，需要通过 catch 事件来捕获 tap 事件，避免冒泡：\n\n```jsx\n<button class=\"t-button\" capture-catch:tap=\"handleTap\">\n```\n\n这样解决了上面的问题，但此时会导致 open-type 的事件不会触发。因此不能使用 capture-catch 而是使用 catch：\n\n```jsx\n<button class=\"t-button\" catch:tap=\"handleTap\">\n```\n\n## 总结\n\n最后 button 的组件完成了，我就好奇业界其他组件库是如何实现的。\n\n于是我去看了下 vant 和 lin-ui，这两个算是微信小程序组件库的两个明星仓库。\n\n结果发现，这两个库都选择了不透传 disabled，自行实现disabled。但在事件问题上，三个组件库走在了不同的路上：\n\n- vant 的 tap 事件是不受 disabled 影响的，新增了一个 disabled 时不触发的 click 事件。\n- lin-ui 则是会在有 open-type 的时候，disabled 失效。\n- TDesign 的 tap 的事件保持了和原生一致。","slug":"miniprogram/component-button","published":1,"updated":"2023-08-04T11:42:24.962Z","_id":"ckyu87j300000wb698dnqb0xd","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>TDesign 的 button 是之前的同事开发的，我接手过来只是做了样式的调整，因此对组件的实现没有很清楚。最近有用户反馈传了 disabled 之后仍然会触发 tap 事件。我的第一反应以为是个小问题，就是漏掉了透传 disabled 而已，但我发现问题没这么简单，于是便有了这篇小文章。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"透传-disabled-属性\"><a href=\"#透传-disabled-属性\" class=\"headerlink\" title=\"透传 disabled 属性\"></a>透传 disabled 属性</h2><p>将 disabled 透传至 button 之后，就发现 user agent 的样式权重很高：</p>\n<p><img src=\"/blog/images/miniprogram/user-agent.png\" alt=\"小程序最终样式\"></p>\n<p>这其实是小程序的坑。按理说 user agent stylesheet 的优先级肯定比 user stylesheet 低才合理的:</p>\n<p><img src=\"/blog/images/miniprogram/css-cascade.png\" alt=\"CSS 层叠样式优先级\"></p>\n<p>这明显是不讲武德了，但问题还是要解决。为了样式的正确还原，有两个解决方案：</p>\n<ul>\n<li>增加封装样式的特异性（specity）</li>\n<li>不透传disabled</li>\n</ul>\n<p>第一种方案，就是为了弥补小程序埋的坑而因此更多的问题，比如用户如果想要自定义主题的话，要想覆盖 TDesign 的样式就需要将 specity 提得更高，因此否定了这个方案。</p>\n<p>第二种方案，就是不将 disabled 属性透传到原生 Button，手动实现 disabled 的效果。</p>\n<h2 id=\"重新实现-disabled\"><a href=\"#重新实现-disabled\" class=\"headerlink\" title=\"重新实现 disabled\"></a>重新实现 disabled</h2><p>这种方案很直观，就是监听 tap 事件，然后在 disabled 的时候不触发 tap 事件即可：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;t-button&quot;</span> bind:tap=<span class=\"string\">&quot;handleTap&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// t-button</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handleTap</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.data.disabled) <span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;tap&#x27;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但此时需要考虑一种情况，就是有 open-type 的时候，会没法阻止。</p>\n<p>此时直观的想法是在每个开发能力对应的事件里，对 disabled 做特殊处理，但其实也是不合理的。因为这样没法阻止 open-type 的事件发生，用户仍然会看到对应的授权弹窗。</p>\n<p>另外一种方案，反而会合理许多，但也 hack 许多。就是在 disabled 的时候，不透传 open-type：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=<span class=\"string\">&quot;&#123;&#123; disabled ? &#x27;&#x27; : openType &#125;&#125;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件问题\"><a href=\"#事件问题\" class=\"headerlink\" title=\"事件问题\"></a>事件问题</h2><p>在使用 t-button 组件的时候，就发现问题了，tap 事件触发了两次：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;t-button bind:tap=<span class=\"string\">&quot;handler&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handler</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>) <span class=\"comment\">// 触发两次</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个问题也是比较典型的事件模型问题：</p>\n<p><img src=\"/blog/images/miniprogram/eventflow.svg\" alt=\"事件模型图\"></p>\n<p>因此，需要通过 catch 事件来捕获 tap 事件，避免冒泡：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;t-button&quot;</span> capture-<span class=\"keyword\">catch</span>:tap=<span class=\"string\">&quot;handleTap&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样解决了上面的问题，但此时会导致 open-type 的事件不会触发。因此不能使用 capture-catch 而是使用 catch：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;t-button&quot;</span> <span class=\"keyword\">catch</span>:tap=<span class=\"string\">&quot;handleTap&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最后 button 的组件完成了，我就好奇业界其他组件库是如何实现的。</p>\n<p>于是我去看了下 vant 和 lin-ui，这两个算是微信小程序组件库的两个明星仓库。</p>\n<p>结果发现，这两个库都选择了不透传 disabled，自行实现disabled。但在事件问题上，三个组件库走在了不同的路上：</p>\n<ul>\n<li>vant 的 tap 事件是不受 disabled 影响的，新增了一个 disabled 时不触发的 click 事件。</li>\n<li>lin-ui 则是会在有 open-type 的时候，disabled 失效。</li>\n<li>TDesign 的 tap 的事件保持了和原生一致。</li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>TDesign 的 button 是之前的同事开发的，我接手过来只是做了样式的调整，因此对组件的实现没有很清楚。最近有用户反馈传了 disabled 之后仍然会触发 tap 事件。我的第一反应以为是个小问题，就是漏掉了透传 disabled 而已，但我发现问题没这么简单，于是便有了这篇小文章。</p>","more":"<h2 id=\"透传-disabled-属性\"><a href=\"#透传-disabled-属性\" class=\"headerlink\" title=\"透传 disabled 属性\"></a>透传 disabled 属性</h2><p>将 disabled 透传至 button 之后，就发现 user agent 的样式权重很高：</p>\n<p><img src=\"/blog/images/miniprogram/user-agent.png\" alt=\"小程序最终样式\"></p>\n<p>这其实是小程序的坑。按理说 user agent stylesheet 的优先级肯定比 user stylesheet 低才合理的:</p>\n<p><img src=\"/blog/images/miniprogram/css-cascade.png\" alt=\"CSS 层叠样式优先级\"></p>\n<p>这明显是不讲武德了，但问题还是要解决。为了样式的正确还原，有两个解决方案：</p>\n<ul>\n<li>增加封装样式的特异性（specity）</li>\n<li>不透传disabled</li>\n</ul>\n<p>第一种方案，就是为了弥补小程序埋的坑而因此更多的问题，比如用户如果想要自定义主题的话，要想覆盖 TDesign 的样式就需要将 specity 提得更高，因此否定了这个方案。</p>\n<p>第二种方案，就是不将 disabled 属性透传到原生 Button，手动实现 disabled 的效果。</p>\n<h2 id=\"重新实现-disabled\"><a href=\"#重新实现-disabled\" class=\"headerlink\" title=\"重新实现 disabled\"></a>重新实现 disabled</h2><p>这种方案很直观，就是监听 tap 事件，然后在 disabled 的时候不触发 tap 事件即可：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;t-button&quot;</span> bind:tap=<span class=\"string\">&quot;handleTap&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// t-button</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handleTap</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.data.disabled) <span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.triggerEvent(<span class=\"string\">&#x27;tap&#x27;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但此时需要考虑一种情况，就是有 open-type 的时候，会没法阻止。</p>\n<p>此时直观的想法是在每个开发能力对应的事件里，对 disabled 做特殊处理，但其实也是不合理的。因为这样没法阻止 open-type 的事件发生，用户仍然会看到对应的授权弹窗。</p>\n<p>另外一种方案，反而会合理许多，但也 hack 许多。就是在 disabled 的时候，不透传 open-type：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=<span class=\"string\">&quot;&#123;&#123; disabled ? &#x27;&#x27; : openType &#125;&#125;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件问题\"><a href=\"#事件问题\" class=\"headerlink\" title=\"事件问题\"></a>事件问题</h2><p>在使用 t-button 组件的时候，就发现问题了，tap 事件触发了两次：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;t-button bind:tap=<span class=\"string\">&quot;handler&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handler</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>) <span class=\"comment\">// 触发两次</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个问题也是比较典型的事件模型问题：</p>\n<p><img src=\"/blog/images/miniprogram/eventflow.svg\" alt=\"事件模型图\"></p>\n<p>因此，需要通过 catch 事件来捕获 tap 事件，避免冒泡：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;t-button&quot;</span> capture-<span class=\"keyword\">catch</span>:tap=<span class=\"string\">&quot;handleTap&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样解决了上面的问题，但此时会导致 open-type 的事件不会触发。因此不能使用 capture-catch 而是使用 catch：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;t-button&quot;</span> <span class=\"keyword\">catch</span>:tap=<span class=\"string\">&quot;handleTap&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最后 button 的组件完成了，我就好奇业界其他组件库是如何实现的。</p>\n<p>于是我去看了下 vant 和 lin-ui，这两个算是微信小程序组件库的两个明星仓库。</p>\n<p>结果发现，这两个库都选择了不透传 disabled，自行实现disabled。但在事件问题上，三个组件库走在了不同的路上：</p>\n<ul>\n<li>vant 的 tap 事件是不受 disabled 影响的，新增了一个 disabled 时不触发的 click 事件。</li>\n<li>lin-ui 则是会在有 open-type 的时候，disabled 失效。</li>\n<li>TDesign 的 tap 的事件保持了和原生一致。</li>\n</ul>"},{"title":"关于组件库的代码复用","date":"2021-12-01T03:31:30.000Z","_content":"\nTDesign 组件库覆盖的范围很广，包括移动端、PC端、小程序端；也覆盖了主流的前端框架，如 Vue、React、Angular 等。因此，开发组件库时，代码的维护及复用是我们最头疼的问题，这就引发了我的思考，也就诞生了这篇文章。\n\n<!-- more -->\n\n## 终端的差异\n\n其实这里讲的差异主要是 web 端和小程序端。本质上，他们不是在一个水平上的产物，小程序属于更高级的框架，提供了新的语法之外，还提供了许多二次封装的组件。\n\n除了组件这方面的差异，还体现在语法支持上的差异。比如说，小程序的组件属性，不支持 Date 类型，这类的问题还属于是开发中才会发现的“陷阱”。\n\n## CSS 的复用\n\nWeb 的组件，本质上是 HTML + CSS + JS 的组合。不管框架如何变化，本质上只会影响 HTML + JS 的写法，并不会对 CSS 有太多影响。反而是终端的变化对 CSS 的影响更大一些。很多时候，我们只会考虑在逻辑做分层处理，反而忽略了 CSS 的分层，其实对 CSS 分层的意义在组件库开发中，尤为重要。其中 CSS 规则大致可以分成以下几类：\n\n- 颜色/文本\n- 尺寸/位置\n- 布局\n- 动画\n\n在不同终端，颜色/文本 和 动画 不会有太大差异，因此可以做到复用。但尺寸/位置 和 布局 则会因为终端的变化而变化。因此 CSS 的分层是这样的：\n\n![CSS分层示意图](/blog/images/ui-library/css-layer.png)\n\n通过这样的分层，就可以最大化复用 CSS ，只需要各自实现一下 Mobile 和 Desktop 的尺寸/位置 和 布局样式即可。对于小程序的处理，则需要对 CSS unit 做个转换即可。不至于导致每个终端都需要重新写一份 CSS。降低代码的重复率，也就降低代码的维护成本，尽可能延续组件库的生命。\n\n## 逻辑复用\n\n业界比较热门的组件库，如 Ant Design 和 Element UI 都是专注于一个框架来开发的。因此他们并不会遇到多框架逻辑复用的问题。\n\n### 跨框架级复用\n\n但最近发布的 Semi Design 则和 TDesign 一样，同步开发了 Vue 和 React 组件库，采用的逻辑复用方案被他们称之为 F/A 方案。其中 F 是 Foundation 的简称，代表与框架无关的逻辑；而 A 则是 Adapter 的简称，代表每个框架的适配器，与框架强相关。\n\n![跨框架复用](/blog/images/ui-library/foundation-adapter.png)\n\n其实思路还是比较直观的，将逻辑拆分成工具函数，封装成一个工具类作为 Foundation，然后在用户操作或者组件生命周期中调用 Foundation 对应的函数。\n\n本质上就是提前规划好组件的函数拆分，做到函数级别上的复用。\n\n目前来说，如果不使用 DSL 或者二次编译的方式，确实没办法做到更多的复用。但如果采用 DSL 的话，极大可能会陷入编译器的深渊之中。\n\n### 组件级复用\n\n当我们使用一个组件，UI 又没法满足要求时，我们往往会选择重新造一个轮子。\n\n但其实，如果此时组件的 UI 无法满足，但逻辑是符合的，是不是可以做到只复用逻辑，然后只需要重写 UI 即可。\n\n比如，以我实际开发时遇到的 Select 举例，TDesign 的 Select 是长这样的：\n\n![TDesign Select](/blog/images/ui-library/select-tdesign.webp)\n\n但用户反馈说，他们的视觉是这样的：\n\n![用户想要的 Select](/blog/images/ui-library/select.webp)\n\n功能可以说是一致的，差别仅仅是 用于筛选的 input 的位置。\n\n对于常规的组件来说，组件的每个节点是固定的，可以扩展的位置（插槽 Slot）也是固定的。像这样要大范围调整内部节点的场景，是无法满足的。\n\n为了满足这样的诉求，我的实现思路是这样的：将组件的实现拆分成两层：rawComponent 和 realComponent\n\n![headless component](/blog/images/ui-library/cross-frame.png)\n\nRawComponent 将每个模块输出，拆分成更小粒度的组件，用户可以自定义组合，也可以通过渲染函数或者 Scoped Slot 来实现不一样的 UI。\n\n在 React 中使用 Render Props 自定义渲染\n\n```jsx\n// raw\nclass RawComponent extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n\n  render() {\n    return this.props.render({\n      // ... some props\n    })\n  }\n}\n\nclass RealComponent extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n\n  render() {\n    return (\n      <RawComponent\n        render={() => (<div></div>)}\n      />\n    )\n  }\n}\n```\n\n在 Vue 中使用 Scoped Slot 自定义渲染\n\n```jsx\n// raw.vue\nVue.extend({\n  data() {\n    return {}\n  },\n\n  render() {\n    return this.$scopedSlots.default({ result: []})\n  }\n})\n```\n\n```jsx\n// real.vue\n<template>\n  <RawComponent>\n    <div scope-slot=\"{ result }\">\n      <span>{{result}}</span>\n    </div>\n  </RawComponent>\n</template>\n\n<script>\nimport RawComponent from './raw.vue';\n\nVue.extend({\n  components: { RawComponent }\n})\n</script>\n```\n\n## 思考\n\n作为组件库的开发者，也是使用者。我选用组件库时，对组件库的期望是这样的：\n\n- 组件数量齐全且特性完善\n- 代码质量高（可维护性高，可阅读性高，可扩展性高）\n- 可复用性高\n\n组件的特性完善需要通过不断的用户反馈然后进行迭代才能达到的。而代码的质量，和可复用性高则是我们从一开始就能考虑并尽可能实现的。\n\n如果说，要如何在相对成熟的组件库市场上有所与众不同，或者说能让用户选用我们的话，那可复用性可能是其中之一。\n\n## 参考资料\n\n- [Semi Design - UI组件库如何分层设计，使其具备适配多种mvvm框架能力](https://bytedance.feishu.cn/docs/doccnTgc0iGOVPubHZkwPpxXSNh)\n- [Component Reusability in React &amp; Vue](https://www.jonathan-harrell.com/blog/component-reusability-in-react-vue/)","source":"_posts/about-code-reuse-for-uilib.md","raw":"---\ntitle: 关于组件库的代码复用\ndate: 2021-12-01 11:31:30\ncategories:\n- 组件库\n---\n\nTDesign 组件库覆盖的范围很广，包括移动端、PC端、小程序端；也覆盖了主流的前端框架，如 Vue、React、Angular 等。因此，开发组件库时，代码的维护及复用是我们最头疼的问题，这就引发了我的思考，也就诞生了这篇文章。\n\n<!-- more -->\n\n## 终端的差异\n\n其实这里讲的差异主要是 web 端和小程序端。本质上，他们不是在一个水平上的产物，小程序属于更高级的框架，提供了新的语法之外，还提供了许多二次封装的组件。\n\n除了组件这方面的差异，还体现在语法支持上的差异。比如说，小程序的组件属性，不支持 Date 类型，这类的问题还属于是开发中才会发现的“陷阱”。\n\n## CSS 的复用\n\nWeb 的组件，本质上是 HTML + CSS + JS 的组合。不管框架如何变化，本质上只会影响 HTML + JS 的写法，并不会对 CSS 有太多影响。反而是终端的变化对 CSS 的影响更大一些。很多时候，我们只会考虑在逻辑做分层处理，反而忽略了 CSS 的分层，其实对 CSS 分层的意义在组件库开发中，尤为重要。其中 CSS 规则大致可以分成以下几类：\n\n- 颜色/文本\n- 尺寸/位置\n- 布局\n- 动画\n\n在不同终端，颜色/文本 和 动画 不会有太大差异，因此可以做到复用。但尺寸/位置 和 布局 则会因为终端的变化而变化。因此 CSS 的分层是这样的：\n\n![CSS分层示意图](/blog/images/ui-library/css-layer.png)\n\n通过这样的分层，就可以最大化复用 CSS ，只需要各自实现一下 Mobile 和 Desktop 的尺寸/位置 和 布局样式即可。对于小程序的处理，则需要对 CSS unit 做个转换即可。不至于导致每个终端都需要重新写一份 CSS。降低代码的重复率，也就降低代码的维护成本，尽可能延续组件库的生命。\n\n## 逻辑复用\n\n业界比较热门的组件库，如 Ant Design 和 Element UI 都是专注于一个框架来开发的。因此他们并不会遇到多框架逻辑复用的问题。\n\n### 跨框架级复用\n\n但最近发布的 Semi Design 则和 TDesign 一样，同步开发了 Vue 和 React 组件库，采用的逻辑复用方案被他们称之为 F/A 方案。其中 F 是 Foundation 的简称，代表与框架无关的逻辑；而 A 则是 Adapter 的简称，代表每个框架的适配器，与框架强相关。\n\n![跨框架复用](/blog/images/ui-library/foundation-adapter.png)\n\n其实思路还是比较直观的，将逻辑拆分成工具函数，封装成一个工具类作为 Foundation，然后在用户操作或者组件生命周期中调用 Foundation 对应的函数。\n\n本质上就是提前规划好组件的函数拆分，做到函数级别上的复用。\n\n目前来说，如果不使用 DSL 或者二次编译的方式，确实没办法做到更多的复用。但如果采用 DSL 的话，极大可能会陷入编译器的深渊之中。\n\n### 组件级复用\n\n当我们使用一个组件，UI 又没法满足要求时，我们往往会选择重新造一个轮子。\n\n但其实，如果此时组件的 UI 无法满足，但逻辑是符合的，是不是可以做到只复用逻辑，然后只需要重写 UI 即可。\n\n比如，以我实际开发时遇到的 Select 举例，TDesign 的 Select 是长这样的：\n\n![TDesign Select](/blog/images/ui-library/select-tdesign.webp)\n\n但用户反馈说，他们的视觉是这样的：\n\n![用户想要的 Select](/blog/images/ui-library/select.webp)\n\n功能可以说是一致的，差别仅仅是 用于筛选的 input 的位置。\n\n对于常规的组件来说，组件的每个节点是固定的，可以扩展的位置（插槽 Slot）也是固定的。像这样要大范围调整内部节点的场景，是无法满足的。\n\n为了满足这样的诉求，我的实现思路是这样的：将组件的实现拆分成两层：rawComponent 和 realComponent\n\n![headless component](/blog/images/ui-library/cross-frame.png)\n\nRawComponent 将每个模块输出，拆分成更小粒度的组件，用户可以自定义组合，也可以通过渲染函数或者 Scoped Slot 来实现不一样的 UI。\n\n在 React 中使用 Render Props 自定义渲染\n\n```jsx\n// raw\nclass RawComponent extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n\n  render() {\n    return this.props.render({\n      // ... some props\n    })\n  }\n}\n\nclass RealComponent extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n\n  render() {\n    return (\n      <RawComponent\n        render={() => (<div></div>)}\n      />\n    )\n  }\n}\n```\n\n在 Vue 中使用 Scoped Slot 自定义渲染\n\n```jsx\n// raw.vue\nVue.extend({\n  data() {\n    return {}\n  },\n\n  render() {\n    return this.$scopedSlots.default({ result: []})\n  }\n})\n```\n\n```jsx\n// real.vue\n<template>\n  <RawComponent>\n    <div scope-slot=\"{ result }\">\n      <span>{{result}}</span>\n    </div>\n  </RawComponent>\n</template>\n\n<script>\nimport RawComponent from './raw.vue';\n\nVue.extend({\n  components: { RawComponent }\n})\n</script>\n```\n\n## 思考\n\n作为组件库的开发者，也是使用者。我选用组件库时，对组件库的期望是这样的：\n\n- 组件数量齐全且特性完善\n- 代码质量高（可维护性高，可阅读性高，可扩展性高）\n- 可复用性高\n\n组件的特性完善需要通过不断的用户反馈然后进行迭代才能达到的。而代码的质量，和可复用性高则是我们从一开始就能考虑并尽可能实现的。\n\n如果说，要如何在相对成熟的组件库市场上有所与众不同，或者说能让用户选用我们的话，那可复用性可能是其中之一。\n\n## 参考资料\n\n- [Semi Design - UI组件库如何分层设计，使其具备适配多种mvvm框架能力](https://bytedance.feishu.cn/docs/doccnTgc0iGOVPubHZkwPpxXSNh)\n- [Component Reusability in React &amp; Vue](https://www.jonathan-harrell.com/blog/component-reusability-in-react-vue/)","slug":"about-code-reuse-for-uilib","published":1,"updated":"2023-08-04T09:02:09.968Z","_id":"clkwckxzs0000peszazuk404y","comments":1,"layout":"post","photos":[],"link":"","content":"<p>TDesign 组件库覆盖的范围很广，包括移动端、PC端、小程序端；也覆盖了主流的前端框架，如 Vue、React、Angular 等。因此，开发组件库时，代码的维护及复用是我们最头疼的问题，这就引发了我的思考，也就诞生了这篇文章。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"终端的差异\"><a href=\"#终端的差异\" class=\"headerlink\" title=\"终端的差异\"></a>终端的差异</h2><p>其实这里讲的差异主要是 web 端和小程序端。本质上，他们不是在一个水平上的产物，小程序属于更高级的框架，提供了新的语法之外，还提供了许多二次封装的组件。</p>\n<p>除了组件这方面的差异，还体现在语法支持上的差异。比如说，小程序的组件属性，不支持 Date 类型，这类的问题还属于是开发中才会发现的“陷阱”。</p>\n<h2 id=\"CSS-的复用\"><a href=\"#CSS-的复用\" class=\"headerlink\" title=\"CSS 的复用\"></a>CSS 的复用</h2><p>Web 的组件，本质上是 HTML + CSS + JS 的组合。不管框架如何变化，本质上只会影响 HTML + JS 的写法，并不会对 CSS 有太多影响。反而是终端的变化对 CSS 的影响更大一些。很多时候，我们只会考虑在逻辑做分层处理，反而忽略了 CSS 的分层，其实对 CSS 分层的意义在组件库开发中，尤为重要。其中 CSS 规则大致可以分成以下几类：</p>\n<ul>\n<li>颜色/文本</li>\n<li>尺寸/位置</li>\n<li>布局</li>\n<li>动画</li>\n</ul>\n<p>在不同终端，颜色/文本 和 动画 不会有太大差异，因此可以做到复用。但尺寸/位置 和 布局 则会因为终端的变化而变化。因此 CSS 的分层是这样的：</p>\n<p><img src=\"/blog/images/ui-library/css-layer.png\" alt=\"CSS分层示意图\"></p>\n<p>通过这样的分层，就可以最大化复用 CSS ，只需要各自实现一下 Mobile 和 Desktop 的尺寸/位置 和 布局样式即可。对于小程序的处理，则需要对 CSS unit 做个转换即可。不至于导致每个终端都需要重新写一份 CSS。降低代码的重复率，也就降低代码的维护成本，尽可能延续组件库的生命。</p>\n<h2 id=\"逻辑复用\"><a href=\"#逻辑复用\" class=\"headerlink\" title=\"逻辑复用\"></a>逻辑复用</h2><p>业界比较热门的组件库，如 Ant Design 和 Element UI 都是专注于一个框架来开发的。因此他们并不会遇到多框架逻辑复用的问题。</p>\n<h3 id=\"跨框架级复用\"><a href=\"#跨框架级复用\" class=\"headerlink\" title=\"跨框架级复用\"></a>跨框架级复用</h3><p>但最近发布的 Semi Design 则和 TDesign 一样，同步开发了 Vue 和 React 组件库，采用的逻辑复用方案被他们称之为 F/A 方案。其中 F 是 Foundation 的简称，代表与框架无关的逻辑；而 A 则是 Adapter 的简称，代表每个框架的适配器，与框架强相关。</p>\n<p><img src=\"/blog/images/ui-library/foundation-adapter.png\" alt=\"跨框架复用\"></p>\n<p>其实思路还是比较直观的，将逻辑拆分成工具函数，封装成一个工具类作为 Foundation，然后在用户操作或者组件生命周期中调用 Foundation 对应的函数。</p>\n<p>本质上就是提前规划好组件的函数拆分，做到函数级别上的复用。</p>\n<p>目前来说，如果不使用 DSL 或者二次编译的方式，确实没办法做到更多的复用。但如果采用 DSL 的话，极大可能会陷入编译器的深渊之中。</p>\n<h3 id=\"组件级复用\"><a href=\"#组件级复用\" class=\"headerlink\" title=\"组件级复用\"></a>组件级复用</h3><p>当我们使用一个组件，UI 又没法满足要求时，我们往往会选择重新造一个轮子。</p>\n<p>但其实，如果此时组件的 UI 无法满足，但逻辑是符合的，是不是可以做到只复用逻辑，然后只需要重写 UI 即可。</p>\n<p>比如，以我实际开发时遇到的 Select 举例，TDesign 的 Select 是长这样的：</p>\n<p><img src=\"/blog/images/ui-library/select-tdesign.webp\" alt=\"TDesign Select\"></p>\n<p>但用户反馈说，他们的视觉是这样的：</p>\n<p><img src=\"/blog/images/ui-library/select.webp\" alt=\"用户想要的 Select\"></p>\n<p>功能可以说是一致的，差别仅仅是 用于筛选的 input 的位置。</p>\n<p>对于常规的组件来说，组件的每个节点是固定的，可以扩展的位置（插槽 Slot）也是固定的。像这样要大范围调整内部节点的场景，是无法满足的。</p>\n<p>为了满足这样的诉求，我的实现思路是这样的：将组件的实现拆分成两层：rawComponent 和 realComponent</p>\n<p><img src=\"/blog/images/ui-library/cross-frame.png\" alt=\"headless component\"></p>\n<p>RawComponent 将每个模块输出，拆分成更小粒度的组件，用户可以自定义组合，也可以通过渲染函数或者 Scoped Slot 来实现不一样的 UI。</p>\n<p>在 React 中使用 Render Props 自定义渲染</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// raw</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RawComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.props.render(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... some props</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">RawComponent</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">render</span>=<span class=\"string\">&#123;()</span> =&gt;</span> (<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>)&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      /&gt;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 Vue 中使用 Scoped Slot 自定义渲染</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// raw.vue</span></span><br><span class=\"line\">Vue.extend(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">data</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.$scopedSlots.default(&#123; <span class=\"attr\">result</span>: []&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// real.vue</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">RawComponent</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">scope-slot</span>=<span class=\"string\">&quot;&#123; result &#125;&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123;result&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">RawComponent</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"keyword\">import</span> RawComponent <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./raw.vue&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">Vue.extend(&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"attr\">components</span>: &#123; RawComponent &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;)</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>作为组件库的开发者，也是使用者。我选用组件库时，对组件库的期望是这样的：</p>\n<ul>\n<li>组件数量齐全且特性完善</li>\n<li>代码质量高（可维护性高，可阅读性高，可扩展性高）</li>\n<li>可复用性高</li>\n</ul>\n<p>组件的特性完善需要通过不断的用户反馈然后进行迭代才能达到的。而代码的质量，和可复用性高则是我们从一开始就能考虑并尽可能实现的。</p>\n<p>如果说，要如何在相对成熟的组件库市场上有所与众不同，或者说能让用户选用我们的话，那可复用性可能是其中之一。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://bytedance.feishu.cn/docs/doccnTgc0iGOVPubHZkwPpxXSNh\">Semi Design - UI组件库如何分层设计，使其具备适配多种mvvm框架能力</a></li>\n<li><a href=\"https://www.jonathan-harrell.com/blog/component-reusability-in-react-vue/\">Component Reusability in React &amp; Vue</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>TDesign 组件库覆盖的范围很广，包括移动端、PC端、小程序端；也覆盖了主流的前端框架，如 Vue、React、Angular 等。因此，开发组件库时，代码的维护及复用是我们最头疼的问题，这就引发了我的思考，也就诞生了这篇文章。</p>","more":"<h2 id=\"终端的差异\"><a href=\"#终端的差异\" class=\"headerlink\" title=\"终端的差异\"></a>终端的差异</h2><p>其实这里讲的差异主要是 web 端和小程序端。本质上，他们不是在一个水平上的产物，小程序属于更高级的框架，提供了新的语法之外，还提供了许多二次封装的组件。</p>\n<p>除了组件这方面的差异，还体现在语法支持上的差异。比如说，小程序的组件属性，不支持 Date 类型，这类的问题还属于是开发中才会发现的“陷阱”。</p>\n<h2 id=\"CSS-的复用\"><a href=\"#CSS-的复用\" class=\"headerlink\" title=\"CSS 的复用\"></a>CSS 的复用</h2><p>Web 的组件，本质上是 HTML + CSS + JS 的组合。不管框架如何变化，本质上只会影响 HTML + JS 的写法，并不会对 CSS 有太多影响。反而是终端的变化对 CSS 的影响更大一些。很多时候，我们只会考虑在逻辑做分层处理，反而忽略了 CSS 的分层，其实对 CSS 分层的意义在组件库开发中，尤为重要。其中 CSS 规则大致可以分成以下几类：</p>\n<ul>\n<li>颜色/文本</li>\n<li>尺寸/位置</li>\n<li>布局</li>\n<li>动画</li>\n</ul>\n<p>在不同终端，颜色/文本 和 动画 不会有太大差异，因此可以做到复用。但尺寸/位置 和 布局 则会因为终端的变化而变化。因此 CSS 的分层是这样的：</p>\n<p><img src=\"/blog/images/ui-library/css-layer.png\" alt=\"CSS分层示意图\"></p>\n<p>通过这样的分层，就可以最大化复用 CSS ，只需要各自实现一下 Mobile 和 Desktop 的尺寸/位置 和 布局样式即可。对于小程序的处理，则需要对 CSS unit 做个转换即可。不至于导致每个终端都需要重新写一份 CSS。降低代码的重复率，也就降低代码的维护成本，尽可能延续组件库的生命。</p>\n<h2 id=\"逻辑复用\"><a href=\"#逻辑复用\" class=\"headerlink\" title=\"逻辑复用\"></a>逻辑复用</h2><p>业界比较热门的组件库，如 Ant Design 和 Element UI 都是专注于一个框架来开发的。因此他们并不会遇到多框架逻辑复用的问题。</p>\n<h3 id=\"跨框架级复用\"><a href=\"#跨框架级复用\" class=\"headerlink\" title=\"跨框架级复用\"></a>跨框架级复用</h3><p>但最近发布的 Semi Design 则和 TDesign 一样，同步开发了 Vue 和 React 组件库，采用的逻辑复用方案被他们称之为 F/A 方案。其中 F 是 Foundation 的简称，代表与框架无关的逻辑；而 A 则是 Adapter 的简称，代表每个框架的适配器，与框架强相关。</p>\n<p><img src=\"/blog/images/ui-library/foundation-adapter.png\" alt=\"跨框架复用\"></p>\n<p>其实思路还是比较直观的，将逻辑拆分成工具函数，封装成一个工具类作为 Foundation，然后在用户操作或者组件生命周期中调用 Foundation 对应的函数。</p>\n<p>本质上就是提前规划好组件的函数拆分，做到函数级别上的复用。</p>\n<p>目前来说，如果不使用 DSL 或者二次编译的方式，确实没办法做到更多的复用。但如果采用 DSL 的话，极大可能会陷入编译器的深渊之中。</p>\n<h3 id=\"组件级复用\"><a href=\"#组件级复用\" class=\"headerlink\" title=\"组件级复用\"></a>组件级复用</h3><p>当我们使用一个组件，UI 又没法满足要求时，我们往往会选择重新造一个轮子。</p>\n<p>但其实，如果此时组件的 UI 无法满足，但逻辑是符合的，是不是可以做到只复用逻辑，然后只需要重写 UI 即可。</p>\n<p>比如，以我实际开发时遇到的 Select 举例，TDesign 的 Select 是长这样的：</p>\n<p><img src=\"/blog/images/ui-library/select-tdesign.webp\" alt=\"TDesign Select\"></p>\n<p>但用户反馈说，他们的视觉是这样的：</p>\n<p><img src=\"/blog/images/ui-library/select.webp\" alt=\"用户想要的 Select\"></p>\n<p>功能可以说是一致的，差别仅仅是 用于筛选的 input 的位置。</p>\n<p>对于常规的组件来说，组件的每个节点是固定的，可以扩展的位置（插槽 Slot）也是固定的。像这样要大范围调整内部节点的场景，是无法满足的。</p>\n<p>为了满足这样的诉求，我的实现思路是这样的：将组件的实现拆分成两层：rawComponent 和 realComponent</p>\n<p><img src=\"/blog/images/ui-library/cross-frame.png\" alt=\"headless component\"></p>\n<p>RawComponent 将每个模块输出，拆分成更小粒度的组件，用户可以自定义组合，也可以通过渲染函数或者 Scoped Slot 来实现不一样的 UI。</p>\n<p>在 React 中使用 Render Props 自定义渲染</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// raw</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RawComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.props.render(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... some props</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">RawComponent</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">render</span>=<span class=\"string\">&#123;()</span> =&gt;</span> (<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>)&#125;</span></span><br><span class=\"line\"><span class=\"xml\">      /&gt;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 Vue 中使用 Scoped Slot 自定义渲染</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// raw.vue</span></span><br><span class=\"line\">Vue.extend(&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">data</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.$scopedSlots.default(&#123; <span class=\"attr\">result</span>: []&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// real.vue</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">RawComponent</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">scope-slot</span>=<span class=\"string\">&quot;&#123; result &#125;&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123;result&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">RawComponent</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"><span class=\"keyword\">import</span> RawComponent <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./raw.vue&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">Vue.extend(&#123;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">  <span class=\"attr\">components</span>: &#123; RawComponent &#125;</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\">&#125;)</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>作为组件库的开发者，也是使用者。我选用组件库时，对组件库的期望是这样的：</p>\n<ul>\n<li>组件数量齐全且特性完善</li>\n<li>代码质量高（可维护性高，可阅读性高，可扩展性高）</li>\n<li>可复用性高</li>\n</ul>\n<p>组件的特性完善需要通过不断的用户反馈然后进行迭代才能达到的。而代码的质量，和可复用性高则是我们从一开始就能考虑并尽可能实现的。</p>\n<p>如果说，要如何在相对成熟的组件库市场上有所与众不同，或者说能让用户选用我们的话，那可复用性可能是其中之一。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://bytedance.feishu.cn/docs/doccnTgc0iGOVPubHZkwPpxXSNh\">Semi Design - UI组件库如何分层设计，使其具备适配多种mvvm框架能力</a></li>\n<li><a href=\"https://www.jonathan-harrell.com/blog/component-reusability-in-react-vue/\">Component Reusability in React &amp; Vue</a></li>\n</ul>"},{"title":"当 TDesign 小程序遇上 GitHub Actions","date":"2022-12-10T04:11:49.000Z","_content":"\n在微信小程序刚发布那会，要想做自动化，都必须有 hack 开发者工具的能力才能做到，而且在 Linux 系统没有开发者工具，需要使用 windows 或 macOS。好在微信也明白开发者的痛点，在小程序发布了 3 年之后的 2020 年提供了 [CI](https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html) 的能力。\n\n在 TDesign 正式开源的前半年，我们投入在自动化这些基础实施的人力比较多，可以分享的内容也挺多，这里主要分享小程序相关的自动化，并且是在 GitHub Actions 上的实现。\n\n<!-- more -->\n\n## 自动上传体验版\n\n在 TDesign 小程序组件库的开发中，比较早期做的CI 能力是自动上传体验版，我也封装了一个 GitHub Actions 可以直接使用：[LeeJim/setup-miniprogram](https://github.com/LeeJim/setup-miniprogram)。\n\n我们的发布流程是这样的：\n\n![开发流程](/blog/images/mp-github-action/dev-flow.png)\n\n> 其中生成 CHANGELOG 也是发布的痛点，这个能力主要是 @lucaszzhou 实现的，后面他可能会分享了相关实现，我再补充下链接。大家可以期待一下。\n\n可以看到，整个发布流程，我只需要修改 package.json 的版本号，后面的流程几乎都是自动操作的。\n\n### 上传密钥\n\n其中，**上传小程序** 这块，需要有上传密钥，具体路径：[微信公众平台](https://mp.weixin.qq.com/) - 开发管理 - 开发设置 - 小程序代码上传密钥。\n\n由于密钥是敏感的信息，不能放在代码里明文展示，因此需要使用到 GitHub 的 secret。具体路径：Settings - Secrets - Actions - Repository secrets\n\n![GitHub 密钥路径](/blog/images/mp-github-action/github-secrets.png)\n\n将在微信公众平台下载下来的密钥保存到这里，然后起一个对应的 secret name 即可。使用的时候，在 GitHub Actions 的 `yml` 文件里可以这样使用，以下以 tdesign-miniprogram 举例：\n\n![miniprogram-action](/blog/images/mp-github-action/github-workflows.png)\n\n### 小程序版本关系\n\n小程序的有 3 种版本：开发版、体验版、正式版。体验版和正式版都只有一个，开发版可以有多个，对应的关系是这样的：\n\n![小程序版本关系](/blog/images/mp-github-action/miniprogram-version.png)\n\n这里需要特别提醒的一点是，**开发版是可以覆盖的，体验版的关系也会继承**。这里如何决定哪个版本覆盖哪个版本，取决于上传时的 CI 机器人编号，而开发者工具无法选择，因此开发者工具上传的开发版会一直覆盖。\n\n所以这个流水线的体验版可以自动覆盖，不需要手动选择，也是基于这个原理。\n\n## 自动预览\n\n由于 TDesign 小程序组件库的开发环境依赖许多编译工具，因此在验收开发者提交的 PR 时需要 `执行构建 - 打开开发者工具 - 点击预览` 一系列操作，才能开始扫码体验，较为繁琐。\n\n> 如果是设计师验收的话，还需要搭开发环境，非常不合理。\n\n另外更麻烦是，小程序的开发版二维码有时效限制（开发者工具显示时效 25 min）。因此没有办法像常规 Web 开发那样，在 PR 的各种检测相关流水通过之后构建出一个产物，后续随时可以验收。\n\n### Web 预览方案\n\n作为对比，可以先看一下 TDesign Web Vue 的 PR 流程：\n\n![TDesignWeb 预览流程](/blog/images/mp-github-action/tdesign-web-preview.png)\n\n可以看到每当 PR 创建或者同步时，都会触发构建官网，这样每次都能预览该 PR 最新的代码，用以验收。对应的预览评论如下：\n\n![web预览地址](/blog/images/mp-github-action/github-comment-1.png)\n\n### 小程序预览方案\n\n因为二维码的时效限制，所以小程序的预览不能直接借鉴 Web 的方式，只能在需要验收的时候再构建，这就需要一个触发构建的开关。\n\n我把这个开关定义成：**在 PR 上评论 “预览” 二字** 。\n\n以下是触发的过程：\n\n![小程序预览方案1](/blog/images/mp-github-action/github-comment-2.png)\n\n因为构建需要一定的时间，因此先通过 Comment 告知构建已在进行。等构建成功之后，就会用二维码将这个 Comment 替换掉。\n\n![小程序预览方案2](/blog/images/mp-github-action/github-comment-3.png)\n\n以上就是小程序预览方案的大体过程。\n\n不过在实现这个方案的时候也遇到了不少坑，这里也顺便分享一下。\n\n## GitHub Actions 避坑\n\n### 获取 PR 对应的代码\n\n因为这个功能使用的是 `issue_comment: created` 这个触发事件。因此需要判断这个 comment 是属于 PR ，并需要获取 Comment 对应的 PR 信息。\n\n判断 Comment 是否属于 PR 比较容易，判断这个环境变量是否存在即可：``${{ github.event.pull_request }}``。\n\n#### 获取 PR 信息\n\n但是，可能是因为触发事件的缘故，没法直接通过 ``${{ github.event.pull_request.head.sha }}`` 获取这个 PR 对应的 Commit SHA。\n\n通过搜索，发现了一个 Action 可以通过 GitHub 的 graphQL 获取对应 PR 的信息：[xt0rted/pull-request-comment-branch](https://github.com/xt0rted/pull-request-comment-branch)\n\n但是，这个 Action 又忽略了另外一个重要的问题：**PR 的 base branch 可能是 fork 的仓库**，它没有返回对应的仓库信息。因此我又基于这个 Action 封装了新的 Action：[LeeJim/pull-request-comment-branch](https://github.com/LeeJim/pull-request-comment-branch)\n\n至此，基于 [actions/checkout](https://github.com/actions/checkout) 和 [LeeJim/pull-request-comment-branch](https://github.com/LeeJim/pull-request-comment-branch) 才完成了指定评论对应的 PR 对应的代码克隆工作：\n\n```yml\n- uses: LeeJim/pull-request-comment-branch@main\n  id: comment-branch\n- uses: actions/checkout@v3\n  if: success()\n  with:\n    ref: ${{ steps.comment-branch.outputs.head_ref }}\n    repository: ${{ steps.comment-branch.outputs.head_repo_name_with_owner }}\n```\n\n### 小程序预览\n\n之前实现小程序发布的时候，因为各种问题也自己实现了一个 Action：[LeeJim/setup-miniprogram](https://github.com/LeeJim/setup-miniprogram)。\n\n因此本次就在这个 Action 的基础上，支持了预览的功能，返回了对应的预览二维码。\n\n### 给评论加图片\n\n因为小程序上传之后，可以选择返回 base64 或 jpg 格式的图片，为了避免图床的问题，因此我就想当然地选择 base64。后来才发现 GitHub 的 MarkDown 因为安全限制的问题，不支持 base64 的图片。因此我需要使用另外的图床。\n\n#### 腾讯云 COS\n\n此时，我的想法也很简单，直接使用腾讯云 COS 发布的 Action 上传就完事。结果在 GitHub 上找到的 Action 都是上传完不返回地址的。于是，我又需要创建\n一个新的 Action：[LeeJim/tencent-cos-action](https://github.com/LeeJim/tencent-cos-action)，将上传的地址返回。\n\n### 评论替换\n\n给指定 PR 添加 Comment 使用的 Action：[thollander/actions-comment-pull-request](https://github.com/thollander/actions-comment-pull-request)。\n\n该 Action 提供了 Comment 的功能，但我遇到的坑是文档和版本不一致。所以此刻就觉得 GitHub Actions 设计的巧妙且简单，当遇到问题的时候，可以直接去看对应的代码实现。\n\n替换的功能是通过 `comment_tag` 的参数来实现。原理也很简单，就是如果有传 `comment_tag` 的话，就会查找这个 PR 对应的所有 Comment 是否存在这个 tag，有的话就直接替换，没有就创建一个新的 Comment。\n\n这里有一个技巧就是：将这个 tag 通过 `<!-- ${{tag}} -->` 包装了，因此在 Comment 也看不到这个 tag。\n\n以下是 [TDesign Miniprogram](https://github.com/Tencent/tdesign-miniprogram/blob/develop/.github/workflows/preview.yml) 自动预览功能的完整实现：\n\n```yml\nname: PREVIEW\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  request-preview:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'issue_comment' &amp;&amp; github.event.issue.pull_request &amp;&amp; github.event.comment.body == '预览'\n    steps:\n      - run: |\n          timestamp=$(date +%s)\n          echo \"timestamp=${timestamp}\" >> $GITHUB_OUTPUT\n        id: time\n      - name: Comment PR\n        uses: thollander/actions-comment-pull-request@v2\n        with:\n          message: |\n            正在构建预览的二维码，请稍等...\n          comment_tag: ${{steps.time.outputs.timestamp}}\n      - uses: LeeJim/pull-request-comment-branch@main\n        id: comment-branch\n      - uses: actions/checkout@v3\n        if: success()\n        with:\n          ref: ${{ steps.comment-branch.outputs.head_ref }}\n          repository: ${{ steps.comment-branch.outputs.head_repo_name_with_owner }}\n      - uses: ./.github/actions/install-dep\n      - run: npm run build\n        shell: bash\n      - name: get preview qrcode\n        id: preview\n        uses: LeeJim/setup-miniprogram@main\n        with:\n          project_type: miniProgram\n          action_type: preview\n          project_path: ./_example\n          es6: true\n          es7: true\n          minify: true\n        env:\n          MINI_APP_ID: ${{ secrets.TDESIGN_APP_ID }}\n          MINI_APP_PRIVATE_KEY: ${{ secrets.TDESIGN_MINI_KEY }}\n      - name: Upload qrcode to Tencent COS\n        uses: LeeJim/tencent-cos-action@main\n        id: cos\n        with:\n          secretId: ${{ secrets.TENCENT_COS_SECRET_ID }}\n          secretKey: ${{ secrets.TENCENT_COS_SECRET_KEY }}\n          bucket: mp-qrcode-1255404841\n          region: ap-guangzhou\n          content: ${{ steps.preview.outputs.preview-qrcode }}\n      - name: Comment PR\n        uses: thollander/actions-comment-pull-request@v2\n        with:\n          message: |\n            <img alt=\"qrcode\" src=\"${{ steps.cos.outputs.url }}\" width=\"256\" />\n          comment_tag: ${{steps.time.outputs.timestamp}}\n```\n\n\n> 最后提醒一下，GitHub Actions 对 Public 的仓库是没有 CI 运行累计时长的限制，而 Private 的仓库只能几千分钟的 CI 累计时长，这个需要注意。\n\n\n\n","source":"_posts/wechat-miniprogarm-with-github-action.md","raw":"---\ntitle: 当 TDesign 小程序遇上 GitHub Actions\ndate: 2022-12-10 12:11:49\ntags:\n- 小程序\ncategories:\n- [小程序]\n- 前端工程化\n---\n\n在微信小程序刚发布那会，要想做自动化，都必须有 hack 开发者工具的能力才能做到，而且在 Linux 系统没有开发者工具，需要使用 windows 或 macOS。好在微信也明白开发者的痛点，在小程序发布了 3 年之后的 2020 年提供了 [CI](https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html) 的能力。\n\n在 TDesign 正式开源的前半年，我们投入在自动化这些基础实施的人力比较多，可以分享的内容也挺多，这里主要分享小程序相关的自动化，并且是在 GitHub Actions 上的实现。\n\n<!-- more -->\n\n## 自动上传体验版\n\n在 TDesign 小程序组件库的开发中，比较早期做的CI 能力是自动上传体验版，我也封装了一个 GitHub Actions 可以直接使用：[LeeJim/setup-miniprogram](https://github.com/LeeJim/setup-miniprogram)。\n\n我们的发布流程是这样的：\n\n![开发流程](/blog/images/mp-github-action/dev-flow.png)\n\n> 其中生成 CHANGELOG 也是发布的痛点，这个能力主要是 @lucaszzhou 实现的，后面他可能会分享了相关实现，我再补充下链接。大家可以期待一下。\n\n可以看到，整个发布流程，我只需要修改 package.json 的版本号，后面的流程几乎都是自动操作的。\n\n### 上传密钥\n\n其中，**上传小程序** 这块，需要有上传密钥，具体路径：[微信公众平台](https://mp.weixin.qq.com/) - 开发管理 - 开发设置 - 小程序代码上传密钥。\n\n由于密钥是敏感的信息，不能放在代码里明文展示，因此需要使用到 GitHub 的 secret。具体路径：Settings - Secrets - Actions - Repository secrets\n\n![GitHub 密钥路径](/blog/images/mp-github-action/github-secrets.png)\n\n将在微信公众平台下载下来的密钥保存到这里，然后起一个对应的 secret name 即可。使用的时候，在 GitHub Actions 的 `yml` 文件里可以这样使用，以下以 tdesign-miniprogram 举例：\n\n![miniprogram-action](/blog/images/mp-github-action/github-workflows.png)\n\n### 小程序版本关系\n\n小程序的有 3 种版本：开发版、体验版、正式版。体验版和正式版都只有一个，开发版可以有多个，对应的关系是这样的：\n\n![小程序版本关系](/blog/images/mp-github-action/miniprogram-version.png)\n\n这里需要特别提醒的一点是，**开发版是可以覆盖的，体验版的关系也会继承**。这里如何决定哪个版本覆盖哪个版本，取决于上传时的 CI 机器人编号，而开发者工具无法选择，因此开发者工具上传的开发版会一直覆盖。\n\n所以这个流水线的体验版可以自动覆盖，不需要手动选择，也是基于这个原理。\n\n## 自动预览\n\n由于 TDesign 小程序组件库的开发环境依赖许多编译工具，因此在验收开发者提交的 PR 时需要 `执行构建 - 打开开发者工具 - 点击预览` 一系列操作，才能开始扫码体验，较为繁琐。\n\n> 如果是设计师验收的话，还需要搭开发环境，非常不合理。\n\n另外更麻烦是，小程序的开发版二维码有时效限制（开发者工具显示时效 25 min）。因此没有办法像常规 Web 开发那样，在 PR 的各种检测相关流水通过之后构建出一个产物，后续随时可以验收。\n\n### Web 预览方案\n\n作为对比，可以先看一下 TDesign Web Vue 的 PR 流程：\n\n![TDesignWeb 预览流程](/blog/images/mp-github-action/tdesign-web-preview.png)\n\n可以看到每当 PR 创建或者同步时，都会触发构建官网，这样每次都能预览该 PR 最新的代码，用以验收。对应的预览评论如下：\n\n![web预览地址](/blog/images/mp-github-action/github-comment-1.png)\n\n### 小程序预览方案\n\n因为二维码的时效限制，所以小程序的预览不能直接借鉴 Web 的方式，只能在需要验收的时候再构建，这就需要一个触发构建的开关。\n\n我把这个开关定义成：**在 PR 上评论 “预览” 二字** 。\n\n以下是触发的过程：\n\n![小程序预览方案1](/blog/images/mp-github-action/github-comment-2.png)\n\n因为构建需要一定的时间，因此先通过 Comment 告知构建已在进行。等构建成功之后，就会用二维码将这个 Comment 替换掉。\n\n![小程序预览方案2](/blog/images/mp-github-action/github-comment-3.png)\n\n以上就是小程序预览方案的大体过程。\n\n不过在实现这个方案的时候也遇到了不少坑，这里也顺便分享一下。\n\n## GitHub Actions 避坑\n\n### 获取 PR 对应的代码\n\n因为这个功能使用的是 `issue_comment: created` 这个触发事件。因此需要判断这个 comment 是属于 PR ，并需要获取 Comment 对应的 PR 信息。\n\n判断 Comment 是否属于 PR 比较容易，判断这个环境变量是否存在即可：``${{ github.event.pull_request }}``。\n\n#### 获取 PR 信息\n\n但是，可能是因为触发事件的缘故，没法直接通过 ``${{ github.event.pull_request.head.sha }}`` 获取这个 PR 对应的 Commit SHA。\n\n通过搜索，发现了一个 Action 可以通过 GitHub 的 graphQL 获取对应 PR 的信息：[xt0rted/pull-request-comment-branch](https://github.com/xt0rted/pull-request-comment-branch)\n\n但是，这个 Action 又忽略了另外一个重要的问题：**PR 的 base branch 可能是 fork 的仓库**，它没有返回对应的仓库信息。因此我又基于这个 Action 封装了新的 Action：[LeeJim/pull-request-comment-branch](https://github.com/LeeJim/pull-request-comment-branch)\n\n至此，基于 [actions/checkout](https://github.com/actions/checkout) 和 [LeeJim/pull-request-comment-branch](https://github.com/LeeJim/pull-request-comment-branch) 才完成了指定评论对应的 PR 对应的代码克隆工作：\n\n```yml\n- uses: LeeJim/pull-request-comment-branch@main\n  id: comment-branch\n- uses: actions/checkout@v3\n  if: success()\n  with:\n    ref: ${{ steps.comment-branch.outputs.head_ref }}\n    repository: ${{ steps.comment-branch.outputs.head_repo_name_with_owner }}\n```\n\n### 小程序预览\n\n之前实现小程序发布的时候，因为各种问题也自己实现了一个 Action：[LeeJim/setup-miniprogram](https://github.com/LeeJim/setup-miniprogram)。\n\n因此本次就在这个 Action 的基础上，支持了预览的功能，返回了对应的预览二维码。\n\n### 给评论加图片\n\n因为小程序上传之后，可以选择返回 base64 或 jpg 格式的图片，为了避免图床的问题，因此我就想当然地选择 base64。后来才发现 GitHub 的 MarkDown 因为安全限制的问题，不支持 base64 的图片。因此我需要使用另外的图床。\n\n#### 腾讯云 COS\n\n此时，我的想法也很简单，直接使用腾讯云 COS 发布的 Action 上传就完事。结果在 GitHub 上找到的 Action 都是上传完不返回地址的。于是，我又需要创建\n一个新的 Action：[LeeJim/tencent-cos-action](https://github.com/LeeJim/tencent-cos-action)，将上传的地址返回。\n\n### 评论替换\n\n给指定 PR 添加 Comment 使用的 Action：[thollander/actions-comment-pull-request](https://github.com/thollander/actions-comment-pull-request)。\n\n该 Action 提供了 Comment 的功能，但我遇到的坑是文档和版本不一致。所以此刻就觉得 GitHub Actions 设计的巧妙且简单，当遇到问题的时候，可以直接去看对应的代码实现。\n\n替换的功能是通过 `comment_tag` 的参数来实现。原理也很简单，就是如果有传 `comment_tag` 的话，就会查找这个 PR 对应的所有 Comment 是否存在这个 tag，有的话就直接替换，没有就创建一个新的 Comment。\n\n这里有一个技巧就是：将这个 tag 通过 `<!-- ${{tag}} -->` 包装了，因此在 Comment 也看不到这个 tag。\n\n以下是 [TDesign Miniprogram](https://github.com/Tencent/tdesign-miniprogram/blob/develop/.github/workflows/preview.yml) 自动预览功能的完整实现：\n\n```yml\nname: PREVIEW\n\non:\n  issue_comment:\n    types: [created]\n\njobs:\n  request-preview:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'issue_comment' &amp;&amp; github.event.issue.pull_request &amp;&amp; github.event.comment.body == '预览'\n    steps:\n      - run: |\n          timestamp=$(date +%s)\n          echo \"timestamp=${timestamp}\" >> $GITHUB_OUTPUT\n        id: time\n      - name: Comment PR\n        uses: thollander/actions-comment-pull-request@v2\n        with:\n          message: |\n            正在构建预览的二维码，请稍等...\n          comment_tag: ${{steps.time.outputs.timestamp}}\n      - uses: LeeJim/pull-request-comment-branch@main\n        id: comment-branch\n      - uses: actions/checkout@v3\n        if: success()\n        with:\n          ref: ${{ steps.comment-branch.outputs.head_ref }}\n          repository: ${{ steps.comment-branch.outputs.head_repo_name_with_owner }}\n      - uses: ./.github/actions/install-dep\n      - run: npm run build\n        shell: bash\n      - name: get preview qrcode\n        id: preview\n        uses: LeeJim/setup-miniprogram@main\n        with:\n          project_type: miniProgram\n          action_type: preview\n          project_path: ./_example\n          es6: true\n          es7: true\n          minify: true\n        env:\n          MINI_APP_ID: ${{ secrets.TDESIGN_APP_ID }}\n          MINI_APP_PRIVATE_KEY: ${{ secrets.TDESIGN_MINI_KEY }}\n      - name: Upload qrcode to Tencent COS\n        uses: LeeJim/tencent-cos-action@main\n        id: cos\n        with:\n          secretId: ${{ secrets.TENCENT_COS_SECRET_ID }}\n          secretKey: ${{ secrets.TENCENT_COS_SECRET_KEY }}\n          bucket: mp-qrcode-1255404841\n          region: ap-guangzhou\n          content: ${{ steps.preview.outputs.preview-qrcode }}\n      - name: Comment PR\n        uses: thollander/actions-comment-pull-request@v2\n        with:\n          message: |\n            <img alt=\"qrcode\" src=\"${{ steps.cos.outputs.url }}\" width=\"256\" />\n          comment_tag: ${{steps.time.outputs.timestamp}}\n```\n\n\n> 最后提醒一下，GitHub Actions 对 Public 的仓库是没有 CI 运行累计时长的限制，而 Private 的仓库只能几千分钟的 CI 累计时长，这个需要注意。\n\n\n\n","slug":"wechat-miniprogarm-with-github-action","published":1,"updated":"2023-08-04T09:42:02.043Z","_id":"clkwcz2tx00026bsz9lxufojj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在微信小程序刚发布那会，要想做自动化，都必须有 hack 开发者工具的能力才能做到，而且在 Linux 系统没有开发者工具，需要使用 windows 或 macOS。好在微信也明白开发者的痛点，在小程序发布了 3 年之后的 2020 年提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html\">CI</a> 的能力。</p>\n<p>在 TDesign 正式开源的前半年，我们投入在自动化这些基础实施的人力比较多，可以分享的内容也挺多，这里主要分享小程序相关的自动化，并且是在 GitHub Actions 上的实现。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"自动上传体验版\"><a href=\"#自动上传体验版\" class=\"headerlink\" title=\"自动上传体验版\"></a>自动上传体验版</h2><p>在 TDesign 小程序组件库的开发中，比较早期做的CI 能力是自动上传体验版，我也封装了一个 GitHub Actions 可以直接使用：<a href=\"https://github.com/LeeJim/setup-miniprogram\">LeeJim/setup-miniprogram</a>。</p>\n<p>我们的发布流程是这样的：</p>\n<p><img src=\"/blog/images/mp-github-action/dev-flow.png\" alt=\"开发流程\"></p>\n<blockquote>\n<p>其中生成 CHANGELOG 也是发布的痛点，这个能力主要是 @lucaszzhou 实现的，后面他可能会分享了相关实现，我再补充下链接。大家可以期待一下。</p>\n</blockquote>\n<p>可以看到，整个发布流程，我只需要修改 package.json 的版本号，后面的流程几乎都是自动操作的。</p>\n<h3 id=\"上传密钥\"><a href=\"#上传密钥\" class=\"headerlink\" title=\"上传密钥\"></a>上传密钥</h3><p>其中，<strong>上传小程序</strong> 这块，需要有上传密钥，具体路径：<a href=\"https://mp.weixin.qq.com/\">微信公众平台</a> - 开发管理 - 开发设置 - 小程序代码上传密钥。</p>\n<p>由于密钥是敏感的信息，不能放在代码里明文展示，因此需要使用到 GitHub 的 secret。具体路径：Settings - Secrets - Actions - Repository secrets</p>\n<p><img src=\"/blog/images/mp-github-action/github-secrets.png\" alt=\"GitHub 密钥路径\"></p>\n<p>将在微信公众平台下载下来的密钥保存到这里，然后起一个对应的 secret name 即可。使用的时候，在 GitHub Actions 的 <code>yml</code> 文件里可以这样使用，以下以 tdesign-miniprogram 举例：</p>\n<p><img src=\"/blog/images/mp-github-action/github-workflows.png\" alt=\"miniprogram-action\"></p>\n<h3 id=\"小程序版本关系\"><a href=\"#小程序版本关系\" class=\"headerlink\" title=\"小程序版本关系\"></a>小程序版本关系</h3><p>小程序的有 3 种版本：开发版、体验版、正式版。体验版和正式版都只有一个，开发版可以有多个，对应的关系是这样的：</p>\n<p><img src=\"/blog/images/mp-github-action/miniprogram-version.png\" alt=\"小程序版本关系\"></p>\n<p>这里需要特别提醒的一点是，<strong>开发版是可以覆盖的，体验版的关系也会继承</strong>。这里如何决定哪个版本覆盖哪个版本，取决于上传时的 CI 机器人编号，而开发者工具无法选择，因此开发者工具上传的开发版会一直覆盖。</p>\n<p>所以这个流水线的体验版可以自动覆盖，不需要手动选择，也是基于这个原理。</p>\n<h2 id=\"自动预览\"><a href=\"#自动预览\" class=\"headerlink\" title=\"自动预览\"></a>自动预览</h2><p>由于 TDesign 小程序组件库的开发环境依赖许多编译工具，因此在验收开发者提交的 PR 时需要 <code>执行构建 - 打开开发者工具 - 点击预览</code> 一系列操作，才能开始扫码体验，较为繁琐。</p>\n<blockquote>\n<p>如果是设计师验收的话，还需要搭开发环境，非常不合理。</p>\n</blockquote>\n<p>另外更麻烦是，小程序的开发版二维码有时效限制（开发者工具显示时效 25 min）。因此没有办法像常规 Web 开发那样，在 PR 的各种检测相关流水通过之后构建出一个产物，后续随时可以验收。</p>\n<h3 id=\"Web-预览方案\"><a href=\"#Web-预览方案\" class=\"headerlink\" title=\"Web 预览方案\"></a>Web 预览方案</h3><p>作为对比，可以先看一下 TDesign Web Vue 的 PR 流程：</p>\n<p><img src=\"/blog/images/mp-github-action/tdesign-web-preview.png\" alt=\"TDesignWeb 预览流程\"></p>\n<p>可以看到每当 PR 创建或者同步时，都会触发构建官网，这样每次都能预览该 PR 最新的代码，用以验收。对应的预览评论如下：</p>\n<p><img src=\"/blog/images/mp-github-action/github-comment-1.png\" alt=\"web预览地址\"></p>\n<h3 id=\"小程序预览方案\"><a href=\"#小程序预览方案\" class=\"headerlink\" title=\"小程序预览方案\"></a>小程序预览方案</h3><p>因为二维码的时效限制，所以小程序的预览不能直接借鉴 Web 的方式，只能在需要验收的时候再构建，这就需要一个触发构建的开关。</p>\n<p>我把这个开关定义成：<strong>在 PR 上评论 “预览” 二字</strong> 。</p>\n<p>以下是触发的过程：</p>\n<p><img src=\"/blog/images/mp-github-action/github-comment-2.png\" alt=\"小程序预览方案1\"></p>\n<p>因为构建需要一定的时间，因此先通过 Comment 告知构建已在进行。等构建成功之后，就会用二维码将这个 Comment 替换掉。</p>\n<p><img src=\"/blog/images/mp-github-action/github-comment-3.png\" alt=\"小程序预览方案2\"></p>\n<p>以上就是小程序预览方案的大体过程。</p>\n<p>不过在实现这个方案的时候也遇到了不少坑，这里也顺便分享一下。</p>\n<h2 id=\"GitHub-Actions-避坑\"><a href=\"#GitHub-Actions-避坑\" class=\"headerlink\" title=\"GitHub Actions 避坑\"></a>GitHub Actions 避坑</h2><h3 id=\"获取-PR-对应的代码\"><a href=\"#获取-PR-对应的代码\" class=\"headerlink\" title=\"获取 PR 对应的代码\"></a>获取 PR 对应的代码</h3><p>因为这个功能使用的是 <code>issue_comment: created</code> 这个触发事件。因此需要判断这个 comment 是属于 PR ，并需要获取 Comment 对应的 PR 信息。</p>\n<p>判断 Comment 是否属于 PR 比较容易，判断这个环境变量是否存在即可：<code>$&#123;&#123; github.event.pull_request &#125;&#125;</code>。</p>\n<h4 id=\"获取-PR-信息\"><a href=\"#获取-PR-信息\" class=\"headerlink\" title=\"获取 PR 信息\"></a>获取 PR 信息</h4><p>但是，可能是因为触发事件的缘故，没法直接通过 <code>$&#123;&#123; github.event.pull_request.head.sha &#125;&#125;</code> 获取这个 PR 对应的 Commit SHA。</p>\n<p>通过搜索，发现了一个 Action 可以通过 GitHub 的 graphQL 获取对应 PR 的信息：<a href=\"https://github.com/xt0rted/pull-request-comment-branch\">xt0rted/pull-request-comment-branch</a></p>\n<p>但是，这个 Action 又忽略了另外一个重要的问题：<strong>PR 的 base branch 可能是 fork 的仓库</strong>，它没有返回对应的仓库信息。因此我又基于这个 Action 封装了新的 Action：<a href=\"https://github.com/LeeJim/pull-request-comment-branch\">LeeJim/pull-request-comment-branch</a></p>\n<p>至此，基于 <a href=\"https://github.com/actions/checkout\">actions/checkout</a> 和 <a href=\"https://github.com/LeeJim/pull-request-comment-branch\">LeeJim/pull-request-comment-branch</a> 才完成了指定评论对应的 PR 对应的代码克隆工作：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/pull-request-comment-branch@main</span></span><br><span class=\"line\">  <span class=\"attr\">id:</span> <span class=\"string\">comment-branch</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span></span><br><span class=\"line\">  <span class=\"attr\">if:</span> <span class=\"string\">success()</span></span><br><span class=\"line\">  <span class=\"attr\">with:</span></span><br><span class=\"line\">    <span class=\"attr\">ref:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_ref</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_repo_name_with_owner</span> <span class=\"string\">&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小程序预览\"><a href=\"#小程序预览\" class=\"headerlink\" title=\"小程序预览\"></a>小程序预览</h3><p>之前实现小程序发布的时候，因为各种问题也自己实现了一个 Action：<a href=\"https://github.com/LeeJim/setup-miniprogram\">LeeJim/setup-miniprogram</a>。</p>\n<p>因此本次就在这个 Action 的基础上，支持了预览的功能，返回了对应的预览二维码。</p>\n<h3 id=\"给评论加图片\"><a href=\"#给评论加图片\" class=\"headerlink\" title=\"给评论加图片\"></a>给评论加图片</h3><p>因为小程序上传之后，可以选择返回 base64 或 jpg 格式的图片，为了避免图床的问题，因此我就想当然地选择 base64。后来才发现 GitHub 的 MarkDown 因为安全限制的问题，不支持 base64 的图片。因此我需要使用另外的图床。</p>\n<h4 id=\"腾讯云-COS\"><a href=\"#腾讯云-COS\" class=\"headerlink\" title=\"腾讯云 COS\"></a>腾讯云 COS</h4><p>此时，我的想法也很简单，直接使用腾讯云 COS 发布的 Action 上传就完事。结果在 GitHub 上找到的 Action 都是上传完不返回地址的。于是，我又需要创建<br>一个新的 Action：<a href=\"https://github.com/LeeJim/tencent-cos-action\">LeeJim/tencent-cos-action</a>，将上传的地址返回。</p>\n<h3 id=\"评论替换\"><a href=\"#评论替换\" class=\"headerlink\" title=\"评论替换\"></a>评论替换</h3><p>给指定 PR 添加 Comment 使用的 Action：<a href=\"https://github.com/thollander/actions-comment-pull-request\">thollander/actions-comment-pull-request</a>。</p>\n<p>该 Action 提供了 Comment 的功能，但我遇到的坑是文档和版本不一致。所以此刻就觉得 GitHub Actions 设计的巧妙且简单，当遇到问题的时候，可以直接去看对应的代码实现。</p>\n<p>替换的功能是通过 <code>comment_tag</code> 的参数来实现。原理也很简单，就是如果有传 <code>comment_tag</code> 的话，就会查找这个 PR 对应的所有 Comment 是否存在这个 tag，有的话就直接替换，没有就创建一个新的 Comment。</p>\n<p>这里有一个技巧就是：将这个 tag 通过 <code>&lt;!-- $&#123;&#123;tag&#125;&#125; --&gt;</code> 包装了，因此在 Comment 也看不到这个 tag。</p>\n<p>以下是 <a href=\"https://github.com/Tencent/tdesign-miniprogram/blob/develop/.github/workflows/preview.yml\">TDesign Miniprogram</a> 自动预览功能的完整实现：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">PREVIEW</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">issue_comment:</span></span><br><span class=\"line\">    <span class=\"attr\">types:</span> [<span class=\"string\">created</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">request-preview:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">if:</span> <span class=\"string\">github.event_name</span> <span class=\"string\">==</span> <span class=\"string\">&#x27;issue_comment&#x27;</span> <span class=\"string\">&amp;amp;&amp;amp;</span> <span class=\"string\">github.event.issue.pull_request</span> <span class=\"string\">&amp;amp;&amp;amp;</span> <span class=\"string\">github.event.comment.body</span> <span class=\"string\">==</span> <span class=\"string\">&#x27;预览&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          timestamp=$(date +%s)</span></span><br><span class=\"line\"><span class=\"string\">          echo &quot;timestamp=$&#123;timestamp&#125;&quot; &gt;&gt; $GITHUB_OUTPUT</span></span><br><span class=\"line\"><span class=\"string\"></span>        <span class=\"attr\">id:</span> <span class=\"string\">time</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Comment</span> <span class=\"string\">PR</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">thollander/actions-comment-pull-request@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">message:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            正在构建预览的二维码，请稍等...</span></span><br><span class=\"line\"><span class=\"string\"></span>          <span class=\"attr\">comment_tag:</span> <span class=\"string\">$&#123;&#123;steps.time.outputs.timestamp&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/pull-request-comment-branch@main</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">comment-branch</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span></span><br><span class=\"line\">        <span class=\"attr\">if:</span> <span class=\"string\">success()</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">ref:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_ref</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">repository:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_repo_name_with_owner</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">./.github/actions/install-dep</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">        <span class=\"attr\">shell:</span> <span class=\"string\">bash</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">get</span> <span class=\"string\">preview</span> <span class=\"string\">qrcode</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">preview</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/setup-miniprogram@main</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">project_type:</span> <span class=\"string\">miniProgram</span></span><br><span class=\"line\">          <span class=\"attr\">action_type:</span> <span class=\"string\">preview</span></span><br><span class=\"line\">          <span class=\"attr\">project_path:</span> <span class=\"string\">./_example</span></span><br><span class=\"line\">          <span class=\"attr\">es6:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">es7:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">minify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">MINI_APP_ID:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TDESIGN_APP_ID</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">MINI_APP_PRIVATE_KEY:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TDESIGN_MINI_KEY</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">qrcode</span> <span class=\"string\">to</span> <span class=\"string\">Tencent</span> <span class=\"string\">COS</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/tencent-cos-action@main</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">cos</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">secretId:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TENCENT_COS_SECRET_ID</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">secretKey:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TENCENT_COS_SECRET_KEY</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">bucket:</span> <span class=\"string\">mp-qrcode-1255404841</span></span><br><span class=\"line\">          <span class=\"attr\">region:</span> <span class=\"string\">ap-guangzhou</span></span><br><span class=\"line\">          <span class=\"attr\">content:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.preview.outputs.preview-qrcode</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Comment</span> <span class=\"string\">PR</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">thollander/actions-comment-pull-request@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">message:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            &lt;img alt=&quot;qrcode&quot; src=&quot;$&#123;&#123; steps.cos.outputs.url &#125;&#125;&quot; width=&quot;256&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span>          <span class=\"attr\">comment_tag:</span> <span class=\"string\">$&#123;&#123;steps.time.outputs.timestamp&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>最后提醒一下，GitHub Actions 对 Public 的仓库是没有 CI 运行累计时长的限制，而 Private 的仓库只能几千分钟的 CI 累计时长，这个需要注意。</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>在微信小程序刚发布那会，要想做自动化，都必须有 hack 开发者工具的能力才能做到，而且在 Linux 系统没有开发者工具，需要使用 windows 或 macOS。好在微信也明白开发者的痛点，在小程序发布了 3 年之后的 2020 年提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/ci.html\">CI</a> 的能力。</p>\n<p>在 TDesign 正式开源的前半年，我们投入在自动化这些基础实施的人力比较多，可以分享的内容也挺多，这里主要分享小程序相关的自动化，并且是在 GitHub Actions 上的实现。</p>","more":"<h2 id=\"自动上传体验版\"><a href=\"#自动上传体验版\" class=\"headerlink\" title=\"自动上传体验版\"></a>自动上传体验版</h2><p>在 TDesign 小程序组件库的开发中，比较早期做的CI 能力是自动上传体验版，我也封装了一个 GitHub Actions 可以直接使用：<a href=\"https://github.com/LeeJim/setup-miniprogram\">LeeJim/setup-miniprogram</a>。</p>\n<p>我们的发布流程是这样的：</p>\n<p><img src=\"/blog/images/mp-github-action/dev-flow.png\" alt=\"开发流程\"></p>\n<blockquote>\n<p>其中生成 CHANGELOG 也是发布的痛点，这个能力主要是 @lucaszzhou 实现的，后面他可能会分享了相关实现，我再补充下链接。大家可以期待一下。</p>\n</blockquote>\n<p>可以看到，整个发布流程，我只需要修改 package.json 的版本号，后面的流程几乎都是自动操作的。</p>\n<h3 id=\"上传密钥\"><a href=\"#上传密钥\" class=\"headerlink\" title=\"上传密钥\"></a>上传密钥</h3><p>其中，<strong>上传小程序</strong> 这块，需要有上传密钥，具体路径：<a href=\"https://mp.weixin.qq.com/\">微信公众平台</a> - 开发管理 - 开发设置 - 小程序代码上传密钥。</p>\n<p>由于密钥是敏感的信息，不能放在代码里明文展示，因此需要使用到 GitHub 的 secret。具体路径：Settings - Secrets - Actions - Repository secrets</p>\n<p><img src=\"/blog/images/mp-github-action/github-secrets.png\" alt=\"GitHub 密钥路径\"></p>\n<p>将在微信公众平台下载下来的密钥保存到这里，然后起一个对应的 secret name 即可。使用的时候，在 GitHub Actions 的 <code>yml</code> 文件里可以这样使用，以下以 tdesign-miniprogram 举例：</p>\n<p><img src=\"/blog/images/mp-github-action/github-workflows.png\" alt=\"miniprogram-action\"></p>\n<h3 id=\"小程序版本关系\"><a href=\"#小程序版本关系\" class=\"headerlink\" title=\"小程序版本关系\"></a>小程序版本关系</h3><p>小程序的有 3 种版本：开发版、体验版、正式版。体验版和正式版都只有一个，开发版可以有多个，对应的关系是这样的：</p>\n<p><img src=\"/blog/images/mp-github-action/miniprogram-version.png\" alt=\"小程序版本关系\"></p>\n<p>这里需要特别提醒的一点是，<strong>开发版是可以覆盖的，体验版的关系也会继承</strong>。这里如何决定哪个版本覆盖哪个版本，取决于上传时的 CI 机器人编号，而开发者工具无法选择，因此开发者工具上传的开发版会一直覆盖。</p>\n<p>所以这个流水线的体验版可以自动覆盖，不需要手动选择，也是基于这个原理。</p>\n<h2 id=\"自动预览\"><a href=\"#自动预览\" class=\"headerlink\" title=\"自动预览\"></a>自动预览</h2><p>由于 TDesign 小程序组件库的开发环境依赖许多编译工具，因此在验收开发者提交的 PR 时需要 <code>执行构建 - 打开开发者工具 - 点击预览</code> 一系列操作，才能开始扫码体验，较为繁琐。</p>\n<blockquote>\n<p>如果是设计师验收的话，还需要搭开发环境，非常不合理。</p>\n</blockquote>\n<p>另外更麻烦是，小程序的开发版二维码有时效限制（开发者工具显示时效 25 min）。因此没有办法像常规 Web 开发那样，在 PR 的各种检测相关流水通过之后构建出一个产物，后续随时可以验收。</p>\n<h3 id=\"Web-预览方案\"><a href=\"#Web-预览方案\" class=\"headerlink\" title=\"Web 预览方案\"></a>Web 预览方案</h3><p>作为对比，可以先看一下 TDesign Web Vue 的 PR 流程：</p>\n<p><img src=\"/blog/images/mp-github-action/tdesign-web-preview.png\" alt=\"TDesignWeb 预览流程\"></p>\n<p>可以看到每当 PR 创建或者同步时，都会触发构建官网，这样每次都能预览该 PR 最新的代码，用以验收。对应的预览评论如下：</p>\n<p><img src=\"/blog/images/mp-github-action/github-comment-1.png\" alt=\"web预览地址\"></p>\n<h3 id=\"小程序预览方案\"><a href=\"#小程序预览方案\" class=\"headerlink\" title=\"小程序预览方案\"></a>小程序预览方案</h3><p>因为二维码的时效限制，所以小程序的预览不能直接借鉴 Web 的方式，只能在需要验收的时候再构建，这就需要一个触发构建的开关。</p>\n<p>我把这个开关定义成：<strong>在 PR 上评论 “预览” 二字</strong> 。</p>\n<p>以下是触发的过程：</p>\n<p><img src=\"/blog/images/mp-github-action/github-comment-2.png\" alt=\"小程序预览方案1\"></p>\n<p>因为构建需要一定的时间，因此先通过 Comment 告知构建已在进行。等构建成功之后，就会用二维码将这个 Comment 替换掉。</p>\n<p><img src=\"/blog/images/mp-github-action/github-comment-3.png\" alt=\"小程序预览方案2\"></p>\n<p>以上就是小程序预览方案的大体过程。</p>\n<p>不过在实现这个方案的时候也遇到了不少坑，这里也顺便分享一下。</p>\n<h2 id=\"GitHub-Actions-避坑\"><a href=\"#GitHub-Actions-避坑\" class=\"headerlink\" title=\"GitHub Actions 避坑\"></a>GitHub Actions 避坑</h2><h3 id=\"获取-PR-对应的代码\"><a href=\"#获取-PR-对应的代码\" class=\"headerlink\" title=\"获取 PR 对应的代码\"></a>获取 PR 对应的代码</h3><p>因为这个功能使用的是 <code>issue_comment: created</code> 这个触发事件。因此需要判断这个 comment 是属于 PR ，并需要获取 Comment 对应的 PR 信息。</p>\n<p>判断 Comment 是否属于 PR 比较容易，判断这个环境变量是否存在即可：<code>$&#123;&#123; github.event.pull_request &#125;&#125;</code>。</p>\n<h4 id=\"获取-PR-信息\"><a href=\"#获取-PR-信息\" class=\"headerlink\" title=\"获取 PR 信息\"></a>获取 PR 信息</h4><p>但是，可能是因为触发事件的缘故，没法直接通过 <code>$&#123;&#123; github.event.pull_request.head.sha &#125;&#125;</code> 获取这个 PR 对应的 Commit SHA。</p>\n<p>通过搜索，发现了一个 Action 可以通过 GitHub 的 graphQL 获取对应 PR 的信息：<a href=\"https://github.com/xt0rted/pull-request-comment-branch\">xt0rted/pull-request-comment-branch</a></p>\n<p>但是，这个 Action 又忽略了另外一个重要的问题：<strong>PR 的 base branch 可能是 fork 的仓库</strong>，它没有返回对应的仓库信息。因此我又基于这个 Action 封装了新的 Action：<a href=\"https://github.com/LeeJim/pull-request-comment-branch\">LeeJim/pull-request-comment-branch</a></p>\n<p>至此，基于 <a href=\"https://github.com/actions/checkout\">actions/checkout</a> 和 <a href=\"https://github.com/LeeJim/pull-request-comment-branch\">LeeJim/pull-request-comment-branch</a> 才完成了指定评论对应的 PR 对应的代码克隆工作：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/pull-request-comment-branch@main</span></span><br><span class=\"line\">  <span class=\"attr\">id:</span> <span class=\"string\">comment-branch</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span></span><br><span class=\"line\">  <span class=\"attr\">if:</span> <span class=\"string\">success()</span></span><br><span class=\"line\">  <span class=\"attr\">with:</span></span><br><span class=\"line\">    <span class=\"attr\">ref:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_ref</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_repo_name_with_owner</span> <span class=\"string\">&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小程序预览\"><a href=\"#小程序预览\" class=\"headerlink\" title=\"小程序预览\"></a>小程序预览</h3><p>之前实现小程序发布的时候，因为各种问题也自己实现了一个 Action：<a href=\"https://github.com/LeeJim/setup-miniprogram\">LeeJim/setup-miniprogram</a>。</p>\n<p>因此本次就在这个 Action 的基础上，支持了预览的功能，返回了对应的预览二维码。</p>\n<h3 id=\"给评论加图片\"><a href=\"#给评论加图片\" class=\"headerlink\" title=\"给评论加图片\"></a>给评论加图片</h3><p>因为小程序上传之后，可以选择返回 base64 或 jpg 格式的图片，为了避免图床的问题，因此我就想当然地选择 base64。后来才发现 GitHub 的 MarkDown 因为安全限制的问题，不支持 base64 的图片。因此我需要使用另外的图床。</p>\n<h4 id=\"腾讯云-COS\"><a href=\"#腾讯云-COS\" class=\"headerlink\" title=\"腾讯云 COS\"></a>腾讯云 COS</h4><p>此时，我的想法也很简单，直接使用腾讯云 COS 发布的 Action 上传就完事。结果在 GitHub 上找到的 Action 都是上传完不返回地址的。于是，我又需要创建<br>一个新的 Action：<a href=\"https://github.com/LeeJim/tencent-cos-action\">LeeJim/tencent-cos-action</a>，将上传的地址返回。</p>\n<h3 id=\"评论替换\"><a href=\"#评论替换\" class=\"headerlink\" title=\"评论替换\"></a>评论替换</h3><p>给指定 PR 添加 Comment 使用的 Action：<a href=\"https://github.com/thollander/actions-comment-pull-request\">thollander/actions-comment-pull-request</a>。</p>\n<p>该 Action 提供了 Comment 的功能，但我遇到的坑是文档和版本不一致。所以此刻就觉得 GitHub Actions 设计的巧妙且简单，当遇到问题的时候，可以直接去看对应的代码实现。</p>\n<p>替换的功能是通过 <code>comment_tag</code> 的参数来实现。原理也很简单，就是如果有传 <code>comment_tag</code> 的话，就会查找这个 PR 对应的所有 Comment 是否存在这个 tag，有的话就直接替换，没有就创建一个新的 Comment。</p>\n<p>这里有一个技巧就是：将这个 tag 通过 <code>&lt;!-- $&#123;&#123;tag&#125;&#125; --&gt;</code> 包装了，因此在 Comment 也看不到这个 tag。</p>\n<p>以下是 <a href=\"https://github.com/Tencent/tdesign-miniprogram/blob/develop/.github/workflows/preview.yml\">TDesign Miniprogram</a> 自动预览功能的完整实现：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">PREVIEW</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">issue_comment:</span></span><br><span class=\"line\">    <span class=\"attr\">types:</span> [<span class=\"string\">created</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">request-preview:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">if:</span> <span class=\"string\">github.event_name</span> <span class=\"string\">==</span> <span class=\"string\">&#x27;issue_comment&#x27;</span> <span class=\"string\">&amp;amp;&amp;amp;</span> <span class=\"string\">github.event.issue.pull_request</span> <span class=\"string\">&amp;amp;&amp;amp;</span> <span class=\"string\">github.event.comment.body</span> <span class=\"string\">==</span> <span class=\"string\">&#x27;预览&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          timestamp=$(date +%s)</span></span><br><span class=\"line\"><span class=\"string\">          echo &quot;timestamp=$&#123;timestamp&#125;&quot; &gt;&gt; $GITHUB_OUTPUT</span></span><br><span class=\"line\"><span class=\"string\"></span>        <span class=\"attr\">id:</span> <span class=\"string\">time</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Comment</span> <span class=\"string\">PR</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">thollander/actions-comment-pull-request@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">message:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            正在构建预览的二维码，请稍等...</span></span><br><span class=\"line\"><span class=\"string\"></span>          <span class=\"attr\">comment_tag:</span> <span class=\"string\">$&#123;&#123;steps.time.outputs.timestamp&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/pull-request-comment-branch@main</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">comment-branch</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span></span><br><span class=\"line\">        <span class=\"attr\">if:</span> <span class=\"string\">success()</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">ref:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_ref</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">repository:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.comment-branch.outputs.head_repo_name_with_owner</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">uses:</span> <span class=\"string\">./.github/actions/install-dep</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">run:</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">        <span class=\"attr\">shell:</span> <span class=\"string\">bash</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">get</span> <span class=\"string\">preview</span> <span class=\"string\">qrcode</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">preview</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/setup-miniprogram@main</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">project_type:</span> <span class=\"string\">miniProgram</span></span><br><span class=\"line\">          <span class=\"attr\">action_type:</span> <span class=\"string\">preview</span></span><br><span class=\"line\">          <span class=\"attr\">project_path:</span> <span class=\"string\">./_example</span></span><br><span class=\"line\">          <span class=\"attr\">es6:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">es7:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">minify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">MINI_APP_ID:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TDESIGN_APP_ID</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">MINI_APP_PRIVATE_KEY:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TDESIGN_MINI_KEY</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">qrcode</span> <span class=\"string\">to</span> <span class=\"string\">Tencent</span> <span class=\"string\">COS</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">LeeJim/tencent-cos-action@main</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">cos</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">secretId:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TENCENT_COS_SECRET_ID</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">secretKey:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.TENCENT_COS_SECRET_KEY</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">bucket:</span> <span class=\"string\">mp-qrcode-1255404841</span></span><br><span class=\"line\">          <span class=\"attr\">region:</span> <span class=\"string\">ap-guangzhou</span></span><br><span class=\"line\">          <span class=\"attr\">content:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.preview.outputs.preview-qrcode</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Comment</span> <span class=\"string\">PR</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">thollander/actions-comment-pull-request@v2</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">message:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">            &lt;img alt=&quot;qrcode&quot; src=&quot;$&#123;&#123; steps.cos.outputs.url &#125;&#125;&quot; width=&quot;256&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span>          <span class=\"attr\">comment_tag:</span> <span class=\"string\">$&#123;&#123;steps.time.outputs.timestamp&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>最后提醒一下，GitHub Actions 对 Public 的仓库是没有 CI 运行累计时长的限制，而 Private 的仓库只能几千分钟的 CI 累计时长，这个需要注意。</p>\n</blockquote>"},{"title":"关于 Vue3 的 Proxy 引起的问题","date":"2021-05-28T09:43:34.000Z","_content":"\nVue3 是 Vuejs 新出的 3.0 版本，性能以及代码可维护性都提升了许多，也解决了许多 Vue2 中使用不便的地方。\n此外，由于使用了 Proxy 来实现 Reactivity，所以对客户端的要求也就更高了，但总的来说，Vue3 的普及是势不可挡的。\n\nTDesign 是汇集了公司多个 Oteam 的结晶，包括了多种框架多种终端的组件。\n\n其中，Tree 可以说是组件库里最复杂的组件了，可以说是没有之一。\n\n这次分享的内容是在我将 Tree 由 Vue2 迁移至 Vue3 过程中遇到的问题、分析过程以及最终的解决方案。\n\n<!-- more -->\n\n## 迁移策略\n\n从 Vue2 升级至 Vue3，可以从官方的 [《Migration Guide》](https://v3.vuejs.org/guide/migration/introduction.html)可以看到了解到底有哪些 breaking changes。\n\n升级的最小成本就是将 breaking changes 修复即可。\n\n至于其他更好用的特性（如 `Composition API`、`Fragments` 等），属于非必需特性，可以放在后置再进行优化。其中的缘由是因为 Vue2 也在高速运转中，仍处于不稳定的状态，不对代码进行较大改动是为了之后可以方便地同步 Vue2 最新的代码。\n\n## Vue3\n\nVue 的核心模块有三个：Reactivity Module、Compiler Module、Renderer Module。\n\n![Vue 核心模块](/blog/images/vue3/vue-core-modules.png)\n\n其中，Compiler Module 是将 template 转换成 render function，日常开发不会遇到问题。\n\n而 Reactivity Module 则从 `Object.defineProperty` 升级成 `Proxy` 的形式实现，会存在原理上的不同，导致代码的实现思路也会受影响。在较复杂逻辑中比较容易出现问题。\n\nRenderer Module 则是核心的渲染逻辑。问题常出现在 Patch 阶段，需要了解其中的 diff 算法。\n\n## 代码结构\n\n在开始迁移之前，先了解了一下 Tree 的代码结构：\n```\n- common\n  - tree-store.ts\n  - tree-node.ts\n- src\n  - tree\n    - td-tree.tsx\n    - tree-item.tsx\n```\n> common里面的代码是tree的公共逻辑，会在多个框架多个终端之间共享。\n\n数据的流动：\n\n![TDesign 树的数据流动](/blog/images/vue3/tree-data-flow.png)\n\n# 状况百出\n## 渲染死循环\n\n通过断点发现，在不断地渲染 `td-tree`，其中就卡在 patchChildren 的逻辑：`vue-next/packages/runder-core/src/renderer.ts:1771`，下面是我摘选的部分代码：\n\n```js\nwhile (i <= e1 && i <= e2) {\n      const n1 = c1[i]\n      const n2 = (c2[i] = optimized\n        ? cloneIfMounted(c2[i] as VNode)\n        : normalizeVNode(c2[i]))\n\t\t//...\n}\n```\n这是一个简单的数组赋值，为什么在 Vue2 正常运行，而在 Vue3 则发生了死循环呢？\n\n是因为我们 `td-tree` 的渲染函数是这样的：\n\n```js\nexport default defineComponent({\n  //...\n  render() {\n    const { TreeNodes } = this;\n    return (<transition-group>{TreeNodes}</transition-group>);\n  }\t\n})\n```\n而 `TreeNodes` 则是 `TreeItem` 实例的集合：\n\n```js\nthis.treeNodes.push(<TreeItem\n      key={node.value}\n      node={node}\n      treeScope={treeScope}\n      onClick={this.handleClick}\n      onChange={this.handleChange}\n/>))\n```\n\n所以，在 patch 的时候，对当前 VNode Child 进行了替换。\n\n由于Vue3使用了 `Proxy` 而不再是Vue2的 `Object.defineProperty`，因此通过数组的下标进行赋值也会被监听到，自然就又重新进入了渲染流程，最终导致了渲染死循环。\n\n解决办法：避免使用 VNode 数组。\n\n在当前的组件里，就是将 `treeNodes` 的元素改成 `node`，而不是 `tree-item` 的 `VNode`。\n\n最终 `td-tree` 的渲染函数是这样的：\n\n```js\nexport default defineComponent({\n  //...\n  render() {\n    const { TreeNodes } = this;\n    return (<transition-group>\n      {TreeNodes.map(node => this.renderItem(node))}\n    </transition-group>);\n  }\t\n})\n```\n\n## 数据变更不渲染\n\n为了实现多框架之间可以实现逻辑复用，所以 `tree` 的很多复杂逻辑计算都被封装在一个公共模块里。\n\n而其中 `tree-item` 的很多逻辑存在于 `common/tree-node.ts` 里面。\n\n按理说，Vue2 运行正常的情况下，我只需要改动 Vue3 的 breaking changes 的地方，其他逻辑我是不需要改动的。而且由于公共模块的部分是多框架复用的，所以我是不应该改动这部分的，除非 Vue2 同样存在问题。\n\n诡异的情况发生了，在测试 [异步加载节点](http://tdesign.woa.com/vue/components/tree#18-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E8%8A%82%E7%82%B9) 的 case 的时候，发现 `loading` 的 `icon` 一直不会消失。\n\n于是我开始梳理各种 `tree` 的渲染逻辑，最后通过数据的追踪，发现其实当前的 `node` 的 `loading` 值已经变成了 `false`，只是`tree-item`的 render 没有被触发而已。\n\n表面的原因发现了，但深层的原因是为什么呢？\n\n其实，这又是 Vue3 和 Vue2 的响应式实现的差异引起的问题。\n\n在 Vue2 中，每个被当作 `property` 传到组件的值，会通过 `Object.defineProperty` 来对每个 `key` 设置 `getter` 和 `setter`。\n\n以当前的组件举例：\n\n```html\n<tree-item :node=\"node\" />\n```\n\n我们将 `node` 当作 `property` 传给 `tree-item` 的时候，Vue 就将 `node` 的每个 `key` 设置了 `getter` 和 `setter`，其中关键的是 `setter`，如果改变了`node` 的任意属性值，就会触发了 `setter` 与此同时就会对当前这个 `tree-item` 进行渲染。\n\n而在 Vue3 中，由于`Object.definedProperty` 的各种局限，所以采用了更先进的 `Proxy` 来实现响应式。\n\n这也就带了问题。`Proxy` 的机制要求我们访问 **代理对象** 而不是源对象，但由于 `tree` 的封装设计，只会在源对象上进行属性值变更，也就不会触发`tree-item`的渲染了。\n\n找到了核心问题，解决思路有很多种：\n\n1. 让公共部分的逻辑在 **代理对象** 上进行，而不是源对象（不能因为版本的差异去影响公共逻辑，所以这个方案 pass）\n2. `tree-item` 不再使用 `tree-store` 返回的 `node`，而是新的 `Object`。在 `tree-store` 触发 `update` 时，再将 `node` 的每个 `key` 值进行比较，逐个`update`，同时也就可以触发渲染了。\n\n# 总结\n\n上面遇到的两个问题都是由 `Vue3` 的 `Reactivity` 机制变更导致的，均不是 `Migration Guide` 里有提到的 `breaking changes`，都属于 Vue3 的核心实现机制的改变。\n\n因此，要想顺利完成 Vue2 到 Vue3 的升级，最好是能理解核心思想的改变，以及能熟悉框架的源码。","source":"_posts/vue3-on-tdesign.md","raw":"---\ntitle: 关于 Vue3 的 Proxy 引起的问题\ndate: 2021-5-28 17:43:34\ntags:\ncategories:\n- vue\n---\n\nVue3 是 Vuejs 新出的 3.0 版本，性能以及代码可维护性都提升了许多，也解决了许多 Vue2 中使用不便的地方。\n此外，由于使用了 Proxy 来实现 Reactivity，所以对客户端的要求也就更高了，但总的来说，Vue3 的普及是势不可挡的。\n\nTDesign 是汇集了公司多个 Oteam 的结晶，包括了多种框架多种终端的组件。\n\n其中，Tree 可以说是组件库里最复杂的组件了，可以说是没有之一。\n\n这次分享的内容是在我将 Tree 由 Vue2 迁移至 Vue3 过程中遇到的问题、分析过程以及最终的解决方案。\n\n<!-- more -->\n\n## 迁移策略\n\n从 Vue2 升级至 Vue3，可以从官方的 [《Migration Guide》](https://v3.vuejs.org/guide/migration/introduction.html)可以看到了解到底有哪些 breaking changes。\n\n升级的最小成本就是将 breaking changes 修复即可。\n\n至于其他更好用的特性（如 `Composition API`、`Fragments` 等），属于非必需特性，可以放在后置再进行优化。其中的缘由是因为 Vue2 也在高速运转中，仍处于不稳定的状态，不对代码进行较大改动是为了之后可以方便地同步 Vue2 最新的代码。\n\n## Vue3\n\nVue 的核心模块有三个：Reactivity Module、Compiler Module、Renderer Module。\n\n![Vue 核心模块](/blog/images/vue3/vue-core-modules.png)\n\n其中，Compiler Module 是将 template 转换成 render function，日常开发不会遇到问题。\n\n而 Reactivity Module 则从 `Object.defineProperty` 升级成 `Proxy` 的形式实现，会存在原理上的不同，导致代码的实现思路也会受影响。在较复杂逻辑中比较容易出现问题。\n\nRenderer Module 则是核心的渲染逻辑。问题常出现在 Patch 阶段，需要了解其中的 diff 算法。\n\n## 代码结构\n\n在开始迁移之前，先了解了一下 Tree 的代码结构：\n```\n- common\n  - tree-store.ts\n  - tree-node.ts\n- src\n  - tree\n    - td-tree.tsx\n    - tree-item.tsx\n```\n> common里面的代码是tree的公共逻辑，会在多个框架多个终端之间共享。\n\n数据的流动：\n\n![TDesign 树的数据流动](/blog/images/vue3/tree-data-flow.png)\n\n# 状况百出\n## 渲染死循环\n\n通过断点发现，在不断地渲染 `td-tree`，其中就卡在 patchChildren 的逻辑：`vue-next/packages/runder-core/src/renderer.ts:1771`，下面是我摘选的部分代码：\n\n```js\nwhile (i <= e1 && i <= e2) {\n      const n1 = c1[i]\n      const n2 = (c2[i] = optimized\n        ? cloneIfMounted(c2[i] as VNode)\n        : normalizeVNode(c2[i]))\n\t\t//...\n}\n```\n这是一个简单的数组赋值，为什么在 Vue2 正常运行，而在 Vue3 则发生了死循环呢？\n\n是因为我们 `td-tree` 的渲染函数是这样的：\n\n```js\nexport default defineComponent({\n  //...\n  render() {\n    const { TreeNodes } = this;\n    return (<transition-group>{TreeNodes}</transition-group>);\n  }\t\n})\n```\n而 `TreeNodes` 则是 `TreeItem` 实例的集合：\n\n```js\nthis.treeNodes.push(<TreeItem\n      key={node.value}\n      node={node}\n      treeScope={treeScope}\n      onClick={this.handleClick}\n      onChange={this.handleChange}\n/>))\n```\n\n所以，在 patch 的时候，对当前 VNode Child 进行了替换。\n\n由于Vue3使用了 `Proxy` 而不再是Vue2的 `Object.defineProperty`，因此通过数组的下标进行赋值也会被监听到，自然就又重新进入了渲染流程，最终导致了渲染死循环。\n\n解决办法：避免使用 VNode 数组。\n\n在当前的组件里，就是将 `treeNodes` 的元素改成 `node`，而不是 `tree-item` 的 `VNode`。\n\n最终 `td-tree` 的渲染函数是这样的：\n\n```js\nexport default defineComponent({\n  //...\n  render() {\n    const { TreeNodes } = this;\n    return (<transition-group>\n      {TreeNodes.map(node => this.renderItem(node))}\n    </transition-group>);\n  }\t\n})\n```\n\n## 数据变更不渲染\n\n为了实现多框架之间可以实现逻辑复用，所以 `tree` 的很多复杂逻辑计算都被封装在一个公共模块里。\n\n而其中 `tree-item` 的很多逻辑存在于 `common/tree-node.ts` 里面。\n\n按理说，Vue2 运行正常的情况下，我只需要改动 Vue3 的 breaking changes 的地方，其他逻辑我是不需要改动的。而且由于公共模块的部分是多框架复用的，所以我是不应该改动这部分的，除非 Vue2 同样存在问题。\n\n诡异的情况发生了，在测试 [异步加载节点](http://tdesign.woa.com/vue/components/tree#18-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E8%8A%82%E7%82%B9) 的 case 的时候，发现 `loading` 的 `icon` 一直不会消失。\n\n于是我开始梳理各种 `tree` 的渲染逻辑，最后通过数据的追踪，发现其实当前的 `node` 的 `loading` 值已经变成了 `false`，只是`tree-item`的 render 没有被触发而已。\n\n表面的原因发现了，但深层的原因是为什么呢？\n\n其实，这又是 Vue3 和 Vue2 的响应式实现的差异引起的问题。\n\n在 Vue2 中，每个被当作 `property` 传到组件的值，会通过 `Object.defineProperty` 来对每个 `key` 设置 `getter` 和 `setter`。\n\n以当前的组件举例：\n\n```html\n<tree-item :node=\"node\" />\n```\n\n我们将 `node` 当作 `property` 传给 `tree-item` 的时候，Vue 就将 `node` 的每个 `key` 设置了 `getter` 和 `setter`，其中关键的是 `setter`，如果改变了`node` 的任意属性值，就会触发了 `setter` 与此同时就会对当前这个 `tree-item` 进行渲染。\n\n而在 Vue3 中，由于`Object.definedProperty` 的各种局限，所以采用了更先进的 `Proxy` 来实现响应式。\n\n这也就带了问题。`Proxy` 的机制要求我们访问 **代理对象** 而不是源对象，但由于 `tree` 的封装设计，只会在源对象上进行属性值变更，也就不会触发`tree-item`的渲染了。\n\n找到了核心问题，解决思路有很多种：\n\n1. 让公共部分的逻辑在 **代理对象** 上进行，而不是源对象（不能因为版本的差异去影响公共逻辑，所以这个方案 pass）\n2. `tree-item` 不再使用 `tree-store` 返回的 `node`，而是新的 `Object`。在 `tree-store` 触发 `update` 时，再将 `node` 的每个 `key` 值进行比较，逐个`update`，同时也就可以触发渲染了。\n\n# 总结\n\n上面遇到的两个问题都是由 `Vue3` 的 `Reactivity` 机制变更导致的，均不是 `Migration Guide` 里有提到的 `breaking changes`，都属于 Vue3 的核心实现机制的改变。\n\n因此，要想顺利完成 Vue2 到 Vue3 的升级，最好是能理解核心思想的改变，以及能熟悉框架的源码。","slug":"vue3-on-tdesign","published":1,"updated":"2023-08-04T11:42:53.164Z","_id":"clkwef2bw00013tsz6mop4pz1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Vue3 是 Vuejs 新出的 3.0 版本，性能以及代码可维护性都提升了许多，也解决了许多 Vue2 中使用不便的地方。<br>此外，由于使用了 Proxy 来实现 Reactivity，所以对客户端的要求也就更高了，但总的来说，Vue3 的普及是势不可挡的。</p>\n<p>TDesign 是汇集了公司多个 Oteam 的结晶，包括了多种框架多种终端的组件。</p>\n<p>其中，Tree 可以说是组件库里最复杂的组件了，可以说是没有之一。</p>\n<p>这次分享的内容是在我将 Tree 由 Vue2 迁移至 Vue3 过程中遇到的问题、分析过程以及最终的解决方案。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"迁移策略\"><a href=\"#迁移策略\" class=\"headerlink\" title=\"迁移策略\"></a>迁移策略</h2><p>从 Vue2 升级至 Vue3，可以从官方的 <a href=\"https://v3.vuejs.org/guide/migration/introduction.html\">《Migration Guide》</a>可以看到了解到底有哪些 breaking changes。</p>\n<p>升级的最小成本就是将 breaking changes 修复即可。</p>\n<p>至于其他更好用的特性（如 <code>Composition API</code>、<code>Fragments</code> 等），属于非必需特性，可以放在后置再进行优化。其中的缘由是因为 Vue2 也在高速运转中，仍处于不稳定的状态，不对代码进行较大改动是为了之后可以方便地同步 Vue2 最新的代码。</p>\n<h2 id=\"Vue3\"><a href=\"#Vue3\" class=\"headerlink\" title=\"Vue3\"></a>Vue3</h2><p>Vue 的核心模块有三个：Reactivity Module、Compiler Module、Renderer Module。</p>\n<p><img src=\"/blog/images/vue3/vue-core-modules.png\" alt=\"Vue 核心模块\"></p>\n<p>其中，Compiler Module 是将 template 转换成 render function，日常开发不会遇到问题。</p>\n<p>而 Reactivity Module 则从 <code>Object.defineProperty</code> 升级成 <code>Proxy</code> 的形式实现，会存在原理上的不同，导致代码的实现思路也会受影响。在较复杂逻辑中比较容易出现问题。</p>\n<p>Renderer Module 则是核心的渲染逻辑。问题常出现在 Patch 阶段，需要了解其中的 diff 算法。</p>\n<h2 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h2><p>在开始迁移之前，先了解了一下 Tree 的代码结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- common</span><br><span class=\"line\">  - tree-store.ts</span><br><span class=\"line\">  - tree-node.ts</span><br><span class=\"line\">- src</span><br><span class=\"line\">  - tree</span><br><span class=\"line\">    - td-tree.tsx</span><br><span class=\"line\">    - tree-item.tsx</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>common里面的代码是tree的公共逻辑，会在多个框架多个终端之间共享。</p>\n</blockquote>\n<p>数据的流动：</p>\n<p><img src=\"/blog/images/vue3/tree-data-flow.png\" alt=\"TDesign 树的数据流动\"></p>\n<h1 id=\"状况百出\"><a href=\"#状况百出\" class=\"headerlink\" title=\"状况百出\"></a>状况百出</h1><h2 id=\"渲染死循环\"><a href=\"#渲染死循环\" class=\"headerlink\" title=\"渲染死循环\"></a>渲染死循环</h2><p>通过断点发现，在不断地渲染 <code>td-tree</code>，其中就卡在 patchChildren 的逻辑：<code>vue-next/packages/runder-core/src/renderer.ts:1771</code>，下面是我摘选的部分代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> n1 = c1[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> n2 = (c2[i] = optimized</span><br><span class=\"line\">        ? cloneIfMounted(c2[i] <span class=\"keyword\">as</span> VNode)</span><br><span class=\"line\">        : normalizeVNode(c2[i]))</span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的数组赋值，为什么在 Vue2 正常运行，而在 Vue3 则发生了死循环呢？</p>\n<p>是因为我们 <code>td-tree</code> 的渲染函数是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineComponent(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; TreeNodes &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span>&gt;</span>&#123;TreeNodes&#125;<span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span>);</span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>而 <code>TreeNodes</code> 则是 <code>TreeItem</code> 实例的集合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.treeNodes.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">TreeItem</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">key</span>=<span class=\"string\">&#123;node.value&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">node</span>=<span class=\"string\">&#123;node&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">treeScope</span>=<span class=\"string\">&#123;treeScope&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handleChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">/&gt;</span></span>))</span><br></pre></td></tr></table></figure>\n\n<p>所以，在 patch 的时候，对当前 VNode Child 进行了替换。</p>\n<p>由于Vue3使用了 <code>Proxy</code> 而不再是Vue2的 <code>Object.defineProperty</code>，因此通过数组的下标进行赋值也会被监听到，自然就又重新进入了渲染流程，最终导致了渲染死循环。</p>\n<p>解决办法：避免使用 VNode 数组。</p>\n<p>在当前的组件里，就是将 <code>treeNodes</code> 的元素改成 <code>node</code>，而不是 <code>tree-item</code> 的 <code>VNode</code>。</p>\n<p>最终 <code>td-tree</code> 的渲染函数是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineComponent(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; TreeNodes &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      &#123;TreeNodes.map(node =&gt; this.renderItem(node))&#125;</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span>);</span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据变更不渲染\"><a href=\"#数据变更不渲染\" class=\"headerlink\" title=\"数据变更不渲染\"></a>数据变更不渲染</h2><p>为了实现多框架之间可以实现逻辑复用，所以 <code>tree</code> 的很多复杂逻辑计算都被封装在一个公共模块里。</p>\n<p>而其中 <code>tree-item</code> 的很多逻辑存在于 <code>common/tree-node.ts</code> 里面。</p>\n<p>按理说，Vue2 运行正常的情况下，我只需要改动 Vue3 的 breaking changes 的地方，其他逻辑我是不需要改动的。而且由于公共模块的部分是多框架复用的，所以我是不应该改动这部分的，除非 Vue2 同样存在问题。</p>\n<p>诡异的情况发生了，在测试 <a href=\"http://tdesign.woa.com/vue/components/tree#18-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E8%8A%82%E7%82%B9\">异步加载节点</a> 的 case 的时候，发现 <code>loading</code> 的 <code>icon</code> 一直不会消失。</p>\n<p>于是我开始梳理各种 <code>tree</code> 的渲染逻辑，最后通过数据的追踪，发现其实当前的 <code>node</code> 的 <code>loading</code> 值已经变成了 <code>false</code>，只是<code>tree-item</code>的 render 没有被触发而已。</p>\n<p>表面的原因发现了，但深层的原因是为什么呢？</p>\n<p>其实，这又是 Vue3 和 Vue2 的响应式实现的差异引起的问题。</p>\n<p>在 Vue2 中，每个被当作 <code>property</code> 传到组件的值，会通过 <code>Object.defineProperty</code> 来对每个 <code>key</code> 设置 <code>getter</code> 和 <code>setter</code>。</p>\n<p>以当前的组件举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tree-item</span> <span class=\"attr\">:node</span>=<span class=\"string\">&quot;node&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们将 <code>node</code> 当作 <code>property</code> 传给 <code>tree-item</code> 的时候，Vue 就将 <code>node</code> 的每个 <code>key</code> 设置了 <code>getter</code> 和 <code>setter</code>，其中关键的是 <code>setter</code>，如果改变了<code>node</code> 的任意属性值，就会触发了 <code>setter</code> 与此同时就会对当前这个 <code>tree-item</code> 进行渲染。</p>\n<p>而在 Vue3 中，由于<code>Object.definedProperty</code> 的各种局限，所以采用了更先进的 <code>Proxy</code> 来实现响应式。</p>\n<p>这也就带了问题。<code>Proxy</code> 的机制要求我们访问 <strong>代理对象</strong> 而不是源对象，但由于 <code>tree</code> 的封装设计，只会在源对象上进行属性值变更，也就不会触发<code>tree-item</code>的渲染了。</p>\n<p>找到了核心问题，解决思路有很多种：</p>\n<ol>\n<li>让公共部分的逻辑在 <strong>代理对象</strong> 上进行，而不是源对象（不能因为版本的差异去影响公共逻辑，所以这个方案 pass）</li>\n<li><code>tree-item</code> 不再使用 <code>tree-store</code> 返回的 <code>node</code>，而是新的 <code>Object</code>。在 <code>tree-store</code> 触发 <code>update</code> 时，再将 <code>node</code> 的每个 <code>key</code> 值进行比较，逐个<code>update</code>，同时也就可以触发渲染了。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>上面遇到的两个问题都是由 <code>Vue3</code> 的 <code>Reactivity</code> 机制变更导致的，均不是 <code>Migration Guide</code> 里有提到的 <code>breaking changes</code>，都属于 Vue3 的核心实现机制的改变。</p>\n<p>因此，要想顺利完成 Vue2 到 Vue3 的升级，最好是能理解核心思想的改变，以及能熟悉框架的源码。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>Vue3 是 Vuejs 新出的 3.0 版本，性能以及代码可维护性都提升了许多，也解决了许多 Vue2 中使用不便的地方。<br>此外，由于使用了 Proxy 来实现 Reactivity，所以对客户端的要求也就更高了，但总的来说，Vue3 的普及是势不可挡的。</p>\n<p>TDesign 是汇集了公司多个 Oteam 的结晶，包括了多种框架多种终端的组件。</p>\n<p>其中，Tree 可以说是组件库里最复杂的组件了，可以说是没有之一。</p>\n<p>这次分享的内容是在我将 Tree 由 Vue2 迁移至 Vue3 过程中遇到的问题、分析过程以及最终的解决方案。</p>","more":"<h2 id=\"迁移策略\"><a href=\"#迁移策略\" class=\"headerlink\" title=\"迁移策略\"></a>迁移策略</h2><p>从 Vue2 升级至 Vue3，可以从官方的 <a href=\"https://v3.vuejs.org/guide/migration/introduction.html\">《Migration Guide》</a>可以看到了解到底有哪些 breaking changes。</p>\n<p>升级的最小成本就是将 breaking changes 修复即可。</p>\n<p>至于其他更好用的特性（如 <code>Composition API</code>、<code>Fragments</code> 等），属于非必需特性，可以放在后置再进行优化。其中的缘由是因为 Vue2 也在高速运转中，仍处于不稳定的状态，不对代码进行较大改动是为了之后可以方便地同步 Vue2 最新的代码。</p>\n<h2 id=\"Vue3\"><a href=\"#Vue3\" class=\"headerlink\" title=\"Vue3\"></a>Vue3</h2><p>Vue 的核心模块有三个：Reactivity Module、Compiler Module、Renderer Module。</p>\n<p><img src=\"/blog/images/vue3/vue-core-modules.png\" alt=\"Vue 核心模块\"></p>\n<p>其中，Compiler Module 是将 template 转换成 render function，日常开发不会遇到问题。</p>\n<p>而 Reactivity Module 则从 <code>Object.defineProperty</code> 升级成 <code>Proxy</code> 的形式实现，会存在原理上的不同，导致代码的实现思路也会受影响。在较复杂逻辑中比较容易出现问题。</p>\n<p>Renderer Module 则是核心的渲染逻辑。问题常出现在 Patch 阶段，需要了解其中的 diff 算法。</p>\n<h2 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h2><p>在开始迁移之前，先了解了一下 Tree 的代码结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- common</span><br><span class=\"line\">  - tree-store.ts</span><br><span class=\"line\">  - tree-node.ts</span><br><span class=\"line\">- src</span><br><span class=\"line\">  - tree</span><br><span class=\"line\">    - td-tree.tsx</span><br><span class=\"line\">    - tree-item.tsx</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>common里面的代码是tree的公共逻辑，会在多个框架多个终端之间共享。</p>\n</blockquote>\n<p>数据的流动：</p>\n<p><img src=\"/blog/images/vue3/tree-data-flow.png\" alt=\"TDesign 树的数据流动\"></p>\n<h1 id=\"状况百出\"><a href=\"#状况百出\" class=\"headerlink\" title=\"状况百出\"></a>状况百出</h1><h2 id=\"渲染死循环\"><a href=\"#渲染死循环\" class=\"headerlink\" title=\"渲染死循环\"></a>渲染死循环</h2><p>通过断点发现，在不断地渲染 <code>td-tree</code>，其中就卡在 patchChildren 的逻辑：<code>vue-next/packages/runder-core/src/renderer.ts:1771</code>，下面是我摘选的部分代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> n1 = c1[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> n2 = (c2[i] = optimized</span><br><span class=\"line\">        ? cloneIfMounted(c2[i] <span class=\"keyword\">as</span> VNode)</span><br><span class=\"line\">        : normalizeVNode(c2[i]))</span><br><span class=\"line\">\t\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的数组赋值，为什么在 Vue2 正常运行，而在 Vue3 则发生了死循环呢？</p>\n<p>是因为我们 <code>td-tree</code> 的渲染函数是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineComponent(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; TreeNodes &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span>&gt;</span>&#123;TreeNodes&#125;<span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span>);</span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>而 <code>TreeNodes</code> 则是 <code>TreeItem</code> 实例的集合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.treeNodes.push(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">TreeItem</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">key</span>=<span class=\"string\">&#123;node.value&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">node</span>=<span class=\"string\">&#123;node&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">treeScope</span>=<span class=\"string\">&#123;treeScope&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.handleClick&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">      <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handleChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">/&gt;</span></span>))</span><br></pre></td></tr></table></figure>\n\n<p>所以，在 patch 的时候，对当前 VNode Child 进行了替换。</p>\n<p>由于Vue3使用了 <code>Proxy</code> 而不再是Vue2的 <code>Object.defineProperty</code>，因此通过数组的下标进行赋值也会被监听到，自然就又重新进入了渲染流程，最终导致了渲染死循环。</p>\n<p>解决办法：避免使用 VNode 数组。</p>\n<p>在当前的组件里，就是将 <code>treeNodes</code> 的元素改成 <code>node</code>，而不是 <code>tree-item</code> 的 <code>VNode</code>。</p>\n<p>最终 <code>td-tree</code> 的渲染函数是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineComponent(&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; TreeNodes &#125; = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">transition-group</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      &#123;TreeNodes.map(node =&gt; this.renderItem(node))&#125;</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">transition-group</span>&gt;</span></span>);</span><br><span class=\"line\">  &#125;\t</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据变更不渲染\"><a href=\"#数据变更不渲染\" class=\"headerlink\" title=\"数据变更不渲染\"></a>数据变更不渲染</h2><p>为了实现多框架之间可以实现逻辑复用，所以 <code>tree</code> 的很多复杂逻辑计算都被封装在一个公共模块里。</p>\n<p>而其中 <code>tree-item</code> 的很多逻辑存在于 <code>common/tree-node.ts</code> 里面。</p>\n<p>按理说，Vue2 运行正常的情况下，我只需要改动 Vue3 的 breaking changes 的地方，其他逻辑我是不需要改动的。而且由于公共模块的部分是多框架复用的，所以我是不应该改动这部分的，除非 Vue2 同样存在问题。</p>\n<p>诡异的情况发生了，在测试 <a href=\"http://tdesign.woa.com/vue/components/tree#18-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E8%8A%82%E7%82%B9\">异步加载节点</a> 的 case 的时候，发现 <code>loading</code> 的 <code>icon</code> 一直不会消失。</p>\n<p>于是我开始梳理各种 <code>tree</code> 的渲染逻辑，最后通过数据的追踪，发现其实当前的 <code>node</code> 的 <code>loading</code> 值已经变成了 <code>false</code>，只是<code>tree-item</code>的 render 没有被触发而已。</p>\n<p>表面的原因发现了，但深层的原因是为什么呢？</p>\n<p>其实，这又是 Vue3 和 Vue2 的响应式实现的差异引起的问题。</p>\n<p>在 Vue2 中，每个被当作 <code>property</code> 传到组件的值，会通过 <code>Object.defineProperty</code> 来对每个 <code>key</code> 设置 <code>getter</code> 和 <code>setter</code>。</p>\n<p>以当前的组件举例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tree-item</span> <span class=\"attr\">:node</span>=<span class=\"string\">&quot;node&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们将 <code>node</code> 当作 <code>property</code> 传给 <code>tree-item</code> 的时候，Vue 就将 <code>node</code> 的每个 <code>key</code> 设置了 <code>getter</code> 和 <code>setter</code>，其中关键的是 <code>setter</code>，如果改变了<code>node</code> 的任意属性值，就会触发了 <code>setter</code> 与此同时就会对当前这个 <code>tree-item</code> 进行渲染。</p>\n<p>而在 Vue3 中，由于<code>Object.definedProperty</code> 的各种局限，所以采用了更先进的 <code>Proxy</code> 来实现响应式。</p>\n<p>这也就带了问题。<code>Proxy</code> 的机制要求我们访问 <strong>代理对象</strong> 而不是源对象，但由于 <code>tree</code> 的封装设计，只会在源对象上进行属性值变更，也就不会触发<code>tree-item</code>的渲染了。</p>\n<p>找到了核心问题，解决思路有很多种：</p>\n<ol>\n<li>让公共部分的逻辑在 <strong>代理对象</strong> 上进行，而不是源对象（不能因为版本的差异去影响公共逻辑，所以这个方案 pass）</li>\n<li><code>tree-item</code> 不再使用 <code>tree-store</code> 返回的 <code>node</code>，而是新的 <code>Object</code>。在 <code>tree-store</code> 触发 <code>update</code> 时，再将 <code>node</code> 的每个 <code>key</code> 值进行比较，逐个<code>update</code>，同时也就可以触发渲染了。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>上面遇到的两个问题都是由 <code>Vue3</code> 的 <code>Reactivity</code> 机制变更导致的，均不是 <code>Migration Guide</code> 里有提到的 <code>breaking changes</code>，都属于 Vue3 的核心实现机制的改变。</p>\n<p>因此，要想顺利完成 Vue2 到 Vue3 的升级，最好是能理解核心思想的改变，以及能熟悉框架的源码。</p>"},{"title":"小程序复用函数的五种方式","date":"2020-03-14T10:42:32.000Z","_content":"\n开发过小程序的朋友们应该都遇到这样的情况，可能很多个页面有相同的函数，例如`onShareAppMessage`，有什么最佳实践吗，应该如何处理呢？\n\n本次开发技巧，我从以下几种解决办法剖析：\n1.  将它复制粘贴到每个地方（最烂的做法）\n2.  抽象成一个公共函数，每个`Page`都手动引用\n3.  提取一个behavior，每个页面手动注入\n4.  通过`Page`封装一个新的`newPage`，以后每个页面都通过`newPage`注册\n5.  劫持Page函数，注入预设方法，页面仍可使用`Page`注册\n\n<!-- more -->\n\n## 复制粘贴大法\n\n这是最直观，也是初学者最常用到的办法。也是作为工程师最不应该采取的办法。这有一个致命的问题，如果某一天，需要改动这个函数，岂不是要将所有的地方都翻出来改，所以这个办法直接否决。\n\n## 抽象公共函数\n\n这种方式，解决了复制粘贴大法的致命问题，不需要改动很多地方，只需要改动这个抽象出来的函数即可。但是其实，这个方式不便捷，每次新增页面都需要手动引入这个函数。\n\n以下都通过`onShareAppMessage`方法举例。\n\n假设在`app.js`通过`global`注册了`onShareAppMessage`方法：\n\n```js\n// app.js\nglobal.onShareAppMessage = function() {\n    return {\n    \ttitle: '我在这里发现了很多好看的壁纸',\n        path: 'pages/index/index',\n        imageUrl: ''\n    }\n}\n```\n\n那么此时每次新增的Page都需要这样引入：\n\n```\n// page.js\nPage({\n    ...global.onShareAppMessage,\n    \n    data: {}\n})\n```\n\n这样的缺点也是非常明显的：\n1. 创建新页面时，容易遗忘\n2. 如果多个相同的函数，则需要每个独立引入，不方便\n\n## 提取Behavior\n\n将多个函数集成到一个对象中，每个页面只需要引入这个对象即可注入多个相同的函数。这种方式可以解决 **抽象公共函数** 提到的 **缺点2**。\n\n大致的实现方式如下：\n\n同样在`app.js`通过`global`注册一个`behavior`对象：\n\n```js\n// app.js\nglobal.commonPage = {\n    onShareAppMessage: function() {\n        return {\n            title: '我在这里发现了很多好看的壁纸',\n            path: 'pages/index/index',\n            imageUrl: ''\n        }\n    },\n    onHide: function() {\n        // do something\n    }\n}\n```\n\n在新增的页面注入：\n\n```js\n// page.js\nPage({\n    data: {},\n    \n    ...global.commonPage,\n}})\n```\n\n缺点仍然是，新增页面时容易遗忘\n\n## 封装新Page\n\n封装新的`Page`，然后每个页面都通过这个新的`Page`注册，而不是采用原有的`Page`。\n\n同理，在`app.js`先封装一个新的`Page`到全局变量`global`：\n\n```js\n// app.js\nglobal.newPage = function(obj) {\n    let defaultSet = {\n        onShareAppMessage: function() {\n            return {\n                title: '我在这里发现了很多好看的壁纸',\n                path: 'pages/index/index',\n                imageUrl: ''\n            }\n        },\n        onShow() {\n            // do something\n        }\n    }\n    return Page({...defaultSet, ...obj})\n}\n```\n\n往后在每个页面都使用新的`newPage`注册：\n\n```js\n// page.js\nglobal.newPage({\n    data: {}\n})\n```\n\n好处即是全新封装了`Page`，后续只需关注是否使用了新的`Page`即可；此外大家也很清晰知道这个是采用了新的封装，避免了覆盖原有的`Page`方法。\n\n我倒是觉得没什么明显缺点，要是非要鸡蛋里挑骨头的话，就是要显式调用新的函数注册页面。\n\n## 劫持Page\n\n劫持函数其实是挺危险的做法，因为开发人员可能会在定位问题时，忽略了这个被劫持的地方。\n\n劫持`Page`的做法，简单的说就是，覆盖`Page`这个函数，重新实现`Page`，但这个新的`Page`内部仍会调用原有的`Page`。说起来可能有点拗口，通过代码看就一目了然：\n\n```js\n// app.js\nlet originalPage = Page\nPage = function(obj) {\n    let defaultSet = {\n        onShareAppMessage: function() {\n            return {\n                title: '我在这里发现了很多好看的壁纸',\n                path: 'pages/index/index',\n                imageUrl: ''\n            }\n        },\n        onShow() {\n            // do something\n        }\n    }\n    return originalPage({ ...defaultSet, ...obj})\n}\n```\n\n通过这种方式，不改变页面的注册方式，但可能会让不了解底层封装的开发者感到困惑：明明没注册的方法，怎么就自动注入了呢？\n\n这种方式的缺点已经说了，优点也很明显，不改变任何原有的页面注册方式。\n\n其实这个是一个挺好的思路，在一些特定的场景下，会有事半功倍的效果。","source":"_posts/miniprogram/how-to-resue-method.md","raw":"---\ntitle: 小程序复用函数的五种方式\ndate: 2020-03-14 18:42:32\ntags:\n---\n\n开发过小程序的朋友们应该都遇到这样的情况，可能很多个页面有相同的函数，例如`onShareAppMessage`，有什么最佳实践吗，应该如何处理呢？\n\n本次开发技巧，我从以下几种解决办法剖析：\n1.  将它复制粘贴到每个地方（最烂的做法）\n2.  抽象成一个公共函数，每个`Page`都手动引用\n3.  提取一个behavior，每个页面手动注入\n4.  通过`Page`封装一个新的`newPage`，以后每个页面都通过`newPage`注册\n5.  劫持Page函数，注入预设方法，页面仍可使用`Page`注册\n\n<!-- more -->\n\n## 复制粘贴大法\n\n这是最直观，也是初学者最常用到的办法。也是作为工程师最不应该采取的办法。这有一个致命的问题，如果某一天，需要改动这个函数，岂不是要将所有的地方都翻出来改，所以这个办法直接否决。\n\n## 抽象公共函数\n\n这种方式，解决了复制粘贴大法的致命问题，不需要改动很多地方，只需要改动这个抽象出来的函数即可。但是其实，这个方式不便捷，每次新增页面都需要手动引入这个函数。\n\n以下都通过`onShareAppMessage`方法举例。\n\n假设在`app.js`通过`global`注册了`onShareAppMessage`方法：\n\n```js\n// app.js\nglobal.onShareAppMessage = function() {\n    return {\n    \ttitle: '我在这里发现了很多好看的壁纸',\n        path: 'pages/index/index',\n        imageUrl: ''\n    }\n}\n```\n\n那么此时每次新增的Page都需要这样引入：\n\n```\n// page.js\nPage({\n    ...global.onShareAppMessage,\n    \n    data: {}\n})\n```\n\n这样的缺点也是非常明显的：\n1. 创建新页面时，容易遗忘\n2. 如果多个相同的函数，则需要每个独立引入，不方便\n\n## 提取Behavior\n\n将多个函数集成到一个对象中，每个页面只需要引入这个对象即可注入多个相同的函数。这种方式可以解决 **抽象公共函数** 提到的 **缺点2**。\n\n大致的实现方式如下：\n\n同样在`app.js`通过`global`注册一个`behavior`对象：\n\n```js\n// app.js\nglobal.commonPage = {\n    onShareAppMessage: function() {\n        return {\n            title: '我在这里发现了很多好看的壁纸',\n            path: 'pages/index/index',\n            imageUrl: ''\n        }\n    },\n    onHide: function() {\n        // do something\n    }\n}\n```\n\n在新增的页面注入：\n\n```js\n// page.js\nPage({\n    data: {},\n    \n    ...global.commonPage,\n}})\n```\n\n缺点仍然是，新增页面时容易遗忘\n\n## 封装新Page\n\n封装新的`Page`，然后每个页面都通过这个新的`Page`注册，而不是采用原有的`Page`。\n\n同理，在`app.js`先封装一个新的`Page`到全局变量`global`：\n\n```js\n// app.js\nglobal.newPage = function(obj) {\n    let defaultSet = {\n        onShareAppMessage: function() {\n            return {\n                title: '我在这里发现了很多好看的壁纸',\n                path: 'pages/index/index',\n                imageUrl: ''\n            }\n        },\n        onShow() {\n            // do something\n        }\n    }\n    return Page({...defaultSet, ...obj})\n}\n```\n\n往后在每个页面都使用新的`newPage`注册：\n\n```js\n// page.js\nglobal.newPage({\n    data: {}\n})\n```\n\n好处即是全新封装了`Page`，后续只需关注是否使用了新的`Page`即可；此外大家也很清晰知道这个是采用了新的封装，避免了覆盖原有的`Page`方法。\n\n我倒是觉得没什么明显缺点，要是非要鸡蛋里挑骨头的话，就是要显式调用新的函数注册页面。\n\n## 劫持Page\n\n劫持函数其实是挺危险的做法，因为开发人员可能会在定位问题时，忽略了这个被劫持的地方。\n\n劫持`Page`的做法，简单的说就是，覆盖`Page`这个函数，重新实现`Page`，但这个新的`Page`内部仍会调用原有的`Page`。说起来可能有点拗口，通过代码看就一目了然：\n\n```js\n// app.js\nlet originalPage = Page\nPage = function(obj) {\n    let defaultSet = {\n        onShareAppMessage: function() {\n            return {\n                title: '我在这里发现了很多好看的壁纸',\n                path: 'pages/index/index',\n                imageUrl: ''\n            }\n        },\n        onShow() {\n            // do something\n        }\n    }\n    return originalPage({ ...defaultSet, ...obj})\n}\n```\n\n通过这种方式，不改变页面的注册方式，但可能会让不了解底层封装的开发者感到困惑：明明没注册的方法，怎么就自动注入了呢？\n\n这种方式的缺点已经说了，优点也很明显，不改变任何原有的页面注册方式。\n\n其实这个是一个挺好的思路，在一些特定的场景下，会有事半功倍的效果。","slug":"miniprogram/how-to-resue-method","published":1,"updated":"2023-08-04T10:45:01.706Z","_id":"clkwgj0cl00063tsz5agfahkh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>开发过小程序的朋友们应该都遇到这样的情况，可能很多个页面有相同的函数，例如<code>onShareAppMessage</code>，有什么最佳实践吗，应该如何处理呢？</p>\n<p>本次开发技巧，我从以下几种解决办法剖析：</p>\n<ol>\n<li> 将它复制粘贴到每个地方（最烂的做法）</li>\n<li> 抽象成一个公共函数，每个<code>Page</code>都手动引用</li>\n<li> 提取一个behavior，每个页面手动注入</li>\n<li> 通过<code>Page</code>封装一个新的<code>newPage</code>，以后每个页面都通过<code>newPage</code>注册</li>\n<li> 劫持Page函数，注入预设方法，页面仍可使用<code>Page</code>注册</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"复制粘贴大法\"><a href=\"#复制粘贴大法\" class=\"headerlink\" title=\"复制粘贴大法\"></a>复制粘贴大法</h2><p>这是最直观，也是初学者最常用到的办法。也是作为工程师最不应该采取的办法。这有一个致命的问题，如果某一天，需要改动这个函数，岂不是要将所有的地方都翻出来改，所以这个办法直接否决。</p>\n<h2 id=\"抽象公共函数\"><a href=\"#抽象公共函数\" class=\"headerlink\" title=\"抽象公共函数\"></a>抽象公共函数</h2><p>这种方式，解决了复制粘贴大法的致命问题，不需要改动很多地方，只需要改动这个抽象出来的函数即可。但是其实，这个方式不便捷，每次新增页面都需要手动引入这个函数。</p>\n<p>以下都通过<code>onShareAppMessage</code>方法举例。</p>\n<p>假设在<code>app.js</code>通过<code>global</code>注册了<code>onShareAppMessage</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.onShareAppMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    \t<span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么此时每次新增的Page都需要这样引入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// page.js</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    ...global.onShareAppMessage,</span><br><span class=\"line\">    </span><br><span class=\"line\">    data: &#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样的缺点也是非常明显的：</p>\n<ol>\n<li>创建新页面时，容易遗忘</li>\n<li>如果多个相同的函数，则需要每个独立引入，不方便</li>\n</ol>\n<h2 id=\"提取Behavior\"><a href=\"#提取Behavior\" class=\"headerlink\" title=\"提取Behavior\"></a>提取Behavior</h2><p>将多个函数集成到一个对象中，每个页面只需要引入这个对象即可注入多个相同的函数。这种方式可以解决 <strong>抽象公共函数</strong> 提到的 <strong>缺点2</strong>。</p>\n<p>大致的实现方式如下：</p>\n<p>同样在<code>app.js</code>通过<code>global</code>注册一个<code>behavior</code>对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.commonPage = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onShareAppMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">onHide</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在新增的页面注入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// page.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...global.commonPage,</span><br><span class=\"line\">&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>缺点仍然是，新增页面时容易遗忘</p>\n<h2 id=\"封装新Page\"><a href=\"#封装新Page\" class=\"headerlink\" title=\"封装新Page\"></a>封装新Page</h2><p>封装新的<code>Page</code>，然后每个页面都通过这个新的<code>Page</code>注册，而不是采用原有的<code>Page</code>。</p>\n<p>同理，在<code>app.js</code>先封装一个新的<code>Page</code>到全局变量<code>global</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.newPage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultSet = &#123;</span><br><span class=\"line\">        <span class=\"attr\">onShareAppMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Page(&#123;...defaultSet, ...obj&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>往后在每个页面都使用新的<code>newPage</code>注册：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// page.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.newPage(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>好处即是全新封装了<code>Page</code>，后续只需关注是否使用了新的<code>Page</code>即可；此外大家也很清晰知道这个是采用了新的封装，避免了覆盖原有的<code>Page</code>方法。</p>\n<p>我倒是觉得没什么明显缺点，要是非要鸡蛋里挑骨头的话，就是要显式调用新的函数注册页面。</p>\n<h2 id=\"劫持Page\"><a href=\"#劫持Page\" class=\"headerlink\" title=\"劫持Page\"></a>劫持Page</h2><p>劫持函数其实是挺危险的做法，因为开发人员可能会在定位问题时，忽略了这个被劫持的地方。</p>\n<p>劫持<code>Page</code>的做法，简单的说就是，覆盖<code>Page</code>这个函数，重新实现<code>Page</code>，但这个新的<code>Page</code>内部仍会调用原有的<code>Page</code>。说起来可能有点拗口，通过代码看就一目了然：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalPage = Page</span><br><span class=\"line\">Page = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultSet = &#123;</span><br><span class=\"line\">        <span class=\"attr\">onShareAppMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> originalPage(&#123; ...defaultSet, ...obj&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式，不改变页面的注册方式，但可能会让不了解底层封装的开发者感到困惑：明明没注册的方法，怎么就自动注入了呢？</p>\n<p>这种方式的缺点已经说了，优点也很明显，不改变任何原有的页面注册方式。</p>\n<p>其实这个是一个挺好的思路，在一些特定的场景下，会有事半功倍的效果。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>开发过小程序的朋友们应该都遇到这样的情况，可能很多个页面有相同的函数，例如<code>onShareAppMessage</code>，有什么最佳实践吗，应该如何处理呢？</p>\n<p>本次开发技巧，我从以下几种解决办法剖析：</p>\n<ol>\n<li> 将它复制粘贴到每个地方（最烂的做法）</li>\n<li> 抽象成一个公共函数，每个<code>Page</code>都手动引用</li>\n<li> 提取一个behavior，每个页面手动注入</li>\n<li> 通过<code>Page</code>封装一个新的<code>newPage</code>，以后每个页面都通过<code>newPage</code>注册</li>\n<li> 劫持Page函数，注入预设方法，页面仍可使用<code>Page</code>注册</li>\n</ol>","more":"<h2 id=\"复制粘贴大法\"><a href=\"#复制粘贴大法\" class=\"headerlink\" title=\"复制粘贴大法\"></a>复制粘贴大法</h2><p>这是最直观，也是初学者最常用到的办法。也是作为工程师最不应该采取的办法。这有一个致命的问题，如果某一天，需要改动这个函数，岂不是要将所有的地方都翻出来改，所以这个办法直接否决。</p>\n<h2 id=\"抽象公共函数\"><a href=\"#抽象公共函数\" class=\"headerlink\" title=\"抽象公共函数\"></a>抽象公共函数</h2><p>这种方式，解决了复制粘贴大法的致命问题，不需要改动很多地方，只需要改动这个抽象出来的函数即可。但是其实，这个方式不便捷，每次新增页面都需要手动引入这个函数。</p>\n<p>以下都通过<code>onShareAppMessage</code>方法举例。</p>\n<p>假设在<code>app.js</code>通过<code>global</code>注册了<code>onShareAppMessage</code>方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.onShareAppMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    \t<span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么此时每次新增的Page都需要这样引入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// page.js</span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    ...global.onShareAppMessage,</span><br><span class=\"line\">    </span><br><span class=\"line\">    data: &#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样的缺点也是非常明显的：</p>\n<ol>\n<li>创建新页面时，容易遗忘</li>\n<li>如果多个相同的函数，则需要每个独立引入，不方便</li>\n</ol>\n<h2 id=\"提取Behavior\"><a href=\"#提取Behavior\" class=\"headerlink\" title=\"提取Behavior\"></a>提取Behavior</h2><p>将多个函数集成到一个对象中，每个页面只需要引入这个对象即可注入多个相同的函数。这种方式可以解决 <strong>抽象公共函数</strong> 提到的 <strong>缺点2</strong>。</p>\n<p>大致的实现方式如下：</p>\n<p>同样在<code>app.js</code>通过<code>global</code>注册一个<code>behavior</code>对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.commonPage = &#123;</span><br><span class=\"line\">    <span class=\"attr\">onShareAppMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">onHide</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在新增的页面注入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// page.js</span></span><br><span class=\"line\">Page(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...global.commonPage,</span><br><span class=\"line\">&#125;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>缺点仍然是，新增页面时容易遗忘</p>\n<h2 id=\"封装新Page\"><a href=\"#封装新Page\" class=\"headerlink\" title=\"封装新Page\"></a>封装新Page</h2><p>封装新的<code>Page</code>，然后每个页面都通过这个新的<code>Page</code>注册，而不是采用原有的<code>Page</code>。</p>\n<p>同理，在<code>app.js</code>先封装一个新的<code>Page</code>到全局变量<code>global</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.newPage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultSet = &#123;</span><br><span class=\"line\">        <span class=\"attr\">onShareAppMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Page(&#123;...defaultSet, ...obj&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>往后在每个页面都使用新的<code>newPage</code>注册：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// page.js</span></span><br><span class=\"line\"><span class=\"built_in\">global</span>.newPage(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>好处即是全新封装了<code>Page</code>，后续只需关注是否使用了新的<code>Page</code>即可；此外大家也很清晰知道这个是采用了新的封装，避免了覆盖原有的<code>Page</code>方法。</p>\n<p>我倒是觉得没什么明显缺点，要是非要鸡蛋里挑骨头的话，就是要显式调用新的函数注册页面。</p>\n<h2 id=\"劫持Page\"><a href=\"#劫持Page\" class=\"headerlink\" title=\"劫持Page\"></a>劫持Page</h2><p>劫持函数其实是挺危险的做法，因为开发人员可能会在定位问题时，忽略了这个被劫持的地方。</p>\n<p>劫持<code>Page</code>的做法，简单的说就是，覆盖<code>Page</code>这个函数，重新实现<code>Page</code>，但这个新的<code>Page</code>内部仍会调用原有的<code>Page</code>。说起来可能有点拗口，通过代码看就一目了然：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalPage = Page</span><br><span class=\"line\">Page = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> defaultSet = &#123;</span><br><span class=\"line\">        <span class=\"attr\">onShareAppMessage</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                <span class=\"attr\">title</span>: <span class=\"string\">&#x27;我在这里发现了很多好看的壁纸&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">path</span>: <span class=\"string\">&#x27;pages/index/index&#x27;</span>,</span><br><span class=\"line\">                <span class=\"attr\">imageUrl</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">onShow</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> originalPage(&#123; ...defaultSet, ...obj&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式，不改变页面的注册方式，但可能会让不了解底层封装的开发者感到困惑：明明没注册的方法，怎么就自动注入了呢？</p>\n<p>这种方式的缺点已经说了，优点也很明显，不改变任何原有的页面注册方式。</p>\n<p>其实这个是一个挺好的思路，在一些特定的场景下，会有事半功倍的效果。</p>"},{"title":"浅谈小程序的错误处理","date":"2020-03-23T10:53:52.000Z","_content":"\n> 其实，错误（异常）处理在任何编程语言里，都是不可避免的。正确处理异常，是一个程序/应用保持健壮的关键。\n\n<!-- more -->\n\n## 现实\n\n从小程序的 API 文档可以看出，每个异步方法都支持传入一个 `fail` 方法，用于异常处理，例如：\n\n```js\nwx.login({\n  success (res) {\n    console.log(res)\n  },\n  fail(err) {\n    // handle error\n  }\n})\n```\n\n会存在这样一种情况：开发人员会因为惰性直接忽略这个参数；而测试人员由于无法 mock 这些错误情况，导致测试用例没有覆盖，最终可能会因此流失用户。\n\n还有一种情况，当这些 API 调用是在非关键流程上。若调用成功，则继续执行；若调用失败，直接忽略也不会影响。\n\n对于第一种情况，除了在 fail 里做异常处理以外，别无他法。\n\n本文将进一步讨论第二种情况。\n\n## 分析\n\n官方提供的 API，在发生异常时，均会通过回调函数 `fail` 回传错误信息。如果我们能采集这些数据，进行统计分析能有这些作用：\n\n- 为后续技术优化提供指导方向\n- 了解用户设备的兼容性，预防踩重复的坑\n\n由于官方提供的 API，所有的异步方法都需要手动传入 `fail`，因此手动给每个方法传入 `fail` 可能是不可行的。\n\n另外，小程序的更新频率很高，每隔一段时间就会出现许多新的API。\n\n因此，最佳的实践即是封装全局对象 `wx`\n\n## 实践\n\n封装 `wx` 的方案有很多，这里就列出两种比较常规的方案：\n\n- 较安全的方案：在全局变量 `global` 上新增方法（如：`global.wx`）\n- 较激进的方案：劫持 `wx`，直接在 `wx` 上动刀\n\n两种方案可有利弊，要看如何权衡。以下我将以第二种方案举例：\n\n```js\n// global.js\n\nlet originalWX = wx;\nwx = new Proxy({}, {  // [0]\n    get(target, name) {\n        if (name in originalWX ) {\n            let isSyncFunction = name.endsWith('Sync'); // 同步函数 [1]\n            let isNotFunction = typeof originalWX[name] !== 'function'; // 非函数 [2]\n\n            if (isSyncFunction || isNotFunction) return originalWX[name];\n\n            return function(obj) {\n                if (typeof obj === 'object') { // [3]\n                    let originalFail = function() {};\n                        \n                    if ('fail' in obj) {\n                        originalFail = obj.fail;\n                    }\n                    obj.fail = function() {\n                        // todo 上报数据到后端 [4]\n                        console.log('hijack success');\n                        originalFail();\n                    };\n                }\n                return originalWX[name](obj);\n            };\n        }\n    }\n});\n```\n\n代码注释：\n- [0]： 这里使用的是ES6提供的`Proxy`代理对象；会有一定的兼容性，如果需要兼容更低版本的机型，可采用其他方案（感兴趣的人多的话，后续补上）\n- [1]：前文也提到，只有异步方法才会有回调，因此同步方法直接返回原`wx`的方法\n- [2]：非函数；wx对象里有非函数的值，如 [wx.env](https://developers.weixin.qq.com/miniprogram/dev/api/base/env/env.html)\n- [3]：wx对象里的函数，可能传入非对象参数。如：[wx.canIUse](https://developers.weixin.qq.com/miniprogram/dev/api/base/wx.canIUse.html)\n- [4]：请看下一章节\n\n![ ](/blog/images/miniprogram/caniuse-proxy.png)\n\n\n## 进阶\n\n其实上述的代码，还不是最终版本。因为数据上报部分，还依赖后端提供接口。\n\n按理说，日志系统也算是通用的服务。我很早前就在思考，为什么微信官方不提供呢？细心的读者可能会反驳说，微信有提供类似的功能：**wx.reportMonitor（业务数据监控上报接口）**。\n\n其实，用过的读者应该了解，这个接口是非实时的，不能算是日志服务。\n\n如果你有不定时翻看微信小程序开发文档的习惯的话，你总会有这样的感觉：时不时就新增了一个特性，塞在了一个不容易发现的角落。接下来要讲的新特性，就是官方提供的 [实时日志](https://developers.weixin.qq.com/miniprogram/dev/framework/realtimelog/)：\n\n```js\nvar log = wx.getRealtimeLogManager ? wx.getRealtimeLogManager() : null\n\nlog && log.info.apply(log, arguments)\n```\n\n所有的日志，都可以通过 **小程序管理后台** 查看。\n\n> 访问路径：[ 开发->运维中心->实时日志 ]\n\n![ ](/blog/images/miniprogram/realtime-log.jpg)","source":"_posts/miniprogram/handle-error.md","raw":"---\ntitle: 浅谈小程序的错误处理\ndate: 2020-03-23 18:53:52\ntags:\n- 小程序\n---\n\n> 其实，错误（异常）处理在任何编程语言里，都是不可避免的。正确处理异常，是一个程序/应用保持健壮的关键。\n\n<!-- more -->\n\n## 现实\n\n从小程序的 API 文档可以看出，每个异步方法都支持传入一个 `fail` 方法，用于异常处理，例如：\n\n```js\nwx.login({\n  success (res) {\n    console.log(res)\n  },\n  fail(err) {\n    // handle error\n  }\n})\n```\n\n会存在这样一种情况：开发人员会因为惰性直接忽略这个参数；而测试人员由于无法 mock 这些错误情况，导致测试用例没有覆盖，最终可能会因此流失用户。\n\n还有一种情况，当这些 API 调用是在非关键流程上。若调用成功，则继续执行；若调用失败，直接忽略也不会影响。\n\n对于第一种情况，除了在 fail 里做异常处理以外，别无他法。\n\n本文将进一步讨论第二种情况。\n\n## 分析\n\n官方提供的 API，在发生异常时，均会通过回调函数 `fail` 回传错误信息。如果我们能采集这些数据，进行统计分析能有这些作用：\n\n- 为后续技术优化提供指导方向\n- 了解用户设备的兼容性，预防踩重复的坑\n\n由于官方提供的 API，所有的异步方法都需要手动传入 `fail`，因此手动给每个方法传入 `fail` 可能是不可行的。\n\n另外，小程序的更新频率很高，每隔一段时间就会出现许多新的API。\n\n因此，最佳的实践即是封装全局对象 `wx`\n\n## 实践\n\n封装 `wx` 的方案有很多，这里就列出两种比较常规的方案：\n\n- 较安全的方案：在全局变量 `global` 上新增方法（如：`global.wx`）\n- 较激进的方案：劫持 `wx`，直接在 `wx` 上动刀\n\n两种方案可有利弊，要看如何权衡。以下我将以第二种方案举例：\n\n```js\n// global.js\n\nlet originalWX = wx;\nwx = new Proxy({}, {  // [0]\n    get(target, name) {\n        if (name in originalWX ) {\n            let isSyncFunction = name.endsWith('Sync'); // 同步函数 [1]\n            let isNotFunction = typeof originalWX[name] !== 'function'; // 非函数 [2]\n\n            if (isSyncFunction || isNotFunction) return originalWX[name];\n\n            return function(obj) {\n                if (typeof obj === 'object') { // [3]\n                    let originalFail = function() {};\n                        \n                    if ('fail' in obj) {\n                        originalFail = obj.fail;\n                    }\n                    obj.fail = function() {\n                        // todo 上报数据到后端 [4]\n                        console.log('hijack success');\n                        originalFail();\n                    };\n                }\n                return originalWX[name](obj);\n            };\n        }\n    }\n});\n```\n\n代码注释：\n- [0]： 这里使用的是ES6提供的`Proxy`代理对象；会有一定的兼容性，如果需要兼容更低版本的机型，可采用其他方案（感兴趣的人多的话，后续补上）\n- [1]：前文也提到，只有异步方法才会有回调，因此同步方法直接返回原`wx`的方法\n- [2]：非函数；wx对象里有非函数的值，如 [wx.env](https://developers.weixin.qq.com/miniprogram/dev/api/base/env/env.html)\n- [3]：wx对象里的函数，可能传入非对象参数。如：[wx.canIUse](https://developers.weixin.qq.com/miniprogram/dev/api/base/wx.canIUse.html)\n- [4]：请看下一章节\n\n![ ](/blog/images/miniprogram/caniuse-proxy.png)\n\n\n## 进阶\n\n其实上述的代码，还不是最终版本。因为数据上报部分，还依赖后端提供接口。\n\n按理说，日志系统也算是通用的服务。我很早前就在思考，为什么微信官方不提供呢？细心的读者可能会反驳说，微信有提供类似的功能：**wx.reportMonitor（业务数据监控上报接口）**。\n\n其实，用过的读者应该了解，这个接口是非实时的，不能算是日志服务。\n\n如果你有不定时翻看微信小程序开发文档的习惯的话，你总会有这样的感觉：时不时就新增了一个特性，塞在了一个不容易发现的角落。接下来要讲的新特性，就是官方提供的 [实时日志](https://developers.weixin.qq.com/miniprogram/dev/framework/realtimelog/)：\n\n```js\nvar log = wx.getRealtimeLogManager ? wx.getRealtimeLogManager() : null\n\nlog && log.info.apply(log, arguments)\n```\n\n所有的日志，都可以通过 **小程序管理后台** 查看。\n\n> 访问路径：[ 开发->运维中心->实时日志 ]\n\n![ ](/blog/images/miniprogram/realtime-log.jpg)","slug":"miniprogram/handle-error","published":1,"updated":"2023-08-04T11:13:38.751Z","_id":"clkwgxd93000a3tszg5fucw5v","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>其实，错误（异常）处理在任何编程语言里，都是不可避免的。正确处理异常，是一个程序/应用保持健壮的关键。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"现实\"><a href=\"#现实\" class=\"headerlink\" title=\"现实\"></a>现实</h2><p>从小程序的 API 文档可以看出，每个异步方法都支持传入一个 <code>fail</code> 方法，用于异常处理，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.login(&#123;</span><br><span class=\"line\">  success (res) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">fail</span>(<span class=\"params\">err</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle error</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>会存在这样一种情况：开发人员会因为惰性直接忽略这个参数；而测试人员由于无法 mock 这些错误情况，导致测试用例没有覆盖，最终可能会因此流失用户。</p>\n<p>还有一种情况，当这些 API 调用是在非关键流程上。若调用成功，则继续执行；若调用失败，直接忽略也不会影响。</p>\n<p>对于第一种情况，除了在 fail 里做异常处理以外，别无他法。</p>\n<p>本文将进一步讨论第二种情况。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>官方提供的 API，在发生异常时，均会通过回调函数 <code>fail</code> 回传错误信息。如果我们能采集这些数据，进行统计分析能有这些作用：</p>\n<ul>\n<li>为后续技术优化提供指导方向</li>\n<li>了解用户设备的兼容性，预防踩重复的坑</li>\n</ul>\n<p>由于官方提供的 API，所有的异步方法都需要手动传入 <code>fail</code>，因此手动给每个方法传入 <code>fail</code> 可能是不可行的。</p>\n<p>另外，小程序的更新频率很高，每隔一段时间就会出现许多新的API。</p>\n<p>因此，最佳的实践即是封装全局对象 <code>wx</code></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>封装 <code>wx</code> 的方案有很多，这里就列出两种比较常规的方案：</p>\n<ul>\n<li>较安全的方案：在全局变量 <code>global</code> 上新增方法（如：<code>global.wx</code>）</li>\n<li>较激进的方案：劫持 <code>wx</code>，直接在 <code>wx</code> 上动刀</li>\n</ul>\n<p>两种方案可有利弊，要看如何权衡。以下我将以第二种方案举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// global.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx;</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;  <span class=\"comment\">// [0]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunction = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>); <span class=\"comment\">// 同步函数 [1]</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunction = <span class=\"keyword\">typeof</span> originalWX[name] !== <span class=\"string\">&#x27;function&#x27;</span>; <span class=\"comment\">// 非函数 [2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunction || isNotFunction) <span class=\"keyword\">return</span> originalWX[name];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj === <span class=\"string\">&#x27;object&#x27;</span>) &#123; <span class=\"comment\">// [3]</span></span><br><span class=\"line\">                    <span class=\"keyword\">let</span> originalFail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;fail&#x27;</span> <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">                        originalFail = obj.fail;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    obj.fail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// todo 上报数据到后端 [4]</span></span><br><span class=\"line\">                        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hijack success&#x27;</span>);</span><br><span class=\"line\">                        originalFail();</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> originalWX[name](obj);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码注释：</p>\n<ul>\n<li>[0]： 这里使用的是ES6提供的<code>Proxy</code>代理对象；会有一定的兼容性，如果需要兼容更低版本的机型，可采用其他方案（感兴趣的人多的话，后续补上）</li>\n<li>[1]：前文也提到，只有异步方法才会有回调，因此同步方法直接返回原<code>wx</code>的方法</li>\n<li>[2]：非函数；wx对象里有非函数的值，如 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/base/env/env.html\">wx.env</a></li>\n<li>[3]：wx对象里的函数，可能传入非对象参数。如：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/base/wx.canIUse.html\">wx.canIUse</a></li>\n<li>[4]：请看下一章节</li>\n</ul>\n<p><img src=\"/blog/images/miniprogram/caniuse-proxy.png\" alt=\" \"></p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>其实上述的代码，还不是最终版本。因为数据上报部分，还依赖后端提供接口。</p>\n<p>按理说，日志系统也算是通用的服务。我很早前就在思考，为什么微信官方不提供呢？细心的读者可能会反驳说，微信有提供类似的功能：<strong>wx.reportMonitor（业务数据监控上报接口）</strong>。</p>\n<p>其实，用过的读者应该了解，这个接口是非实时的，不能算是日志服务。</p>\n<p>如果你有不定时翻看微信小程序开发文档的习惯的话，你总会有这样的感觉：时不时就新增了一个特性，塞在了一个不容易发现的角落。接下来要讲的新特性，就是官方提供的 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/realtimelog/\">实时日志</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> log = wx.getRealtimeLogManager ? wx.getRealtimeLogManager() : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">log &amp;&amp; log.info.apply(log, <span class=\"built_in\">arguments</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所有的日志，都可以通过 <strong>小程序管理后台</strong> 查看。</p>\n<blockquote>\n<p>访问路径：[ 开发-&gt;运维中心-&gt;实时日志 ]</p>\n</blockquote>\n<p><img src=\"/blog/images/miniprogram/realtime-log.jpg\" alt=\" \"></p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<blockquote>\n<p>其实，错误（异常）处理在任何编程语言里，都是不可避免的。正确处理异常，是一个程序/应用保持健壮的关键。</p>\n</blockquote>","more":"<h2 id=\"现实\"><a href=\"#现实\" class=\"headerlink\" title=\"现实\"></a>现实</h2><p>从小程序的 API 文档可以看出，每个异步方法都支持传入一个 <code>fail</code> 方法，用于异常处理，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.login(&#123;</span><br><span class=\"line\">  success (res) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">fail</span>(<span class=\"params\">err</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle error</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>会存在这样一种情况：开发人员会因为惰性直接忽略这个参数；而测试人员由于无法 mock 这些错误情况，导致测试用例没有覆盖，最终可能会因此流失用户。</p>\n<p>还有一种情况，当这些 API 调用是在非关键流程上。若调用成功，则继续执行；若调用失败，直接忽略也不会影响。</p>\n<p>对于第一种情况，除了在 fail 里做异常处理以外，别无他法。</p>\n<p>本文将进一步讨论第二种情况。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>官方提供的 API，在发生异常时，均会通过回调函数 <code>fail</code> 回传错误信息。如果我们能采集这些数据，进行统计分析能有这些作用：</p>\n<ul>\n<li>为后续技术优化提供指导方向</li>\n<li>了解用户设备的兼容性，预防踩重复的坑</li>\n</ul>\n<p>由于官方提供的 API，所有的异步方法都需要手动传入 <code>fail</code>，因此手动给每个方法传入 <code>fail</code> 可能是不可行的。</p>\n<p>另外，小程序的更新频率很高，每隔一段时间就会出现许多新的API。</p>\n<p>因此，最佳的实践即是封装全局对象 <code>wx</code></p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>封装 <code>wx</code> 的方案有很多，这里就列出两种比较常规的方案：</p>\n<ul>\n<li>较安全的方案：在全局变量 <code>global</code> 上新增方法（如：<code>global.wx</code>）</li>\n<li>较激进的方案：劫持 <code>wx</code>，直接在 <code>wx</code> 上动刀</li>\n</ul>\n<p>两种方案可有利弊，要看如何权衡。以下我将以第二种方案举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// global.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> originalWX = wx;</span><br><span class=\"line\">wx = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;  <span class=\"comment\">// [0]</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">target, name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> originalWX ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> isSyncFunction = name.endsWith(<span class=\"string\">&#x27;Sync&#x27;</span>); <span class=\"comment\">// 同步函数 [1]</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> isNotFunction = <span class=\"keyword\">typeof</span> originalWX[name] !== <span class=\"string\">&#x27;function&#x27;</span>; <span class=\"comment\">// 非函数 [2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSyncFunction || isNotFunction) <span class=\"keyword\">return</span> originalWX[name];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj === <span class=\"string\">&#x27;object&#x27;</span>) &#123; <span class=\"comment\">// [3]</span></span><br><span class=\"line\">                    <span class=\"keyword\">let</span> originalFail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;fail&#x27;</span> <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">                        originalFail = obj.fail;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    obj.fail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// todo 上报数据到后端 [4]</span></span><br><span class=\"line\">                        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;hijack success&#x27;</span>);</span><br><span class=\"line\">                        originalFail();</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> originalWX[name](obj);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码注释：</p>\n<ul>\n<li>[0]： 这里使用的是ES6提供的<code>Proxy</code>代理对象；会有一定的兼容性，如果需要兼容更低版本的机型，可采用其他方案（感兴趣的人多的话，后续补上）</li>\n<li>[1]：前文也提到，只有异步方法才会有回调，因此同步方法直接返回原<code>wx</code>的方法</li>\n<li>[2]：非函数；wx对象里有非函数的值，如 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/base/env/env.html\">wx.env</a></li>\n<li>[3]：wx对象里的函数，可能传入非对象参数。如：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/base/wx.canIUse.html\">wx.canIUse</a></li>\n<li>[4]：请看下一章节</li>\n</ul>\n<p><img src=\"/blog/images/miniprogram/caniuse-proxy.png\" alt=\" \"></p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>其实上述的代码，还不是最终版本。因为数据上报部分，还依赖后端提供接口。</p>\n<p>按理说，日志系统也算是通用的服务。我很早前就在思考，为什么微信官方不提供呢？细心的读者可能会反驳说，微信有提供类似的功能：<strong>wx.reportMonitor（业务数据监控上报接口）</strong>。</p>\n<p>其实，用过的读者应该了解，这个接口是非实时的，不能算是日志服务。</p>\n<p>如果你有不定时翻看微信小程序开发文档的习惯的话，你总会有这样的感觉：时不时就新增了一个特性，塞在了一个不容易发现的角落。接下来要讲的新特性，就是官方提供的 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/realtimelog/\">实时日志</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> log = wx.getRealtimeLogManager ? wx.getRealtimeLogManager() : <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">log &amp;&amp; log.info.apply(log, <span class=\"built_in\">arguments</span>)</span><br></pre></td></tr></table></figure>\n\n<p>所有的日志，都可以通过 <strong>小程序管理后台</strong> 查看。</p>\n<blockquote>\n<p>访问路径：[ 开发-&gt;运维中心-&gt;实时日志 ]</p>\n</blockquote>\n<p><img src=\"/blog/images/miniprogram/realtime-log.jpg\" alt=\" \"></p>"},{"title":"小程序加载性能优化实践","date":"2020-05-27T11:16:55.000Z","_content":"\n# 前言\n\n对于互联网产品来说，第一印象就是应用的启动速度。虽然启动足够快时用户不会有很大的感知，但是如果慢就会被发现就会被挑战，总结来说，快就是应该的。\n\n而应用的启动速度优化，又可以分成首次启动速度优化和二次启动速度优化。对于不同的类型，对应的优化方案也是截然不同的。要如何确定优化方向以及优先级呢，这就要从具体的业务场景出发。\n\n<!-- more -->\n\n# 业务场景\n\n但凡不谈业务场景就直接谈优化都是不够专业的。\n\n本次优化实践主要是依托在微保的车险业务。\n\n众所周知，车险一般都是一年期的保险。因此车险用户的访问频次非常低，一年一次。其次，因监管要求，用户在投保车险之前，必须要先完成实名认证；认证通过之后才能添加要投保的车辆。因此一个用户要想完成投保，一定要经过实名认证、添加车辆、报价、支付、完成投保等步骤。\n\n另外，为了优化用户访问频次低的问题，平台通常会提供一些车主必备服务。以提升用户活跃度。\n\n由此可见，微保车险的业务矩阵大致如下：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8322c2918f~tplv-t2oaga2asx-image.image)\n\n相较于车主服务，主流程的性能显得更为重要，毕竟涉及到成交的流程才是关键。因此，本次总结也是在 **主流程** 上优化实践得出的。\n\n# 优化方向\n\n绝大多数车主用户只拥有一辆汽车。因此一年之中就只有一次购买车险的机会。对于如此低频的产品，每次用户过来，都是全新的UI，全新的代码。相当于每次过来都是首次启动，此时 **首次启动速度** 就显得极为重要。这也是本次优化的主要方向。\n\n我们参考Google提出的RAIL性能模型目标。\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327b49bed~tplv-t2oaga2asx-image.image)\n\n- 以用户为中心；最终目标不是让您的网站在任何特定设备上都能运行很快，而是使大部分用户满意。\n- 立即响应用户；在 100 毫秒以内确认用户输入。\n- 设置动画或滚动时，在 10 毫秒以内生成帧。\n- 最大程度增加主线程的空闲时间。\n- 持续吸引用户；在 1000 毫秒以内呈现交互内容。\n\n总结起来，我们的第一优化原则就是，**保证绝大多数**的用户能够较快地访问我们的应用。\n\n# 准备工作\n\n展开性能优化工作之前，还有一个重要的准备工作。即要预先采集基准数据。有了基准数据，才能很好地衡量自己的优化效果。\n\n微信公众平台虽有提供小程序启动耗时、下载耗时的图表，但由于不能提供原始数据，不利于细化分析，因此本次性能优化采用的是自建日志上报系统提供的数据。\n\n确定好性能指标，获取到相关数据，这还不够。\n\n由于现实网络环境非常复杂，收集的原始数据是非常粗犷的，相同的代码，相同的配置，在不同的网络环境和手机上，加载时间会千差万别。因此对于收集到各种极端数据，必须要做一定的加工处理，才能变成可分析的数据：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83237d3aa9~tplv-t2oaga2asx-image.image)\n\n常见的加工处理（指标计算口径）主要如下几种：\n\n- **平均数：** 最直接的想法，计算所有数据的平均值。但是平均数会因为部分极端值导致偏大，会观察到数据的波动较大，因此平均数不适合作为参考指标。\n- **95分位数：** 将所有数据从小到大排列，取第 95%位置的数值，将这个值作为我们的性能指标。\n- **截尾平均数：** 同样将所有数据顺序排列，将尾部的部分数据移除，然后取平均值。这个值会相对平稳，比较适合作为参考指标。\n\n结合前面提到的第一优化原则，明显 **截尾平均数** 这种指标计算口径是最佳选择。\n\n比如假设我们承诺保证90%的用户在1000ms内完成小程序的加载，那么我们就只要关注前90%的用户的加载耗时是否在1000ms内即可。\n\n通过截尾获得耗时较少的前50%、80%、90%用户的平均加载耗时数据（后续横向分析这三类用户的加载耗时的优化效果）\n\n处理好数据之后，进行性能分析的时，可以如下进行分类分析：\n\n-   按手机系统（Android、iOS）分类\n-   按网络环境（WIFI和4G）分类\n\n以下是采集的 **4G网络下，不区分手机系统** 的车险分包的加载耗时（作为优化前的基线数据）：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327c663c2~tplv-t2oaga2asx-image.image)\n\n# 实践\n\n由于小程序有提供许多基础API、UI库，而这部分代码是每个小程序的依赖。因此初始化代码的时候，这个是最先初始化的，渲染流程大致如下：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f832a7c0123~tplv-t2oaga2asx-image.image)\n\n相对于传统web，我们能在很多环节上做优化。比如资源加载顺序（图片懒加载、CSS前置加载，JS后置加载等），使用构建工具实现按需加载等。但小程序的底层逻辑比较封闭，我们无法深入参与，因此要优化小程序的加载性能，能做且最行之有效的方案就是优化小程序代码包的大小。\n\n优化代码包大小的方案主要有以下几种：\n- 移除未使用的代码\n- 实现代码按需加载（在小程序里，即是采用分包加载方案）\n- 移除小程序包里的图片资源（因为小程序包下载时，默认使用了gzip压缩，而非文本的压缩效率较低）\n- 简化JavaScript，尽量避免在前端进行复杂的计算（将JS逻辑尽量迁移至后端或者采用Nodejs中台来完成这部分计算工作，这样也利于后续扩展到多平台）\n\n## 移除未使用的代码\n\n由于车险是微保最先推出的产品，经历了无数多个迭代，不可避免会出现已下线的业务或功能。这部分代码一般都是以页面为单位，因此可以结合PV数据来找到这部分代码。\n\n提到PV数据，顺带提一下如何自建日志上报系统。由于小程序的每个页面都有完整的生命周期，因此进入一个新页面时，都会触发Page的onLoad方法，此时通过向后台服务上报进入页面的信息，即可完成页面PV数据统计。\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83395e7ced~tplv-t2oaga2asx-image.image)\n\n对于如何实现错误路径的重定向处理，提供两个思路：\n\n1.  小程序提供的路由能力（如`wx.navigateTo`），当传入的url不存在时，会触发 `fail` 方法，此时在 `fail` 处理下即可。\n2.  使用 `wx.onPageNotFound` 方法处理，不过有一定的兼容性问题。\n\n移除未使用的代码之后，车险分包由 1100+KB 降到 **900+KB** （减小18%）\n\n## 代码按需加载\n\n理想情况下，访问用户应该只下载有访问到的资源，其他资源一概等到需要的时候才下载。这种按需加载的方案，小程序是采用代码分包的方式处理。但由于分包与分包之间无法相互引用资源，无法复用代码，因此拆分分包必然导致开发的效率下降。因此拆分分包时，要把握好性能与效率的平衡。\n\n由此，我们提出了 **基于UV及访问路径的分包拆分原则** 。\n\n结合日志系统，我们发现车险的实名认证页是UV大户，而实名认证的逻辑和添加车辆、编辑车辆的逻辑比较类似，均包含了车辆管理逻辑和组件。因此这部分页面的代码相似度较高，比较适合拆成一个分包，最终将实名认证、车辆管理等页面拆分到：新用户分包A。\n\n其次，通过观察页面漏斗数据发现，大部分的用户只访问了主流程上的页面：车险首页、报价页、支付页、保单详情页。至于调整方案页、车辆列表页等分支流程，只有少部分用户会访问到的。因此将主流程的页面拆分成主分包B，而其他所有分支流程的页面则拆分成另外一个分包：其他分包C。\n\n最后将车险的分包拆分成如下：\n- 包含实名认证、车辆管理流程的新用户分包A（200+KB）\n- 包含主流程的主分包B（400+KB）\n- 包含分支流程的其他分包C（100+KB）\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8341f3d701~tplv-t2oaga2asx-image.image)\n\n对于新用户（未完成实名认证），通过预检测实名情况，分发不同路径，从而实现新用户仅先加载新用户分包A，与此同时预加载主分包B。因此对于新用户来说，首次加载的是200+KB的新用户分包A，相对于优化前加载的900+KB完整分包，加载的小程序分包大小减少了78%。\n\n对于旧用户（已完成实名认证），不再加载新用户分包A，与此同时预加载了其他分包C，因此加载的小程序分包大小减少了56%。\n\n## 简化JavaScript\n\n这部分优化与传统web开发的优化原理类似。\n\n代码包下载完成之后，就要完成业务代码注入。这时，JS引擎就要解析/编译JavaScript，这也是JS引擎最耗时的操作，从Chrome开发者工具可以看到，其中黄色部分就是解析/编译耗时的部分：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f834167f0c6~tplv-t2oaga2asx-image.image)\n\n因历史遗留问题，导致一些复杂的数据需要前端拼凑计算处理（如可续保车辆的计算等）。将这部分逻辑迁移至后端后，JavaScript的代码得到了进一步简化，只对最终数据做基本展示变换。\n\n由于本次实践没有深入这方面的优化，故不详细叙述这块优化的效果，后续有机会另外开篇文章详细讲。\n\n# 遇到的问题\n\n在本次优化实践的过程中，遇到了许多问题，和大家分享一下我们的处理办法。\n\n第一个遇到的问题，就是组件的引用。\n\n因为小程序的限制，组件不能跨分包互相引用，要想跨分包复用，就要将组件放在小程序主包，而主包的代码是跨业务共有的，不能随意添加。因此在拆分分包的时候，需考虑到这个问题。\n\n其次，是JS公共库的引用问题。\n\n原本在同一个分包时，通过相对路径引入即可。但拆分成多个分包之后，JS就无法直接引用了。此时需要变换思路，如：将JS公共库挂载到全局变量global上；或者将代码copy一份到其他分包上（当然不是直接copy，是通过gulp或者webpack打包）；又或者将公共库放在主包上。\n\n还有更让人头疼的是，目录变更导致的路由跳转问题。\n\n由于小程序分包机制要求每个分包都在一个目录里。因此拆分分包就不可避免地要对文件进行迁移，而小程序的跳转又和文件目录强耦合，文件路径变更导致跳转路径变化。因此涉及到的页面的跳转路径均要改变。\n\n此时，还要考虑向前兼容，比如已推送的模板通知。因此路由跳转的封装就显得极为必要。\n\n# 效果\n\n经历以上的抽茧剥丝，终于等到了上线时间，可以到看，优化的效果非常明显：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83466d3d75~tplv-t2oaga2asx-image.image)\n\n横向对比不同分类的用户，可以更清晰看到各类用户的提升情况：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8348a6b8e4~tplv-t2oaga2asx-image.image)\n\n对于较快的前50%用户，也提升了接近50%的访问速度。\n\n此次优化，保证了90%的用户可以在2000ms内完成小程序的加载。\n\n# 后续优化\n\n对于接下来的优化工作，我们仍有几个计划：\n\n充分利用小程序提供的预下载分包功能。若没有设置预下载，用户在跳转其他分包页面时，就要等待分包的下载。对于比较急躁的用户，会以为卡机了，最终导致用户跳出。（小程序预下载的唯一限制就是，当前分包和预下载的分包大小之和不能超出2M，如果超出，可以考虑再次拆分分包）\n\n简化WXML的class。类选择器是最常见的样式选择器，当页面变得庞大时，class的长度往往会越来越长。然而在不支持DOM操作的小程序里，class的主要作用主要是样式注入。因此可以通过脚本将WXML和WXSS相同的class统一精简成短小的命名。\n\n采用Node.js中台转移部分计算。将JavaScript的代码进一步简化，这样有利于对小程序的加载性能进一步优化。其次，这样也有利用扩展到其他平台，比如H5等。\n\n# 总结\n\n尽管看似微信小程序的开发、发布方式和传统web有很大的差异。但是底层的运行还是类似的，因此可以从传统的web优化实践中找到优化的思路。\n\n其中本文提到的一些优化实践是非常定制化的，是根据特殊的业务场景采取的特殊方式处理。毫无疑问，业务在发展，代码也会随着发生变动，这就需要不断的优化，才让用户的体验愈来愈好。\n\n感谢大家阅读，如有错误，欢迎指正，感谢。","source":"_posts/miniprogram/performance-optimization.md","raw":"---\ntitle: 小程序加载性能优化实践\ndate: 2020-05-27 19:16:55\ntags:\n---\n\n# 前言\n\n对于互联网产品来说，第一印象就是应用的启动速度。虽然启动足够快时用户不会有很大的感知，但是如果慢就会被发现就会被挑战，总结来说，快就是应该的。\n\n而应用的启动速度优化，又可以分成首次启动速度优化和二次启动速度优化。对于不同的类型，对应的优化方案也是截然不同的。要如何确定优化方向以及优先级呢，这就要从具体的业务场景出发。\n\n<!-- more -->\n\n# 业务场景\n\n但凡不谈业务场景就直接谈优化都是不够专业的。\n\n本次优化实践主要是依托在微保的车险业务。\n\n众所周知，车险一般都是一年期的保险。因此车险用户的访问频次非常低，一年一次。其次，因监管要求，用户在投保车险之前，必须要先完成实名认证；认证通过之后才能添加要投保的车辆。因此一个用户要想完成投保，一定要经过实名认证、添加车辆、报价、支付、完成投保等步骤。\n\n另外，为了优化用户访问频次低的问题，平台通常会提供一些车主必备服务。以提升用户活跃度。\n\n由此可见，微保车险的业务矩阵大致如下：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8322c2918f~tplv-t2oaga2asx-image.image)\n\n相较于车主服务，主流程的性能显得更为重要，毕竟涉及到成交的流程才是关键。因此，本次总结也是在 **主流程** 上优化实践得出的。\n\n# 优化方向\n\n绝大多数车主用户只拥有一辆汽车。因此一年之中就只有一次购买车险的机会。对于如此低频的产品，每次用户过来，都是全新的UI，全新的代码。相当于每次过来都是首次启动，此时 **首次启动速度** 就显得极为重要。这也是本次优化的主要方向。\n\n我们参考Google提出的RAIL性能模型目标。\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327b49bed~tplv-t2oaga2asx-image.image)\n\n- 以用户为中心；最终目标不是让您的网站在任何特定设备上都能运行很快，而是使大部分用户满意。\n- 立即响应用户；在 100 毫秒以内确认用户输入。\n- 设置动画或滚动时，在 10 毫秒以内生成帧。\n- 最大程度增加主线程的空闲时间。\n- 持续吸引用户；在 1000 毫秒以内呈现交互内容。\n\n总结起来，我们的第一优化原则就是，**保证绝大多数**的用户能够较快地访问我们的应用。\n\n# 准备工作\n\n展开性能优化工作之前，还有一个重要的准备工作。即要预先采集基准数据。有了基准数据，才能很好地衡量自己的优化效果。\n\n微信公众平台虽有提供小程序启动耗时、下载耗时的图表，但由于不能提供原始数据，不利于细化分析，因此本次性能优化采用的是自建日志上报系统提供的数据。\n\n确定好性能指标，获取到相关数据，这还不够。\n\n由于现实网络环境非常复杂，收集的原始数据是非常粗犷的，相同的代码，相同的配置，在不同的网络环境和手机上，加载时间会千差万别。因此对于收集到各种极端数据，必须要做一定的加工处理，才能变成可分析的数据：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83237d3aa9~tplv-t2oaga2asx-image.image)\n\n常见的加工处理（指标计算口径）主要如下几种：\n\n- **平均数：** 最直接的想法，计算所有数据的平均值。但是平均数会因为部分极端值导致偏大，会观察到数据的波动较大，因此平均数不适合作为参考指标。\n- **95分位数：** 将所有数据从小到大排列，取第 95%位置的数值，将这个值作为我们的性能指标。\n- **截尾平均数：** 同样将所有数据顺序排列，将尾部的部分数据移除，然后取平均值。这个值会相对平稳，比较适合作为参考指标。\n\n结合前面提到的第一优化原则，明显 **截尾平均数** 这种指标计算口径是最佳选择。\n\n比如假设我们承诺保证90%的用户在1000ms内完成小程序的加载，那么我们就只要关注前90%的用户的加载耗时是否在1000ms内即可。\n\n通过截尾获得耗时较少的前50%、80%、90%用户的平均加载耗时数据（后续横向分析这三类用户的加载耗时的优化效果）\n\n处理好数据之后，进行性能分析的时，可以如下进行分类分析：\n\n-   按手机系统（Android、iOS）分类\n-   按网络环境（WIFI和4G）分类\n\n以下是采集的 **4G网络下，不区分手机系统** 的车险分包的加载耗时（作为优化前的基线数据）：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327c663c2~tplv-t2oaga2asx-image.image)\n\n# 实践\n\n由于小程序有提供许多基础API、UI库，而这部分代码是每个小程序的依赖。因此初始化代码的时候，这个是最先初始化的，渲染流程大致如下：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f832a7c0123~tplv-t2oaga2asx-image.image)\n\n相对于传统web，我们能在很多环节上做优化。比如资源加载顺序（图片懒加载、CSS前置加载，JS后置加载等），使用构建工具实现按需加载等。但小程序的底层逻辑比较封闭，我们无法深入参与，因此要优化小程序的加载性能，能做且最行之有效的方案就是优化小程序代码包的大小。\n\n优化代码包大小的方案主要有以下几种：\n- 移除未使用的代码\n- 实现代码按需加载（在小程序里，即是采用分包加载方案）\n- 移除小程序包里的图片资源（因为小程序包下载时，默认使用了gzip压缩，而非文本的压缩效率较低）\n- 简化JavaScript，尽量避免在前端进行复杂的计算（将JS逻辑尽量迁移至后端或者采用Nodejs中台来完成这部分计算工作，这样也利于后续扩展到多平台）\n\n## 移除未使用的代码\n\n由于车险是微保最先推出的产品，经历了无数多个迭代，不可避免会出现已下线的业务或功能。这部分代码一般都是以页面为单位，因此可以结合PV数据来找到这部分代码。\n\n提到PV数据，顺带提一下如何自建日志上报系统。由于小程序的每个页面都有完整的生命周期，因此进入一个新页面时，都会触发Page的onLoad方法，此时通过向后台服务上报进入页面的信息，即可完成页面PV数据统计。\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83395e7ced~tplv-t2oaga2asx-image.image)\n\n对于如何实现错误路径的重定向处理，提供两个思路：\n\n1.  小程序提供的路由能力（如`wx.navigateTo`），当传入的url不存在时，会触发 `fail` 方法，此时在 `fail` 处理下即可。\n2.  使用 `wx.onPageNotFound` 方法处理，不过有一定的兼容性问题。\n\n移除未使用的代码之后，车险分包由 1100+KB 降到 **900+KB** （减小18%）\n\n## 代码按需加载\n\n理想情况下，访问用户应该只下载有访问到的资源，其他资源一概等到需要的时候才下载。这种按需加载的方案，小程序是采用代码分包的方式处理。但由于分包与分包之间无法相互引用资源，无法复用代码，因此拆分分包必然导致开发的效率下降。因此拆分分包时，要把握好性能与效率的平衡。\n\n由此，我们提出了 **基于UV及访问路径的分包拆分原则** 。\n\n结合日志系统，我们发现车险的实名认证页是UV大户，而实名认证的逻辑和添加车辆、编辑车辆的逻辑比较类似，均包含了车辆管理逻辑和组件。因此这部分页面的代码相似度较高，比较适合拆成一个分包，最终将实名认证、车辆管理等页面拆分到：新用户分包A。\n\n其次，通过观察页面漏斗数据发现，大部分的用户只访问了主流程上的页面：车险首页、报价页、支付页、保单详情页。至于调整方案页、车辆列表页等分支流程，只有少部分用户会访问到的。因此将主流程的页面拆分成主分包B，而其他所有分支流程的页面则拆分成另外一个分包：其他分包C。\n\n最后将车险的分包拆分成如下：\n- 包含实名认证、车辆管理流程的新用户分包A（200+KB）\n- 包含主流程的主分包B（400+KB）\n- 包含分支流程的其他分包C（100+KB）\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8341f3d701~tplv-t2oaga2asx-image.image)\n\n对于新用户（未完成实名认证），通过预检测实名情况，分发不同路径，从而实现新用户仅先加载新用户分包A，与此同时预加载主分包B。因此对于新用户来说，首次加载的是200+KB的新用户分包A，相对于优化前加载的900+KB完整分包，加载的小程序分包大小减少了78%。\n\n对于旧用户（已完成实名认证），不再加载新用户分包A，与此同时预加载了其他分包C，因此加载的小程序分包大小减少了56%。\n\n## 简化JavaScript\n\n这部分优化与传统web开发的优化原理类似。\n\n代码包下载完成之后，就要完成业务代码注入。这时，JS引擎就要解析/编译JavaScript，这也是JS引擎最耗时的操作，从Chrome开发者工具可以看到，其中黄色部分就是解析/编译耗时的部分：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f834167f0c6~tplv-t2oaga2asx-image.image)\n\n因历史遗留问题，导致一些复杂的数据需要前端拼凑计算处理（如可续保车辆的计算等）。将这部分逻辑迁移至后端后，JavaScript的代码得到了进一步简化，只对最终数据做基本展示变换。\n\n由于本次实践没有深入这方面的优化，故不详细叙述这块优化的效果，后续有机会另外开篇文章详细讲。\n\n# 遇到的问题\n\n在本次优化实践的过程中，遇到了许多问题，和大家分享一下我们的处理办法。\n\n第一个遇到的问题，就是组件的引用。\n\n因为小程序的限制，组件不能跨分包互相引用，要想跨分包复用，就要将组件放在小程序主包，而主包的代码是跨业务共有的，不能随意添加。因此在拆分分包的时候，需考虑到这个问题。\n\n其次，是JS公共库的引用问题。\n\n原本在同一个分包时，通过相对路径引入即可。但拆分成多个分包之后，JS就无法直接引用了。此时需要变换思路，如：将JS公共库挂载到全局变量global上；或者将代码copy一份到其他分包上（当然不是直接copy，是通过gulp或者webpack打包）；又或者将公共库放在主包上。\n\n还有更让人头疼的是，目录变更导致的路由跳转问题。\n\n由于小程序分包机制要求每个分包都在一个目录里。因此拆分分包就不可避免地要对文件进行迁移，而小程序的跳转又和文件目录强耦合，文件路径变更导致跳转路径变化。因此涉及到的页面的跳转路径均要改变。\n\n此时，还要考虑向前兼容，比如已推送的模板通知。因此路由跳转的封装就显得极为必要。\n\n# 效果\n\n经历以上的抽茧剥丝，终于等到了上线时间，可以到看，优化的效果非常明显：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83466d3d75~tplv-t2oaga2asx-image.image)\n\n横向对比不同分类的用户，可以更清晰看到各类用户的提升情况：\n\n![ ](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8348a6b8e4~tplv-t2oaga2asx-image.image)\n\n对于较快的前50%用户，也提升了接近50%的访问速度。\n\n此次优化，保证了90%的用户可以在2000ms内完成小程序的加载。\n\n# 后续优化\n\n对于接下来的优化工作，我们仍有几个计划：\n\n充分利用小程序提供的预下载分包功能。若没有设置预下载，用户在跳转其他分包页面时，就要等待分包的下载。对于比较急躁的用户，会以为卡机了，最终导致用户跳出。（小程序预下载的唯一限制就是，当前分包和预下载的分包大小之和不能超出2M，如果超出，可以考虑再次拆分分包）\n\n简化WXML的class。类选择器是最常见的样式选择器，当页面变得庞大时，class的长度往往会越来越长。然而在不支持DOM操作的小程序里，class的主要作用主要是样式注入。因此可以通过脚本将WXML和WXSS相同的class统一精简成短小的命名。\n\n采用Node.js中台转移部分计算。将JavaScript的代码进一步简化，这样有利于对小程序的加载性能进一步优化。其次，这样也有利用扩展到其他平台，比如H5等。\n\n# 总结\n\n尽管看似微信小程序的开发、发布方式和传统web有很大的差异。但是底层的运行还是类似的，因此可以从传统的web优化实践中找到优化的思路。\n\n其中本文提到的一些优化实践是非常定制化的，是根据特殊的业务场景采取的特殊方式处理。毫无疑问，业务在发展，代码也会随着发生变动，这就需要不断的优化，才让用户的体验愈来愈好。\n\n感谢大家阅读，如有错误，欢迎指正，感谢。","slug":"miniprogram/performance-optimization","published":1,"updated":"2023-08-04T11:18:00.449Z","_id":"clkwhqxi6000d3tsz05wy12li","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>对于互联网产品来说，第一印象就是应用的启动速度。虽然启动足够快时用户不会有很大的感知，但是如果慢就会被发现就会被挑战，总结来说，快就是应该的。</p>\n<p>而应用的启动速度优化，又可以分成首次启动速度优化和二次启动速度优化。对于不同的类型，对应的优化方案也是截然不同的。要如何确定优化方向以及优先级呢，这就要从具体的业务场景出发。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h1><p>但凡不谈业务场景就直接谈优化都是不够专业的。</p>\n<p>本次优化实践主要是依托在微保的车险业务。</p>\n<p>众所周知，车险一般都是一年期的保险。因此车险用户的访问频次非常低，一年一次。其次，因监管要求，用户在投保车险之前，必须要先完成实名认证；认证通过之后才能添加要投保的车辆。因此一个用户要想完成投保，一定要经过实名认证、添加车辆、报价、支付、完成投保等步骤。</p>\n<p>另外，为了优化用户访问频次低的问题，平台通常会提供一些车主必备服务。以提升用户活跃度。</p>\n<p>由此可见，微保车险的业务矩阵大致如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8322c2918f~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>相较于车主服务，主流程的性能显得更为重要，毕竟涉及到成交的流程才是关键。因此，本次总结也是在 <strong>主流程</strong> 上优化实践得出的。</p>\n<h1 id=\"优化方向\"><a href=\"#优化方向\" class=\"headerlink\" title=\"优化方向\"></a>优化方向</h1><p>绝大多数车主用户只拥有一辆汽车。因此一年之中就只有一次购买车险的机会。对于如此低频的产品，每次用户过来，都是全新的UI，全新的代码。相当于每次过来都是首次启动，此时 <strong>首次启动速度</strong> 就显得极为重要。这也是本次优化的主要方向。</p>\n<p>我们参考Google提出的RAIL性能模型目标。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327b49bed~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<ul>\n<li>以用户为中心；最终目标不是让您的网站在任何特定设备上都能运行很快，而是使大部分用户满意。</li>\n<li>立即响应用户；在 100 毫秒以内确认用户输入。</li>\n<li>设置动画或滚动时，在 10 毫秒以内生成帧。</li>\n<li>最大程度增加主线程的空闲时间。</li>\n<li>持续吸引用户；在 1000 毫秒以内呈现交互内容。</li>\n</ul>\n<p>总结起来，我们的第一优化原则就是，<strong>保证绝大多数</strong>的用户能够较快地访问我们的应用。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>展开性能优化工作之前，还有一个重要的准备工作。即要预先采集基准数据。有了基准数据，才能很好地衡量自己的优化效果。</p>\n<p>微信公众平台虽有提供小程序启动耗时、下载耗时的图表，但由于不能提供原始数据，不利于细化分析，因此本次性能优化采用的是自建日志上报系统提供的数据。</p>\n<p>确定好性能指标，获取到相关数据，这还不够。</p>\n<p>由于现实网络环境非常复杂，收集的原始数据是非常粗犷的，相同的代码，相同的配置，在不同的网络环境和手机上，加载时间会千差万别。因此对于收集到各种极端数据，必须要做一定的加工处理，才能变成可分析的数据：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83237d3aa9~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>常见的加工处理（指标计算口径）主要如下几种：</p>\n<ul>\n<li><strong>平均数：</strong> 最直接的想法，计算所有数据的平均值。但是平均数会因为部分极端值导致偏大，会观察到数据的波动较大，因此平均数不适合作为参考指标。</li>\n<li><strong>95分位数：</strong> 将所有数据从小到大排列，取第 95%位置的数值，将这个值作为我们的性能指标。</li>\n<li><strong>截尾平均数：</strong> 同样将所有数据顺序排列，将尾部的部分数据移除，然后取平均值。这个值会相对平稳，比较适合作为参考指标。</li>\n</ul>\n<p>结合前面提到的第一优化原则，明显 <strong>截尾平均数</strong> 这种指标计算口径是最佳选择。</p>\n<p>比如假设我们承诺保证90%的用户在1000ms内完成小程序的加载，那么我们就只要关注前90%的用户的加载耗时是否在1000ms内即可。</p>\n<p>通过截尾获得耗时较少的前50%、80%、90%用户的平均加载耗时数据（后续横向分析这三类用户的加载耗时的优化效果）</p>\n<p>处理好数据之后，进行性能分析的时，可以如下进行分类分析：</p>\n<ul>\n<li>  按手机系统（Android、iOS）分类</li>\n<li>  按网络环境（WIFI和4G）分类</li>\n</ul>\n<p>以下是采集的 <strong>4G网络下，不区分手机系统</strong> 的车险分包的加载耗时（作为优化前的基线数据）：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327c663c2~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>由于小程序有提供许多基础API、UI库，而这部分代码是每个小程序的依赖。因此初始化代码的时候，这个是最先初始化的，渲染流程大致如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f832a7c0123~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>相对于传统web，我们能在很多环节上做优化。比如资源加载顺序（图片懒加载、CSS前置加载，JS后置加载等），使用构建工具实现按需加载等。但小程序的底层逻辑比较封闭，我们无法深入参与，因此要优化小程序的加载性能，能做且最行之有效的方案就是优化小程序代码包的大小。</p>\n<p>优化代码包大小的方案主要有以下几种：</p>\n<ul>\n<li>移除未使用的代码</li>\n<li>实现代码按需加载（在小程序里，即是采用分包加载方案）</li>\n<li>移除小程序包里的图片资源（因为小程序包下载时，默认使用了gzip压缩，而非文本的压缩效率较低）</li>\n<li>简化JavaScript，尽量避免在前端进行复杂的计算（将JS逻辑尽量迁移至后端或者采用Nodejs中台来完成这部分计算工作，这样也利于后续扩展到多平台）</li>\n</ul>\n<h2 id=\"移除未使用的代码\"><a href=\"#移除未使用的代码\" class=\"headerlink\" title=\"移除未使用的代码\"></a>移除未使用的代码</h2><p>由于车险是微保最先推出的产品，经历了无数多个迭代，不可避免会出现已下线的业务或功能。这部分代码一般都是以页面为单位，因此可以结合PV数据来找到这部分代码。</p>\n<p>提到PV数据，顺带提一下如何自建日志上报系统。由于小程序的每个页面都有完整的生命周期，因此进入一个新页面时，都会触发Page的onLoad方法，此时通过向后台服务上报进入页面的信息，即可完成页面PV数据统计。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83395e7ced~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>对于如何实现错误路径的重定向处理，提供两个思路：</p>\n<ol>\n<li> 小程序提供的路由能力（如<code>wx.navigateTo</code>），当传入的url不存在时，会触发 <code>fail</code> 方法，此时在 <code>fail</code> 处理下即可。</li>\n<li> 使用 <code>wx.onPageNotFound</code> 方法处理，不过有一定的兼容性问题。</li>\n</ol>\n<p>移除未使用的代码之后，车险分包由 1100+KB 降到 <strong>900+KB</strong> （减小18%）</p>\n<h2 id=\"代码按需加载\"><a href=\"#代码按需加载\" class=\"headerlink\" title=\"代码按需加载\"></a>代码按需加载</h2><p>理想情况下，访问用户应该只下载有访问到的资源，其他资源一概等到需要的时候才下载。这种按需加载的方案，小程序是采用代码分包的方式处理。但由于分包与分包之间无法相互引用资源，无法复用代码，因此拆分分包必然导致开发的效率下降。因此拆分分包时，要把握好性能与效率的平衡。</p>\n<p>由此，我们提出了 <strong>基于UV及访问路径的分包拆分原则</strong> 。</p>\n<p>结合日志系统，我们发现车险的实名认证页是UV大户，而实名认证的逻辑和添加车辆、编辑车辆的逻辑比较类似，均包含了车辆管理逻辑和组件。因此这部分页面的代码相似度较高，比较适合拆成一个分包，最终将实名认证、车辆管理等页面拆分到：新用户分包A。</p>\n<p>其次，通过观察页面漏斗数据发现，大部分的用户只访问了主流程上的页面：车险首页、报价页、支付页、保单详情页。至于调整方案页、车辆列表页等分支流程，只有少部分用户会访问到的。因此将主流程的页面拆分成主分包B，而其他所有分支流程的页面则拆分成另外一个分包：其他分包C。</p>\n<p>最后将车险的分包拆分成如下：</p>\n<ul>\n<li>包含实名认证、车辆管理流程的新用户分包A（200+KB）</li>\n<li>包含主流程的主分包B（400+KB）</li>\n<li>包含分支流程的其他分包C（100+KB）</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8341f3d701~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>对于新用户（未完成实名认证），通过预检测实名情况，分发不同路径，从而实现新用户仅先加载新用户分包A，与此同时预加载主分包B。因此对于新用户来说，首次加载的是200+KB的新用户分包A，相对于优化前加载的900+KB完整分包，加载的小程序分包大小减少了78%。</p>\n<p>对于旧用户（已完成实名认证），不再加载新用户分包A，与此同时预加载了其他分包C，因此加载的小程序分包大小减少了56%。</p>\n<h2 id=\"简化JavaScript\"><a href=\"#简化JavaScript\" class=\"headerlink\" title=\"简化JavaScript\"></a>简化JavaScript</h2><p>这部分优化与传统web开发的优化原理类似。</p>\n<p>代码包下载完成之后，就要完成业务代码注入。这时，JS引擎就要解析/编译JavaScript，这也是JS引擎最耗时的操作，从Chrome开发者工具可以看到，其中黄色部分就是解析/编译耗时的部分：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f834167f0c6~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>因历史遗留问题，导致一些复杂的数据需要前端拼凑计算处理（如可续保车辆的计算等）。将这部分逻辑迁移至后端后，JavaScript的代码得到了进一步简化，只对最终数据做基本展示变换。</p>\n<p>由于本次实践没有深入这方面的优化，故不详细叙述这块优化的效果，后续有机会另外开篇文章详细讲。</p>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><p>在本次优化实践的过程中，遇到了许多问题，和大家分享一下我们的处理办法。</p>\n<p>第一个遇到的问题，就是组件的引用。</p>\n<p>因为小程序的限制，组件不能跨分包互相引用，要想跨分包复用，就要将组件放在小程序主包，而主包的代码是跨业务共有的，不能随意添加。因此在拆分分包的时候，需考虑到这个问题。</p>\n<p>其次，是JS公共库的引用问题。</p>\n<p>原本在同一个分包时，通过相对路径引入即可。但拆分成多个分包之后，JS就无法直接引用了。此时需要变换思路，如：将JS公共库挂载到全局变量global上；或者将代码copy一份到其他分包上（当然不是直接copy，是通过gulp或者webpack打包）；又或者将公共库放在主包上。</p>\n<p>还有更让人头疼的是，目录变更导致的路由跳转问题。</p>\n<p>由于小程序分包机制要求每个分包都在一个目录里。因此拆分分包就不可避免地要对文件进行迁移，而小程序的跳转又和文件目录强耦合，文件路径变更导致跳转路径变化。因此涉及到的页面的跳转路径均要改变。</p>\n<p>此时，还要考虑向前兼容，比如已推送的模板通知。因此路由跳转的封装就显得极为必要。</p>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>经历以上的抽茧剥丝，终于等到了上线时间，可以到看，优化的效果非常明显：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83466d3d75~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>横向对比不同分类的用户，可以更清晰看到各类用户的提升情况：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8348a6b8e4~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>对于较快的前50%用户，也提升了接近50%的访问速度。</p>\n<p>此次优化，保证了90%的用户可以在2000ms内完成小程序的加载。</p>\n<h1 id=\"后续优化\"><a href=\"#后续优化\" class=\"headerlink\" title=\"后续优化\"></a>后续优化</h1><p>对于接下来的优化工作，我们仍有几个计划：</p>\n<p>充分利用小程序提供的预下载分包功能。若没有设置预下载，用户在跳转其他分包页面时，就要等待分包的下载。对于比较急躁的用户，会以为卡机了，最终导致用户跳出。（小程序预下载的唯一限制就是，当前分包和预下载的分包大小之和不能超出2M，如果超出，可以考虑再次拆分分包）</p>\n<p>简化WXML的class。类选择器是最常见的样式选择器，当页面变得庞大时，class的长度往往会越来越长。然而在不支持DOM操作的小程序里，class的主要作用主要是样式注入。因此可以通过脚本将WXML和WXSS相同的class统一精简成短小的命名。</p>\n<p>采用Node.js中台转移部分计算。将JavaScript的代码进一步简化，这样有利于对小程序的加载性能进一步优化。其次，这样也有利用扩展到其他平台，比如H5等。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>尽管看似微信小程序的开发、发布方式和传统web有很大的差异。但是底层的运行还是类似的，因此可以从传统的web优化实践中找到优化的思路。</p>\n<p>其中本文提到的一些优化实践是非常定制化的，是根据特殊的业务场景采取的特殊方式处理。毫无疑问，业务在发展，代码也会随着发生变动，这就需要不断的优化，才让用户的体验愈来愈好。</p>\n<p>感谢大家阅读，如有错误，欢迎指正，感谢。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>对于互联网产品来说，第一印象就是应用的启动速度。虽然启动足够快时用户不会有很大的感知，但是如果慢就会被发现就会被挑战，总结来说，快就是应该的。</p>\n<p>而应用的启动速度优化，又可以分成首次启动速度优化和二次启动速度优化。对于不同的类型，对应的优化方案也是截然不同的。要如何确定优化方向以及优先级呢，这就要从具体的业务场景出发。</p>","more":"<h1 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h1><p>但凡不谈业务场景就直接谈优化都是不够专业的。</p>\n<p>本次优化实践主要是依托在微保的车险业务。</p>\n<p>众所周知，车险一般都是一年期的保险。因此车险用户的访问频次非常低，一年一次。其次，因监管要求，用户在投保车险之前，必须要先完成实名认证；认证通过之后才能添加要投保的车辆。因此一个用户要想完成投保，一定要经过实名认证、添加车辆、报价、支付、完成投保等步骤。</p>\n<p>另外，为了优化用户访问频次低的问题，平台通常会提供一些车主必备服务。以提升用户活跃度。</p>\n<p>由此可见，微保车险的业务矩阵大致如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8322c2918f~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>相较于车主服务，主流程的性能显得更为重要，毕竟涉及到成交的流程才是关键。因此，本次总结也是在 <strong>主流程</strong> 上优化实践得出的。</p>\n<h1 id=\"优化方向\"><a href=\"#优化方向\" class=\"headerlink\" title=\"优化方向\"></a>优化方向</h1><p>绝大多数车主用户只拥有一辆汽车。因此一年之中就只有一次购买车险的机会。对于如此低频的产品，每次用户过来，都是全新的UI，全新的代码。相当于每次过来都是首次启动，此时 <strong>首次启动速度</strong> 就显得极为重要。这也是本次优化的主要方向。</p>\n<p>我们参考Google提出的RAIL性能模型目标。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327b49bed~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<ul>\n<li>以用户为中心；最终目标不是让您的网站在任何特定设备上都能运行很快，而是使大部分用户满意。</li>\n<li>立即响应用户；在 100 毫秒以内确认用户输入。</li>\n<li>设置动画或滚动时，在 10 毫秒以内生成帧。</li>\n<li>最大程度增加主线程的空闲时间。</li>\n<li>持续吸引用户；在 1000 毫秒以内呈现交互内容。</li>\n</ul>\n<p>总结起来，我们的第一优化原则就是，<strong>保证绝大多数</strong>的用户能够较快地访问我们的应用。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>展开性能优化工作之前，还有一个重要的准备工作。即要预先采集基准数据。有了基准数据，才能很好地衡量自己的优化效果。</p>\n<p>微信公众平台虽有提供小程序启动耗时、下载耗时的图表，但由于不能提供原始数据，不利于细化分析，因此本次性能优化采用的是自建日志上报系统提供的数据。</p>\n<p>确定好性能指标，获取到相关数据，这还不够。</p>\n<p>由于现实网络环境非常复杂，收集的原始数据是非常粗犷的，相同的代码，相同的配置，在不同的网络环境和手机上，加载时间会千差万别。因此对于收集到各种极端数据，必须要做一定的加工处理，才能变成可分析的数据：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83237d3aa9~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>常见的加工处理（指标计算口径）主要如下几种：</p>\n<ul>\n<li><strong>平均数：</strong> 最直接的想法，计算所有数据的平均值。但是平均数会因为部分极端值导致偏大，会观察到数据的波动较大，因此平均数不适合作为参考指标。</li>\n<li><strong>95分位数：</strong> 将所有数据从小到大排列，取第 95%位置的数值，将这个值作为我们的性能指标。</li>\n<li><strong>截尾平均数：</strong> 同样将所有数据顺序排列，将尾部的部分数据移除，然后取平均值。这个值会相对平稳，比较适合作为参考指标。</li>\n</ul>\n<p>结合前面提到的第一优化原则，明显 <strong>截尾平均数</strong> 这种指标计算口径是最佳选择。</p>\n<p>比如假设我们承诺保证90%的用户在1000ms内完成小程序的加载，那么我们就只要关注前90%的用户的加载耗时是否在1000ms内即可。</p>\n<p>通过截尾获得耗时较少的前50%、80%、90%用户的平均加载耗时数据（后续横向分析这三类用户的加载耗时的优化效果）</p>\n<p>处理好数据之后，进行性能分析的时，可以如下进行分类分析：</p>\n<ul>\n<li>  按手机系统（Android、iOS）分类</li>\n<li>  按网络环境（WIFI和4G）分类</li>\n</ul>\n<p>以下是采集的 <strong>4G网络下，不区分手机系统</strong> 的车险分包的加载耗时（作为优化前的基线数据）：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8327c663c2~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>由于小程序有提供许多基础API、UI库，而这部分代码是每个小程序的依赖。因此初始化代码的时候，这个是最先初始化的，渲染流程大致如下：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f832a7c0123~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>相对于传统web，我们能在很多环节上做优化。比如资源加载顺序（图片懒加载、CSS前置加载，JS后置加载等），使用构建工具实现按需加载等。但小程序的底层逻辑比较封闭，我们无法深入参与，因此要优化小程序的加载性能，能做且最行之有效的方案就是优化小程序代码包的大小。</p>\n<p>优化代码包大小的方案主要有以下几种：</p>\n<ul>\n<li>移除未使用的代码</li>\n<li>实现代码按需加载（在小程序里，即是采用分包加载方案）</li>\n<li>移除小程序包里的图片资源（因为小程序包下载时，默认使用了gzip压缩，而非文本的压缩效率较低）</li>\n<li>简化JavaScript，尽量避免在前端进行复杂的计算（将JS逻辑尽量迁移至后端或者采用Nodejs中台来完成这部分计算工作，这样也利于后续扩展到多平台）</li>\n</ul>\n<h2 id=\"移除未使用的代码\"><a href=\"#移除未使用的代码\" class=\"headerlink\" title=\"移除未使用的代码\"></a>移除未使用的代码</h2><p>由于车险是微保最先推出的产品，经历了无数多个迭代，不可避免会出现已下线的业务或功能。这部分代码一般都是以页面为单位，因此可以结合PV数据来找到这部分代码。</p>\n<p>提到PV数据，顺带提一下如何自建日志上报系统。由于小程序的每个页面都有完整的生命周期，因此进入一个新页面时，都会触发Page的onLoad方法，此时通过向后台服务上报进入页面的信息，即可完成页面PV数据统计。</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83395e7ced~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>对于如何实现错误路径的重定向处理，提供两个思路：</p>\n<ol>\n<li> 小程序提供的路由能力（如<code>wx.navigateTo</code>），当传入的url不存在时，会触发 <code>fail</code> 方法，此时在 <code>fail</code> 处理下即可。</li>\n<li> 使用 <code>wx.onPageNotFound</code> 方法处理，不过有一定的兼容性问题。</li>\n</ol>\n<p>移除未使用的代码之后，车险分包由 1100+KB 降到 <strong>900+KB</strong> （减小18%）</p>\n<h2 id=\"代码按需加载\"><a href=\"#代码按需加载\" class=\"headerlink\" title=\"代码按需加载\"></a>代码按需加载</h2><p>理想情况下，访问用户应该只下载有访问到的资源，其他资源一概等到需要的时候才下载。这种按需加载的方案，小程序是采用代码分包的方式处理。但由于分包与分包之间无法相互引用资源，无法复用代码，因此拆分分包必然导致开发的效率下降。因此拆分分包时，要把握好性能与效率的平衡。</p>\n<p>由此，我们提出了 <strong>基于UV及访问路径的分包拆分原则</strong> 。</p>\n<p>结合日志系统，我们发现车险的实名认证页是UV大户，而实名认证的逻辑和添加车辆、编辑车辆的逻辑比较类似，均包含了车辆管理逻辑和组件。因此这部分页面的代码相似度较高，比较适合拆成一个分包，最终将实名认证、车辆管理等页面拆分到：新用户分包A。</p>\n<p>其次，通过观察页面漏斗数据发现，大部分的用户只访问了主流程上的页面：车险首页、报价页、支付页、保单详情页。至于调整方案页、车辆列表页等分支流程，只有少部分用户会访问到的。因此将主流程的页面拆分成主分包B，而其他所有分支流程的页面则拆分成另外一个分包：其他分包C。</p>\n<p>最后将车险的分包拆分成如下：</p>\n<ul>\n<li>包含实名认证、车辆管理流程的新用户分包A（200+KB）</li>\n<li>包含主流程的主分包B（400+KB）</li>\n<li>包含分支流程的其他分包C（100+KB）</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8341f3d701~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>对于新用户（未完成实名认证），通过预检测实名情况，分发不同路径，从而实现新用户仅先加载新用户分包A，与此同时预加载主分包B。因此对于新用户来说，首次加载的是200+KB的新用户分包A，相对于优化前加载的900+KB完整分包，加载的小程序分包大小减少了78%。</p>\n<p>对于旧用户（已完成实名认证），不再加载新用户分包A，与此同时预加载了其他分包C，因此加载的小程序分包大小减少了56%。</p>\n<h2 id=\"简化JavaScript\"><a href=\"#简化JavaScript\" class=\"headerlink\" title=\"简化JavaScript\"></a>简化JavaScript</h2><p>这部分优化与传统web开发的优化原理类似。</p>\n<p>代码包下载完成之后，就要完成业务代码注入。这时，JS引擎就要解析/编译JavaScript，这也是JS引擎最耗时的操作，从Chrome开发者工具可以看到，其中黄色部分就是解析/编译耗时的部分：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f834167f0c6~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>因历史遗留问题，导致一些复杂的数据需要前端拼凑计算处理（如可续保车辆的计算等）。将这部分逻辑迁移至后端后，JavaScript的代码得到了进一步简化，只对最终数据做基本展示变换。</p>\n<p>由于本次实践没有深入这方面的优化，故不详细叙述这块优化的效果，后续有机会另外开篇文章详细讲。</p>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><p>在本次优化实践的过程中，遇到了许多问题，和大家分享一下我们的处理办法。</p>\n<p>第一个遇到的问题，就是组件的引用。</p>\n<p>因为小程序的限制，组件不能跨分包互相引用，要想跨分包复用，就要将组件放在小程序主包，而主包的代码是跨业务共有的，不能随意添加。因此在拆分分包的时候，需考虑到这个问题。</p>\n<p>其次，是JS公共库的引用问题。</p>\n<p>原本在同一个分包时，通过相对路径引入即可。但拆分成多个分包之后，JS就无法直接引用了。此时需要变换思路，如：将JS公共库挂载到全局变量global上；或者将代码copy一份到其他分包上（当然不是直接copy，是通过gulp或者webpack打包）；又或者将公共库放在主包上。</p>\n<p>还有更让人头疼的是，目录变更导致的路由跳转问题。</p>\n<p>由于小程序分包机制要求每个分包都在一个目录里。因此拆分分包就不可避免地要对文件进行迁移，而小程序的跳转又和文件目录强耦合，文件路径变更导致跳转路径变化。因此涉及到的页面的跳转路径均要改变。</p>\n<p>此时，还要考虑向前兼容，比如已推送的模板通知。因此路由跳转的封装就显得极为必要。</p>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>经历以上的抽茧剥丝，终于等到了上线时间，可以到看，优化的效果非常明显：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f83466d3d75~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>横向对比不同分类的用户，可以更清晰看到各类用户的提升情况：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/27/17255f8348a6b8e4~tplv-t2oaga2asx-image.image\" alt=\" \"></p>\n<p>对于较快的前50%用户，也提升了接近50%的访问速度。</p>\n<p>此次优化，保证了90%的用户可以在2000ms内完成小程序的加载。</p>\n<h1 id=\"后续优化\"><a href=\"#后续优化\" class=\"headerlink\" title=\"后续优化\"></a>后续优化</h1><p>对于接下来的优化工作，我们仍有几个计划：</p>\n<p>充分利用小程序提供的预下载分包功能。若没有设置预下载，用户在跳转其他分包页面时，就要等待分包的下载。对于比较急躁的用户，会以为卡机了，最终导致用户跳出。（小程序预下载的唯一限制就是，当前分包和预下载的分包大小之和不能超出2M，如果超出，可以考虑再次拆分分包）</p>\n<p>简化WXML的class。类选择器是最常见的样式选择器，当页面变得庞大时，class的长度往往会越来越长。然而在不支持DOM操作的小程序里，class的主要作用主要是样式注入。因此可以通过脚本将WXML和WXSS相同的class统一精简成短小的命名。</p>\n<p>采用Node.js中台转移部分计算。将JavaScript的代码进一步简化，这样有利于对小程序的加载性能进一步优化。其次，这样也有利用扩展到其他平台，比如H5等。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>尽管看似微信小程序的开发、发布方式和传统web有很大的差异。但是底层的运行还是类似的，因此可以从传统的web优化实践中找到优化的思路。</p>\n<p>其中本文提到的一些优化实践是非常定制化的，是根据特殊的业务场景采取的特殊方式处理。毫无疑问，业务在发展，代码也会随着发生变动，这就需要不断的优化，才让用户的体验愈来愈好。</p>\n<p>感谢大家阅读，如有错误，欢迎指正，感谢。</p>"},{"title":"浅谈小程序路由的封装设计","date":"2020-06-02T11:29:17.000Z","_content":"\n微信官方提供了基础的路由能力，在日常的开发中虽已够用，但随着开发的深入，会遇到许多值得思考提炼的问题。本文将探讨作者在微信小程序（以下简称小程序）开发当中遇到的问题，以及解决方案设计。\n\n参考“WHY-HOW-WHAT\"黄金圈思维法则，首先讲述为什么小程序的路由需要封装设计，也就是存在哪些问题，需要封装处理？\n\n<!-- more -->\n\n## 存在的问题\n\n### 路由跳转的路径与文件路径耦合\n\n小程序的路由跳转使用的是真实文件路径，因此若文件的结构发生变化，必会影响到所有的页面的跳转路径。\n\n笔者在实际开发中就遇到这个问题，以小程序分包举例。\n\n小程序的分包是以文件夹为单位的。如果要将一系列的页面拆分成分包，则需要将这些文件移至同个目录之下，因此必然导致路由的跳转路径发生变更。如果此时路由跳转均是直接通过文件路径跳转的话，则需要全局改动，导致的工作量不少。\n\n另外，当开发团队比较庞大时，不同的业务之间总会存在互相跳转的情况。当其中一个页面地址发生变更时，其他业务跳转到该页面的路径都需要手动变更。若此时通知不及时，或者遗漏了一些地方，导致跳转失败，终会酿成大错。\n\n### 路由传参\n\n目前小程序支持的传参方式，即通过跳转路径上的 query 查询参数。\n\n通过 query 传参的问题，与在 Web 上 URL 传参是一致的，比如：\n\n- query 的参数长度有限\n- query 只能传递可序列化的数据\n- 导航前需手动序列化，到达目标页面后需反序列化\n\n### 条件导航\n\n在日常业务中，会存在一些页面需要一定条件才允许进入的。\n\n举个例子，会员服务是一种很常见的能力，而会员中心的进入条件是：\n\n- 该用户已经完成登录\n- 该用户是本产品的会员\n\n一般情况下，这有特定准入资格的页面的导航逻辑是这样的：\n\n![路由权限控制](/blog/images/miniprogram/router/路由权限控制.png)\n\n这种方式简单明了，但存在一个问题：需要每次跳转前主动判断，逻辑冗余以外，还可能被遗漏。\n\n## 思路\n\n由于小程序本身已提供了基础的路由导航能力，不像 react、vue 那样需要从底层进行封装，从而提供路由能力。但是，本质上小程序可以理解成类 vue 这样的框架，因此可以从 vue 的路由库 vue-router 上找到灵感，从而解决以上问题。\n\n### 命名路由\n\n使用 **命名路由** 的方式可以解决前文提及的跳转路径和文件真实路径耦合问题。\n\n通过 `Map` 来映射 **页面ID** 和 **页面地址**，路由跳转时，仅能使用 **页面ID** 进行路由跳转。\n\n下面以导航至首页举例：\n\n```js\n// before\nwx.switchTab('pages/home/index')\n\n// after\nrouter.go('home')\n```\n\n> 由于小程序有 tab 页面和普通页面之分，因此导航至 tab 页时需使用 switchTab\n\n细心的读者可能会发现上文使用了 `go` 方法，而不是 `switchTab`。其实，具体哪些页面属于 tab 页面，在 `app.json` 已经明确配置。对于使用者来说，不需要关心跳转的页面是属于哪种类型，这些细节都应该统一在底层封装好。下面罗列 `Router` 与官方 API 的对应关系：\n\n![路由的方法](/blog/images/miniprogram/router/router-methods.png)\n\n> Router API的设计原则是保持简单，以及尽量保持与web规范一致\n\n### 参数传递\n\n微信官方提供的 query 方式传参，若参数是普通数据类型（如`Number`、`String`）时可以直接使用；但若是涉及到复杂数据类型（如`Array`、`Object`）时，需要先做序列化处理，当数据较为庞大时，性能的损耗还是比较明显的。\n\n因此，在内存上传递参数是比较便利且容易想到的办法。\n\n利用数据字典，将 `页面ID` 作为 `key`、传递的参数作为 `value`，写入 `Router` 的 `state`：\n\n```js\nrouter.go = function(pageID, params) {\n    // do something...\n    router.state[pageID] = params\n}\n```\n\n在目标页面上，可以通过 `router.getParams()` 方法，获取传递的参数。\n\n> 由于采用了命名路由的方式，可以使用 `页面ID` 作为 `key`，避免了使用跳转路径做 `key` 时，涉及到的绝对与相对路径问题。\n\n### 条件导航\n\n条件导航可以使用类似 vue-router 的导航守卫来解决问题。\n\n由于路由的能力是微信官方提供的，因此无法像 vue-router 那样提供多类型的导航守卫，但仅有全局导航守卫也足够使用。\n\n以下仍以“会员中心”的进入逻辑举例，并简要介绍实现思路：\n\n![ ](/blog/images/miniprogram/router/demo1.png)\n\n其中，to和from目前是pageID，其实可以封装更多信息，以保证导航守卫可以尽可能拥有更多的信息。因此to可以理解成是即将进入的页面路由对象，而from则是当前正要离开的路由对象。\n\n路由对象可以包含以下信息： \n- `pageID`：页面 ID\n- `path`：页面 ID 对应的 path\n- `params`：传递的参数\n- `query`: URL的查询参数\n\n### 配置信息\n\n由前文提到的 **命名路由** 做法需要一个配置文件来关联 `页面ID` 与 `页面路径` 的关系。\n\n页面的配置信息，则是使用 `router.config.js` 设置，然后通过构建工具编译转成 `app.json`。\n\n以下是 `route.config.js`：\n\n![ ](/blog/images/miniprogram/router/demo2.png)\n\n> 其中，跳转首页则是 `router.go('home')`；而跳转分包 `health` 的首页则是使用 `router.go('health.home')`\n\n通过以上的配置文件，使用构建工具转换成微信官方可识别的 `app.json` 配置：\n\n![ ](/blog/images/miniprogram/router/demo3.png)\n\n### 辅助函数\n\n在日常开发当中，经常会用到一些和路由相关的通用辅助函数，如获取当前页面，获取上个页面等。这些辅助函数都应该统一抽象封装，避免代码冗余。\n\n```js\nrouter.utils = {\n    getCurPage() { // 获取当前页面信息\n        let pages = getCurrentPages()\n        let len = pages.length\n        \n        return pages[len - 1]\n    },\n\n    getPrePage() {}, // 获取上个页面信息\n\n    getParams() {}, // 获取传递的参数\n\n    getPageID(path) {} // 通过path找到pageID\n}\n```\n\n### navigator 组件\n\n微信官方除了提供 `API` 用于导航以外，还提供了 `navigator` 组件。\n\n> 另外还有 `functional-page-navigator` 是用于插件当中，不能在小程序包使用，因此本文暂且将其忽略。\n\n由于 `navigator` 的跳转参数仍是使用 `path`，因此笔者将其进行二次封装，改造成可以通过 `pageID` 跳转：\n\n![ ](/blog/images/miniprogram/router/demo4.png)\n\n## 总结\n\n由于小程序相对比较封闭，因此在路由上能做的东西比较有限。\n\n但路由又与许多概念有千丝万缕的关系。比如路由与文件结构关联，而文件结构又影响到分包的设计，环环相扣，影响到的地方则会越来越多。\n\n因此，能提前看到本文提到的可能出现的问题，也许对后续的小程序开发有一定的参考意义。\n\n另外，前文提到的很多问题，在早期开发，或者没有深入开发之前，都不会遇到。但是当你开始经历前文提到的那些问题时，往往此时的改造成本已经很大了。因此希望本文能给你带了一些启发，在早期规避这些问题，那本文的使命就达到了。","source":"_posts/miniprogram/router-design.md","raw":"---\ntitle: 浅谈小程序路由的封装设计\ndate: 2020-06-02 19:29:17\ntags:\n- 小程序\ncategories:\n- 小程序\n---\n\n微信官方提供了基础的路由能力，在日常的开发中虽已够用，但随着开发的深入，会遇到许多值得思考提炼的问题。本文将探讨作者在微信小程序（以下简称小程序）开发当中遇到的问题，以及解决方案设计。\n\n参考“WHY-HOW-WHAT\"黄金圈思维法则，首先讲述为什么小程序的路由需要封装设计，也就是存在哪些问题，需要封装处理？\n\n<!-- more -->\n\n## 存在的问题\n\n### 路由跳转的路径与文件路径耦合\n\n小程序的路由跳转使用的是真实文件路径，因此若文件的结构发生变化，必会影响到所有的页面的跳转路径。\n\n笔者在实际开发中就遇到这个问题，以小程序分包举例。\n\n小程序的分包是以文件夹为单位的。如果要将一系列的页面拆分成分包，则需要将这些文件移至同个目录之下，因此必然导致路由的跳转路径发生变更。如果此时路由跳转均是直接通过文件路径跳转的话，则需要全局改动，导致的工作量不少。\n\n另外，当开发团队比较庞大时，不同的业务之间总会存在互相跳转的情况。当其中一个页面地址发生变更时，其他业务跳转到该页面的路径都需要手动变更。若此时通知不及时，或者遗漏了一些地方，导致跳转失败，终会酿成大错。\n\n### 路由传参\n\n目前小程序支持的传参方式，即通过跳转路径上的 query 查询参数。\n\n通过 query 传参的问题，与在 Web 上 URL 传参是一致的，比如：\n\n- query 的参数长度有限\n- query 只能传递可序列化的数据\n- 导航前需手动序列化，到达目标页面后需反序列化\n\n### 条件导航\n\n在日常业务中，会存在一些页面需要一定条件才允许进入的。\n\n举个例子，会员服务是一种很常见的能力，而会员中心的进入条件是：\n\n- 该用户已经完成登录\n- 该用户是本产品的会员\n\n一般情况下，这有特定准入资格的页面的导航逻辑是这样的：\n\n![路由权限控制](/blog/images/miniprogram/router/路由权限控制.png)\n\n这种方式简单明了，但存在一个问题：需要每次跳转前主动判断，逻辑冗余以外，还可能被遗漏。\n\n## 思路\n\n由于小程序本身已提供了基础的路由导航能力，不像 react、vue 那样需要从底层进行封装，从而提供路由能力。但是，本质上小程序可以理解成类 vue 这样的框架，因此可以从 vue 的路由库 vue-router 上找到灵感，从而解决以上问题。\n\n### 命名路由\n\n使用 **命名路由** 的方式可以解决前文提及的跳转路径和文件真实路径耦合问题。\n\n通过 `Map` 来映射 **页面ID** 和 **页面地址**，路由跳转时，仅能使用 **页面ID** 进行路由跳转。\n\n下面以导航至首页举例：\n\n```js\n// before\nwx.switchTab('pages/home/index')\n\n// after\nrouter.go('home')\n```\n\n> 由于小程序有 tab 页面和普通页面之分，因此导航至 tab 页时需使用 switchTab\n\n细心的读者可能会发现上文使用了 `go` 方法，而不是 `switchTab`。其实，具体哪些页面属于 tab 页面，在 `app.json` 已经明确配置。对于使用者来说，不需要关心跳转的页面是属于哪种类型，这些细节都应该统一在底层封装好。下面罗列 `Router` 与官方 API 的对应关系：\n\n![路由的方法](/blog/images/miniprogram/router/router-methods.png)\n\n> Router API的设计原则是保持简单，以及尽量保持与web规范一致\n\n### 参数传递\n\n微信官方提供的 query 方式传参，若参数是普通数据类型（如`Number`、`String`）时可以直接使用；但若是涉及到复杂数据类型（如`Array`、`Object`）时，需要先做序列化处理，当数据较为庞大时，性能的损耗还是比较明显的。\n\n因此，在内存上传递参数是比较便利且容易想到的办法。\n\n利用数据字典，将 `页面ID` 作为 `key`、传递的参数作为 `value`，写入 `Router` 的 `state`：\n\n```js\nrouter.go = function(pageID, params) {\n    // do something...\n    router.state[pageID] = params\n}\n```\n\n在目标页面上，可以通过 `router.getParams()` 方法，获取传递的参数。\n\n> 由于采用了命名路由的方式，可以使用 `页面ID` 作为 `key`，避免了使用跳转路径做 `key` 时，涉及到的绝对与相对路径问题。\n\n### 条件导航\n\n条件导航可以使用类似 vue-router 的导航守卫来解决问题。\n\n由于路由的能力是微信官方提供的，因此无法像 vue-router 那样提供多类型的导航守卫，但仅有全局导航守卫也足够使用。\n\n以下仍以“会员中心”的进入逻辑举例，并简要介绍实现思路：\n\n![ ](/blog/images/miniprogram/router/demo1.png)\n\n其中，to和from目前是pageID，其实可以封装更多信息，以保证导航守卫可以尽可能拥有更多的信息。因此to可以理解成是即将进入的页面路由对象，而from则是当前正要离开的路由对象。\n\n路由对象可以包含以下信息： \n- `pageID`：页面 ID\n- `path`：页面 ID 对应的 path\n- `params`：传递的参数\n- `query`: URL的查询参数\n\n### 配置信息\n\n由前文提到的 **命名路由** 做法需要一个配置文件来关联 `页面ID` 与 `页面路径` 的关系。\n\n页面的配置信息，则是使用 `router.config.js` 设置，然后通过构建工具编译转成 `app.json`。\n\n以下是 `route.config.js`：\n\n![ ](/blog/images/miniprogram/router/demo2.png)\n\n> 其中，跳转首页则是 `router.go('home')`；而跳转分包 `health` 的首页则是使用 `router.go('health.home')`\n\n通过以上的配置文件，使用构建工具转换成微信官方可识别的 `app.json` 配置：\n\n![ ](/blog/images/miniprogram/router/demo3.png)\n\n### 辅助函数\n\n在日常开发当中，经常会用到一些和路由相关的通用辅助函数，如获取当前页面，获取上个页面等。这些辅助函数都应该统一抽象封装，避免代码冗余。\n\n```js\nrouter.utils = {\n    getCurPage() { // 获取当前页面信息\n        let pages = getCurrentPages()\n        let len = pages.length\n        \n        return pages[len - 1]\n    },\n\n    getPrePage() {}, // 获取上个页面信息\n\n    getParams() {}, // 获取传递的参数\n\n    getPageID(path) {} // 通过path找到pageID\n}\n```\n\n### navigator 组件\n\n微信官方除了提供 `API` 用于导航以外，还提供了 `navigator` 组件。\n\n> 另外还有 `functional-page-navigator` 是用于插件当中，不能在小程序包使用，因此本文暂且将其忽略。\n\n由于 `navigator` 的跳转参数仍是使用 `path`，因此笔者将其进行二次封装，改造成可以通过 `pageID` 跳转：\n\n![ ](/blog/images/miniprogram/router/demo4.png)\n\n## 总结\n\n由于小程序相对比较封闭，因此在路由上能做的东西比较有限。\n\n但路由又与许多概念有千丝万缕的关系。比如路由与文件结构关联，而文件结构又影响到分包的设计，环环相扣，影响到的地方则会越来越多。\n\n因此，能提前看到本文提到的可能出现的问题，也许对后续的小程序开发有一定的参考意义。\n\n另外，前文提到的很多问题，在早期开发，或者没有深入开发之前，都不会遇到。但是当你开始经历前文提到的那些问题时，往往此时的改造成本已经很大了。因此希望本文能给你带了一些启发，在早期规避这些问题，那本文的使命就达到了。","slug":"miniprogram/router-design","published":1,"updated":"2023-08-04T11:41:49.982Z","_id":"clkwi6toz000f3tsz54bv6571","comments":1,"layout":"post","photos":[],"link":"","content":"<p>微信官方提供了基础的路由能力，在日常的开发中虽已够用，但随着开发的深入，会遇到许多值得思考提炼的问题。本文将探讨作者在微信小程序（以下简称小程序）开发当中遇到的问题，以及解决方案设计。</p>\n<p>参考“WHY-HOW-WHAT”黄金圈思维法则，首先讲述为什么小程序的路由需要封装设计，也就是存在哪些问题，需要封装处理？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><h3 id=\"路由跳转的路径与文件路径耦合\"><a href=\"#路由跳转的路径与文件路径耦合\" class=\"headerlink\" title=\"路由跳转的路径与文件路径耦合\"></a>路由跳转的路径与文件路径耦合</h3><p>小程序的路由跳转使用的是真实文件路径，因此若文件的结构发生变化，必会影响到所有的页面的跳转路径。</p>\n<p>笔者在实际开发中就遇到这个问题，以小程序分包举例。</p>\n<p>小程序的分包是以文件夹为单位的。如果要将一系列的页面拆分成分包，则需要将这些文件移至同个目录之下，因此必然导致路由的跳转路径发生变更。如果此时路由跳转均是直接通过文件路径跳转的话，则需要全局改动，导致的工作量不少。</p>\n<p>另外，当开发团队比较庞大时，不同的业务之间总会存在互相跳转的情况。当其中一个页面地址发生变更时，其他业务跳转到该页面的路径都需要手动变更。若此时通知不及时，或者遗漏了一些地方，导致跳转失败，终会酿成大错。</p>\n<h3 id=\"路由传参\"><a href=\"#路由传参\" class=\"headerlink\" title=\"路由传参\"></a>路由传参</h3><p>目前小程序支持的传参方式，即通过跳转路径上的 query 查询参数。</p>\n<p>通过 query 传参的问题，与在 Web 上 URL 传参是一致的，比如：</p>\n<ul>\n<li>query 的参数长度有限</li>\n<li>query 只能传递可序列化的数据</li>\n<li>导航前需手动序列化，到达目标页面后需反序列化</li>\n</ul>\n<h3 id=\"条件导航\"><a href=\"#条件导航\" class=\"headerlink\" title=\"条件导航\"></a>条件导航</h3><p>在日常业务中，会存在一些页面需要一定条件才允许进入的。</p>\n<p>举个例子，会员服务是一种很常见的能力，而会员中心的进入条件是：</p>\n<ul>\n<li>该用户已经完成登录</li>\n<li>该用户是本产品的会员</li>\n</ul>\n<p>一般情况下，这有特定准入资格的页面的导航逻辑是这样的：</p>\n<p><img src=\"/blog/images/miniprogram/router/%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.png\" alt=\"路由权限控制\"></p>\n<p>这种方式简单明了，但存在一个问题：需要每次跳转前主动判断，逻辑冗余以外，还可能被遗漏。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由于小程序本身已提供了基础的路由导航能力，不像 react、vue 那样需要从底层进行封装，从而提供路由能力。但是，本质上小程序可以理解成类 vue 这样的框架，因此可以从 vue 的路由库 vue-router 上找到灵感，从而解决以上问题。</p>\n<h3 id=\"命名路由\"><a href=\"#命名路由\" class=\"headerlink\" title=\"命名路由\"></a>命名路由</h3><p>使用 <strong>命名路由</strong> 的方式可以解决前文提及的跳转路径和文件真实路径耦合问题。</p>\n<p>通过 <code>Map</code> 来映射 <strong>页面ID</strong> 和 <strong>页面地址</strong>，路由跳转时，仅能使用 <strong>页面ID</strong> 进行路由跳转。</p>\n<p>下面以导航至首页举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">wx.switchTab(<span class=\"string\">&#x27;pages/home/index&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">router.go(<span class=\"string\">&#x27;home&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于小程序有 tab 页面和普通页面之分，因此导航至 tab 页时需使用 switchTab</p>\n</blockquote>\n<p>细心的读者可能会发现上文使用了 <code>go</code> 方法，而不是 <code>switchTab</code>。其实，具体哪些页面属于 tab 页面，在 <code>app.json</code> 已经明确配置。对于使用者来说，不需要关心跳转的页面是属于哪种类型，这些细节都应该统一在底层封装好。下面罗列 <code>Router</code> 与官方 API 的对应关系：</p>\n<p><img src=\"/blog/images/miniprogram/router/router-methods.png\" alt=\"路由的方法\"></p>\n<blockquote>\n<p>Router API的设计原则是保持简单，以及尽量保持与web规范一致</p>\n</blockquote>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><p>微信官方提供的 query 方式传参，若参数是普通数据类型（如<code>Number</code>、<code>String</code>）时可以直接使用；但若是涉及到复杂数据类型（如<code>Array</code>、<code>Object</code>）时，需要先做序列化处理，当数据较为庞大时，性能的损耗还是比较明显的。</p>\n<p>因此，在内存上传递参数是比较便利且容易想到的办法。</p>\n<p>利用数据字典，将 <code>页面ID</code> 作为 <code>key</code>、传递的参数作为 <code>value</code>，写入 <code>Router</code> 的 <code>state</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.go = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pageID, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    router.state[pageID] = params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在目标页面上，可以通过 <code>router.getParams()</code> 方法，获取传递的参数。</p>\n<blockquote>\n<p>由于采用了命名路由的方式，可以使用 <code>页面ID</code> 作为 <code>key</code>，避免了使用跳转路径做 <code>key</code> 时，涉及到的绝对与相对路径问题。</p>\n</blockquote>\n<h3 id=\"条件导航-1\"><a href=\"#条件导航-1\" class=\"headerlink\" title=\"条件导航\"></a>条件导航</h3><p>条件导航可以使用类似 vue-router 的导航守卫来解决问题。</p>\n<p>由于路由的能力是微信官方提供的，因此无法像 vue-router 那样提供多类型的导航守卫，但仅有全局导航守卫也足够使用。</p>\n<p>以下仍以“会员中心”的进入逻辑举例，并简要介绍实现思路：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo1.png\" alt=\" \"></p>\n<p>其中，to和from目前是pageID，其实可以封装更多信息，以保证导航守卫可以尽可能拥有更多的信息。因此to可以理解成是即将进入的页面路由对象，而from则是当前正要离开的路由对象。</p>\n<p>路由对象可以包含以下信息： </p>\n<ul>\n<li><code>pageID</code>：页面 ID</li>\n<li><code>path</code>：页面 ID 对应的 path</li>\n<li><code>params</code>：传递的参数</li>\n<li><code>query</code>: URL的查询参数</li>\n</ul>\n<h3 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h3><p>由前文提到的 <strong>命名路由</strong> 做法需要一个配置文件来关联 <code>页面ID</code> 与 <code>页面路径</code> 的关系。</p>\n<p>页面的配置信息，则是使用 <code>router.config.js</code> 设置，然后通过构建工具编译转成 <code>app.json</code>。</p>\n<p>以下是 <code>route.config.js</code>：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo2.png\" alt=\" \"></p>\n<blockquote>\n<p>其中，跳转首页则是 <code>router.go(&#39;home&#39;)</code>；而跳转分包 <code>health</code> 的首页则是使用 <code>router.go(&#39;health.home&#39;)</code></p>\n</blockquote>\n<p>通过以上的配置文件，使用构建工具转换成微信官方可识别的 <code>app.json</code> 配置：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo3.png\" alt=\" \"></p>\n<h3 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h3><p>在日常开发当中，经常会用到一些和路由相关的通用辅助函数，如获取当前页面，获取上个页面等。这些辅助函数都应该统一抽象封装，避免代码冗余。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.utils = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getCurPage</span>(<span class=\"params\"></span>)</span> &#123; <span class=\"comment\">// 获取当前页面信息</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> pages = getCurrentPages()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = pages.length</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> pages[len - <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getPrePage</span>(<span class=\"params\"></span>)</span> &#123;&#125;, <span class=\"comment\">// 获取上个页面信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getParams</span>(<span class=\"params\"></span>)</span> &#123;&#125;, <span class=\"comment\">// 获取传递的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getPageID</span>(<span class=\"params\">path</span>)</span> &#123;&#125; <span class=\"comment\">// 通过path找到pageID</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"navigator-组件\"><a href=\"#navigator-组件\" class=\"headerlink\" title=\"navigator 组件\"></a>navigator 组件</h3><p>微信官方除了提供 <code>API</code> 用于导航以外，还提供了 <code>navigator</code> 组件。</p>\n<blockquote>\n<p>另外还有 <code>functional-page-navigator</code> 是用于插件当中，不能在小程序包使用，因此本文暂且将其忽略。</p>\n</blockquote>\n<p>由于 <code>navigator</code> 的跳转参数仍是使用 <code>path</code>，因此笔者将其进行二次封装，改造成可以通过 <code>pageID</code> 跳转：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo4.png\" alt=\" \"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>由于小程序相对比较封闭，因此在路由上能做的东西比较有限。</p>\n<p>但路由又与许多概念有千丝万缕的关系。比如路由与文件结构关联，而文件结构又影响到分包的设计，环环相扣，影响到的地方则会越来越多。</p>\n<p>因此，能提前看到本文提到的可能出现的问题，也许对后续的小程序开发有一定的参考意义。</p>\n<p>另外，前文提到的很多问题，在早期开发，或者没有深入开发之前，都不会遇到。但是当你开始经历前文提到的那些问题时，往往此时的改造成本已经很大了。因此希望本文能给你带了一些启发，在早期规避这些问题，那本文的使命就达到了。</p>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<p>微信官方提供了基础的路由能力，在日常的开发中虽已够用，但随着开发的深入，会遇到许多值得思考提炼的问题。本文将探讨作者在微信小程序（以下简称小程序）开发当中遇到的问题，以及解决方案设计。</p>\n<p>参考“WHY-HOW-WHAT”黄金圈思维法则，首先讲述为什么小程序的路由需要封装设计，也就是存在哪些问题，需要封装处理？</p>","more":"<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><h3 id=\"路由跳转的路径与文件路径耦合\"><a href=\"#路由跳转的路径与文件路径耦合\" class=\"headerlink\" title=\"路由跳转的路径与文件路径耦合\"></a>路由跳转的路径与文件路径耦合</h3><p>小程序的路由跳转使用的是真实文件路径，因此若文件的结构发生变化，必会影响到所有的页面的跳转路径。</p>\n<p>笔者在实际开发中就遇到这个问题，以小程序分包举例。</p>\n<p>小程序的分包是以文件夹为单位的。如果要将一系列的页面拆分成分包，则需要将这些文件移至同个目录之下，因此必然导致路由的跳转路径发生变更。如果此时路由跳转均是直接通过文件路径跳转的话，则需要全局改动，导致的工作量不少。</p>\n<p>另外，当开发团队比较庞大时，不同的业务之间总会存在互相跳转的情况。当其中一个页面地址发生变更时，其他业务跳转到该页面的路径都需要手动变更。若此时通知不及时，或者遗漏了一些地方，导致跳转失败，终会酿成大错。</p>\n<h3 id=\"路由传参\"><a href=\"#路由传参\" class=\"headerlink\" title=\"路由传参\"></a>路由传参</h3><p>目前小程序支持的传参方式，即通过跳转路径上的 query 查询参数。</p>\n<p>通过 query 传参的问题，与在 Web 上 URL 传参是一致的，比如：</p>\n<ul>\n<li>query 的参数长度有限</li>\n<li>query 只能传递可序列化的数据</li>\n<li>导航前需手动序列化，到达目标页面后需反序列化</li>\n</ul>\n<h3 id=\"条件导航\"><a href=\"#条件导航\" class=\"headerlink\" title=\"条件导航\"></a>条件导航</h3><p>在日常业务中，会存在一些页面需要一定条件才允许进入的。</p>\n<p>举个例子，会员服务是一种很常见的能力，而会员中心的进入条件是：</p>\n<ul>\n<li>该用户已经完成登录</li>\n<li>该用户是本产品的会员</li>\n</ul>\n<p>一般情况下，这有特定准入资格的页面的导航逻辑是这样的：</p>\n<p><img src=\"/blog/images/miniprogram/router/%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.png\" alt=\"路由权限控制\"></p>\n<p>这种方式简单明了，但存在一个问题：需要每次跳转前主动判断，逻辑冗余以外，还可能被遗漏。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>由于小程序本身已提供了基础的路由导航能力，不像 react、vue 那样需要从底层进行封装，从而提供路由能力。但是，本质上小程序可以理解成类 vue 这样的框架，因此可以从 vue 的路由库 vue-router 上找到灵感，从而解决以上问题。</p>\n<h3 id=\"命名路由\"><a href=\"#命名路由\" class=\"headerlink\" title=\"命名路由\"></a>命名路由</h3><p>使用 <strong>命名路由</strong> 的方式可以解决前文提及的跳转路径和文件真实路径耦合问题。</p>\n<p>通过 <code>Map</code> 来映射 <strong>页面ID</strong> 和 <strong>页面地址</strong>，路由跳转时，仅能使用 <strong>页面ID</strong> 进行路由跳转。</p>\n<p>下面以导航至首页举例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">wx.switchTab(<span class=\"string\">&#x27;pages/home/index&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">router.go(<span class=\"string\">&#x27;home&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于小程序有 tab 页面和普通页面之分，因此导航至 tab 页时需使用 switchTab</p>\n</blockquote>\n<p>细心的读者可能会发现上文使用了 <code>go</code> 方法，而不是 <code>switchTab</code>。其实，具体哪些页面属于 tab 页面，在 <code>app.json</code> 已经明确配置。对于使用者来说，不需要关心跳转的页面是属于哪种类型，这些细节都应该统一在底层封装好。下面罗列 <code>Router</code> 与官方 API 的对应关系：</p>\n<p><img src=\"/blog/images/miniprogram/router/router-methods.png\" alt=\"路由的方法\"></p>\n<blockquote>\n<p>Router API的设计原则是保持简单，以及尽量保持与web规范一致</p>\n</blockquote>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><p>微信官方提供的 query 方式传参，若参数是普通数据类型（如<code>Number</code>、<code>String</code>）时可以直接使用；但若是涉及到复杂数据类型（如<code>Array</code>、<code>Object</code>）时，需要先做序列化处理，当数据较为庞大时，性能的损耗还是比较明显的。</p>\n<p>因此，在内存上传递参数是比较便利且容易想到的办法。</p>\n<p>利用数据字典，将 <code>页面ID</code> 作为 <code>key</code>、传递的参数作为 <code>value</code>，写入 <code>Router</code> 的 <code>state</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.go = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pageID, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">    router.state[pageID] = params</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在目标页面上，可以通过 <code>router.getParams()</code> 方法，获取传递的参数。</p>\n<blockquote>\n<p>由于采用了命名路由的方式，可以使用 <code>页面ID</code> 作为 <code>key</code>，避免了使用跳转路径做 <code>key</code> 时，涉及到的绝对与相对路径问题。</p>\n</blockquote>\n<h3 id=\"条件导航-1\"><a href=\"#条件导航-1\" class=\"headerlink\" title=\"条件导航\"></a>条件导航</h3><p>条件导航可以使用类似 vue-router 的导航守卫来解决问题。</p>\n<p>由于路由的能力是微信官方提供的，因此无法像 vue-router 那样提供多类型的导航守卫，但仅有全局导航守卫也足够使用。</p>\n<p>以下仍以“会员中心”的进入逻辑举例，并简要介绍实现思路：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo1.png\" alt=\" \"></p>\n<p>其中，to和from目前是pageID，其实可以封装更多信息，以保证导航守卫可以尽可能拥有更多的信息。因此to可以理解成是即将进入的页面路由对象，而from则是当前正要离开的路由对象。</p>\n<p>路由对象可以包含以下信息： </p>\n<ul>\n<li><code>pageID</code>：页面 ID</li>\n<li><code>path</code>：页面 ID 对应的 path</li>\n<li><code>params</code>：传递的参数</li>\n<li><code>query</code>: URL的查询参数</li>\n</ul>\n<h3 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h3><p>由前文提到的 <strong>命名路由</strong> 做法需要一个配置文件来关联 <code>页面ID</code> 与 <code>页面路径</code> 的关系。</p>\n<p>页面的配置信息，则是使用 <code>router.config.js</code> 设置，然后通过构建工具编译转成 <code>app.json</code>。</p>\n<p>以下是 <code>route.config.js</code>：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo2.png\" alt=\" \"></p>\n<blockquote>\n<p>其中，跳转首页则是 <code>router.go(&#39;home&#39;)</code>；而跳转分包 <code>health</code> 的首页则是使用 <code>router.go(&#39;health.home&#39;)</code></p>\n</blockquote>\n<p>通过以上的配置文件，使用构建工具转换成微信官方可识别的 <code>app.json</code> 配置：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo3.png\" alt=\" \"></p>\n<h3 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h3><p>在日常开发当中，经常会用到一些和路由相关的通用辅助函数，如获取当前页面，获取上个页面等。这些辅助函数都应该统一抽象封装，避免代码冗余。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.utils = &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getCurPage</span>(<span class=\"params\"></span>)</span> &#123; <span class=\"comment\">// 获取当前页面信息</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> pages = getCurrentPages()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = pages.length</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> pages[len - <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getPrePage</span>(<span class=\"params\"></span>)</span> &#123;&#125;, <span class=\"comment\">// 获取上个页面信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getParams</span>(<span class=\"params\"></span>)</span> &#123;&#125;, <span class=\"comment\">// 获取传递的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">getPageID</span>(<span class=\"params\">path</span>)</span> &#123;&#125; <span class=\"comment\">// 通过path找到pageID</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"navigator-组件\"><a href=\"#navigator-组件\" class=\"headerlink\" title=\"navigator 组件\"></a>navigator 组件</h3><p>微信官方除了提供 <code>API</code> 用于导航以外，还提供了 <code>navigator</code> 组件。</p>\n<blockquote>\n<p>另外还有 <code>functional-page-navigator</code> 是用于插件当中，不能在小程序包使用，因此本文暂且将其忽略。</p>\n</blockquote>\n<p>由于 <code>navigator</code> 的跳转参数仍是使用 <code>path</code>，因此笔者将其进行二次封装，改造成可以通过 <code>pageID</code> 跳转：</p>\n<p><img src=\"/blog/images/miniprogram/router/demo4.png\" alt=\" \"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>由于小程序相对比较封闭，因此在路由上能做的东西比较有限。</p>\n<p>但路由又与许多概念有千丝万缕的关系。比如路由与文件结构关联，而文件结构又影响到分包的设计，环环相扣，影响到的地方则会越来越多。</p>\n<p>因此，能提前看到本文提到的可能出现的问题，也许对后续的小程序开发有一定的参考意义。</p>\n<p>另外，前文提到的很多问题，在早期开发，或者没有深入开发之前，都不会遇到。但是当你开始经历前文提到的那些问题时，往往此时的改造成本已经很大了。因此希望本文能给你带了一些启发，在早期规避这些问题，那本文的使命就达到了。</p>"},{"title":"移动端适配的四种方案","date":"2020-08-11T11:44:03.000Z","_content":"\n# viewport 的作用\n\nviewport 翻译成中文是“视窗”的意思，也就是字面上的意思，页面展示的窗口。知道这个 viewport 有哪些作用呢？我举例一下：\n\n<!-- more -->\n\n## 计算百分比值\n\n当我们设置一个块级元素的宽度为百分比的时候，在HTML的规则中，最终的大小取决于它的父元素。如果元素嵌套情况如下：\n\n```\nhtml > body > div\n```\n\n最终要计算出 `div` 的实际大小，就要知道 `body` 的大小，而 `body` 的大小又依赖于 `html`。所以最终的问题是，如何计算 `html` 的大小。而这个 `html` 是根元素，没有父元素。此时就是 `viewport` 登场了。由它来约束 `html` 的大小。\n\n## 用户缩放\n\n当用户进行缩放时，对于我们的页面是如何变化的，或者用户当前是否存在缩放状态，这些都是通过 `viewport` 来获取的。\n\n用户进行缩放时，页面的 CSS 像素是不发生变化的（如果有变化，必然触发重新渲染），变化的是视窗的大小。当用户放大页面是，视窗应该是变小，但物理像素是不会变化的，因此相同的 CSS 像素占用更多的设备像素，因此此时 dpr 会变大。\n\n> dpr(device pixel ratio) 设备像素比 = 物理像素 / 设备独立像素\n\n在 `JavaScript` 里，我们可以通过 `screen.width` 获取物理像素的宽度，通过 `window.innerWidth` 获取当前页面的独立设备像素，因此可以这样计算设备像素比：`screen.width / window.innerWidth`。\n\n当然，也可以直接获得设备像素比：`window.devicePixelRatio`\n\n在桌面端，**设备像素比(dpr)** 通常情况下都是等于 1，当不等于 1 的时候，通常是用户进行缩放了。\n\n## 移动端适配\n\n在移动端，会有许多各种尺寸的屏幕。如何在不同的屏幕呈现相同的效果，这就是移动端适配的工作，要想弄清楚如何兼容，就要先理解 `viewport` 的概念。\n\n# 基础概念\n\n## 屏幕尺寸\n\n可通过 `screen.width/height` 获得。一般是通过 **设备像素(device pixel)** 来计算。\n\n![screen-width](/blog/images/responsive-web/screen-width.png)\n\n## 窗口尺寸\n\n可通过 `window.innerWidth/innerHeight` 获得。一般是通过 CSS 像素来计算。窗口是浏览器的窗口，包含了滚动条的尺寸，不包含顶部菜单：\n\n![window-width](/blog/images/responsive-web/window-width.png)\n\n## 视窗尺寸\n\n可通过 `document.documentElement.clientWidth/clientHeight` 获得。一般是通过 CSS 像素来计算。视窗与窗口差别在于不包含滚动条的尺寸：\n\n![viewport-width](/blog/images/responsive-web/viewport-width.png)\n\n# 移动端适配\n\n## REM 方案\n\n视觉稿 750px，设置根元素即（html）的大小为 75px，所有元素均这样计算，以 `230px` 举例:\n\n```\nwidth: 350px / 75px = 5rem\n```\n\n此时页面上的所有元素均以根元素的 `font-size` 计算，因此要做到动态支持不同尺寸的手机，只需要动态修改根元素的 `font-size` 即可。由于我们是以 `750px` 的十分之一为基准的，所以只需将当前 **视觉窗口(visual viewport)** 同样除以 10 即可：\n\n```js\nlet docEl = document.documentElement\nlet rem = docEl.clientWidth / 10\n\ndocEl.style.fontSize = rem + 'px'\n```\n\n另外，由于 `font-size` 是继承性属性，上述代码将 `<html>` 的 `font-size` 修改了，为了不影响到默认的字体大小，可以在 `<body>` 上重置 `font-size`:\n\n```css\nbody {\n  font-size: inital;\n}\n```\n\n## VW 方案\n\nVW 方案是和 REM 方案的原理是一致的：以当前宽度按比例动态调整。\n\nVW 方案的优势是 **不需要动态调整基数**。vw 单元原生支持与当前视觉窗口按比例动态变化。**缺点是会有一定的兼容性**，可以看下 vw 的兼容情况：\n\n![vw-compatibility](/blog/images/responsive-web/vw-compatibility.png)\n\n具体实现方案与 REM 类似，以视觉稿的宽度（一般为 750px）为基准，将 px 单位转换成 vw 单位，以 `75px` 举例：(基于 vw 的定义，全宽等于 100vw)：\n\n```css\n.banner {\n  width: calc(75 / 750 * 100) vw\n}\n```\n\n## transfrom 方案\n\n该方案不需要转换单位，正常以 `px` 为单位。只需要以屏幕宽度与视觉稿的宽度的比作为基数，在根节点上进行缩变即可：\n\n```js\nlet docEl = document.documentElement\nlet ratio = 750 / docEl.clientWidth\n\ndocument.body.style.transform = `scale(${ratio})`\n```\n\n> 目前发现此方案存在兼容性问题，在 iOS 上，`fixed` 定位的元素会失去固定的效果，会随着滚动改变位置。另外在某些 Android 上，`fixed` 的元素会滑动之后消失。因此，**不建议使用此方案**\n\n## viewport meta 方案\n\n此方案与 transform 方案类似，通过缩变，以将页面宽度适应屏幕宽度。\n\n不同的地方在于，需要移除现有的 `viewport meta`，在 `head` 增加一个脚本实时生成 `viewport meta`：\n\n```html\n<script>\n  let meta = document.createElement('meta')\n  meta.setAttribute('name', 'viewport')\n  meta.setAttribute('content', `width=750, initial-scale=${screen.width/750}, user-scalable=no`)\n  document.documentElement.firstElementChild.appendChild(meta)\n</script>\n<!-- <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no\"> -->\n```\n\n# 参考资料\n\n- [移动端viewport标签背后的三层含义](https://zhuanlan.zhihu.com/p/21276657)\n- [使用Flexible实现手淘H5页面的终端适配](https://github.com/amfe/article/issues/17)\n- [MDN meta](https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag)\n- [Configuring the Viewport](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html)\n- [A tale of two viewports — part two](https://www.quirksmode.org/mobile/viewports2.html)\n- [掘金](https://juejin.im/post/5b6503dee51d45191e0d30d2#heading-24)\n- [H5移动多终端适配全解 - 从原理到方案](https://zhuanlan.zhihu.com/p/25422063)","source":"_posts/responsive-web.md","raw":"---\ntitle: 移动端适配的四种方案\ndate: 2020-08-11 19:44:03\ntags:\ncategories:\n- 前端基础\n---\n\n# viewport 的作用\n\nviewport 翻译成中文是“视窗”的意思，也就是字面上的意思，页面展示的窗口。知道这个 viewport 有哪些作用呢？我举例一下：\n\n<!-- more -->\n\n## 计算百分比值\n\n当我们设置一个块级元素的宽度为百分比的时候，在HTML的规则中，最终的大小取决于它的父元素。如果元素嵌套情况如下：\n\n```\nhtml > body > div\n```\n\n最终要计算出 `div` 的实际大小，就要知道 `body` 的大小，而 `body` 的大小又依赖于 `html`。所以最终的问题是，如何计算 `html` 的大小。而这个 `html` 是根元素，没有父元素。此时就是 `viewport` 登场了。由它来约束 `html` 的大小。\n\n## 用户缩放\n\n当用户进行缩放时，对于我们的页面是如何变化的，或者用户当前是否存在缩放状态，这些都是通过 `viewport` 来获取的。\n\n用户进行缩放时，页面的 CSS 像素是不发生变化的（如果有变化，必然触发重新渲染），变化的是视窗的大小。当用户放大页面是，视窗应该是变小，但物理像素是不会变化的，因此相同的 CSS 像素占用更多的设备像素，因此此时 dpr 会变大。\n\n> dpr(device pixel ratio) 设备像素比 = 物理像素 / 设备独立像素\n\n在 `JavaScript` 里，我们可以通过 `screen.width` 获取物理像素的宽度，通过 `window.innerWidth` 获取当前页面的独立设备像素，因此可以这样计算设备像素比：`screen.width / window.innerWidth`。\n\n当然，也可以直接获得设备像素比：`window.devicePixelRatio`\n\n在桌面端，**设备像素比(dpr)** 通常情况下都是等于 1，当不等于 1 的时候，通常是用户进行缩放了。\n\n## 移动端适配\n\n在移动端，会有许多各种尺寸的屏幕。如何在不同的屏幕呈现相同的效果，这就是移动端适配的工作，要想弄清楚如何兼容，就要先理解 `viewport` 的概念。\n\n# 基础概念\n\n## 屏幕尺寸\n\n可通过 `screen.width/height` 获得。一般是通过 **设备像素(device pixel)** 来计算。\n\n![screen-width](/blog/images/responsive-web/screen-width.png)\n\n## 窗口尺寸\n\n可通过 `window.innerWidth/innerHeight` 获得。一般是通过 CSS 像素来计算。窗口是浏览器的窗口，包含了滚动条的尺寸，不包含顶部菜单：\n\n![window-width](/blog/images/responsive-web/window-width.png)\n\n## 视窗尺寸\n\n可通过 `document.documentElement.clientWidth/clientHeight` 获得。一般是通过 CSS 像素来计算。视窗与窗口差别在于不包含滚动条的尺寸：\n\n![viewport-width](/blog/images/responsive-web/viewport-width.png)\n\n# 移动端适配\n\n## REM 方案\n\n视觉稿 750px，设置根元素即（html）的大小为 75px，所有元素均这样计算，以 `230px` 举例:\n\n```\nwidth: 350px / 75px = 5rem\n```\n\n此时页面上的所有元素均以根元素的 `font-size` 计算，因此要做到动态支持不同尺寸的手机，只需要动态修改根元素的 `font-size` 即可。由于我们是以 `750px` 的十分之一为基准的，所以只需将当前 **视觉窗口(visual viewport)** 同样除以 10 即可：\n\n```js\nlet docEl = document.documentElement\nlet rem = docEl.clientWidth / 10\n\ndocEl.style.fontSize = rem + 'px'\n```\n\n另外，由于 `font-size` 是继承性属性，上述代码将 `<html>` 的 `font-size` 修改了，为了不影响到默认的字体大小，可以在 `<body>` 上重置 `font-size`:\n\n```css\nbody {\n  font-size: inital;\n}\n```\n\n## VW 方案\n\nVW 方案是和 REM 方案的原理是一致的：以当前宽度按比例动态调整。\n\nVW 方案的优势是 **不需要动态调整基数**。vw 单元原生支持与当前视觉窗口按比例动态变化。**缺点是会有一定的兼容性**，可以看下 vw 的兼容情况：\n\n![vw-compatibility](/blog/images/responsive-web/vw-compatibility.png)\n\n具体实现方案与 REM 类似，以视觉稿的宽度（一般为 750px）为基准，将 px 单位转换成 vw 单位，以 `75px` 举例：(基于 vw 的定义，全宽等于 100vw)：\n\n```css\n.banner {\n  width: calc(75 / 750 * 100) vw\n}\n```\n\n## transfrom 方案\n\n该方案不需要转换单位，正常以 `px` 为单位。只需要以屏幕宽度与视觉稿的宽度的比作为基数，在根节点上进行缩变即可：\n\n```js\nlet docEl = document.documentElement\nlet ratio = 750 / docEl.clientWidth\n\ndocument.body.style.transform = `scale(${ratio})`\n```\n\n> 目前发现此方案存在兼容性问题，在 iOS 上，`fixed` 定位的元素会失去固定的效果，会随着滚动改变位置。另外在某些 Android 上，`fixed` 的元素会滑动之后消失。因此，**不建议使用此方案**\n\n## viewport meta 方案\n\n此方案与 transform 方案类似，通过缩变，以将页面宽度适应屏幕宽度。\n\n不同的地方在于，需要移除现有的 `viewport meta`，在 `head` 增加一个脚本实时生成 `viewport meta`：\n\n```html\n<script>\n  let meta = document.createElement('meta')\n  meta.setAttribute('name', 'viewport')\n  meta.setAttribute('content', `width=750, initial-scale=${screen.width/750}, user-scalable=no`)\n  document.documentElement.firstElementChild.appendChild(meta)\n</script>\n<!-- <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no\"> -->\n```\n\n# 参考资料\n\n- [移动端viewport标签背后的三层含义](https://zhuanlan.zhihu.com/p/21276657)\n- [使用Flexible实现手淘H5页面的终端适配](https://github.com/amfe/article/issues/17)\n- [MDN meta](https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag)\n- [Configuring the Viewport](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html)\n- [A tale of two viewports — part two](https://www.quirksmode.org/mobile/viewports2.html)\n- [掘金](https://juejin.im/post/5b6503dee51d45191e0d30d2#heading-24)\n- [H5移动多终端适配全解 - 从原理到方案](https://zhuanlan.zhihu.com/p/25422063)","slug":"responsive-web","published":1,"updated":"2023-08-04T11:56:06.994Z","_id":"clkwipq6z000l3tsz634a948g","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"viewport-的作用\"><a href=\"#viewport-的作用\" class=\"headerlink\" title=\"viewport 的作用\"></a>viewport 的作用</h1><p>viewport 翻译成中文是“视窗”的意思，也就是字面上的意思，页面展示的窗口。知道这个 viewport 有哪些作用呢？我举例一下：</p>\n<span id=\"more\"></span>\n\n<h2 id=\"计算百分比值\"><a href=\"#计算百分比值\" class=\"headerlink\" title=\"计算百分比值\"></a>计算百分比值</h2><p>当我们设置一个块级元素的宽度为百分比的时候，在HTML的规则中，最终的大小取决于它的父元素。如果元素嵌套情况如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html &gt; body &gt; div</span><br></pre></td></tr></table></figure>\n\n<p>最终要计算出 <code>div</code> 的实际大小，就要知道 <code>body</code> 的大小，而 <code>body</code> 的大小又依赖于 <code>html</code>。所以最终的问题是，如何计算 <code>html</code> 的大小。而这个 <code>html</code> 是根元素，没有父元素。此时就是 <code>viewport</code> 登场了。由它来约束 <code>html</code> 的大小。</p>\n<h2 id=\"用户缩放\"><a href=\"#用户缩放\" class=\"headerlink\" title=\"用户缩放\"></a>用户缩放</h2><p>当用户进行缩放时，对于我们的页面是如何变化的，或者用户当前是否存在缩放状态，这些都是通过 <code>viewport</code> 来获取的。</p>\n<p>用户进行缩放时，页面的 CSS 像素是不发生变化的（如果有变化，必然触发重新渲染），变化的是视窗的大小。当用户放大页面是，视窗应该是变小，但物理像素是不会变化的，因此相同的 CSS 像素占用更多的设备像素，因此此时 dpr 会变大。</p>\n<blockquote>\n<p>dpr(device pixel ratio) 设备像素比 = 物理像素 / 设备独立像素</p>\n</blockquote>\n<p>在 <code>JavaScript</code> 里，我们可以通过 <code>screen.width</code> 获取物理像素的宽度，通过 <code>window.innerWidth</code> 获取当前页面的独立设备像素，因此可以这样计算设备像素比：<code>screen.width / window.innerWidth</code>。</p>\n<p>当然，也可以直接获得设备像素比：<code>window.devicePixelRatio</code></p>\n<p>在桌面端，<strong>设备像素比(dpr)</strong> 通常情况下都是等于 1，当不等于 1 的时候，通常是用户进行缩放了。</p>\n<h2 id=\"移动端适配\"><a href=\"#移动端适配\" class=\"headerlink\" title=\"移动端适配\"></a>移动端适配</h2><p>在移动端，会有许多各种尺寸的屏幕。如何在不同的屏幕呈现相同的效果，这就是移动端适配的工作，要想弄清楚如何兼容，就要先理解 <code>viewport</code> 的概念。</p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"屏幕尺寸\"><a href=\"#屏幕尺寸\" class=\"headerlink\" title=\"屏幕尺寸\"></a>屏幕尺寸</h2><p>可通过 <code>screen.width/height</code> 获得。一般是通过 <strong>设备像素(device pixel)</strong> 来计算。</p>\n<p><img src=\"/blog/images/responsive-web/screen-width.png\" alt=\"screen-width\"></p>\n<h2 id=\"窗口尺寸\"><a href=\"#窗口尺寸\" class=\"headerlink\" title=\"窗口尺寸\"></a>窗口尺寸</h2><p>可通过 <code>window.innerWidth/innerHeight</code> 获得。一般是通过 CSS 像素来计算。窗口是浏览器的窗口，包含了滚动条的尺寸，不包含顶部菜单：</p>\n<p><img src=\"/blog/images/responsive-web/window-width.png\" alt=\"window-width\"></p>\n<h2 id=\"视窗尺寸\"><a href=\"#视窗尺寸\" class=\"headerlink\" title=\"视窗尺寸\"></a>视窗尺寸</h2><p>可通过 <code>document.documentElement.clientWidth/clientHeight</code> 获得。一般是通过 CSS 像素来计算。视窗与窗口差别在于不包含滚动条的尺寸：</p>\n<p><img src=\"/blog/images/responsive-web/viewport-width.png\" alt=\"viewport-width\"></p>\n<h1 id=\"移动端适配-1\"><a href=\"#移动端适配-1\" class=\"headerlink\" title=\"移动端适配\"></a>移动端适配</h1><h2 id=\"REM-方案\"><a href=\"#REM-方案\" class=\"headerlink\" title=\"REM 方案\"></a>REM 方案</h2><p>视觉稿 750px，设置根元素即（html）的大小为 75px，所有元素均这样计算，以 <code>230px</code> 举例:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width: 350px / 75px = 5rem</span><br></pre></td></tr></table></figure>\n\n<p>此时页面上的所有元素均以根元素的 <code>font-size</code> 计算，因此要做到动态支持不同尺寸的手机，只需要动态修改根元素的 <code>font-size</code> 即可。由于我们是以 <code>750px</code> 的十分之一为基准的，所以只需将当前 <strong>视觉窗口(visual viewport)</strong> 同样除以 10 即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> docEl = <span class=\"built_in\">document</span>.documentElement</span><br><span class=\"line\"><span class=\"keyword\">let</span> rem = docEl.clientWidth / <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">docEl.style.fontSize = rem + <span class=\"string\">&#x27;px&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，由于 <code>font-size</code> 是继承性属性，上述代码将 <code>&lt;html&gt;</code> 的 <code>font-size</code> 修改了，为了不影响到默认的字体大小，可以在 <code>&lt;body&gt;</code> 上重置 <code>font-size</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: inital;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"VW-方案\"><a href=\"#VW-方案\" class=\"headerlink\" title=\"VW 方案\"></a>VW 方案</h2><p>VW 方案是和 REM 方案的原理是一致的：以当前宽度按比例动态调整。</p>\n<p>VW 方案的优势是 <strong>不需要动态调整基数</strong>。vw 单元原生支持与当前视觉窗口按比例动态变化。<strong>缺点是会有一定的兼容性</strong>，可以看下 vw 的兼容情况：</p>\n<p><img src=\"/blog/images/responsive-web/vw-compatibility.png\" alt=\"vw-compatibility\"></p>\n<p>具体实现方案与 REM 类似，以视觉稿的宽度（一般为 750px）为基准，将 px 单位转换成 vw 单位，以 <code>75px</code> 举例：(基于 vw 的定义，全宽等于 100vw)：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.banner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"built_in\">calc</span>(<span class=\"number\">75</span> / <span class=\"number\">750</span> * <span class=\"number\">100</span>) vw</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"transfrom-方案\"><a href=\"#transfrom-方案\" class=\"headerlink\" title=\"transfrom 方案\"></a>transfrom 方案</h2><p>该方案不需要转换单位，正常以 <code>px</code> 为单位。只需要以屏幕宽度与视觉稿的宽度的比作为基数，在根节点上进行缩变即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> docEl = <span class=\"built_in\">document</span>.documentElement</span><br><span class=\"line\"><span class=\"keyword\">let</span> ratio = <span class=\"number\">750</span> / docEl.clientWidth</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.style.transform = <span class=\"string\">`scale(<span class=\"subst\">$&#123;ratio&#125;</span>)`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>目前发现此方案存在兼容性问题，在 iOS 上，<code>fixed</code> 定位的元素会失去固定的效果，会随着滚动改变位置。另外在某些 Android 上，<code>fixed</code> 的元素会滑动之后消失。因此，<strong>不建议使用此方案</strong></p>\n</blockquote>\n<h2 id=\"viewport-meta-方案\"><a href=\"#viewport-meta-方案\" class=\"headerlink\" title=\"viewport meta 方案\"></a>viewport meta 方案</h2><p>此方案与 transform 方案类似，通过缩变，以将页面宽度适应屏幕宽度。</p>\n<p>不同的地方在于，需要移除现有的 <code>viewport meta</code>，在 <code>head</code> 增加一个脚本实时生成 <code>viewport meta</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> meta = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;meta&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  meta.setAttribute(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;viewport&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  meta.setAttribute(<span class=\"string\">&#x27;content&#x27;</span>, <span class=\"string\">`width=750, initial-scale=<span class=\"subst\">$&#123;screen.width/<span class=\"number\">750</span>&#125;</span>, user-scalable=no`</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.documentElement.firstElementChild.appendChild(meta)</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; --&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21276657\">移动端viewport标签背后的三层含义</a></li>\n<li><a href=\"https://github.com/amfe/article/issues/17\">使用Flexible实现手淘H5页面的终端适配</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag\">MDN meta</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html\">Configuring the Viewport</a></li>\n<li><a href=\"https://www.quirksmode.org/mobile/viewports2.html\">A tale of two viewports — part two</a></li>\n<li><a href=\"https://juejin.im/post/5b6503dee51d45191e0d30d2#heading-24\">掘金</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25422063\">H5移动多终端适配全解 - 从原理到方案</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h1 id=\"viewport-的作用\"><a href=\"#viewport-的作用\" class=\"headerlink\" title=\"viewport 的作用\"></a>viewport 的作用</h1><p>viewport 翻译成中文是“视窗”的意思，也就是字面上的意思，页面展示的窗口。知道这个 viewport 有哪些作用呢？我举例一下：</p>","more":"<h2 id=\"计算百分比值\"><a href=\"#计算百分比值\" class=\"headerlink\" title=\"计算百分比值\"></a>计算百分比值</h2><p>当我们设置一个块级元素的宽度为百分比的时候，在HTML的规则中，最终的大小取决于它的父元素。如果元素嵌套情况如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html &gt; body &gt; div</span><br></pre></td></tr></table></figure>\n\n<p>最终要计算出 <code>div</code> 的实际大小，就要知道 <code>body</code> 的大小，而 <code>body</code> 的大小又依赖于 <code>html</code>。所以最终的问题是，如何计算 <code>html</code> 的大小。而这个 <code>html</code> 是根元素，没有父元素。此时就是 <code>viewport</code> 登场了。由它来约束 <code>html</code> 的大小。</p>\n<h2 id=\"用户缩放\"><a href=\"#用户缩放\" class=\"headerlink\" title=\"用户缩放\"></a>用户缩放</h2><p>当用户进行缩放时，对于我们的页面是如何变化的，或者用户当前是否存在缩放状态，这些都是通过 <code>viewport</code> 来获取的。</p>\n<p>用户进行缩放时，页面的 CSS 像素是不发生变化的（如果有变化，必然触发重新渲染），变化的是视窗的大小。当用户放大页面是，视窗应该是变小，但物理像素是不会变化的，因此相同的 CSS 像素占用更多的设备像素，因此此时 dpr 会变大。</p>\n<blockquote>\n<p>dpr(device pixel ratio) 设备像素比 = 物理像素 / 设备独立像素</p>\n</blockquote>\n<p>在 <code>JavaScript</code> 里，我们可以通过 <code>screen.width</code> 获取物理像素的宽度，通过 <code>window.innerWidth</code> 获取当前页面的独立设备像素，因此可以这样计算设备像素比：<code>screen.width / window.innerWidth</code>。</p>\n<p>当然，也可以直接获得设备像素比：<code>window.devicePixelRatio</code></p>\n<p>在桌面端，<strong>设备像素比(dpr)</strong> 通常情况下都是等于 1，当不等于 1 的时候，通常是用户进行缩放了。</p>\n<h2 id=\"移动端适配\"><a href=\"#移动端适配\" class=\"headerlink\" title=\"移动端适配\"></a>移动端适配</h2><p>在移动端，会有许多各种尺寸的屏幕。如何在不同的屏幕呈现相同的效果，这就是移动端适配的工作，要想弄清楚如何兼容，就要先理解 <code>viewport</code> 的概念。</p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"屏幕尺寸\"><a href=\"#屏幕尺寸\" class=\"headerlink\" title=\"屏幕尺寸\"></a>屏幕尺寸</h2><p>可通过 <code>screen.width/height</code> 获得。一般是通过 <strong>设备像素(device pixel)</strong> 来计算。</p>\n<p><img src=\"/blog/images/responsive-web/screen-width.png\" alt=\"screen-width\"></p>\n<h2 id=\"窗口尺寸\"><a href=\"#窗口尺寸\" class=\"headerlink\" title=\"窗口尺寸\"></a>窗口尺寸</h2><p>可通过 <code>window.innerWidth/innerHeight</code> 获得。一般是通过 CSS 像素来计算。窗口是浏览器的窗口，包含了滚动条的尺寸，不包含顶部菜单：</p>\n<p><img src=\"/blog/images/responsive-web/window-width.png\" alt=\"window-width\"></p>\n<h2 id=\"视窗尺寸\"><a href=\"#视窗尺寸\" class=\"headerlink\" title=\"视窗尺寸\"></a>视窗尺寸</h2><p>可通过 <code>document.documentElement.clientWidth/clientHeight</code> 获得。一般是通过 CSS 像素来计算。视窗与窗口差别在于不包含滚动条的尺寸：</p>\n<p><img src=\"/blog/images/responsive-web/viewport-width.png\" alt=\"viewport-width\"></p>\n<h1 id=\"移动端适配-1\"><a href=\"#移动端适配-1\" class=\"headerlink\" title=\"移动端适配\"></a>移动端适配</h1><h2 id=\"REM-方案\"><a href=\"#REM-方案\" class=\"headerlink\" title=\"REM 方案\"></a>REM 方案</h2><p>视觉稿 750px，设置根元素即（html）的大小为 75px，所有元素均这样计算，以 <code>230px</code> 举例:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width: 350px / 75px = 5rem</span><br></pre></td></tr></table></figure>\n\n<p>此时页面上的所有元素均以根元素的 <code>font-size</code> 计算，因此要做到动态支持不同尺寸的手机，只需要动态修改根元素的 <code>font-size</code> 即可。由于我们是以 <code>750px</code> 的十分之一为基准的，所以只需将当前 <strong>视觉窗口(visual viewport)</strong> 同样除以 10 即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> docEl = <span class=\"built_in\">document</span>.documentElement</span><br><span class=\"line\"><span class=\"keyword\">let</span> rem = docEl.clientWidth / <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">docEl.style.fontSize = rem + <span class=\"string\">&#x27;px&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，由于 <code>font-size</code> 是继承性属性，上述代码将 <code>&lt;html&gt;</code> 的 <code>font-size</code> 修改了，为了不影响到默认的字体大小，可以在 <code>&lt;body&gt;</code> 上重置 <code>font-size</code>:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: inital;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"VW-方案\"><a href=\"#VW-方案\" class=\"headerlink\" title=\"VW 方案\"></a>VW 方案</h2><p>VW 方案是和 REM 方案的原理是一致的：以当前宽度按比例动态调整。</p>\n<p>VW 方案的优势是 <strong>不需要动态调整基数</strong>。vw 单元原生支持与当前视觉窗口按比例动态变化。<strong>缺点是会有一定的兼容性</strong>，可以看下 vw 的兼容情况：</p>\n<p><img src=\"/blog/images/responsive-web/vw-compatibility.png\" alt=\"vw-compatibility\"></p>\n<p>具体实现方案与 REM 类似，以视觉稿的宽度（一般为 750px）为基准，将 px 单位转换成 vw 单位，以 <code>75px</code> 举例：(基于 vw 的定义，全宽等于 100vw)：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.banner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"built_in\">calc</span>(<span class=\"number\">75</span> / <span class=\"number\">750</span> * <span class=\"number\">100</span>) vw</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"transfrom-方案\"><a href=\"#transfrom-方案\" class=\"headerlink\" title=\"transfrom 方案\"></a>transfrom 方案</h2><p>该方案不需要转换单位，正常以 <code>px</code> 为单位。只需要以屏幕宽度与视觉稿的宽度的比作为基数，在根节点上进行缩变即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> docEl = <span class=\"built_in\">document</span>.documentElement</span><br><span class=\"line\"><span class=\"keyword\">let</span> ratio = <span class=\"number\">750</span> / docEl.clientWidth</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.style.transform = <span class=\"string\">`scale(<span class=\"subst\">$&#123;ratio&#125;</span>)`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>目前发现此方案存在兼容性问题，在 iOS 上，<code>fixed</code> 定位的元素会失去固定的效果，会随着滚动改变位置。另外在某些 Android 上，<code>fixed</code> 的元素会滑动之后消失。因此，<strong>不建议使用此方案</strong></p>\n</blockquote>\n<h2 id=\"viewport-meta-方案\"><a href=\"#viewport-meta-方案\" class=\"headerlink\" title=\"viewport meta 方案\"></a>viewport meta 方案</h2><p>此方案与 transform 方案类似，通过缩变，以将页面宽度适应屏幕宽度。</p>\n<p>不同的地方在于，需要移除现有的 <code>viewport meta</code>，在 <code>head</code> 增加一个脚本实时生成 <code>viewport meta</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">let</span> meta = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;meta&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  meta.setAttribute(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;viewport&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  meta.setAttribute(<span class=\"string\">&#x27;content&#x27;</span>, <span class=\"string\">`width=750, initial-scale=<span class=\"subst\">$&#123;screen.width/<span class=\"number\">750</span>&#125;</span>, user-scalable=no`</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.documentElement.firstElementChild.appendChild(meta)</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; --&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21276657\">移动端viewport标签背后的三层含义</a></li>\n<li><a href=\"https://github.com/amfe/article/issues/17\">使用Flexible实现手淘H5页面的终端适配</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag\">MDN meta</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html\">Configuring the Viewport</a></li>\n<li><a href=\"https://www.quirksmode.org/mobile/viewports2.html\">A tale of two viewports — part two</a></li>\n<li><a href=\"https://juejin.im/post/5b6503dee51d45191e0d30d2#heading-24\">掘金</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25422063\">H5移动多终端适配全解 - 从原理到方案</a></li>\n</ul>"},{"title":"Vue 技术细节 - data","date":"2020-07-22T11:57:53.000Z","_content":"\n> Vue.js 是前端热门的UI框架。目前国内的前端团队一般都是 Vue.js、React 二选一。\n\n理解 Vue.js 的技术细节，既有助于日常工作开发，也是一个很好的敲门砖。\n\n<!-- more -->\n\n# 背景\n\n我在社区里搜索过 Vue.js 相关的文章，发现不少高赞的文章都是水文，或者是年久失修的老文。\n\n如果读者不明所以，直接照本宣科，面试的结果必然是凉凉。因此，我还是建议读者们自行阅读源码，或者看一些源码解析的文章（这里我推荐一下[黄老师的源码解析](https://ustbhuangyi.github.io/vue-analysis/)），不会一知半解，被水文坑害。本文也是笔者自己的 Vue.js 相关的底层原理的认知总结，如有纰漏，或者错误，烦请指正。\n\n# 常见问题\n\n## Vue.js 里 data 为什么必须是函数？\n\n因为最近几年微信小程序也挺火，因此这个问题可以联想到 **微信小程序的 data 怎么是对象而不是函数呢？**\n\n> vue 的官方也有提到，在同时渲染多个相同组件时，为了避免组件之间的数据互相影响，因此需要使用函数返回的对象来隔离。\n\n其实，从上面官网的解释很容易理解。对象是引用类型，被多个组件使用，必然会互相影响。所以不要被官网初始化 Vue 实例的例子误导：\n\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n\n因为这个 Vue 实例是唯一的，所以不存在互相影响的问题。\n\n所以可以得出结论1：**data 使用函数是避免多个组件实例之间互相影响**\n\n使用组件有两种方式：\n1. 全局注册；使用 `Vue.component()`\n2. 局部注册；在组件对象里使用 `components` 属性\n\n下面以局部注册举例。\n\n渲染页面时，Vue.js 会解析 `HTML` 的tag，如果此时发现不是原生 tag，就会从 `components` 属性里获取对应的组件声明，如果找到，则使用 `createComponent` 函数创建组件，将组件声明通过 `Vue.extend`（源码位置：`src/core/global-api/extend.js`）来初始化构造函数 `Ctor`，这个 `Ctor` 将会被复用。\n\n由此可见，我们的组件声明并不是直接用来当构造函数的，而是构造函数的入参。因此使用 data 函数可以避免数据的混淆，也避免了 Vue.js 需要对 data 进行深复制的繁琐操作，提升了执行速度。\n\n# 参考资料\n- [Vue.js技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)","source":"_posts/vue/why-data-must-function.md","raw":"---\ntitle: Vue 技术细节 - data\ndate: 2020-07-22 19:57:53\ntags:\n---\n\n> Vue.js 是前端热门的UI框架。目前国内的前端团队一般都是 Vue.js、React 二选一。\n\n理解 Vue.js 的技术细节，既有助于日常工作开发，也是一个很好的敲门砖。\n\n<!-- more -->\n\n# 背景\n\n我在社区里搜索过 Vue.js 相关的文章，发现不少高赞的文章都是水文，或者是年久失修的老文。\n\n如果读者不明所以，直接照本宣科，面试的结果必然是凉凉。因此，我还是建议读者们自行阅读源码，或者看一些源码解析的文章（这里我推荐一下[黄老师的源码解析](https://ustbhuangyi.github.io/vue-analysis/)），不会一知半解，被水文坑害。本文也是笔者自己的 Vue.js 相关的底层原理的认知总结，如有纰漏，或者错误，烦请指正。\n\n# 常见问题\n\n## Vue.js 里 data 为什么必须是函数？\n\n因为最近几年微信小程序也挺火，因此这个问题可以联想到 **微信小程序的 data 怎么是对象而不是函数呢？**\n\n> vue 的官方也有提到，在同时渲染多个相同组件时，为了避免组件之间的数据互相影响，因此需要使用函数返回的对象来隔离。\n\n其实，从上面官网的解释很容易理解。对象是引用类型，被多个组件使用，必然会互相影响。所以不要被官网初始化 Vue 实例的例子误导：\n\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n```\n\n因为这个 Vue 实例是唯一的，所以不存在互相影响的问题。\n\n所以可以得出结论1：**data 使用函数是避免多个组件实例之间互相影响**\n\n使用组件有两种方式：\n1. 全局注册；使用 `Vue.component()`\n2. 局部注册；在组件对象里使用 `components` 属性\n\n下面以局部注册举例。\n\n渲染页面时，Vue.js 会解析 `HTML` 的tag，如果此时发现不是原生 tag，就会从 `components` 属性里获取对应的组件声明，如果找到，则使用 `createComponent` 函数创建组件，将组件声明通过 `Vue.extend`（源码位置：`src/core/global-api/extend.js`）来初始化构造函数 `Ctor`，这个 `Ctor` 将会被复用。\n\n由此可见，我们的组件声明并不是直接用来当构造函数的，而是构造函数的入参。因此使用 data 函数可以避免数据的混淆，也避免了 Vue.js 需要对 data 进行深复制的繁琐操作，提升了执行速度。\n\n# 参考资料\n- [Vue.js技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)","slug":"vue/why-data-must-function","published":1,"updated":"2023-08-04T12:05:42.576Z","_id":"clkwj7s6e000r3tsze7ls8rln","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Vue.js 是前端热门的UI框架。目前国内的前端团队一般都是 Vue.js、React 二选一。</p>\n</blockquote>\n<p>理解 Vue.js 的技术细节，既有助于日常工作开发，也是一个很好的敲门砖。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>我在社区里搜索过 Vue.js 相关的文章，发现不少高赞的文章都是水文，或者是年久失修的老文。</p>\n<p>如果读者不明所以，直接照本宣科，面试的结果必然是凉凉。因此，我还是建议读者们自行阅读源码，或者看一些源码解析的文章（这里我推荐一下<a href=\"https://ustbhuangyi.github.io/vue-analysis/\">黄老师的源码解析</a>），不会一知半解，被水文坑害。本文也是笔者自己的 Vue.js 相关的底层原理的认知总结，如有纰漏，或者错误，烦请指正。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h2 id=\"Vue-js-里-data-为什么必须是函数？\"><a href=\"#Vue-js-里-data-为什么必须是函数？\" class=\"headerlink\" title=\"Vue.js 里 data 为什么必须是函数？\"></a>Vue.js 里 data 为什么必须是函数？</h2><p>因为最近几年微信小程序也挺火，因此这个问题可以联想到 <strong>微信小程序的 data 怎么是对象而不是函数呢？</strong></p>\n<blockquote>\n<p>vue 的官方也有提到，在同时渲染多个相同组件时，为了避免组件之间的数据互相影响，因此需要使用函数返回的对象来隔离。</p>\n</blockquote>\n<p>其实，从上面官网的解释很容易理解。对象是引用类型，被多个组件使用，必然会互相影响。所以不要被官网初始化 Vue 实例的例子误导：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello Vue!&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>因为这个 Vue 实例是唯一的，所以不存在互相影响的问题。</p>\n<p>所以可以得出结论1：<strong>data 使用函数是避免多个组件实例之间互相影响</strong></p>\n<p>使用组件有两种方式：</p>\n<ol>\n<li>全局注册；使用 <code>Vue.component()</code></li>\n<li>局部注册；在组件对象里使用 <code>components</code> 属性</li>\n</ol>\n<p>下面以局部注册举例。</p>\n<p>渲染页面时，Vue.js 会解析 <code>HTML</code> 的tag，如果此时发现不是原生 tag，就会从 <code>components</code> 属性里获取对应的组件声明，如果找到，则使用 <code>createComponent</code> 函数创建组件，将组件声明通过 <code>Vue.extend</code>（源码位置：<code>src/core/global-api/extend.js</code>）来初始化构造函数 <code>Ctor</code>，这个 <code>Ctor</code> 将会被复用。</p>\n<p>由此可见，我们的组件声明并不是直接用来当构造函数的，而是构造函数的入参。因此使用 data 函数可以避免数据的混淆，也避免了 Vue.js 需要对 data 进行深复制的繁琐操作，提升了执行速度。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/\">Vue.js技术揭秘</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<blockquote>\n<p>Vue.js 是前端热门的UI框架。目前国内的前端团队一般都是 Vue.js、React 二选一。</p>\n</blockquote>\n<p>理解 Vue.js 的技术细节，既有助于日常工作开发，也是一个很好的敲门砖。</p>","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>我在社区里搜索过 Vue.js 相关的文章，发现不少高赞的文章都是水文，或者是年久失修的老文。</p>\n<p>如果读者不明所以，直接照本宣科，面试的结果必然是凉凉。因此，我还是建议读者们自行阅读源码，或者看一些源码解析的文章（这里我推荐一下<a href=\"https://ustbhuangyi.github.io/vue-analysis/\">黄老师的源码解析</a>），不会一知半解，被水文坑害。本文也是笔者自己的 Vue.js 相关的底层原理的认知总结，如有纰漏，或者错误，烦请指正。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h2 id=\"Vue-js-里-data-为什么必须是函数？\"><a href=\"#Vue-js-里-data-为什么必须是函数？\" class=\"headerlink\" title=\"Vue.js 里 data 为什么必须是函数？\"></a>Vue.js 里 data 为什么必须是函数？</h2><p>因为最近几年微信小程序也挺火，因此这个问题可以联想到 <strong>微信小程序的 data 怎么是对象而不是函数呢？</strong></p>\n<blockquote>\n<p>vue 的官方也有提到，在同时渲染多个相同组件时，为了避免组件之间的数据互相影响，因此需要使用函数返回的对象来隔离。</p>\n</blockquote>\n<p>其实，从上面官网的解释很容易理解。对象是引用类型，被多个组件使用，必然会互相影响。所以不要被官网初始化 Vue 实例的例子误导：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello Vue!&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>因为这个 Vue 实例是唯一的，所以不存在互相影响的问题。</p>\n<p>所以可以得出结论1：<strong>data 使用函数是避免多个组件实例之间互相影响</strong></p>\n<p>使用组件有两种方式：</p>\n<ol>\n<li>全局注册；使用 <code>Vue.component()</code></li>\n<li>局部注册；在组件对象里使用 <code>components</code> 属性</li>\n</ol>\n<p>下面以局部注册举例。</p>\n<p>渲染页面时，Vue.js 会解析 <code>HTML</code> 的tag，如果此时发现不是原生 tag，就会从 <code>components</code> 属性里获取对应的组件声明，如果找到，则使用 <code>createComponent</code> 函数创建组件，将组件声明通过 <code>Vue.extend</code>（源码位置：<code>src/core/global-api/extend.js</code>）来初始化构造函数 <code>Ctor</code>，这个 <code>Ctor</code> 将会被复用。</p>\n<p>由此可见，我们的组件声明并不是直接用来当构造函数的，而是构造函数的入参。因此使用 data 函数可以避免数据的混淆，也避免了 Vue.js 需要对 data 进行深复制的繁琐操作，提升了执行速度。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/\">Vue.js技术揭秘</a></li>\n</ul>"},{"title":"JavaScript 数据类型详解","date":"2020-07-27T12:04:26.000Z","toc":true,"_content":"\n# 前言\n\nJavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。\n\n但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。\n\n社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。但为了解决问题而引入新的语法糖，只会是增加复杂度，将问题转移罢了。\n\n因此对待问题的最好解决办法是正视它，剖析其背后原理。\n\n本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。\n\n<!-- more -->\n\n# 数据类型\n\n- 基础数据类型：undefined、null、Boolean、String、Number、Symbol\n- 引用数据类型：Object\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fee2f56647c6~tplv-t2oaga2asx-image.image)\n\n> 任何没有赋值的变量都有这个值：undefined\n\n# 类型转换\n\n## 显示类型转换（explicit conversion）\n\n常用的数据类型有这三种：Boolean、Number、String，可以看下显示转换：\n\n||undefined|null|Boolean|Number|String|Symbol|Object|\n|--|--|--|--|--|--|--|--|\n|toBoolean|false|false|/|false: -0、+0、NaN<br>true：其他|false: ''<br>true：其他|true|true|\n|toNumber|NaN|0|1：true<br>0：false|/|（下章详解）|抛出异常TypeError|调用valueOf()|\n|toString|'undefined'|'null'|'true'：true<br>'false'：false|（下章详解）|/|抛出异常TypeError|调用toString()|\n\n## 隐式类型转换（implicitly conversion）\n\n大致有以下场景会出现隐式类型转换：\n- 条件语句（`if`、`else`、）\n- 循环语句（`for`、`while`）\n- 逻辑运算符：`!`、`&&`、`||`、`?:`三元运算符\n- 算术运算符：`+`\n- 比较运算符：`==`、`<`、`>`\n\n其中，条件语句和循环语句都是将类型转换成 Boolean，因此可以参考上表。其他的类型，会有特殊的类型转换规则：\n\n||Number|String|Boolean|Object|undefined|null|Symbol|\n|--|--|--|--|--|--|--|--|\nNumber|===||||||\nString|string.toNumber()|===|||||\nBoolean|boolean.toNumber()|boolean.toNumber()|===||||\nObject|Object.toPrimitive()|Object.toPrimitive()|false|===|||\nundefined|false|false|false|false|true||\nnull|false|false|false|false|true|true|\nSymbol|false|false|false|Object.toPrimitive()|false|false|===|\n\n## 字符串转数字\n\n具体转换算法有些复杂，以下拿具体的方式举例。\n\nJavaScript 提供了好几种方式：\n- `parseInt()`\n- `parseFloat()`\n- `Number()`\n- `Math.ceil()`\n- `Math.floor()`\n- 运算符：`+`或`*`\n\n以下举例对比之前的差别，如整数字符串(int string)：\n\n```js\nlet intStr = '1'\n\nparseInt(intStr) // 1\nparseFloat(intStr) // 1\nNumber(intStr) // 1\nMath.ceil(intStr) // 1\nMath.floor(intStr) // 1\n+ intStr // 1\nintStr * 1 // 1\n```\n\n浮点型数字字符串(float string)：\n\n```js\nlet fltStr = '1.23'\n\nparseInt(fltStr) // 1\nparseFloat(fltStr) // 1.23\nNumber(fltStr) // 1.23\nMath.ceil(fltStr) // 2\nMath.floor(fltStr) // 1\n+ fltStr // 1.23\nfltStr * 1 // 1.23\n```\n\n非数字字符串(NaN string)\n\n```js\nlet str = 'abcdefg'\n\nparseInt(str) // NaN\nparseFloat(str) // NaN\nNumber(str) // NaN\nMath.ceil(str) // NaN\nMath.floor(str) // NaN\n+ str // NaN\nstr * 1 // NaN\n```\n\n数字+字母 字符串(number and alpha string):\n\n```js\nlet str = '1.23abcdefg'\n\nparseInt(str) // 1\nparseFloat(str) // 1.23\nNumber(str) // NaN\nMath.ceil(str) // NaN\nMath.floor(str) // NaN\n+ str // NaN\nstr * 1 // NaN\n```\n\n字母+数字 字符串(alpha and number string)\n\n```js\nlet str = 'abcd1.23'\n\nparseInt(str) // NaN\nparseFloat(str) // NaN\nNumber(str) // NaN\nMath.ceil(str) // NaN\nMath.floor(str) // NaN\n+ str // NaN\nstr * 1 // NaN\n```\n\n除了结果直接的差异之外，性能也有些差异，在[《how-to-convert-string-to-number-javascript》](https://flaviocopes.com/how-to-convert-string-to-number-javascript/)文章有相关的性能对比，有兴趣的可以看一下。这里我直接贴个结果图：\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/27/1738f4e0446f03b9~tplv-t2oaga2asx-image.image)\n\n## 数字转字符串\n\n相对比较复杂，可以参考 ecma262 的[文档](https://tc39.es/ecma262/#sec-numeric-types-number-tostring)\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fe0f5d595809~tplv-t2oaga2asx-image.image)\n\n。。。持续更新\n\n# 参考\n\n- [深入理解JS的类型、值、类型转换](https://github.com/amandakelake/blog/issues/34)\n- [JavaScript Convert String to Number](https://stackabuse.com/javascript-convert-string-to-number/)\n- [Converting strings to numbers with vanilla JavaScript](https://gomakethings.com/converting-strings-to-numbers-with-vanilla-javascript/)\n- [How to convert a string to a number in JavaScript](https://flaviocopes.com/how-to-convert-string-to-number-javascript/)","source":"_posts/fe-base/js-data-type.md","raw":"---\ntitle: JavaScript 数据类型详解\ndate: 2020-07-27 20:04:26\ntags:\ntoc: true\n---\n\n# 前言\n\nJavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。\n\n但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。\n\n社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。但为了解决问题而引入新的语法糖，只会是增加复杂度，将问题转移罢了。\n\n因此对待问题的最好解决办法是正视它，剖析其背后原理。\n\n本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。\n\n<!-- more -->\n\n# 数据类型\n\n- 基础数据类型：undefined、null、Boolean、String、Number、Symbol\n- 引用数据类型：Object\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fee2f56647c6~tplv-t2oaga2asx-image.image)\n\n> 任何没有赋值的变量都有这个值：undefined\n\n# 类型转换\n\n## 显示类型转换（explicit conversion）\n\n常用的数据类型有这三种：Boolean、Number、String，可以看下显示转换：\n\n||undefined|null|Boolean|Number|String|Symbol|Object|\n|--|--|--|--|--|--|--|--|\n|toBoolean|false|false|/|false: -0、+0、NaN<br>true：其他|false: ''<br>true：其他|true|true|\n|toNumber|NaN|0|1：true<br>0：false|/|（下章详解）|抛出异常TypeError|调用valueOf()|\n|toString|'undefined'|'null'|'true'：true<br>'false'：false|（下章详解）|/|抛出异常TypeError|调用toString()|\n\n## 隐式类型转换（implicitly conversion）\n\n大致有以下场景会出现隐式类型转换：\n- 条件语句（`if`、`else`、）\n- 循环语句（`for`、`while`）\n- 逻辑运算符：`!`、`&&`、`||`、`?:`三元运算符\n- 算术运算符：`+`\n- 比较运算符：`==`、`<`、`>`\n\n其中，条件语句和循环语句都是将类型转换成 Boolean，因此可以参考上表。其他的类型，会有特殊的类型转换规则：\n\n||Number|String|Boolean|Object|undefined|null|Symbol|\n|--|--|--|--|--|--|--|--|\nNumber|===||||||\nString|string.toNumber()|===|||||\nBoolean|boolean.toNumber()|boolean.toNumber()|===||||\nObject|Object.toPrimitive()|Object.toPrimitive()|false|===|||\nundefined|false|false|false|false|true||\nnull|false|false|false|false|true|true|\nSymbol|false|false|false|Object.toPrimitive()|false|false|===|\n\n## 字符串转数字\n\n具体转换算法有些复杂，以下拿具体的方式举例。\n\nJavaScript 提供了好几种方式：\n- `parseInt()`\n- `parseFloat()`\n- `Number()`\n- `Math.ceil()`\n- `Math.floor()`\n- 运算符：`+`或`*`\n\n以下举例对比之前的差别，如整数字符串(int string)：\n\n```js\nlet intStr = '1'\n\nparseInt(intStr) // 1\nparseFloat(intStr) // 1\nNumber(intStr) // 1\nMath.ceil(intStr) // 1\nMath.floor(intStr) // 1\n+ intStr // 1\nintStr * 1 // 1\n```\n\n浮点型数字字符串(float string)：\n\n```js\nlet fltStr = '1.23'\n\nparseInt(fltStr) // 1\nparseFloat(fltStr) // 1.23\nNumber(fltStr) // 1.23\nMath.ceil(fltStr) // 2\nMath.floor(fltStr) // 1\n+ fltStr // 1.23\nfltStr * 1 // 1.23\n```\n\n非数字字符串(NaN string)\n\n```js\nlet str = 'abcdefg'\n\nparseInt(str) // NaN\nparseFloat(str) // NaN\nNumber(str) // NaN\nMath.ceil(str) // NaN\nMath.floor(str) // NaN\n+ str // NaN\nstr * 1 // NaN\n```\n\n数字+字母 字符串(number and alpha string):\n\n```js\nlet str = '1.23abcdefg'\n\nparseInt(str) // 1\nparseFloat(str) // 1.23\nNumber(str) // NaN\nMath.ceil(str) // NaN\nMath.floor(str) // NaN\n+ str // NaN\nstr * 1 // NaN\n```\n\n字母+数字 字符串(alpha and number string)\n\n```js\nlet str = 'abcd1.23'\n\nparseInt(str) // NaN\nparseFloat(str) // NaN\nNumber(str) // NaN\nMath.ceil(str) // NaN\nMath.floor(str) // NaN\n+ str // NaN\nstr * 1 // NaN\n```\n\n除了结果直接的差异之外，性能也有些差异，在[《how-to-convert-string-to-number-javascript》](https://flaviocopes.com/how-to-convert-string-to-number-javascript/)文章有相关的性能对比，有兴趣的可以看一下。这里我直接贴个结果图：\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/27/1738f4e0446f03b9~tplv-t2oaga2asx-image.image)\n\n## 数字转字符串\n\n相对比较复杂，可以参考 ecma262 的[文档](https://tc39.es/ecma262/#sec-numeric-types-number-tostring)\n\n\n![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fe0f5d595809~tplv-t2oaga2asx-image.image)\n\n。。。持续更新\n\n# 参考\n\n- [深入理解JS的类型、值、类型转换](https://github.com/amandakelake/blog/issues/34)\n- [JavaScript Convert String to Number](https://stackabuse.com/javascript-convert-string-to-number/)\n- [Converting strings to numbers with vanilla JavaScript](https://gomakethings.com/converting-strings-to-numbers-with-vanilla-javascript/)\n- [How to convert a string to a number in JavaScript](https://flaviocopes.com/how-to-convert-string-to-number-javascript/)","slug":"fe-base/js-data-type","published":1,"updated":"2023-08-04T12:07:30.830Z","_id":"clkwjgcbb000v3tszhg0pdyw1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>JavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。</p>\n<p>但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。</p>\n<p>社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。但为了解决问题而引入新的语法糖，只会是增加复杂度，将问题转移罢了。</p>\n<p>因此对待问题的最好解决办法是正视它，剖析其背后原理。</p>\n<p>本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><ul>\n<li>基础数据类型：undefined、null、Boolean、String、Number、Symbol</li>\n<li>引用数据类型：Object</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fee2f56647c6~tplv-t2oaga2asx-image.image\"></p>\n<blockquote>\n<p>任何没有赋值的变量都有这个值：undefined</p>\n</blockquote>\n<h1 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h1><h2 id=\"显示类型转换（explicit-conversion）\"><a href=\"#显示类型转换（explicit-conversion）\" class=\"headerlink\" title=\"显示类型转换（explicit conversion）\"></a>显示类型转换（explicit conversion）</h2><p>常用的数据类型有这三种：Boolean、Number、String，可以看下显示转换：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>undefined</th>\n<th>null</th>\n<th>Boolean</th>\n<th>Number</th>\n<th>String</th>\n<th>Symbol</th>\n<th>Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>toBoolean</td>\n<td>false</td>\n<td>false</td>\n<td>/</td>\n<td>false: -0、+0、NaN<br>true：其他</td>\n<td>false: ‘’<br>true：其他</td>\n<td>true</td>\n<td>true</td>\n</tr>\n<tr>\n<td>toNumber</td>\n<td>NaN</td>\n<td>0</td>\n<td>1：true<br>0：false</td>\n<td>/</td>\n<td>（下章详解）</td>\n<td>抛出异常TypeError</td>\n<td>调用valueOf()</td>\n</tr>\n<tr>\n<td>toString</td>\n<td>‘undefined’</td>\n<td>‘null’</td>\n<td>‘true’：true<br>‘false’：false</td>\n<td>（下章详解）</td>\n<td>/</td>\n<td>抛出异常TypeError</td>\n<td>调用toString()</td>\n</tr>\n</tbody></table>\n<h2 id=\"隐式类型转换（implicitly-conversion）\"><a href=\"#隐式类型转换（implicitly-conversion）\" class=\"headerlink\" title=\"隐式类型转换（implicitly conversion）\"></a>隐式类型转换（implicitly conversion）</h2><p>大致有以下场景会出现隐式类型转换：</p>\n<ul>\n<li>条件语句（<code>if</code>、<code>else</code>、）</li>\n<li>循环语句（<code>for</code>、<code>while</code>）</li>\n<li>逻辑运算符：<code>!</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>?:</code>三元运算符</li>\n<li>算术运算符：<code>+</code></li>\n<li>比较运算符：<code>==</code>、<code>&lt;</code>、<code>&gt;</code></li>\n</ul>\n<p>其中，条件语句和循环语句都是将类型转换成 Boolean，因此可以参考上表。其他的类型，会有特殊的类型转换规则：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Number</th>\n<th>String</th>\n<th>Boolean</th>\n<th>Object</th>\n<th>undefined</th>\n<th>null</th>\n<th>Symbol</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>String</td>\n<td>string.toNumber()</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>boolean.toNumber()</td>\n<td>boolean.toNumber()</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Object</td>\n<td>Object.toPrimitive()</td>\n<td>Object.toPrimitive()</td>\n<td>false</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>undefined</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>true</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>null</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>true</td>\n<td>true</td>\n<td></td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>Object.toPrimitive()</td>\n<td>false</td>\n<td>false</td>\n<td>===</td>\n</tr>\n</tbody></table>\n<h2 id=\"字符串转数字\"><a href=\"#字符串转数字\" class=\"headerlink\" title=\"字符串转数字\"></a>字符串转数字</h2><p>具体转换算法有些复杂，以下拿具体的方式举例。</p>\n<p>JavaScript 提供了好几种方式：</p>\n<ul>\n<li><code>parseInt()</code></li>\n<li><code>parseFloat()</code></li>\n<li><code>Number()</code></li>\n<li><code>Math.ceil()</code></li>\n<li><code>Math.floor()</code></li>\n<li>运算符：<code>+</code>或<code>*</code></li>\n</ul>\n<p>以下举例对比之前的差别，如整数字符串(int string)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> intStr = <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\">+ intStr <span class=\"comment\">// 1</span></span><br><span class=\"line\">intStr * <span class=\"number\">1</span> <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>浮点型数字字符串(float string)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fltStr = <span class=\"string\">&#x27;1.23&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(fltStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(fltStr) <span class=\"comment\">// 1.23</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(fltStr) <span class=\"comment\">// 1.23</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(fltStr) <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(fltStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\">+ fltStr <span class=\"comment\">// 1.23</span></span><br><span class=\"line\">fltStr * <span class=\"number\">1</span> <span class=\"comment\">// 1.23</span></span><br></pre></td></tr></table></figure>\n\n<p>非数字字符串(NaN string)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+ str <span class=\"comment\">// NaN</span></span><br><span class=\"line\">str * <span class=\"number\">1</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>数字+字母 字符串(number and alpha string):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;1.23abcdefg&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(str) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(str) <span class=\"comment\">// 1.23</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+ str <span class=\"comment\">// NaN</span></span><br><span class=\"line\">str * <span class=\"number\">1</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>字母+数字 字符串(alpha and number string)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abcd1.23&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+ str <span class=\"comment\">// NaN</span></span><br><span class=\"line\">str * <span class=\"number\">1</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>除了结果直接的差异之外，性能也有些差异，在<a href=\"https://flaviocopes.com/how-to-convert-string-to-number-javascript/\">《how-to-convert-string-to-number-javascript》</a>文章有相关的性能对比，有兴趣的可以看一下。这里我直接贴个结果图：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/27/1738f4e0446f03b9~tplv-t2oaga2asx-image.image\"></p>\n<h2 id=\"数字转字符串\"><a href=\"#数字转字符串\" class=\"headerlink\" title=\"数字转字符串\"></a>数字转字符串</h2><p>相对比较复杂，可以参考 ecma262 的<a href=\"https://tc39.es/ecma262/#sec-numeric-types-number-tostring\">文档</a></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fe0f5d595809~tplv-t2oaga2asx-image.image\"></p>\n<p>。。。持续更新</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://github.com/amandakelake/blog/issues/34\">深入理解JS的类型、值、类型转换</a></li>\n<li><a href=\"https://stackabuse.com/javascript-convert-string-to-number/\">JavaScript Convert String to Number</a></li>\n<li><a href=\"https://gomakethings.com/converting-strings-to-numbers-with-vanilla-javascript/\">Converting strings to numbers with vanilla JavaScript</a></li>\n<li><a href=\"https://flaviocopes.com/how-to-convert-string-to-number-javascript/\">How to convert a string to a number in JavaScript</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>JavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。</p>\n<p>但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。</p>\n<p>社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。但为了解决问题而引入新的语法糖，只会是增加复杂度，将问题转移罢了。</p>\n<p>因此对待问题的最好解决办法是正视它，剖析其背后原理。</p>\n<p>本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。</p>","more":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><ul>\n<li>基础数据类型：undefined、null、Boolean、String、Number、Symbol</li>\n<li>引用数据类型：Object</li>\n</ul>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fee2f56647c6~tplv-t2oaga2asx-image.image\"></p>\n<blockquote>\n<p>任何没有赋值的变量都有这个值：undefined</p>\n</blockquote>\n<h1 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h1><h2 id=\"显示类型转换（explicit-conversion）\"><a href=\"#显示类型转换（explicit-conversion）\" class=\"headerlink\" title=\"显示类型转换（explicit conversion）\"></a>显示类型转换（explicit conversion）</h2><p>常用的数据类型有这三种：Boolean、Number、String，可以看下显示转换：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>undefined</th>\n<th>null</th>\n<th>Boolean</th>\n<th>Number</th>\n<th>String</th>\n<th>Symbol</th>\n<th>Object</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>toBoolean</td>\n<td>false</td>\n<td>false</td>\n<td>/</td>\n<td>false: -0、+0、NaN<br>true：其他</td>\n<td>false: ‘’<br>true：其他</td>\n<td>true</td>\n<td>true</td>\n</tr>\n<tr>\n<td>toNumber</td>\n<td>NaN</td>\n<td>0</td>\n<td>1：true<br>0：false</td>\n<td>/</td>\n<td>（下章详解）</td>\n<td>抛出异常TypeError</td>\n<td>调用valueOf()</td>\n</tr>\n<tr>\n<td>toString</td>\n<td>‘undefined’</td>\n<td>‘null’</td>\n<td>‘true’：true<br>‘false’：false</td>\n<td>（下章详解）</td>\n<td>/</td>\n<td>抛出异常TypeError</td>\n<td>调用toString()</td>\n</tr>\n</tbody></table>\n<h2 id=\"隐式类型转换（implicitly-conversion）\"><a href=\"#隐式类型转换（implicitly-conversion）\" class=\"headerlink\" title=\"隐式类型转换（implicitly conversion）\"></a>隐式类型转换（implicitly conversion）</h2><p>大致有以下场景会出现隐式类型转换：</p>\n<ul>\n<li>条件语句（<code>if</code>、<code>else</code>、）</li>\n<li>循环语句（<code>for</code>、<code>while</code>）</li>\n<li>逻辑运算符：<code>!</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>?:</code>三元运算符</li>\n<li>算术运算符：<code>+</code></li>\n<li>比较运算符：<code>==</code>、<code>&lt;</code>、<code>&gt;</code></li>\n</ul>\n<p>其中，条件语句和循环语句都是将类型转换成 Boolean，因此可以参考上表。其他的类型，会有特殊的类型转换规则：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Number</th>\n<th>String</th>\n<th>Boolean</th>\n<th>Object</th>\n<th>undefined</th>\n<th>null</th>\n<th>Symbol</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>String</td>\n<td>string.toNumber()</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>boolean.toNumber()</td>\n<td>boolean.toNumber()</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Object</td>\n<td>Object.toPrimitive()</td>\n<td>Object.toPrimitive()</td>\n<td>false</td>\n<td>===</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>undefined</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>true</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>null</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>true</td>\n<td>true</td>\n<td></td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>false</td>\n<td>false</td>\n<td>false</td>\n<td>Object.toPrimitive()</td>\n<td>false</td>\n<td>false</td>\n<td>===</td>\n</tr>\n</tbody></table>\n<h2 id=\"字符串转数字\"><a href=\"#字符串转数字\" class=\"headerlink\" title=\"字符串转数字\"></a>字符串转数字</h2><p>具体转换算法有些复杂，以下拿具体的方式举例。</p>\n<p>JavaScript 提供了好几种方式：</p>\n<ul>\n<li><code>parseInt()</code></li>\n<li><code>parseFloat()</code></li>\n<li><code>Number()</code></li>\n<li><code>Math.ceil()</code></li>\n<li><code>Math.floor()</code></li>\n<li>运算符：<code>+</code>或<code>*</code></li>\n</ul>\n<p>以下举例对比之前的差别，如整数字符串(int string)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> intStr = <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(intStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\">+ intStr <span class=\"comment\">// 1</span></span><br><span class=\"line\">intStr * <span class=\"number\">1</span> <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>浮点型数字字符串(float string)：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fltStr = <span class=\"string\">&#x27;1.23&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(fltStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(fltStr) <span class=\"comment\">// 1.23</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(fltStr) <span class=\"comment\">// 1.23</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(fltStr) <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(fltStr) <span class=\"comment\">// 1</span></span><br><span class=\"line\">+ fltStr <span class=\"comment\">// 1.23</span></span><br><span class=\"line\">fltStr * <span class=\"number\">1</span> <span class=\"comment\">// 1.23</span></span><br></pre></td></tr></table></figure>\n\n<p>非数字字符串(NaN string)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abcdefg&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+ str <span class=\"comment\">// NaN</span></span><br><span class=\"line\">str * <span class=\"number\">1</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>数字+字母 字符串(number and alpha string):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;1.23abcdefg&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(str) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(str) <span class=\"comment\">// 1.23</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+ str <span class=\"comment\">// NaN</span></span><br><span class=\"line\">str * <span class=\"number\">1</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>字母+数字 字符串(alpha and number string)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;abcd1.23&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.ceil(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(str) <span class=\"comment\">// NaN</span></span><br><span class=\"line\">+ str <span class=\"comment\">// NaN</span></span><br><span class=\"line\">str * <span class=\"number\">1</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>除了结果直接的差异之外，性能也有些差异，在<a href=\"https://flaviocopes.com/how-to-convert-string-to-number-javascript/\">《how-to-convert-string-to-number-javascript》</a>文章有相关的性能对比，有兴趣的可以看一下。这里我直接贴个结果图：</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/27/1738f4e0446f03b9~tplv-t2oaga2asx-image.image\"></p>\n<h2 id=\"数字转字符串\"><a href=\"#数字转字符串\" class=\"headerlink\" title=\"数字转字符串\"></a>数字转字符串</h2><p>相对比较复杂，可以参考 ecma262 的<a href=\"https://tc39.es/ecma262/#sec-numeric-types-number-tostring\">文档</a></p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737fe0f5d595809~tplv-t2oaga2asx-image.image\"></p>\n<p>。。。持续更新</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://github.com/amandakelake/blog/issues/34\">深入理解JS的类型、值、类型转换</a></li>\n<li><a href=\"https://stackabuse.com/javascript-convert-string-to-number/\">JavaScript Convert String to Number</a></li>\n<li><a href=\"https://gomakethings.com/converting-strings-to-numbers-with-vanilla-javascript/\">Converting strings to numbers with vanilla JavaScript</a></li>\n<li><a href=\"https://flaviocopes.com/how-to-convert-string-to-number-javascript/\">How to convert a string to a number in JavaScript</a></li>\n</ul>"},{"title":"JavaScript 的数据类型转换","date":"2021-02-03T12:09:07.000Z","toc":true,"_content":"\n# 前言\n\nJavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。\n\n但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。\n\n社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。从团队的收益出发，增加这些是一个好的选择，但是也增加了许多学习成本。思考本质的话，这其实是为了解决问题而引入新的语法糖，增加了项目的复杂度，将问题转移罢了。\n\n因此对于个人成长而言，对待问题的最好解决办法是正视它，剖析其背后原理。\n\n本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。\n\n原始数据类型：boolean、number、bigint、string、undefined、null、symbol（ES2016新增）\n\n复合数据类型：Object\n\n<!-- more -->\n\n# 相等算法\n\n截止 ES2015，存在 4 种数值相等算法：\n\n- Abstract Equality Comparison(==)：也称半等\n- Strict Equality Comparison(===)：也成全等；使用相同算法的还有 `Array.prototype.indexOf`、`Array.prototype.lastIndexOf`、`case` 语法\n- Same-Value-Zero：`Set`、`Map`、还有 `Array.prototype.includes` 和 `String.prototype.includes`\n- Same-Value：除了以上都是该算法；常见：`Object.is`\n\n半等和全等比较常见，唯一差别就是是否进行类型转换（当类型相同时，两个算法是相等的）\n\n半等和全等为了满足 IEEE 754 标准，做了特殊处理：NaN ! = NaN 和 -0 == +0\n\n## 半等 Abstract Equality Comparison\n\n半等（==）的逻辑大致可以这么理解：\n\n1. 类型是否相等？同类型则使用全等比较，类型不同则往下\n2. 两个数分别是 undefined、null？是则返回 true，否则往下\n3. 类型是 boolean 或 string？通过转换成 number 再比较\n\n    使用`Number()`转换而不是`parseInt`，可以看下面代码：\n\n    ```jsx\n    '123abc' == 123 // false\n    parseInt('123abc') == 123 // true\n    ```\n\n4. 类型是 object？通过 **转换成原始数据类型(`toPrimitive`)** 再比较\n\n    转换原始数据类型优先使用 `valueOf()` 而不是 `toString()` ，但如果未定义 `valueOf()` 则会使用 `toSting()`\n\n    ```jsx\n    var obj = {\n    \tvalueOf: () => 1,\n    \ttoString: () => 2\n    }\n\n    obj == 1 // true\n    obj == 2 // false\n\n    var obj2 = {\n    \ttoString: () => 2\n    }\n\n    obj == 2 // true\n    ```\n\n5. 都不是则返回 false\n\n> 总的原则是：尽可能都转换成Number容易比较\n\n## 全等 Strict Equality Comparison\n\n全等（===）的逻辑比较符合预期：\n\n1. 类型不一致，直接返回 false\n2. 如果是 undefined 或 null，则返回 true\n3. 如果是 Number 的话，做了特殊处理：\n    - `NaN != NaN`\n    - `-0 == +0`\n4. 如果是对象，查看是否是同个引用，是则返回 true，否则返回 false\n5. 剩下的逻辑都是判断两值是否相等\n\n## Same-Value 算法\n\n之所以会提供这个算法，是因为半等和全等存在两个问题：\n\n- 无法正确判断NaN，因为 `NaN != NaN`\n- 无法区分 `+0` 和 `-0`\n\n而支持该算法的函数有 `Object.is()` ：\n\n```jsx\nObject.is(-0, +0) // false\n-0 == +0 // true\n-0 === +0 // true\n\nObject.is(NaN, NaN) // true\nNaN == NaN // false\nNaN === NaN // false\n```\n\n此处 NaN 的判断又可以延伸一下，ES2015 提供了 `Number.isNaN` 方法\n\n此时，你会很奇怪，之前不是有个全局方法 `isNaN` 了吗？是的，这个方法也是很诡异的。\n\n因为 isNaN 会对传入的参数做类型转换，如果能转换成 Number 类型，则返回 true，否则返回 false\n\n而 Number.isNaN 修正了这个逻辑，只做纯粹的判断，避免了歧义：\n\n```jsx\nvar numberStr = '123'\n\nisNaN(numberStr) // false\nNumber.isNaN(numberStr) // false\n\nvar str = 'abc'\n\nisNaN(str) // true **歧义点**\nNumber.isNaN(str) // false\n\nisNaN(NaN) // true\nNumber.isNaN(NaN) // true\n```\n\n因此，`Number.isNaN` 的 pollfill 可以这样实现：\n\n```jsx\nNumber.isNaN = function(value) {\n\treturn typeof value == 'number' && isNaN(value);\n}\n```\n\n## Same-Value-Zero 算法\n\n很多时候，可能并不想区别开 `+0` 与 `-0`，但还需要知道是不是 `NaN`，因此推出了这个算法。\n\n这个算法和 Same-Value 算法很类似，以为差别是目前这个算法 `+0` 等于 `-0` 。\n\n内置该算法的函数前面有提到，下面以 `Set` 举例：\n\n```jsx\nlet set = new Set()\n\nset.add(NaN)\nset.add(0 / 0) // 0 / 0 = NaN 因此不会添加\n\nconsole.log(set.size) // 1\n\nset.add(+0)\nset.add(-0) // -0 == +0 因此不会添加\n\nconsole.log(set.size) // 2\n```\n\n参考资料：\n\n- [Primitive | MDN](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\n- [Standard ECMA-262 5.1 Edition](https://262.ecma-international.org/5.1)\n- [Equality comparisons and sameness | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)","source":"_posts/fe-base/js-data-type-transform.md","raw":"---\ntitle: JavaScript 的数据类型转换\ndate: 2021-02-03 20:09:07\ntags:\ntoc: true\ncategories:\n- 前端基础\n---\n\n# 前言\n\nJavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。\n\n但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。\n\n社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。从团队的收益出发，增加这些是一个好的选择，但是也增加了许多学习成本。思考本质的话，这其实是为了解决问题而引入新的语法糖，增加了项目的复杂度，将问题转移罢了。\n\n因此对于个人成长而言，对待问题的最好解决办法是正视它，剖析其背后原理。\n\n本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。\n\n原始数据类型：boolean、number、bigint、string、undefined、null、symbol（ES2016新增）\n\n复合数据类型：Object\n\n<!-- more -->\n\n# 相等算法\n\n截止 ES2015，存在 4 种数值相等算法：\n\n- Abstract Equality Comparison(==)：也称半等\n- Strict Equality Comparison(===)：也成全等；使用相同算法的还有 `Array.prototype.indexOf`、`Array.prototype.lastIndexOf`、`case` 语法\n- Same-Value-Zero：`Set`、`Map`、还有 `Array.prototype.includes` 和 `String.prototype.includes`\n- Same-Value：除了以上都是该算法；常见：`Object.is`\n\n半等和全等比较常见，唯一差别就是是否进行类型转换（当类型相同时，两个算法是相等的）\n\n半等和全等为了满足 IEEE 754 标准，做了特殊处理：NaN ! = NaN 和 -0 == +0\n\n## 半等 Abstract Equality Comparison\n\n半等（==）的逻辑大致可以这么理解：\n\n1. 类型是否相等？同类型则使用全等比较，类型不同则往下\n2. 两个数分别是 undefined、null？是则返回 true，否则往下\n3. 类型是 boolean 或 string？通过转换成 number 再比较\n\n    使用`Number()`转换而不是`parseInt`，可以看下面代码：\n\n    ```jsx\n    '123abc' == 123 // false\n    parseInt('123abc') == 123 // true\n    ```\n\n4. 类型是 object？通过 **转换成原始数据类型(`toPrimitive`)** 再比较\n\n    转换原始数据类型优先使用 `valueOf()` 而不是 `toString()` ，但如果未定义 `valueOf()` 则会使用 `toSting()`\n\n    ```jsx\n    var obj = {\n    \tvalueOf: () => 1,\n    \ttoString: () => 2\n    }\n\n    obj == 1 // true\n    obj == 2 // false\n\n    var obj2 = {\n    \ttoString: () => 2\n    }\n\n    obj == 2 // true\n    ```\n\n5. 都不是则返回 false\n\n> 总的原则是：尽可能都转换成Number容易比较\n\n## 全等 Strict Equality Comparison\n\n全等（===）的逻辑比较符合预期：\n\n1. 类型不一致，直接返回 false\n2. 如果是 undefined 或 null，则返回 true\n3. 如果是 Number 的话，做了特殊处理：\n    - `NaN != NaN`\n    - `-0 == +0`\n4. 如果是对象，查看是否是同个引用，是则返回 true，否则返回 false\n5. 剩下的逻辑都是判断两值是否相等\n\n## Same-Value 算法\n\n之所以会提供这个算法，是因为半等和全等存在两个问题：\n\n- 无法正确判断NaN，因为 `NaN != NaN`\n- 无法区分 `+0` 和 `-0`\n\n而支持该算法的函数有 `Object.is()` ：\n\n```jsx\nObject.is(-0, +0) // false\n-0 == +0 // true\n-0 === +0 // true\n\nObject.is(NaN, NaN) // true\nNaN == NaN // false\nNaN === NaN // false\n```\n\n此处 NaN 的判断又可以延伸一下，ES2015 提供了 `Number.isNaN` 方法\n\n此时，你会很奇怪，之前不是有个全局方法 `isNaN` 了吗？是的，这个方法也是很诡异的。\n\n因为 isNaN 会对传入的参数做类型转换，如果能转换成 Number 类型，则返回 true，否则返回 false\n\n而 Number.isNaN 修正了这个逻辑，只做纯粹的判断，避免了歧义：\n\n```jsx\nvar numberStr = '123'\n\nisNaN(numberStr) // false\nNumber.isNaN(numberStr) // false\n\nvar str = 'abc'\n\nisNaN(str) // true **歧义点**\nNumber.isNaN(str) // false\n\nisNaN(NaN) // true\nNumber.isNaN(NaN) // true\n```\n\n因此，`Number.isNaN` 的 pollfill 可以这样实现：\n\n```jsx\nNumber.isNaN = function(value) {\n\treturn typeof value == 'number' && isNaN(value);\n}\n```\n\n## Same-Value-Zero 算法\n\n很多时候，可能并不想区别开 `+0` 与 `-0`，但还需要知道是不是 `NaN`，因此推出了这个算法。\n\n这个算法和 Same-Value 算法很类似，以为差别是目前这个算法 `+0` 等于 `-0` 。\n\n内置该算法的函数前面有提到，下面以 `Set` 举例：\n\n```jsx\nlet set = new Set()\n\nset.add(NaN)\nset.add(0 / 0) // 0 / 0 = NaN 因此不会添加\n\nconsole.log(set.size) // 1\n\nset.add(+0)\nset.add(-0) // -0 == +0 因此不会添加\n\nconsole.log(set.size) // 2\n```\n\n参考资料：\n\n- [Primitive | MDN](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\n- [Standard ECMA-262 5.1 Edition](https://262.ecma-international.org/5.1)\n- [Equality comparisons and sameness | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)","slug":"fe-base/js-data-type-transform","published":1,"updated":"2023-08-04T12:14:07.609Z","_id":"clkwjm14i000x3tsz2ny3gt3w","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>JavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。</p>\n<p>但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。</p>\n<p>社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。从团队的收益出发，增加这些是一个好的选择，但是也增加了许多学习成本。思考本质的话，这其实是为了解决问题而引入新的语法糖，增加了项目的复杂度，将问题转移罢了。</p>\n<p>因此对于个人成长而言，对待问题的最好解决办法是正视它，剖析其背后原理。</p>\n<p>本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。</p>\n<p>原始数据类型：boolean、number、bigint、string、undefined、null、symbol（ES2016新增）</p>\n<p>复合数据类型：Object</p>\n<span id=\"more\"></span>\n\n<h1 id=\"相等算法\"><a href=\"#相等算法\" class=\"headerlink\" title=\"相等算法\"></a>相等算法</h1><p>截止 ES2015，存在 4 种数值相等算法：</p>\n<ul>\n<li>Abstract Equality Comparison(==)：也称半等</li>\n<li>Strict Equality Comparison(===)：也成全等；使用相同算法的还有 <code>Array.prototype.indexOf</code>、<code>Array.prototype.lastIndexOf</code>、<code>case</code> 语法</li>\n<li>Same-Value-Zero：<code>Set</code>、<code>Map</code>、还有 <code>Array.prototype.includes</code> 和 <code>String.prototype.includes</code></li>\n<li>Same-Value：除了以上都是该算法；常见：<code>Object.is</code></li>\n</ul>\n<p>半等和全等比较常见，唯一差别就是是否进行类型转换（当类型相同时，两个算法是相等的）</p>\n<p>半等和全等为了满足 IEEE 754 标准，做了特殊处理：NaN ! = NaN 和 -0 == +0</p>\n<h2 id=\"半等-Abstract-Equality-Comparison\"><a href=\"#半等-Abstract-Equality-Comparison\" class=\"headerlink\" title=\"半等 Abstract Equality Comparison\"></a>半等 Abstract Equality Comparison</h2><p>半等（==）的逻辑大致可以这么理解：</p>\n<ol>\n<li><p>类型是否相等？同类型则使用全等比较，类型不同则往下</p>\n</li>\n<li><p>两个数分别是 undefined、null？是则返回 true，否则往下</p>\n</li>\n<li><p>类型是 boolean 或 string？通过转换成 number 再比较</p>\n<p> 使用<code>Number()</code>转换而不是<code>parseInt</code>，可以看下面代码：</p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;123abc&#x27;</span> == <span class=\"number\">123</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;123abc&#x27;</span>) == <span class=\"number\">123</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></li>\n<li><p>类型是 object？通过 <strong>转换成原始数据类型(<code>toPrimitive</code>)</strong> 再比较</p>\n<p> 转换原始数据类型优先使用 <code>valueOf()</code> 而不是 <code>toString()</code> ，但如果未定义 <code>valueOf()</code> 则会使用 <code>toSting()</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">valueOf</span>: <span class=\"function\">() =&gt;</span> <span class=\"number\">1</span>,</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"function\">() =&gt;</span> <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">obj == <span class=\"number\">2</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"function\">() =&gt;</span> <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj == <span class=\"number\">2</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></li>\n<li><p>都不是则返回 false</p>\n</li>\n</ol>\n<blockquote>\n<p>总的原则是：尽可能都转换成Number容易比较</p>\n</blockquote>\n<h2 id=\"全等-Strict-Equality-Comparison\"><a href=\"#全等-Strict-Equality-Comparison\" class=\"headerlink\" title=\"全等 Strict Equality Comparison\"></a>全等 Strict Equality Comparison</h2><p>全等（===）的逻辑比较符合预期：</p>\n<ol>\n<li>类型不一致，直接返回 false</li>\n<li>如果是 undefined 或 null，则返回 true</li>\n<li>如果是 Number 的话，做了特殊处理：<ul>\n<li><code>NaN != NaN</code></li>\n<li><code>-0 == +0</code></li>\n</ul>\n</li>\n<li>如果是对象，查看是否是同个引用，是则返回 true，否则返回 false</li>\n<li>剩下的逻辑都是判断两值是否相等</li>\n</ol>\n<h2 id=\"Same-Value-算法\"><a href=\"#Same-Value-算法\" class=\"headerlink\" title=\"Same-Value 算法\"></a>Same-Value 算法</h2><p>之所以会提供这个算法，是因为半等和全等存在两个问题：</p>\n<ul>\n<li>无法正确判断NaN，因为 <code>NaN != NaN</code></li>\n<li>无法区分 <code>+0</code> 和 <code>-0</code></li>\n</ul>\n<p>而支持该算法的函数有 <code>Object.is()</code> ：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.is(-<span class=\"number\">0</span>, +<span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">-<span class=\"number\">0</span> == +<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">-<span class=\"number\">0</span> === +<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>此处 NaN 的判断又可以延伸一下，ES2015 提供了 <code>Number.isNaN</code> 方法</p>\n<p>此时，你会很奇怪，之前不是有个全局方法 <code>isNaN</code> 了吗？是的，这个方法也是很诡异的。</p>\n<p>因为 isNaN 会对传入的参数做类型转换，如果能转换成 Number 类型，则返回 true，否则返回 false</p>\n<p>而 Number.isNaN 修正了这个逻辑，只做纯粹的判断，避免了歧义：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numberStr = <span class=\"string\">&#x27;123&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(numberStr) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(numberStr) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abc&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(str) <span class=\"comment\">// true **歧义点**</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(str) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>Number.isNaN</code> 的 pollfill 可以这样实现：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value == <span class=\"string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"built_in\">isNaN</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Same-Value-Zero-算法\"><a href=\"#Same-Value-Zero-算法\" class=\"headerlink\" title=\"Same-Value-Zero 算法\"></a>Same-Value-Zero 算法</h2><p>很多时候，可能并不想区别开 <code>+0</code> 与 <code>-0</code>，但还需要知道是不是 <code>NaN</code>，因此推出了这个算法。</p>\n<p>这个算法和 Same-Value 算法很类似，以为差别是目前这个算法 <code>+0</code> 等于 <code>-0</code> 。</p>\n<p>内置该算法的函数前面有提到，下面以 <code>Set</code> 举例：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">set.add(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\">set.add(<span class=\"number\">0</span> / <span class=\"number\">0</span>) <span class=\"comment\">// 0 / 0 = NaN 因此不会添加</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set.size) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">set.add(+<span class=\"number\">0</span>)</span><br><span class=\"line\">set.add(-<span class=\"number\">0</span>) <span class=\"comment\">// -0 == +0 因此不会添加</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set.size) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">Primitive | MDN</a></li>\n<li><a href=\"https://262.ecma-international.org/5.1\">Standard ECMA-262 5.1 Edition</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\">Equality comparisons and sameness | MDN</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"tub.js","url":"https://github.com/LeeJim/tub.js","desc":"a simple JavaScript Alert/Notification plugin"},{"name":"xLoad","url":"https://github.com/LeeJim/xLoad","desc":"a simple scroll load plugin"},{"name":"favweb","url":"http://favweb.cn","desc":"一个以分享有趣网站为宗旨的网站，带你探索整个互联网"},{"name":"时间寄存器","url":"https://minapp.com/miniapp/3437","desc":"微信小程序，第三方时间管理程序。"},{"name":"Jeep-UI","url":"http://jui.qiulijun.com","desc":"基于Vue.js 2.0的UI库"}]}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>JavaScript 是弱类型语言，在定义变量时不需要明确定义类型，刚接触是觉得非常灵活，很方便。</p>\n<p>但随着开发走进深水区，更多的协作开发，越发觉得这种弱类型语言不受控，容易出错。</p>\n<p>社区为了解决弱类型的问题，也有了如 Flow、TypeScript 等扩充。从团队的收益出发，增加这些是一个好的选择，但是也增加了许多学习成本。思考本质的话，这其实是为了解决问题而引入新的语法糖，增加了项目的复杂度，将问题转移罢了。</p>\n<p>因此对于个人成长而言，对待问题的最好解决办法是正视它，剖析其背后原理。</p>\n<p>本文将尝试将 JavaScript 的类型转换归纳总结，试图将日常开发遇到的问题与技巧尽可能地分享给大家。</p>\n<p>原始数据类型：boolean、number、bigint、string、undefined、null、symbol（ES2016新增）</p>\n<p>复合数据类型：Object</p>","more":"<h1 id=\"相等算法\"><a href=\"#相等算法\" class=\"headerlink\" title=\"相等算法\"></a>相等算法</h1><p>截止 ES2015，存在 4 种数值相等算法：</p>\n<ul>\n<li>Abstract Equality Comparison(==)：也称半等</li>\n<li>Strict Equality Comparison(===)：也成全等；使用相同算法的还有 <code>Array.prototype.indexOf</code>、<code>Array.prototype.lastIndexOf</code>、<code>case</code> 语法</li>\n<li>Same-Value-Zero：<code>Set</code>、<code>Map</code>、还有 <code>Array.prototype.includes</code> 和 <code>String.prototype.includes</code></li>\n<li>Same-Value：除了以上都是该算法；常见：<code>Object.is</code></li>\n</ul>\n<p>半等和全等比较常见，唯一差别就是是否进行类型转换（当类型相同时，两个算法是相等的）</p>\n<p>半等和全等为了满足 IEEE 754 标准，做了特殊处理：NaN ! = NaN 和 -0 == +0</p>\n<h2 id=\"半等-Abstract-Equality-Comparison\"><a href=\"#半等-Abstract-Equality-Comparison\" class=\"headerlink\" title=\"半等 Abstract Equality Comparison\"></a>半等 Abstract Equality Comparison</h2><p>半等（==）的逻辑大致可以这么理解：</p>\n<ol>\n<li><p>类型是否相等？同类型则使用全等比较，类型不同则往下</p>\n</li>\n<li><p>两个数分别是 undefined、null？是则返回 true，否则往下</p>\n</li>\n<li><p>类型是 boolean 或 string？通过转换成 number 再比较</p>\n<p> 使用<code>Number()</code>转换而不是<code>parseInt</code>，可以看下面代码：</p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;123abc&#x27;</span> == <span class=\"number\">123</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;123abc&#x27;</span>) == <span class=\"number\">123</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></li>\n<li><p>类型是 object？通过 <strong>转换成原始数据类型(<code>toPrimitive</code>)</strong> 再比较</p>\n<p> 转换原始数据类型优先使用 <code>valueOf()</code> 而不是 <code>toString()</code> ，但如果未定义 <code>valueOf()</code> 则会使用 <code>toSting()</code></p>\n <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">valueOf</span>: <span class=\"function\">() =&gt;</span> <span class=\"number\">1</span>,</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"function\">() =&gt;</span> <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">obj == <span class=\"number\">2</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"function\">() =&gt;</span> <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj == <span class=\"number\">2</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></li>\n<li><p>都不是则返回 false</p>\n</li>\n</ol>\n<blockquote>\n<p>总的原则是：尽可能都转换成Number容易比较</p>\n</blockquote>\n<h2 id=\"全等-Strict-Equality-Comparison\"><a href=\"#全等-Strict-Equality-Comparison\" class=\"headerlink\" title=\"全等 Strict Equality Comparison\"></a>全等 Strict Equality Comparison</h2><p>全等（===）的逻辑比较符合预期：</p>\n<ol>\n<li>类型不一致，直接返回 false</li>\n<li>如果是 undefined 或 null，则返回 true</li>\n<li>如果是 Number 的话，做了特殊处理：<ul>\n<li><code>NaN != NaN</code></li>\n<li><code>-0 == +0</code></li>\n</ul>\n</li>\n<li>如果是对象，查看是否是同个引用，是则返回 true，否则返回 false</li>\n<li>剩下的逻辑都是判断两值是否相等</li>\n</ol>\n<h2 id=\"Same-Value-算法\"><a href=\"#Same-Value-算法\" class=\"headerlink\" title=\"Same-Value 算法\"></a>Same-Value 算法</h2><p>之所以会提供这个算法，是因为半等和全等存在两个问题：</p>\n<ul>\n<li>无法正确判断NaN，因为 <code>NaN != NaN</code></li>\n<li>无法区分 <code>+0</code> 和 <code>-0</code></li>\n</ul>\n<p>而支持该算法的函数有 <code>Object.is()</code> ：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.is(-<span class=\"number\">0</span>, +<span class=\"number\">0</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">-<span class=\"number\">0</span> == +<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">-<span class=\"number\">0</span> === +<span class=\"number\">0</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>此处 NaN 的判断又可以延伸一下，ES2015 提供了 <code>Number.isNaN</code> 方法</p>\n<p>此时，你会很奇怪，之前不是有个全局方法 <code>isNaN</code> 了吗？是的，这个方法也是很诡异的。</p>\n<p>因为 isNaN 会对传入的参数做类型转换，如果能转换成 Number 类型，则返回 true，否则返回 false</p>\n<p>而 Number.isNaN 修正了这个逻辑，只做纯粹的判断，避免了歧义：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numberStr = <span class=\"string\">&#x27;123&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(numberStr) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(numberStr) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;abc&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(str) <span class=\"comment\">// true **歧义点**</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(str) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>Number.isNaN</code> 的 pollfill 可以这样实现：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.isNaN = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value == <span class=\"string\">&#x27;number&#x27;</span> &amp;&amp; <span class=\"built_in\">isNaN</span>(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Same-Value-Zero-算法\"><a href=\"#Same-Value-Zero-算法\" class=\"headerlink\" title=\"Same-Value-Zero 算法\"></a>Same-Value-Zero 算法</h2><p>很多时候，可能并不想区别开 <code>+0</code> 与 <code>-0</code>，但还需要知道是不是 <code>NaN</code>，因此推出了这个算法。</p>\n<p>这个算法和 Same-Value 算法很类似，以为差别是目前这个算法 <code>+0</code> 等于 <code>-0</code> 。</p>\n<p>内置该算法的函数前面有提到，下面以 <code>Set</code> 举例：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">set.add(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\">set.add(<span class=\"number\">0</span> / <span class=\"number\">0</span>) <span class=\"comment\">// 0 / 0 = NaN 因此不会添加</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set.size) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">set.add(+<span class=\"number\">0</span>)</span><br><span class=\"line\">set.add(-<span class=\"number\">0</span>) <span class=\"comment\">// -0 == +0 因此不会添加</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set.size) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">Primitive | MDN</a></li>\n<li><a href=\"https://262.ecma-international.org/5.1\">Standard ECMA-262 5.1 Edition</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\">Equality comparisons and sameness | MDN</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cky5gxvi20000n669b4en271i","category_id":"cky5gzxx1000cn669gnzfhy35","_id":"cky5gzxx2000en669b1xo8397"},{"post_id":"cky5gxvi20000n669b4en271i","category_id":"cky5gzxx2000dn669bt5a6ejc","_id":"cky5gzxx3000fn6690cy672cf"},{"post_id":"cky5gyu8l0006n66981ypaxvq","category_id":"cky5gzxx1000cn669gnzfhy35","_id":"cky5h01kb000gn6690nl15rf3"},{"post_id":"cky5gyu8l0006n66981ypaxvq","category_id":"cky5gzxx2000dn669bt5a6ejc","_id":"cky5h01kb000hn6690qx38g9r"},{"post_id":"cky5gz03r0009n669g47k01vi","category_id":"cky5gzxx1000cn669gnzfhy35","_id":"cky5h03vo000in669h5av286t"},{"post_id":"cky5gz03r0009n669g47k01vi","category_id":"cky5gzxx2000dn669bt5a6ejc","_id":"cky5h03vo000jn669gsqe8l6r"},{"post_id":"cky5gyomk0003n669hjjtay8h","category_id":"cky5gzxx1000cn669gnzfhy35","_id":"cky5h05sl000kn6693ssqflez"},{"post_id":"cky5gyomk0003n669hjjtay8h","category_id":"cky5gzxx2000dn669bt5a6ejc","_id":"cky5h05sl000ln6692lcz1zix"},{"post_id":"cky5ioqer0011n669acm951wc","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqeu0017n6699h5624bb"},{"post_id":"cky5ioqes0012n669gor85mvz","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqev001an669budfg61n"},{"post_id":"cky5ioqet0014n6694fi2336q","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqev001dn6691pe25ee2"},{"post_id":"cky5ioqeu0019n669gy528ksl","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqey001jn66997rt61sv"},{"post_id":"cky5ioqew001fn6694aok78z9","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqez001nn669ffcd6unc"},{"post_id":"cky5ioqex001in66993vkbz4v","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqez001pn669596w2tkf"},{"post_id":"cky5ioqey001ln6691r2db44c","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqf0001rn669c2zs4wiz"},{"post_id":"cky5ioqf0001yn669cm8s1rzq","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5ioqf10020n669hl35a7xd"},{"post_id":"cky5iqlwf0022n669b4hvh6aq","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5iqlwh0024n6698bd61x9i"},{"post_id":"ckxvfmfb80004brqq4tlofoza","category_id":"cky5j47cr002an66955pk4nsp","_id":"cky5j47cs002bn6693bo538rq"},{"post_id":"ckxvfmfdl001obrqq049pap06","category_id":"cky5j68dc002en669eoww9sca","_id":"cky5j68dc002fn6696d9t4gsf"},{"post_id":"ckxvfmfeh0035brqqc2frc291","category_id":"cky5j68dc002en669eoww9sca","_id":"cky5j6gnm002gn669dged62sg"},{"post_id":"ckxvfmfej0036brqq1bfld27k","category_id":"cky5j68dc002en669eoww9sca","_id":"cky5j6pk7002hn6694wczg37k"},{"post_id":"ckxvfmfd0001bbrqqbo8mbgqt","category_id":"cky5j9pz2002in669202042x8","_id":"cky5j9pz3002jn6695dme586w"},{"post_id":"ckxvfmfbe000cbrqq06fa8psr","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jfz5p00041h698wqa1v9n"},{"post_id":"ckxvfmfbe000cbrqq06fa8psr","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5jfz5q00051h69esiecl9y"},{"post_id":"cky5ieoi7000mn6694dbta4cd","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jg4r800071h69euw50zfn"},{"post_id":"cky5ieoi7000mn6694dbta4cd","category_id":"cky5jg4r700061h69a1ama3iy","_id":"cky5jg4r800081h69gc9zbvz1"},{"post_id":"ckxvfmfbe000cbrqq06fa8psr","category_id":"cky5jgj6p00091h69fhuc2iri","_id":"cky5jgj6p000a1h696n1ye86h"},{"post_id":"cky5jh6iq000b1h69497sevdg","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5jhh59000e1h6971chf0ie"},{"post_id":"cky5j2nxc0025n669gj912itz","category_id":"cky5j2zgx0028n669azpo3iff","_id":"cky5jjth2000k1h690xb0a85p"},{"post_id":"cky5jbq26002kn6698ycq45wq","category_id":"cky5j2zgx0028n669azpo3iff","_id":"cky5jjxuh000l1h695d79a092"},{"post_id":"ckxvfmfcs0016brqq1fig8rui","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jm2jg000q1h699w2n5jnl"},{"post_id":"ckxvfmfcs0016brqq1fig8rui","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5jm2jg000r1h69163xbl5g"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jmz2o000s1h69fl7kfc5z"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5jmz2o000t1h6935z4bkry"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","category_id":"cky5jgj6p00091h69fhuc2iri","_id":"cky5jmz2o000u1h6959hud1pd"},{"post_id":"ckxvfmfcn0011brqqfgwtbnl0","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jo653000v1h6966la0rq2"},{"post_id":"ckxvfmfcn0011brqqfgwtbnl0","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5jo654000w1h69fdobd64e"},{"post_id":"cky5jpv1a000x1h69gnob9gx2","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jq77d000y1h699jdr5jf9"},{"post_id":"cky5jpv1a000x1h69gnob9gx2","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5jq77d000z1h69b8ew11ec"},{"post_id":"ckxvfmfcj000xbrqq10lwerlk","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jrjez0000da69acla0pq6"},{"post_id":"ckxvfmfcj000xbrqq10lwerlk","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5jrjf00001da691fl87fhu"},{"post_id":"ckxvfmfcf000tbrqqh4j62d07","category_id":"cky5j9pz2002in669202042x8","_id":"cky5ju48e0002da69hn7p7o8u"},{"post_id":"ckxvfmfcg000ubrqqdgcc86lp","category_id":"cky5jv1pn0003da69ds7cdifg","_id":"cky5jv1po0004da6915795thr"},{"post_id":"ckxvfmfct0017brqq83n24pwy","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5jyvb50005da697rd5852j"},{"post_id":"ckxvfmfct0017brqq83n24pwy","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5jyvb50006da69gh25d449"},{"post_id":"ckxvfmfd4001fbrqq9i5r6i6p","category_id":"cky5jzper0007da692we0470r","_id":"cky5k03u7000cda697sjm8vey"},{"post_id":"ckxvfmfcu0019brqq7iygg312","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5k2o1y000dda69hoa2co96"},{"post_id":"ckxvfmfcu0019brqq7iygg312","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5k2o1y000eda699gt37ssy"},{"post_id":"ckxvfmfdd001jbrqqhyl7h2px","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5k3cv0000fda696k4ucs6g"},{"post_id":"ckxvfmfdd001jbrqqhyl7h2px","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5k3cv0000gda69hkgo2dl8"},{"post_id":"ckxvfmfck000zbrqqg6j9457e","category_id":"cky5jgj6p00091h69fhuc2iri","_id":"cky5k4jy8000hda69hu9h6pem"},{"post_id":"ckxvfmfd3001ebrqqb3f43pj5","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5k5l3t000ida69dbon826z"},{"post_id":"ckxvfmfd3001ebrqqb3f43pj5","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5k5l3t000jda698yd5d7pf"},{"post_id":"ckxvfmfd3001ebrqqb3f43pj5","category_id":"cky5jgj6p00091h69fhuc2iri","_id":"cky5k5qq5000kda695htqct77"},{"post_id":"cky5k7fkc000lda698dm8f586","category_id":"cky5j47cr002an66955pk4nsp","_id":"cky5k7s7o000oda69a5360e4r"},{"post_id":"cky5kb73k000qda692wechm5u","category_id":"cky5j2zgx0028n669azpo3iff","_id":"cky5kb73m000sda698mhk6q7u"},{"post_id":"cky5kbjen000tda69fwlpb5r6","category_id":"cky5j2zgx0028n669azpo3iff","_id":"cky5kbpa7000vda69a9wv8jua"},{"post_id":"ckxvfmfd5001gbrqq6t7q7ca3","category_id":"cky5jfz5o00021h69d5yjas9y","_id":"cky5kcgg8000wda69cnhp7yyo"},{"post_id":"ckxvfmfd5001gbrqq6t7q7ca3","category_id":"cky5jfz5p00031h693xds6401","_id":"cky5kcgg9000xda69fhz9530s"},{"post_id":"cky5ioqev001cn669bv0z1rc6","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"cky5kiism000yda694bu89y9f"},{"post_id":"clkwckxzs0000peszazuk404y","category_id":"clkwcxj7g00006bsz7pg57jyh","_id":"clkwcxj7k00016bszdhf31s6p"},{"post_id":"clkwcz2tx00026bsz9lxufojj","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"clkwd2m7r000a6bszcf1e6aye"},{"post_id":"clkwcz2tx00026bsz9lxufojj","category_id":"cky5jzper0007da692we0470r","_id":"clkwd8u67000f6bsz1iqta819"},{"post_id":"cky5ioqet0016n66963gx6id4","category_id":"clkwgpvka00073tsz20wfh5sh","_id":"clkwgpvke00083tsz476e9a5j"},{"post_id":"clkwi6toz000f3tsz54bv6571","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"clkwi7fp4000h3tsz5bs1beb1"},{"post_id":"ckyu87j300000wb698dnqb0xd","category_id":"cky5eqzvl0000i569bo4g38ik","_id":"clkwinm70000i3tsz4dme4ms5"},{"post_id":"clkwef2bw00013tsz6mop4pz1","category_id":"clkwio80n000j3tszdeb1800w","_id":"clkwio80r000k3tszc5f49pve"},{"post_id":"clkwipq6z000l3tsz634a948g","category_id":"cky5jfe2q00001h69aso52bgy","_id":"clkwisbud000o3tsz7k7sdyqo"},{"post_id":"ckxvfmfc8000kbrqqddkn36p5","category_id":"clkwio80n000j3tszdeb1800w","_id":"clkwjdhfr000s3tsz4jlthyh4"},{"post_id":"clkwjm14i000x3tsz2ny3gt3w","category_id":"cky5jfe2q00001h69aso52bgy","_id":"clkwjocq9000y3tsz4fn96s0z"}],"PostTag":[{"post_id":"ckxvfmfb80004brqq4tlofoza","tag_id":"ckxvfmfba0006brqqcyo843ev","_id":"ckxvfmfbe000bbrqqf85tghfa"},{"post_id":"ckxvfmfbe000cbrqq06fa8psr","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfcw001abrqq1lbnd27b"},{"post_id":"ckxvfmfbe000cbrqq06fa8psr","tag_id":"ckxvfmfcs0015brqq196f43oh","_id":"ckxvfmfd1001cbrqqbamof480"},{"post_id":"ckxvfmfce000rbrqqd3ui3zpt","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfdy0027brqqfrx88ejw"},{"post_id":"ckxvfmfce000rbrqqd3ui3zpt","tag_id":"ckxvfmfdx0025brqqfknuh8q4","_id":"ckxvfmfdy0028brqq0v93fab2"},{"post_id":"ckxvfmfcf000tbrqqh4j62d07","tag_id":"ckxvfmfdy0026brqqbm46500t","_id":"ckxvfmfdz002abrqq81lkemhp"},{"post_id":"ckxvfmfcg000ubrqqdgcc86lp","tag_id":"ckxvfmfdy0029brqq071c7idn","_id":"ckxvfmfdz002cbrqqh6ei0s28"},{"post_id":"ckxvfmfcj000xbrqq10lwerlk","tag_id":"ckxvfmfdz002bbrqq1m2ugzy5","_id":"ckxvfmfe0002fbrqqb2yifuej"},{"post_id":"ckxvfmfcj000xbrqq10lwerlk","tag_id":"ckxvfmfe0002dbrqqa69xb0v5","_id":"ckxvfmfe0002gbrqq3ix2hqxi"},{"post_id":"ckxvfmfcn0011brqqfgwtbnl0","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfe2002kbrqq722i7u2p"},{"post_id":"ckxvfmfcn0011brqqfgwtbnl0","tag_id":"ckxvfmfe1002hbrqq77rrfbt6","_id":"ckxvfmfe2002lbrqq7w1j5etx"},{"post_id":"ckxvfmfcs0016brqq1fig8rui","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfe2002nbrqq559chxou"},{"post_id":"ckxvfmfcs0016brqq1fig8rui","tag_id":"ckxvfmfe1002jbrqqcqvsftac","_id":"ckxvfmfe2002obrqq8pi58ugs"},{"post_id":"ckxvfmfcu0019brqq7iygg312","tag_id":"ckxvfmfe2002mbrqqae966syr","_id":"ckxvfmfe5002qbrqqb07i2s8j"},{"post_id":"ckxvfmfd0001bbrqqbo8mbgqt","tag_id":"ckxvfmfdy0026brqqbm46500t","_id":"ckxvfmfe6002tbrqq59g18hga"},{"post_id":"ckxvfmfd0001bbrqqbo8mbgqt","tag_id":"ckxvfmfe5002rbrqqa8vlh53b","_id":"ckxvfmfe7002ubrqqfisubecl"},{"post_id":"ckxvfmfd3001ebrqqb3f43pj5","tag_id":"ckxvfmfe5002sbrqqc0j2b7e5","_id":"ckxvfmfe7002wbrqq5tjr9gs7"},{"post_id":"ckxvfmfd4001fbrqq9i5r6i6p","tag_id":"ckxvfmfe7002vbrqq5jkqdvtc","_id":"ckxvfmfe8002ybrqq2cam924g"},{"post_id":"ckxvfmfd5001gbrqq6t7q7ca3","tag_id":"ckxvfmfe7002xbrqqbyzm218y","_id":"ckxvfmfe80030brqqcfpa6zx0"},{"post_id":"ckxvfmfdl001obrqq049pap06","tag_id":"ckxvfmfds001ybrqq8ddj3zw1","_id":"ckxvfmfeb0034brqqcq4q9wr2"},{"post_id":"ckxvfmfeh0035brqqc2frc291","tag_id":"ckxvfmfds001ybrqq8ddj3zw1","_id":"ckxvfmfek0037brqq6sh43b5b"},{"post_id":"ckxvfmfej0036brqq1bfld27k","tag_id":"ckxvfmfds001ybrqq8ddj3zw1","_id":"ckxvfmfel0038brqqf38d52yc"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"ckxvfmfeo003cbrqq8cs494xq"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","tag_id":"ckxvfmfen003abrqqbrtedjdk","_id":"ckxvfmfeo003dbrqq7fzwf8q1"},{"post_id":"ckxvfmfem0039brqq7tqldh2s","tag_id":"ckxvfmfen003bbrqq2bux9p36","_id":"ckxvfmfeo003ebrqq3sx7dfm2"},{"post_id":"cky5gxvi20000n669b4en271i","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"cky5gxvi40001n6698lqt2564"},{"post_id":"cky5gxvi20000n669b4en271i","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"cky5gxvi40002n669cgmt272i"},{"post_id":"cky5gyomk0003n669hjjtay8h","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"cky5gyoml0004n6690jfk790g"},{"post_id":"cky5gyomk0003n669hjjtay8h","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"cky5gyoml0005n6692843bko5"},{"post_id":"cky5gyu8l0006n66981ypaxvq","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"cky5gyu8m0007n669bdy178ad"},{"post_id":"cky5gyu8l0006n66981ypaxvq","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"cky5gyu8n0008n669aw1oad4u"},{"post_id":"cky5gz03r0009n669g47k01vi","tag_id":"ckxvfmfcl0010brqq3g9z1fxj","_id":"cky5gz03s000an6696pk84usx"},{"post_id":"cky5gz03r0009n669g47k01vi","tag_id":"ckxvfmfd1001dbrqqggwadqsr","_id":"cky5gz03s000bn669fgnx6po2"},{"post_id":"cky5ioqer0011n669acm951wc","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqes0013n6695nvmdkkm"},{"post_id":"cky5ioqes0012n669gor85mvz","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqeu0018n669bcbxd63a"},{"post_id":"cky5ioqet0014n6694fi2336q","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqew001en669581ugvfx"},{"post_id":"cky5ioqet0016n66963gx6id4","tag_id":"ckxvfmfyn003tbrqqhuwo47s8","_id":"cky5ioqey001kn669dadp93oc"},{"post_id":"cky5ioqeu0019n669gy528ksl","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqez001mn66958f0hv8q"},{"post_id":"cky5ioqev001cn669bv0z1rc6","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqez001on669awxm8inx"},{"post_id":"cky5ioqew001fn6694aok78z9","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqf0001qn66906by67mi"},{"post_id":"cky5ioqex001in66993vkbz4v","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqf0001sn6690rzg8ytv"},{"post_id":"cky5ioqey001ln6691r2db44c","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqf0001xn669764adr8g"},{"post_id":"cky5ioqf0001yn669cm8s1rzq","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5ioqf1001zn669cldve3vi"},{"post_id":"cky5iqlwf0022n669b4hvh6aq","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5iqlwh0023n669d5bv1ui4"},{"post_id":"cky5j2nxc0025n669gj912itz","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"cky5j2nxe0026n669ad55b2t7"},{"post_id":"cky5j2nxc0025n669gj912itz","tag_id":"ckxvfmfbn000ebrqqfz4e8dck","_id":"cky5j2nxe0027n6694arx00tc"},{"post_id":"cky5jbq26002kn6698ycq45wq","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"cky5jbq28002ln669gctw9fa0"},{"post_id":"cky5jbq26002kn6698ycq45wq","tag_id":"ckxvfmfe8002zbrqq7lr8154x","_id":"cky5jbq28002mn6697nz4al07"},{"post_id":"cky5jh6iq000b1h69497sevdg","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"cky5jh6ir000c1h690kc2dnpn"},{"post_id":"cky5jh6iq000b1h69497sevdg","tag_id":"ckxvfmfci000vbrqqb3hs8frk","_id":"cky5jh6is000d1h69fcjb1292"},{"post_id":"cky5k7fkc000lda698dm8f586","tag_id":"ckxvfmfc9000mbrqq8ukh22ll","_id":"cky5k7fkd000mda698aobaeuj"},{"post_id":"cky5k7fkc000lda698dm8f586","tag_id":"ckxvfmfcd000qbrqqhrgg4skw","_id":"cky5k7fkd000nda691ka9b61b"},{"post_id":"cky5kb73k000qda692wechm5u","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"cky5kb73m000rda697emp1ljs"},{"post_id":"cky5kbjen000tda69fwlpb5r6","tag_id":"ckxvfmfbd000abrqq1qdj7wxd","_id":"cky5kbjeo000uda69f4yad9vm"},{"post_id":"cky5ioqet0014n6694fi2336q","tag_id":"cky5m8ajb0002iy690t6x8m3m","_id":"cky5m8ajb0003iy696d2iabif"},{"post_id":"cky5ioqes0012n669gor85mvz","tag_id":"cky5m8ajb0002iy690t6x8m3m","_id":"cky5m92000005iy69c85f36d7"},{"post_id":"cky5ioqex001in66993vkbz4v","tag_id":"cky5m8ajb0002iy690t6x8m3m","_id":"cky5m9bwa0006iy69dogdbb7y"},{"post_id":"cky5ieoi7000mn6694dbta4cd","tag_id":"cky5m9xdx0007iy69h1jn4etx","_id":"cky5m9xdy0008iy69bfo4655k"},{"post_id":"clkwcz2tx00026bsz9lxufojj","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"clkwd1rry00086bszdeps5tjr"},{"post_id":"clkwgxd93000a3tszg5fucw5v","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"clkwgzh6j000b3tszdbb1279a"},{"post_id":"clkwi6toz000f3tsz54bv6571","tag_id":"ckxvfmf9y0002brqqdzaza9jd","_id":"clkwi7aw8000g3tsz0zm078y9"},{"post_id":"ckxvfmfc8000kbrqqddkn36p5","tag_id":"clkwegbe900023tszcekc4bm2","_id":"clkwjeelf000t3tszd8y55xwh"}],"Tag":[{"name":"小程序","_id":"ckxvfmf9y0002brqqdzaza9jd"},{"name":"cookie","_id":"ckxvfmfba0006brqqcyo843ev"},{"name":"CSS","_id":"ckxvfmfbd000abrqq1qdj7wxd"},{"name":"BFC","_id":"ckxvfmfbn000ebrqqfz4e8dck"},{"name":"网络安全","_id":"ckxvfmfc9000mbrqq8ukh22ll"},{"name":"HTTP","_id":"ckxvfmfcd000qbrqqhrgg4skw"},{"name":"Session","_id":"ckxvfmfci000vbrqqb3hs8frk"},{"name":"JavaScript","_id":"ckxvfmfcl0010brqq3g9z1fxj"},{"name":"Storage","_id":"ckxvfmfcs0015brqq196f43oh"},{"name":"underscore.js","_id":"ckxvfmfd1001dbrqqggwadqsr"},{"name":"vue.js","_id":"ckxvfmfds001ybrqq8ddj3zw1"},{"name":"promise 宏任务 微任务","_id":"ckxvfmfdu0021brqq5lih8xby"},{"name":"事件","_id":"ckxvfmfdx0025brqqfknuh8q4"},{"name":"Node.js","_id":"ckxvfmfdy0026brqqbm46500t"},{"name":"MongoDB","_id":"ckxvfmfdy0029brqq071c7idn"},{"name":"ES6","_id":"ckxvfmfdz002bbrqq1m2ugzy5"},{"name":"模块化","_id":"ckxvfmfe0002dbrqqa69xb0v5"},{"name":"键盘","_id":"ckxvfmfe0002ebrqq2jge0ocw"},{"name":"Array","_id":"ckxvfmfe1002hbrqq77rrfbt6"},{"name":"闭包","_id":"ckxvfmfe1002jbrqqcqvsftac"},{"name":"HTML","_id":"ckxvfmfe2002mbrqqae966syr"},{"name":"Buffers","_id":"ckxvfmfe5002rbrqqa8vlh53b"},{"name":"History API","_id":"ckxvfmfe5002sbrqqc0j2b7e5"},{"name":"gulp","_id":"ckxvfmfe7002vbrqq5jkqdvtc"},{"name":"路由","_id":"ckxvfmfe7002xbrqqbyzm218y"},{"name":"盒模型","_id":"ckxvfmfe8002zbrqq7lr8154x"},{"name":"内存管理","_id":"ckxvfmfen003abrqqbrtedjdk"},{"name":"垃圾回收","_id":"ckxvfmfen003bbrqq2bux9p36"},{"name":"编码规范","_id":"ckxvfmfyn003tbrqqhuwo47s8"},{"name":"miniprogram function property 函数属性","_id":"cky2xw4by00018269gaey839s"},{"name":"miniprogram","_id":"cky2xyra70000f969dz014i74"},{"name":"function property","_id":"cky2xyrac0001f969focif65a"},{"name":"函数属性","_id":"cky2xyrac0002f9696ledc8l6"},{"name":"函数","_id":"cky2yojmo0006f969fouf34qb"},{"name":"属性","_id":"cky2yojmt0007f9694iny551g"},{"name":"tdesign","_id":"cky2yojmu0008f969693j3dss"},{"name":"promisify","_id":"cky5eslvb0007nd691tmn2th3"},{"name":"自定义导航栏","_id":"cky5et1le000bnd69hpny87ii"},{"name":"tabbar","_id":"cky5etbpo000end697jitb9al"},{"name":"自定义组建","_id":"cky5m88q50000iy69a7tcdi3g"},{"name":"自定义组件","_id":"cky5m8ajb0002iy690t6x8m3m"},{"name":"promise","_id":"cky5m9xdx0007iy69h1jn4etx"},{"name":"组件库","_id":"clkwcljiq0001peszcxsr15zl"},{"name":"工程化","_id":"clkwd1rrv00066bsz93a545kd"},{"name":"vue","_id":"clkwegbe900023tszcekc4bm2"}]}}